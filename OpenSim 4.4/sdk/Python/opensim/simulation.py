# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _simulation
else:
    import _simulation

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _simulation.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _simulation.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _simulation.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _simulation.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _simulation.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _simulation.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _simulation.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _simulation.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _simulation.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _simulation.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _simulation.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _simulation.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _simulation.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _simulation.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _simulation.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _simulation.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _simulation:
_simulation.SwigPyIterator_swigregister(SwigPyIterator)

import opensim.common
import opensim.simbody
class _StdVectorState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simulation._StdVectorState_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simulation._StdVectorState___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simulation._StdVectorState___bool__(self)

    def __len__(self) -> "std::vector< SimTK::State >::size_type":
        return _simulation._StdVectorState___len__(self)

    def __getslice__(self, i: "std::vector< SimTK::State >::difference_type", j: "std::vector< SimTK::State >::difference_type") -> "std::vector< SimTK::State,std::allocator< SimTK::State > > *":
        return _simulation._StdVectorState___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simulation._StdVectorState___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SimTK::State >::difference_type", j: "std::vector< SimTK::State >::difference_type") -> "void":
        return _simulation._StdVectorState___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simulation._StdVectorState___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SimTK::State >::value_type const &":
        return _simulation._StdVectorState___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simulation._StdVectorState___setitem__(self, *args)

    def pop(self) -> "std::vector< SimTK::State >::value_type":
        return _simulation._StdVectorState_pop(self)

    def append(self, x: "State") -> "void":
        return _simulation._StdVectorState_append(self, x)

    def empty(self) -> "bool":
        return _simulation._StdVectorState_empty(self)

    def size(self) -> "std::vector< SimTK::State >::size_type":
        return _simulation._StdVectorState_size(self)

    def swap(self, v: "StdVectorState") -> "void":
        return _simulation._StdVectorState_swap(self, v)

    def begin(self) -> "std::vector< SimTK::State >::iterator":
        return _simulation._StdVectorState_begin(self)

    def end(self) -> "std::vector< SimTK::State >::iterator":
        return _simulation._StdVectorState_end(self)

    def rbegin(self) -> "std::vector< SimTK::State >::reverse_iterator":
        return _simulation._StdVectorState_rbegin(self)

    def rend(self) -> "std::vector< SimTK::State >::reverse_iterator":
        return _simulation._StdVectorState_rend(self)

    def clear(self) -> "void":
        return _simulation._StdVectorState_clear(self)

    def get_allocator(self) -> "std::vector< SimTK::State >::allocator_type":
        return _simulation._StdVectorState_get_allocator(self)

    def pop_back(self) -> "void":
        return _simulation._StdVectorState_pop_back(self)

    def erase(self, *args) -> "std::vector< SimTK::State >::iterator":
        return _simulation._StdVectorState_erase(self, *args)

    def __init__(self, *args):
        _simulation._StdVectorState_swiginit(self, _simulation.new__StdVectorState(*args))

    def push_back(self, x: "State") -> "void":
        return _simulation._StdVectorState_push_back(self, x)

    def front(self) -> "std::vector< SimTK::State >::value_type const &":
        return _simulation._StdVectorState_front(self)

    def back(self) -> "std::vector< SimTK::State >::value_type const &":
        return _simulation._StdVectorState_back(self)

    def assign(self, n: "std::vector< SimTK::State >::size_type", x: "State") -> "void":
        return _simulation._StdVectorState_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simulation._StdVectorState_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simulation._StdVectorState_insert(self, *args)

    def reserve(self, n: "std::vector< SimTK::State >::size_type") -> "void":
        return _simulation._StdVectorState_reserve(self, n)

    def capacity(self) -> "std::vector< SimTK::State >::size_type":
        return _simulation._StdVectorState_capacity(self)
    __swig_destroy__ = _simulation.delete__StdVectorState

# Register _StdVectorState in _simulation:
_simulation._StdVectorState_swigregister(_StdVectorState)

class SurfaceProperties(opensim.common.OpenSimObject):
    r"""
    SurfaceProperties class holds the appearance properties of a piece of Geometry
    displayed in the OpenSim visualizer or GUI as a surface. The properties in this
    class are specific to geometry that have surfaces so that these surfaces can be
    textured, or rendered using  a variety of shading models.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SurfaceProperties *":
        return _simulation.SurfaceProperties_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SurfaceProperties_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SurfaceProperties_getClassName()

    def clone(self) -> "OpenSim::SurfaceProperties *":
        return _simulation.SurfaceProperties_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SurfaceProperties_getConcreteClassName(self)

    def copyProperty_representation(self, source: "SurfaceProperties") -> "void":
        return _simulation.SurfaceProperties_copyProperty_representation(self, source)

    def append_representation(self, value: "int const &") -> "int":
        return _simulation.SurfaceProperties_append_representation(self, value)

    def constructProperty_representation(self, initValue: "int const &") -> "void":
        return _simulation.SurfaceProperties_constructProperty_representation(self, initValue)

    def get_representation(self, *args) -> "int const &":
        return _simulation.SurfaceProperties_get_representation(self, *args)

    def upd_representation(self, *args) -> "int &":
        return _simulation.SurfaceProperties_upd_representation(self, *args)

    def set_representation(self, *args) -> "void":
        return _simulation.SurfaceProperties_set_representation(self, *args)

    def copyProperty_texture(self, source: "SurfaceProperties") -> "void":
        return _simulation.SurfaceProperties_copyProperty_texture(self, source)

    def append_texture(self, value: "std::string const &") -> "int":
        return _simulation.SurfaceProperties_append_texture(self, value)

    def constructProperty_texture(self, *args) -> "void":
        return _simulation.SurfaceProperties_constructProperty_texture(self, *args)

    def get_texture(self, *args) -> "std::string const &":
        return _simulation.SurfaceProperties_get_texture(self, *args)

    def upd_texture(self, *args) -> "std::string &":
        return _simulation.SurfaceProperties_upd_texture(self, *args)

    def set_texture(self, *args) -> "void":
        return _simulation.SurfaceProperties_set_texture(self, *args)

    def __init__(self):
        _simulation.SurfaceProperties_swiginit(self, _simulation.new_SurfaceProperties())
    __swig_destroy__ = _simulation.delete_SurfaceProperties

    def hasTexture(self) -> "bool":
        return _simulation.SurfaceProperties_hasTexture(self)

# Register SurfaceProperties in _simulation:
_simulation.SurfaceProperties_swigregister(SurfaceProperties)

def SurfaceProperties_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SurfaceProperties *":
    return _simulation.SurfaceProperties_safeDownCast(obj)

def SurfaceProperties_getClassName() -> "std::string const &":
    return _simulation.SurfaceProperties_getClassName()

class Appearance(opensim.common.OpenSimObject):
    r"""
    A class that holds the Appearance properties of Geometry displayed
    in the OpenSim Visualizer. It affects how Geometry is displayed.

    Appearance contains properties that apply to all geometry.
    Geometry that have a surface so that it can be textured will utilize
    SurfaceProperties, while schematic line drawings (e.g. Arrows, Frames)
    can utilize CurveProperties which offers thickness.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Appearance *":
        return _simulation.Appearance_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Appearance_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Appearance_getClassName()

    def clone(self) -> "OpenSim::Appearance *":
        return _simulation.Appearance_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Appearance_getConcreteClassName(self)

    def copyProperty_visible(self, source: "Appearance") -> "void":
        return _simulation.Appearance_copyProperty_visible(self, source)

    def append_visible(self, value: "bool const &") -> "int":
        return _simulation.Appearance_append_visible(self, value)

    def constructProperty_visible(self, initValue: "bool const &") -> "void":
        return _simulation.Appearance_constructProperty_visible(self, initValue)

    def get_visible(self, *args) -> "bool const &":
        return _simulation.Appearance_get_visible(self, *args)

    def upd_visible(self, *args) -> "bool &":
        return _simulation.Appearance_upd_visible(self, *args)

    def set_visible(self, *args) -> "void":
        return _simulation.Appearance_set_visible(self, *args)

    def copyProperty_opacity(self, source: "Appearance") -> "void":
        return _simulation.Appearance_copyProperty_opacity(self, source)

    def append_opacity(self, value: "double const &") -> "int":
        return _simulation.Appearance_append_opacity(self, value)

    def constructProperty_opacity(self, initValue: "double const &") -> "void":
        return _simulation.Appearance_constructProperty_opacity(self, initValue)

    def get_opacity(self, *args) -> "double const &":
        return _simulation.Appearance_get_opacity(self, *args)

    def upd_opacity(self, *args) -> "double &":
        return _simulation.Appearance_upd_opacity(self, *args)

    def set_opacity(self, *args) -> "void":
        return _simulation.Appearance_set_opacity(self, *args)

    def copyProperty_color(self, source: "Appearance") -> "void":
        return _simulation.Appearance_copyProperty_color(self, source)

    def append_color(self, value: "Vec3") -> "int":
        return _simulation.Appearance_append_color(self, value)

    def constructProperty_color(self, initValue: "Vec3") -> "void":
        return _simulation.Appearance_constructProperty_color(self, initValue)

    def get_color(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Appearance_get_color(self, *args)

    def upd_color(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Appearance_upd_color(self, *args)

    def set_color(self, *args) -> "void":
        return _simulation.Appearance_set_color(self, *args)

    def copyProperty_SurfaceProperties(self, source: "Appearance") -> "void":
        return _simulation.Appearance_copyProperty_SurfaceProperties(self, source)

    def append_SurfaceProperties(self, value: "SurfaceProperties") -> "int":
        return _simulation.Appearance_append_SurfaceProperties(self, value)

    def constructProperty_SurfaceProperties(self, initValue: "SurfaceProperties") -> "void":
        return _simulation.Appearance_constructProperty_SurfaceProperties(self, initValue)

    def get_SurfaceProperties(self, *args) -> "OpenSim::SurfaceProperties const &":
        return _simulation.Appearance_get_SurfaceProperties(self, *args)

    def upd_SurfaceProperties(self, *args) -> "OpenSim::SurfaceProperties &":
        return _simulation.Appearance_upd_SurfaceProperties(self, *args)

    def set_SurfaceProperties(self, *args) -> "void":
        return _simulation.Appearance_set_SurfaceProperties(self, *args)

    def __init__(self):
        _simulation.Appearance_swiginit(self, _simulation.new_Appearance())
    __swig_destroy__ = _simulation.delete_Appearance

    def get_representation(self) -> "OpenSim::VisualRepresentation":
        return _simulation.Appearance_get_representation(self)

    def set_representation(self, rep: "OpenSim::VisualRepresentation const &") -> "void":
        return _simulation.Appearance_set_representation(self, rep)

# Register Appearance in _simulation:
_simulation.Appearance_swigregister(Appearance)

def Appearance_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Appearance *":
    return _simulation.Appearance_safeDownCast(obj)

def Appearance_getClassName() -> "std::string const &":
    return _simulation.Appearance_getClassName()

class Geometry(opensim.common.Component):
    r"""
    Class Geometry is intended to be used as the base class for all
    geometry that needs to be represented in the system, including mesh files,
    and built in analytic shapes. Any ModelComponent can specify a list of
    Geometry items to represent itself in graphics window. The relation between
    a ModelComponent and specific Geometry utilizes the Component mechanism, as
    the specific pieces of geometry are treated as subcomponents. The placement
    of the Geometry in 3D space is computed from the Frame that the Geometry is
    "Connected" to.

    Geometry (and all its subclasses) serve as the set of higher level primitives
    available to OpenSim component writers to express the Geometry of interest.
    The Geometry class handles serialization and also the translation to a set of
    DecorativeGeometry objects that gets passed to the Visualization system to be
    rendered.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Geometry *":
        return _simulation.Geometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Geometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Geometry_getClassName()

    def clone(self) -> "OpenSim::Geometry *":
        return _simulation.Geometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Geometry_getConcreteClassName(self)

    def copyProperty_scale_factors(self, source: "Geometry") -> "void":
        return _simulation.Geometry_copyProperty_scale_factors(self, source)

    def append_scale_factors(self, value: "Vec3") -> "int":
        return _simulation.Geometry_append_scale_factors(self, value)

    def constructProperty_scale_factors(self, initValue: "Vec3") -> "void":
        return _simulation.Geometry_constructProperty_scale_factors(self, initValue)

    def get_scale_factors(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Geometry_get_scale_factors(self, *args)

    def upd_scale_factors(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Geometry_upd_scale_factors(self, *args)

    def set_scale_factors(self, *args) -> "void":
        return _simulation.Geometry_set_scale_factors(self, *args)

    def copyProperty_Appearance(self, source: "Geometry") -> "void":
        return _simulation.Geometry_copyProperty_Appearance(self, source)

    def append_Appearance(self, value: "Appearance") -> "int":
        return _simulation.Geometry_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue: "Appearance") -> "void":
        return _simulation.Geometry_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args) -> "OpenSim::Appearance const &":
        return _simulation.Geometry_get_Appearance(self, *args)

    def upd_Appearance(self, *args) -> "OpenSim::Appearance &":
        return _simulation.Geometry_upd_Appearance(self, *args)

    def set_Appearance(self, *args) -> "void":
        return _simulation.Geometry_set_Appearance(self, *args)
    PropertyIndex_socket_frame = property(_simulation.Geometry_PropertyIndex_socket_frame_get, _simulation.Geometry_PropertyIndex_socket_frame_set)

    def constructSocket_frame(self) -> "PropertyIndex":
        return _simulation.Geometry_constructSocket_frame(self)

    def connectSocket_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.Geometry_connectSocket_frame(self, object)
    PropertyIndex_input_transform = property(_simulation.Geometry_PropertyIndex_input_transform_get, _simulation.Geometry_PropertyIndex_input_transform_set)

    def connectInput_transform(self, *args) -> "void":
        return _simulation.Geometry_connectInput_transform(self, *args)
    __swig_destroy__ = _simulation.delete_Geometry

    def setFrame(self, frame: "Frame") -> "void":
        r""" Interface methods to handle the Frame which the Geometry is attached to.  %Set the Frame of attachment *"""
        return _simulation.Geometry_setFrame(self, frame)

    def getFrame(self) -> "OpenSim::Frame const &":
        r"""
        Return a reference to the name of the Frame to which
           this Geometry is attached (using a Socket). * Return a reference to the actual Frame to which this Geometry
           is attached.
        """
        return _simulation.Geometry_getFrame(self)

    def setColor(self, color: "Vec3") -> "void":
        r"""
        Convenient access to set Appearance/Color
        color is RGB, each components is in the range [0, 1].
        """
        return _simulation.Geometry_setColor(self, color)

    def getColor(self) -> "SimTK::Vec3 const &":
        r"""
        Convenient access to get Appearance/Color
        returns RGB , each components is in the range [0, 1].
        """
        return _simulation.Geometry_getColor(self)

    def setOpacity(self, opacity: "double const") -> "void":
        r""" Convenient access to set Appearance/Opacity"""
        return _simulation.Geometry_setOpacity(self, opacity)

    def getOpacity(self) -> "double":
        r""" Convenient access to get Appearance/Opacity"""
        return _simulation.Geometry_getOpacity(self)

    def setRepresentation(self, rep: "OpenSim::VisualRepresentation") -> "void":
        r""" Convenient access to set Appearance/representation"""
        return _simulation.Geometry_setRepresentation(self, rep)

    def getRepresentation(self) -> "OpenSim::VisualRepresentation":
        r""" Convenient access to get Appearance/representation"""
        return _simulation.Geometry_getRepresentation(self)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Implement method from Component interface. Subclasses only need to
        implement implementCreateDecorativeGeometry to generate an Array of
        SimTK::DecorativeGeometry. From then on, setting Transforms & Appearance
        is handled by the base class Geometry to avoid duplication.
        """
        return _simulation.Geometry_generateDecorations(self, fixed, hints, state, appendToThis)

# Register Geometry in _simulation:
_simulation.Geometry_swigregister(Geometry)

def Geometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Geometry *":
    return _simulation.Geometry_safeDownCast(obj)

def Geometry_getClassName() -> "std::string const &":
    return _simulation.Geometry_getClassName()

class LineGeometry(Geometry):
    r"""
    LineGeometry is a utility class used to abstract a line segment.
    It is used by muscle segments so that it's as small and useful as possible.

    NOTE: LineGeometry assumes its Frame is Ground!
    TODO make LineGeometry draw between actual Points!
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::LineGeometry *":
        return _simulation.LineGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.LineGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.LineGeometry_getClassName()

    def clone(self) -> "OpenSim::LineGeometry *":
        return _simulation.LineGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.LineGeometry_getConcreteClassName(self)

    def copyProperty_start_point(self, source: "LineGeometry") -> "void":
        return _simulation.LineGeometry_copyProperty_start_point(self, source)

    def append_start_point(self, value: "Vec3") -> "int":
        return _simulation.LineGeometry_append_start_point(self, value)

    def constructProperty_start_point(self, initValue: "Vec3") -> "void":
        return _simulation.LineGeometry_constructProperty_start_point(self, initValue)

    def get_start_point(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.LineGeometry_get_start_point(self, *args)

    def upd_start_point(self, *args) -> "SimTK::Vec3 &":
        return _simulation.LineGeometry_upd_start_point(self, *args)

    def set_start_point(self, *args) -> "void":
        return _simulation.LineGeometry_set_start_point(self, *args)

    def copyProperty_end_point(self, source: "LineGeometry") -> "void":
        return _simulation.LineGeometry_copyProperty_end_point(self, source)

    def append_end_point(self, value: "Vec3") -> "int":
        return _simulation.LineGeometry_append_end_point(self, value)

    def constructProperty_end_point(self, initValue: "Vec3") -> "void":
        return _simulation.LineGeometry_constructProperty_end_point(self, initValue)

    def get_end_point(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.LineGeometry_get_end_point(self, *args)

    def upd_end_point(self, *args) -> "SimTK::Vec3 &":
        return _simulation.LineGeometry_upd_end_point(self, *args)

    def set_end_point(self, *args) -> "void":
        return _simulation.LineGeometry_set_end_point(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor that takes two end points

        |

        *Overload 2:*
        default constructor, creates line (0,0,0)-(1,1,1)
        """
        _simulation.LineGeometry_swiginit(self, _simulation.new_LineGeometry(*args))
    __swig_destroy__ = _simulation.delete_LineGeometry

    def getPoints(self, rPoint1: "Vec3", rPoint2: "Vec3") -> "void":
        r""" Get end points as Vec3 in passed in arguments"""
        return _simulation.LineGeometry_getPoints(self, rPoint1, rPoint2)

    def setPoints(self, aPoint1: "Vec3", aPoint2: "Vec3") -> "void":
        r""" %Set end points from passed in arguments"""
        return _simulation.LineGeometry_setPoints(self, aPoint1, aPoint2)

# Register LineGeometry in _simulation:
_simulation.LineGeometry_swigregister(LineGeometry)

def LineGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::LineGeometry *":
    return _simulation.LineGeometry_safeDownCast(obj)

def LineGeometry_getClassName() -> "std::string const &":
    return _simulation.LineGeometry_getClassName()

class Arrow(Geometry):
    r"""
    Arrow is a Geometry subclass used to represent an arrow. The arrow goes from
    start_point (Property) and has direction (Property) and length (Property)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Arrow *":
        return _simulation.Arrow_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Arrow_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Arrow_getClassName()

    def clone(self) -> "OpenSim::Arrow *":
        return _simulation.Arrow_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Arrow_getConcreteClassName(self)

    def copyProperty_start_point(self, source: "Arrow") -> "void":
        return _simulation.Arrow_copyProperty_start_point(self, source)

    def append_start_point(self, value: "Vec3") -> "int":
        return _simulation.Arrow_append_start_point(self, value)

    def constructProperty_start_point(self, initValue: "Vec3") -> "void":
        return _simulation.Arrow_constructProperty_start_point(self, initValue)

    def get_start_point(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Arrow_get_start_point(self, *args)

    def upd_start_point(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Arrow_upd_start_point(self, *args)

    def set_start_point(self, *args) -> "void":
        return _simulation.Arrow_set_start_point(self, *args)

    def copyProperty_direction(self, source: "Arrow") -> "void":
        return _simulation.Arrow_copyProperty_direction(self, source)

    def append_direction(self, value: "Vec3") -> "int":
        return _simulation.Arrow_append_direction(self, value)

    def constructProperty_direction(self, initValue: "Vec3") -> "void":
        return _simulation.Arrow_constructProperty_direction(self, initValue)

    def get_direction(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Arrow_get_direction(self, *args)

    def upd_direction(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Arrow_upd_direction(self, *args)

    def set_direction(self, *args) -> "void":
        return _simulation.Arrow_set_direction(self, *args)

    def copyProperty_length(self, source: "Arrow") -> "void":
        return _simulation.Arrow_copyProperty_length(self, source)

    def append_length(self, value: "double const &") -> "int":
        return _simulation.Arrow_append_length(self, value)

    def constructProperty_length(self, initValue: "double const &") -> "void":
        return _simulation.Arrow_constructProperty_length(self, initValue)

    def get_length(self, *args) -> "double const &":
        return _simulation.Arrow_get_length(self, *args)

    def upd_length(self, *args) -> "double &":
        return _simulation.Arrow_upd_length(self, *args)

    def set_length(self, *args) -> "void":
        return _simulation.Arrow_set_length(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        constructor that takes startPoint, direction vector and length

        |

        *Overload 2:*
        Default constructor that creates Arrow of length 1 starting at origin
        in the direction (1,1,1)
        """
        _simulation.Arrow_swiginit(self, _simulation.new_Arrow(*args))
    __swig_destroy__ = _simulation.delete_Arrow

# Register Arrow in _simulation:
_simulation.Arrow_swigregister(Arrow)

def Arrow_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Arrow *":
    return _simulation.Arrow_safeDownCast(obj)

def Arrow_getClassName() -> "std::string const &":
    return _simulation.Arrow_getClassName()

class AnalyticGeometry(Geometry):
    r"""
    Abstract class for analytical geometry (e.g. surfaces of revolution) whose
    rendering is optimized by the graphics library (e.g. threejs). Unlike other
    geometry, property edits require a recreation of the AnalyticGeometry on
    the renderer and not simple updates. AnalyticGeometry is the base class for
    Sphere, Cylinder, Cone, Ellipsoid and Torus geometry.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalyticGeometry *":
        return _simulation.AnalyticGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.AnalyticGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.AnalyticGeometry_getClassName()

    def clone(self) -> "OpenSim::AnalyticGeometry *":
        return _simulation.AnalyticGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.AnalyticGeometry_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_AnalyticGeometry

# Register AnalyticGeometry in _simulation:
_simulation.AnalyticGeometry_swigregister(AnalyticGeometry)

def AnalyticGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalyticGeometry *":
    return _simulation.AnalyticGeometry_safeDownCast(obj)

def AnalyticGeometry_getClassName() -> "std::string const &":
    return _simulation.AnalyticGeometry_getClassName()

class Sphere(AnalyticGeometry):
    r"""A class to represent Sphere geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Sphere *":
        return _simulation.Sphere_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Sphere_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Sphere_getClassName()

    def clone(self) -> "OpenSim::Sphere *":
        return _simulation.Sphere_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Sphere_getConcreteClassName(self)

    def copyProperty_radius(self, source: "Sphere") -> "void":
        return _simulation.Sphere_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.Sphere_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.Sphere_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.Sphere_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.Sphere_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.Sphere_set_radius(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, creates a sphere of radius 1.0

        |

        *Overload 2:*
        Another constructor that takes in a specified radius
        """
        _simulation.Sphere_swiginit(self, _simulation.new_Sphere(*args))
    __swig_destroy__ = _simulation.delete_Sphere

# Register Sphere in _simulation:
_simulation.Sphere_swigregister(Sphere)

def Sphere_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Sphere *":
    return _simulation.Sphere_safeDownCast(obj)

def Sphere_getClassName() -> "std::string const &":
    return _simulation.Sphere_getClassName()

class Ellipsoid(AnalyticGeometry):
    r"""A class to represent an Ellipsoid geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ellipsoid *":
        return _simulation.Ellipsoid_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Ellipsoid_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Ellipsoid_getClassName()

    def clone(self) -> "OpenSim::Ellipsoid *":
        return _simulation.Ellipsoid_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Ellipsoid_getConcreteClassName(self)

    def copyProperty_radii(self, source: "Ellipsoid") -> "void":
        return _simulation.Ellipsoid_copyProperty_radii(self, source)

    def append_radii(self, value: "Vec3") -> "int":
        return _simulation.Ellipsoid_append_radii(self, value)

    def constructProperty_radii(self, initValue: "Vec3") -> "void":
        return _simulation.Ellipsoid_constructProperty_radii(self, initValue)

    def get_radii(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Ellipsoid_get_radii(self, *args)

    def upd_radii(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Ellipsoid_upd_radii(self, *args)

    def set_radii(self, *args) -> "void":
        return _simulation.Ellipsoid_set_radii(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, creates an Ellipsoid of radii 0.5, 1., 2.

        |

        *Overload 2:*
        Constructor that takes in three radii
        """
        _simulation.Ellipsoid_swiginit(self, _simulation.new_Ellipsoid(*args))
    __swig_destroy__ = _simulation.delete_Ellipsoid

    def setEllipsoidParams(self, radius1: "double", radius2: "double", radius3: "double") -> "void":
        r""" Convenience interface to set radii"""
        return _simulation.Ellipsoid_setEllipsoidParams(self, radius1, radius2, radius3)

# Register Ellipsoid in _simulation:
_simulation.Ellipsoid_swigregister(Ellipsoid)

def Ellipsoid_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ellipsoid *":
    return _simulation.Ellipsoid_safeDownCast(obj)

def Ellipsoid_getClassName() -> "std::string const &":
    return _simulation.Ellipsoid_getClassName()

class Cylinder(AnalyticGeometry):
    r"""A class to represent a Cylinder geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Cylinder *":
        return _simulation.Cylinder_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Cylinder_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Cylinder_getClassName()

    def clone(self) -> "OpenSim::Cylinder *":
        return _simulation.Cylinder_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Cylinder_getConcreteClassName(self)

    def copyProperty_radius(self, source: "Cylinder") -> "void":
        return _simulation.Cylinder_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.Cylinder_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.Cylinder_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.Cylinder_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.Cylinder_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.Cylinder_set_radius(self, *args)

    def copyProperty_half_height(self, source: "Cylinder") -> "void":
        return _simulation.Cylinder_copyProperty_half_height(self, source)

    def append_half_height(self, value: "double const &") -> "int":
        return _simulation.Cylinder_append_half_height(self, value)

    def constructProperty_half_height(self, initValue: "double const &") -> "void":
        return _simulation.Cylinder_constructProperty_half_height(self, initValue)

    def get_half_height(self, *args) -> "double const &":
        return _simulation.Cylinder_get_half_height(self, *args)

    def upd_half_height(self, *args) -> "double &":
        return _simulation.Cylinder_upd_half_height(self, *args)

    def set_half_height(self, *args) -> "void":
        return _simulation.Cylinder_set_half_height(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor that takes radius and half-height
        """
        _simulation.Cylinder_swiginit(self, _simulation.new_Cylinder(*args))
    __swig_destroy__ = _simulation.delete_Cylinder

    def getCylinderParams(self, params: "Vec2") -> "void":
        r""" Convenient way to get the two parameters that define the cylinder"""
        return _simulation.Cylinder_getCylinderParams(self, params)

# Register Cylinder in _simulation:
_simulation.Cylinder_swigregister(Cylinder)

def Cylinder_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Cylinder *":
    return _simulation.Cylinder_safeDownCast(obj)

def Cylinder_getClassName() -> "std::string const &":
    return _simulation.Cylinder_getClassName()

class Cone(AnalyticGeometry):
    r"""A class to represent a Cone geometry."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Cone *":
        return _simulation.Cone_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Cone_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Cone_getClassName()

    def clone(self) -> "OpenSim::Cone *":
        return _simulation.Cone_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Cone_getConcreteClassName(self)

    def copyProperty_origin(self, source: "Cone") -> "void":
        return _simulation.Cone_copyProperty_origin(self, source)

    def append_origin(self, value: "Vec3") -> "int":
        return _simulation.Cone_append_origin(self, value)

    def constructProperty_origin(self, initValue: "Vec3") -> "void":
        return _simulation.Cone_constructProperty_origin(self, initValue)

    def get_origin(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Cone_get_origin(self, *args)

    def upd_origin(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Cone_upd_origin(self, *args)

    def set_origin(self, *args) -> "void":
        return _simulation.Cone_set_origin(self, *args)

    def copyProperty_direction(self, source: "Cone") -> "void":
        return _simulation.Cone_copyProperty_direction(self, source)

    def append_direction(self, value: "Vec3") -> "int":
        return _simulation.Cone_append_direction(self, value)

    def constructProperty_direction(self, initValue: "Vec3") -> "void":
        return _simulation.Cone_constructProperty_direction(self, initValue)

    def get_direction(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Cone_get_direction(self, *args)

    def upd_direction(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Cone_upd_direction(self, *args)

    def set_direction(self, *args) -> "void":
        return _simulation.Cone_set_direction(self, *args)

    def copyProperty_base_radius(self, source: "Cone") -> "void":
        return _simulation.Cone_copyProperty_base_radius(self, source)

    def append_base_radius(self, value: "double const &") -> "int":
        return _simulation.Cone_append_base_radius(self, value)

    def constructProperty_base_radius(self, initValue: "double const &") -> "void":
        return _simulation.Cone_constructProperty_base_radius(self, initValue)

    def get_base_radius(self, *args) -> "double const &":
        return _simulation.Cone_get_base_radius(self, *args)

    def upd_base_radius(self, *args) -> "double &":
        return _simulation.Cone_upd_base_radius(self, *args)

    def set_base_radius(self, *args) -> "void":
        return _simulation.Cone_set_base_radius(self, *args)

    def copyProperty_height(self, source: "Cone") -> "void":
        return _simulation.Cone_copyProperty_height(self, source)

    def append_height(self, value: "double const &") -> "int":
        return _simulation.Cone_append_height(self, value)

    def constructProperty_height(self, initValue: "double const &") -> "void":
        return _simulation.Cone_constructProperty_height(self, initValue)

    def get_height(self, *args) -> "double const &":
        return _simulation.Cone_get_height(self, *args)

    def upd_height(self, *args) -> "double &":
        return _simulation.Cone_upd_height(self, *args)

    def set_height(self, *args) -> "void":
        return _simulation.Cone_set_height(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor that takes radius and half-height
        """
        _simulation.Cone_swiginit(self, _simulation.new_Cone(*args))
    __swig_destroy__ = _simulation.delete_Cone

# Register Cone in _simulation:
_simulation.Cone_swigregister(Cone)

def Cone_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Cone *":
    return _simulation.Cone_safeDownCast(obj)

def Cone_getClassName() -> "std::string const &":
    return _simulation.Cone_getClassName()

class Torus(AnalyticGeometry):
    r"""
    A class to represent Torus geometry. The torus is centered at the
    origin with the axial direction aligned to the z-axis. It is defined by
    a ring_radius (radius of the circular centerline of the torus, measured
    from the origin), and a cross_section (radius of the torus cross-section:
    perpendicular distance from the circular centerline to the surface).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Torus *":
        return _simulation.Torus_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Torus_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Torus_getClassName()

    def clone(self) -> "OpenSim::Torus *":
        return _simulation.Torus_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Torus_getConcreteClassName(self)

    def copyProperty_cross_section(self, source: "Torus") -> "void":
        return _simulation.Torus_copyProperty_cross_section(self, source)

    def append_cross_section(self, value: "double const &") -> "int":
        return _simulation.Torus_append_cross_section(self, value)

    def constructProperty_cross_section(self, initValue: "double const &") -> "void":
        return _simulation.Torus_constructProperty_cross_section(self, initValue)

    def get_cross_section(self, *args) -> "double const &":
        return _simulation.Torus_get_cross_section(self, *args)

    def upd_cross_section(self, *args) -> "double &":
        return _simulation.Torus_upd_cross_section(self, *args)

    def set_cross_section(self, *args) -> "void":
        return _simulation.Torus_set_cross_section(self, *args)

    def copyProperty_ring_radius(self, source: "Torus") -> "void":
        return _simulation.Torus_copyProperty_ring_radius(self, source)

    def append_ring_radius(self, value: "double const &") -> "int":
        return _simulation.Torus_append_ring_radius(self, value)

    def constructProperty_ring_radius(self, initValue: "double const &") -> "void":
        return _simulation.Torus_constructProperty_ring_radius(self, initValue)

    def get_ring_radius(self, *args) -> "double const &":
        return _simulation.Torus_get_ring_radius(self, *args)

    def upd_ring_radius(self, *args) -> "double &":
        return _simulation.Torus_upd_ring_radius(self, *args)

    def set_ring_radius(self, *args) -> "void":
        return _simulation.Torus_set_ring_radius(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Constructor that takes in two radii
        """
        _simulation.Torus_swiginit(self, _simulation.new_Torus(*args))
    __swig_destroy__ = _simulation.delete_Torus

# Register Torus in _simulation:
_simulation.Torus_swigregister(Torus)

def Torus_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Torus *":
    return _simulation.Torus_safeDownCast(obj)

def Torus_getClassName() -> "std::string const &":
    return _simulation.Torus_getClassName()

class Brick(Geometry):
    r"""A class to represent Brick geometry. Brick is specified by three half_lengths"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Brick *":
        return _simulation.Brick_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Brick_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Brick_getClassName()

    def clone(self) -> "OpenSim::Brick *":
        return _simulation.Brick_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Brick_getConcreteClassName(self)

    def copyProperty_half_lengths(self, source: "Brick") -> "void":
        return _simulation.Brick_copyProperty_half_lengths(self, source)

    def append_half_lengths(self, value: "Vec3") -> "int":
        return _simulation.Brick_append_half_lengths(self, value)

    def constructProperty_half_lengths(self, initValue: "Vec3") -> "void":
        return _simulation.Brick_constructProperty_half_lengths(self, initValue)

    def get_half_lengths(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Brick_get_half_lengths(self, *args)

    def upd_half_lengths(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Brick_upd_half_lengths(self, *args)

    def set_half_lengths(self, *args) -> "void":
        return _simulation.Brick_set_half_lengths(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes a Brick with half-length 0.1,0.2,0.3

        |

        *Overload 2:*
        Convenience constructor with specified half-lengths
        """
        _simulation.Brick_swiginit(self, _simulation.new_Brick(*args))
    __swig_destroy__ = _simulation.delete_Brick

# Register Brick in _simulation:
_simulation.Brick_swigregister(Brick)

def Brick_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Brick *":
    return _simulation.Brick_safeDownCast(obj)

def Brick_getClassName() -> "std::string const &":
    return _simulation.Brick_getClassName()

class Mesh(Geometry):
    r"""
    A class to represent Mesh geometry that comes from a file.
    Supported file formats .vtp, .stl, .obj but will grow over time
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Mesh *":
        return _simulation.Mesh_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Mesh_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Mesh_getClassName()

    def clone(self) -> "OpenSim::Mesh *":
        return _simulation.Mesh_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Mesh_getConcreteClassName(self)

    def copyProperty_mesh_file(self, source: "Mesh") -> "void":
        return _simulation.Mesh_copyProperty_mesh_file(self, source)

    def append_mesh_file(self, value: "std::string const &") -> "int":
        return _simulation.Mesh_append_mesh_file(self, value)

    def constructProperty_mesh_file(self, initValue: "std::string const &") -> "void":
        return _simulation.Mesh_constructProperty_mesh_file(self, initValue)

    def get_mesh_file(self, *args) -> "std::string const &":
        return _simulation.Mesh_get_mesh_file(self, *args)

    def upd_mesh_file(self, *args) -> "std::string &":
        return _simulation.Mesh_upd_mesh_file(self, *args)

    def set_mesh_file(self, *args) -> "void":
        return _simulation.Mesh_set_mesh_file(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Constructor that takes a mesh file name
        """
        _simulation.Mesh_swiginit(self, _simulation.new_Mesh(*args))
    __swig_destroy__ = _simulation.delete_Mesh

    def getGeometryFilename(self) -> "std::string const &":
        r""" Retrieve file name"""
        return _simulation.Mesh_getGeometryFilename(self)

# Register Mesh in _simulation:
_simulation.Mesh_swigregister(Mesh)

def Mesh_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Mesh *":
    return _simulation.Mesh_safeDownCast(obj)

def Mesh_getClassName() -> "std::string const &":
    return _simulation.Mesh_getClassName()

class FrameGeometry(Geometry):
    r"""
    A class to represent Frame geometry. Knobs that can be changed
    are in Appearance::Representation, size, thickness.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FrameGeometry *":
        return _simulation.FrameGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FrameGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FrameGeometry_getClassName()

    def clone(self) -> "OpenSim::FrameGeometry *":
        return _simulation.FrameGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FrameGeometry_getConcreteClassName(self)

    def copyProperty_display_radius(self, source: "FrameGeometry") -> "void":
        return _simulation.FrameGeometry_copyProperty_display_radius(self, source)

    def append_display_radius(self, value: "double const &") -> "int":
        return _simulation.FrameGeometry_append_display_radius(self, value)

    def constructProperty_display_radius(self, initValue: "double const &") -> "void":
        return _simulation.FrameGeometry_constructProperty_display_radius(self, initValue)

    def get_display_radius(self, *args) -> "double const &":
        return _simulation.FrameGeometry_get_display_radius(self, *args)

    def upd_display_radius(self, *args) -> "double &":
        return _simulation.FrameGeometry_upd_display_radius(self, *args)

    def set_display_radius(self, *args) -> "void":
        return _simulation.FrameGeometry_set_display_radius(self, *args)

    def __init__(self, scale: "double"=0.2):
        r""" Default constructor"""
        _simulation.FrameGeometry_swiginit(self, _simulation.new_FrameGeometry(scale))
    __swig_destroy__ = _simulation.delete_FrameGeometry

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        return _simulation.FrameGeometry_generateDecorations(self, fixed, hints, state, appendToThis)

# Register FrameGeometry in _simulation:
_simulation.FrameGeometry_swigregister(FrameGeometry)

def FrameGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FrameGeometry *":
    return _simulation.FrameGeometry_safeDownCast(obj)

def FrameGeometry_getClassName() -> "std::string const &":
    return _simulation.FrameGeometry_getClassName()

class ModelComponent(opensim.common.Component):
    r"""
    This defines the abstract ModelComponent class, which is used to specify
    components of a musculoskeletal model and the elements they add to the
    underlying computational SimTK::System (MultibodySystem). A ModelComponent is
    an OpenSim::Component and therefore has the capabilities to add necessary
    system resources to the System and to manage access to those resources (See also: 
    Component)

    Bodies, Joints, Coordinates, Constraints, Forces, Actuators, Controllers,
    and even Model itself, are ModelComponents. Each component is "connected" to
    a model and an underlying SimTK::Subsystem, which by default is the
    System's DefaultSubsystem.

    The primary responsibility of a ModelComponent is to add its computational
    representation(s) of physical musculoskeletal structures to the underlying
    SimTK::System by implementing extendAddToSystem().

    Additional methods provide support for adding modeling options, state and
    cache variables (See also: Component).

    Public methods enable access to component variables via their names.

    Author: Ajay Seth, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponent *":
        return _simulation.ModelComponent_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponent_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponent_getClassName()

    def clone(self) -> "OpenSim::ModelComponent *":
        return _simulation.ModelComponent_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponent_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ModelComponent

    def connectToModel(self, model: "Model") -> "void":
        r""" Connect this ModelComponent to its aggregate- a  Model"""
        return _simulation.ModelComponent_connectToModel(self, model)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ModelComponent_getModel(self)

    def updModel(self) -> "OpenSim::Model &":
        r""" Get a modifiable reference to the Model this component is part of."""
        return _simulation.ModelComponent_updModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ModelComponent_hasModel(self)

    def preScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Perform any computations that must occur before ModelComponent::scale()
               is invoked on all ModelComponents in the Model. For example, a
               GeometryPath must calculate and store its path length in the original
               model before scaling so that an owning Muscle can use this information
               to update the properties of the muscle after scaling. This method calls
               the virtual extendPreScale() method, which may be implemented by any
               subclass of ModelComponent.
               See also: extendPreScale()
               See also: scale()
               See also: postScale()
        """
        return _simulation.ModelComponent_preScale(self, s, scaleSet)

    def scale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the ModelComponent. This method calls the virtual extendScale()
               method, which may be implemented by any subclass of ModelComponent.
               See also: preScale()
               See also: extendScale()
               See also: postScale()
        """
        return _simulation.ModelComponent_scale(self, s, scaleSet)

    def postScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Perform any computations that must occur after ModelComponent::scale()
               has been invoked on all ModelComponents in the Model. This method calls
               the virtual extendPostScale() method, which may be implemented by any
               subclass of ModelComponent.
               See also: preScale()
               See also: scale()
               See also: extendPostScale()
        """
        return _simulation.ModelComponent_postScale(self, s, scaleSet)

# Register ModelComponent in _simulation:
_simulation.ModelComponent_swigregister(ModelComponent)

def ModelComponent_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponent *":
    return _simulation.ModelComponent_safeDownCast(obj)

def ModelComponent_getClassName() -> "std::string const &":
    return _simulation.ModelComponent_getClassName()

class SetModelComponents(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ModelComponent,OpenSim::ModelComponent > *":
        return _simulation.SetModelComponents_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetModelComponents_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetModelComponents_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::ModelComponent,OpenSim::ModelComponent > *":
        return _simulation.SetModelComponents_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetModelComponents_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetModelComponents

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ModelComponent,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetModelComponents_swiginit(self, _simulation.new_SetModelComponents(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetModelComponents_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetModelComponents_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetModelComponents_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetModelComponents_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetModelComponents_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetModelComponents_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "ModelComponent") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetModelComponents_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "ModelComponent") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetModelComponents_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "ModelComponent") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetModelComponents_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ModelComponent`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetModelComponents_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetModelComponents_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "ModelComponent", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ModelComponent`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetModelComponents_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::ModelComponent &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ModelComponent`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ModelComponent`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetModelComponents_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetModelComponents_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetModelComponents_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetModelComponents_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetModelComponents_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetModelComponents_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetModelComponents_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetModelComponents_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetModelComponents_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetModelComponents_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetModelComponents in _simulation:
_simulation.SetModelComponents_swigregister(SetModelComponents)

def SetModelComponents_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ModelComponent,OpenSim::ModelComponent > *":
    return _simulation.SetModelComponents_safeDownCast(obj)

def SetModelComponents_getClassName() -> "std::string const &":
    return _simulation.SetModelComponents_getClassName()

class ModelComponentSetModelComponent(SetModelComponents):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ModelComponent > *":
        return _simulation.ModelComponentSetModelComponent_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetModelComponent_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetModelComponent_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::ModelComponent > *":
        return _simulation.ModelComponentSetModelComponent_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetModelComponent_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetModelComponent_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetModelComponent_swiginit(self, _simulation.new_ModelComponentSetModelComponent())
    __swig_destroy__ = _simulation.delete_ModelComponentSetModelComponent

# Register ModelComponentSetModelComponent in _simulation:
_simulation.ModelComponentSetModelComponent_swigregister(ModelComponentSetModelComponent)

def ModelComponentSetModelComponent_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ModelComponent > *":
    return _simulation.ModelComponentSetModelComponent_safeDownCast(obj)

def ModelComponentSetModelComponent_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetModelComponent_getClassName()

class ComponentSet(ModelComponentSetModelComponent):
    r"""
    A class for holding a set of miscellaneous model components.

    Authors: Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ComponentSet *":
        return _simulation.ComponentSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ComponentSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ComponentSet_getClassName()

    def clone(self) -> "OpenSim::ComponentSet *":
        return _simulation.ComponentSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ComponentSet_getConcreteClassName(self)

    def __init__(self):
        _simulation.ComponentSet_swiginit(self, _simulation.new_ComponentSet())
    __swig_destroy__ = _simulation.delete_ComponentSet

# Register ComponentSet in _simulation:
_simulation.ComponentSet_swigregister(ComponentSet)

def ComponentSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ComponentSet *":
    return _simulation.ComponentSet_safeDownCast(obj)

def ComponentSet_getClassName() -> "std::string const &":
    return _simulation.ComponentSet_getClassName()

class SetMuscles(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Muscle,OpenSim::Object > *":
        return _simulation.SetMuscles_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetMuscles_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetMuscles_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Muscle,OpenSim::Object > *":
        return _simulation.SetMuscles_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetMuscles_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMuscles

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Muscle,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetMuscles_swiginit(self, _simulation.new_SetMuscles(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMuscles_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMuscles_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMuscles_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMuscles_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Muscle`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMuscles_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetMuscles_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Muscle") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMuscles_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Muscle") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Muscle`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMuscles_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Muscle") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMuscles_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Muscle`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMuscles_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetMuscles_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Muscle", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Muscle`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMuscles_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Muscle &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Muscle`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Muscle`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMuscles_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMuscles_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMuscles_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetMuscles_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetMuscles_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMuscles_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetMuscles_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetMuscles_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetMuscles_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMuscles_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMuscles in _simulation:
_simulation.SetMuscles_swigregister(SetMuscles)

def SetMuscles_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Muscle,OpenSim::Object > *":
    return _simulation.SetMuscles_safeDownCast(obj)

def SetMuscles_getClassName() -> "std::string const &":
    return _simulation.SetMuscles_getClassName()

class Solver(opensim.common.OpenSimObject):
    r"""
    The base (abstract) class for a family of objects responsible for solving
    system equations (statics, dynamic, kinematics, muscle, etc...) given by a
    model for values of interest.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Solver *":
        return _simulation.Solver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Solver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Solver_getClassName()

    def clone(self) -> "OpenSim::Solver *":
        return _simulation.Solver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Solver_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_Solver

    def getModel(self) -> "OpenSim::Model const &":
        return _simulation.Solver_getModel(self)

# Register Solver in _simulation:
_simulation.Solver_swigregister(Solver)

def Solver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Solver *":
    return _simulation.Solver_safeDownCast(obj)

def Solver_getClassName() -> "std::string const &":
    return _simulation.Solver_getClassName()

class InverseDynamicsSolver(Solver):
    r"""
    Solve for the generalized coordinate forces (1 per degree-of-
    freedom) that satisfy the unconstrained equations of motion given kinematics:
    q, u, u_dot

    The InverseDynamics equation: Tau = M*u_dot-G(q)-C(q,u)-A(q,u,t,x)

    The InverseDynamicsSolver utilizes efficient methods in Simbody(TM) to
    compute the generalized forces, Tau, without explicitly forming the Mass
    matrix, M. System gravity, G, centrifugal and Coriolis, C, forces are
    computed internally.
    Caller provides q,u,t (supplied by the State), the desired u_dot and the
    applied loads, A. If applied loads are due to forces in the model, these
    loads are automatically computed and applied unless explicitly disabled in
    the model.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseDynamicsSolver *":
        return _simulation.InverseDynamicsSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.InverseDynamicsSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.InverseDynamicsSolver_getClassName()

    def clone(self) -> "OpenSim::InverseDynamicsSolver *":
        return _simulation.InverseDynamicsSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.InverseDynamicsSolver_getConcreteClassName(self)

    def __init__(self, model: "Model"):
        r""" Construct an InverseDynamics solver applied to the provided model"""
        _simulation.InverseDynamicsSolver_swiginit(self, _simulation.new_InverseDynamicsSolver(model))

    def solve(self, *args) -> "SimTK::Vector":
        r"""
        *Overload 1:*
        Solve the inverse dynamics system of equations for generalized
               coordinate forces, Tau. Applied loads are computed by the model
               according to the state.
               :type s: :py:class:`State`, in
               :param s:    the system state specifying time, coordinates and speeds
               :type udot: :py:class:`Vector`, in, optional
               :param udot: the vector of generalized accelerations in the order

        |

        *Overload 2:*
        Solve the inverse dynamics system of equations for generalized coordinate forces, Tau.
               Applied loads are explicitly provided as generalized coordinate forces (MobilityForces)
               and/or a Vector of Spatial-body forces

        |

        *Overload 3:*
        Solve the inverse dynamics system of equations for generalized coordinate
               forces, Tau. Now the state is updated from known coordinates, q, as
               functions of time. Coordinate functions must be twice differentiable and
               are used to supply the coordinate speed and acceleration. Coordinate
               functions must be in the same order as the order of q's, u's, and udot's
               in the provided SimTK::State.
               NOTE: forces with internal states should be removed/disabled prior to
                     solving if default state is inappropriate

        |

        *Overload 4:*
        This is the same as above, but can be used when qdot != u. This adds an
               extra vector, coordinatesToSpeedsIndexMap, which is the length of number of u's in
               the SimTK::State, and whose i'th index is the index of the FunctionSet
               Qs from which each 'u' and 'udot' will be calculated.
        """
        return _simulation.InverseDynamicsSolver_solve(self, *args)
    __swig_destroy__ = _simulation.delete_InverseDynamicsSolver

# Register InverseDynamicsSolver in _simulation:
_simulation.InverseDynamicsSolver_swigregister(InverseDynamicsSolver)

def InverseDynamicsSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseDynamicsSolver *":
    return _simulation.InverseDynamicsSolver_safeDownCast(obj)

def InverseDynamicsSolver_getClassName() -> "std::string const &":
    return _simulation.InverseDynamicsSolver_getClassName()

class MomentArmSolver(Solver):
    r"""
    Solve for the effective moment arms at all degrees-of-freedom due to one or
    more point forces.  This may result from the underlying geometry of a Force
    or Actuator with a complex path (like ligaments and muscles) but this solver
    is only concerned with the set of points and unit forces that maps a scalar
    force value (like tension) to the resulting generalized force.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MomentArmSolver *":
        return _simulation.MomentArmSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MomentArmSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MomentArmSolver_getClassName()

    def clone(self) -> "OpenSim::MomentArmSolver *":
        return _simulation.MomentArmSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MomentArmSolver_getConcreteClassName(self)

    def __init__(self, model: "Model"):
        _simulation.MomentArmSolver_swiginit(self, _simulation.new_MomentArmSolver(model))
    __swig_destroy__ = _simulation.delete_MomentArmSolver

    def solve(self, *args) -> "double":
        r"""
        *Overload 1:*
        Solve for the effective moment-arm about the all coordinates (q) based
               on the geometric distribution of forces described by a GeometryPath.
           :type state: :py:class:`State`
           :param state:               current state of the model
           :type coordinate: :py:class:`Coordinate`
           :param coordinate:          Coordinate about which we want the moment-arm
           :type path: :py:class:`GeometryPath`
           :param path:                GeometryPath for which to calculate a moment-arm
           :rtype: float
           :return: ma                  resulting moment-arm as a double

        |

        *Overload 2:*
        Solve for the effective moment-arm about the specified coordinate based
               on the geometric distribution of forces described by the list of
               PointForceDirections.
           :type state: :py:class:`State`
           :param state:               current state of the model
           :type coordinate: :py:class:`Coordinate`
           :param coordinate:          Coordinate about which we want the moment-arm
           :type pfds: OpenSim::Array< OpenSim::PointForceDirection * >
           :param pfds:                PointForceDirections applied to the model
           :rtype: float
           :return: ma                  resulting moment-arm as a double
        """
        return _simulation.MomentArmSolver_solve(self, *args)

# Register MomentArmSolver in _simulation:
_simulation.MomentArmSolver_swigregister(MomentArmSolver)

def MomentArmSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MomentArmSolver *":
    return _simulation.MomentArmSolver_safeDownCast(obj)

def MomentArmSolver_getClassName() -> "std::string const &":
    return _simulation.MomentArmSolver_getClassName()

class Frame(ModelComponent):
    r"""
    A Frame is an OpenSim representation of a reference frame. It consists of
    a right-handed set of three orthogonal axes and an origin point. Frames are
    intended to provide convenient reference frames for locating physical
    structures (such as joints and muscle attachments) as well as provide a
    convenient basis for performing spatial calculations. For example, if your
    system involves contact, you might define a Frame that is aligned with the
    normal direction of a contact surface and whose origin is at the
    center-of-pressure.

    Every Frame is capable of providing its SimTK::Transform (translation of
    the origin and the orientation of its axes) in the Ground frame as a
    function of the Model's (SimTK::MultibodySystem's) state.

    The Frame class also provides convenience methods for re-expressing vectors
    from one Frame to another.

    As already noted, Frames are useful for locating physical structures such as
    bodies, their joints, and the locations where constraints can be connected
    and forces can be applied. It is perhaps less evident that Frames can be
    extremely useful for relating a multitude of reference frames together to
    form chains and trees. For example, a Frame to specify muscle attachments
    (M) and a Frame to specify a joint location (J) could themselves be
    specified in an anatomical Frame (A) defined by bony landmarks identified
    by surface markers or tagged on CT or MRI images. The body (B), to which the
    anatomical frame (A) is attached, can be thought of as a "Base" frame or a
    root of a tree from which a set of descendant frames arise. In particular, a
    Base frame and all its descendants have the property that they share the
    same angular velocity, since they are affixed to the same underlying Frame
    (in this case a Body).

            M---muscle points
           /
      B---A

            J---joint axes

    Therefore, a useful concept is that of a Base frame, and a Frame can always
    provide a Base frame. If a Frame is not affixed to another frame, its Base
    frame is itself.

    See also: SimTK::Transform

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Frame *":
        return _simulation.Frame_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Frame_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Frame_getClassName()

    def clone(self) -> "OpenSim::Frame *":
        return _simulation.Frame_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Frame_getConcreteClassName(self)

    def copyProperty_frame_geometry(self, source: "Frame") -> "void":
        return _simulation.Frame_copyProperty_frame_geometry(self, source)

    def append_frame_geometry(self, value: "FrameGeometry") -> "int":
        return _simulation.Frame_append_frame_geometry(self, value)

    def constructProperty_frame_geometry(self, initValue: "FrameGeometry") -> "void":
        return _simulation.Frame_constructProperty_frame_geometry(self, initValue)

    def get_frame_geometry(self, *args) -> "OpenSim::FrameGeometry const &":
        return _simulation.Frame_get_frame_geometry(self, *args)

    def upd_frame_geometry(self, *args) -> "OpenSim::FrameGeometry &":
        return _simulation.Frame_upd_frame_geometry(self, *args)

    def set_frame_geometry(self, *args) -> "void":
        return _simulation.Frame_set_frame_geometry(self, *args)

    def copyProperty_attached_geometry(self, source: "Frame") -> "void":
        return _simulation.Frame_copyProperty_attached_geometry(self, source)

    def get_attached_geometry(self, i: "int") -> "OpenSim::Geometry const &":
        return _simulation.Frame_get_attached_geometry(self, i)

    def upd_attached_geometry(self, i: "int") -> "OpenSim::Geometry &":
        return _simulation.Frame_upd_attached_geometry(self, i)

    def set_attached_geometry(self, i: "int", value: "Geometry") -> "void":
        return _simulation.Frame_set_attached_geometry(self, i, value)

    def append_attached_geometry(self, value: "Geometry") -> "int":
        return _simulation.Frame_append_attached_geometry(self, value)

    def constructProperty_attached_geometry(self) -> "void":
        return _simulation.Frame_constructProperty_attached_geometry(self)
    _has_output_position = property(_simulation.Frame__has_output_position_get, _simulation.Frame__has_output_position_set)
    _has_output_rotation = property(_simulation.Frame__has_output_rotation_get, _simulation.Frame__has_output_rotation_set)
    _has_output_transform = property(_simulation.Frame__has_output_transform_get, _simulation.Frame__has_output_transform_set)
    _has_output_velocity = property(_simulation.Frame__has_output_velocity_get, _simulation.Frame__has_output_velocity_set)
    _has_output_angular_velocity = property(_simulation.Frame__has_output_angular_velocity_get, _simulation.Frame__has_output_angular_velocity_set)
    _has_output_linear_velocity = property(_simulation.Frame__has_output_linear_velocity_get, _simulation.Frame__has_output_linear_velocity_set)
    _has_output_acceleration = property(_simulation.Frame__has_output_acceleration_get, _simulation.Frame__has_output_acceleration_set)
    _has_output_angular_acceleration = property(_simulation.Frame__has_output_angular_acceleration_get, _simulation.Frame__has_output_angular_acceleration_set)
    _has_output_linear_acceleration = property(_simulation.Frame__has_output_linear_acceleration_get, _simulation.Frame__has_output_linear_acceleration_set)
    __swig_destroy__ = _simulation.delete_Frame

    def getTransformInGround(self, state: "State") -> "SimTK::Transform const &":
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.Frame_getTransformInGround(self, state)

    def getVelocityInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.Frame_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.Frame_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.Frame_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.Frame_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.Frame_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.Frame_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state: "State", otherFrame: "Frame") -> "SimTK::Transform":
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.Frame_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state: "State", vec_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.Frame_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state: "State", vec_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.Frame_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state: "State", station_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.Frame_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.Frame_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.Frame_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.Frame_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self) -> "OpenSim::Frame const &":
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.Frame_findBaseFrame(self)

    def findTransformInBaseFrame(self) -> "SimTK::Transform":
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.Frame_findTransformInBaseFrame(self)

    def getPositionInGround(self, state: "State") -> "SimTK::Vec3":
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.Frame_getPositionInGround(self, state)

    def getRotationInGround(self, state: "State") -> "SimTK::Rotation_< double >":
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.Frame_getRotationInGround(self, state)

    def attachGeometry(self, geom: "Geometry") -> "void":
        r"""
        Attach Geometry to this Frame and have this Frame take ownership of
                it by adding it to this Frame's <attached_geometry> property list.
                The Geometry is treated as being fixed to this Frame such that the
                transform used to position the Geometry is that of this Frame.
        """
        val = _simulation.Frame_attachGeometry(self, geom)

        geom._markAdopted()


        return val


    def scaleAttachedGeometry(self, scaleFactors: "Vec3") -> "void":
        return _simulation.Frame_scaleAttachedGeometry(self, scaleFactors)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scales Geometry components that reside in the Frame's
               `attached_geometry` list property. Note that Geometry residing elsewhere
               (e.g., in the `components` list property of a Frame or any other
               Component) will not be scaled. Note also that ContactGeometry derives
               from ModelComponent so the classes derived from ContactGeometry are
               responsible for scaling themselves. (However, `scale()` is not currently
               implemented on ContactGeometry or classes derived therefrom so they will
               not scale with the Model.)
        """
        return _simulation.Frame_extendScale(self, s, scaleSet)

# Register Frame in _simulation:
_simulation.Frame_swigregister(Frame)

def Frame_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Frame *":
    return _simulation.Frame_safeDownCast(obj)

def Frame_getClassName() -> "std::string const &":
    return _simulation.Frame_getClassName()

class WrapObject(ModelComponent):
    r"""
    An abstract class that specifies the interface for a wrapping
    object.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapObject *":
        return _simulation.WrapObject_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapObject_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapObject_getClassName()

    def clone(self) -> "OpenSim::WrapObject *":
        return _simulation.WrapObject_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapObject_getConcreteClassName(self)

    def copyProperty_active(self, source: "WrapObject") -> "void":
        return _simulation.WrapObject_copyProperty_active(self, source)

    def append_active(self, value: "bool const &") -> "int":
        return _simulation.WrapObject_append_active(self, value)

    def constructProperty_active(self, initValue: "bool const &") -> "void":
        return _simulation.WrapObject_constructProperty_active(self, initValue)

    def get_active(self, *args) -> "bool const &":
        return _simulation.WrapObject_get_active(self, *args)

    def upd_active(self, *args) -> "bool &":
        return _simulation.WrapObject_upd_active(self, *args)

    def set_active(self, *args) -> "void":
        return _simulation.WrapObject_set_active(self, *args)

    def copyProperty_xyz_body_rotation(self, source: "WrapObject") -> "void":
        return _simulation.WrapObject_copyProperty_xyz_body_rotation(self, source)

    def append_xyz_body_rotation(self, value: "Vec3") -> "int":
        return _simulation.WrapObject_append_xyz_body_rotation(self, value)

    def constructProperty_xyz_body_rotation(self, initValue: "Vec3") -> "void":
        return _simulation.WrapObject_constructProperty_xyz_body_rotation(self, initValue)

    def get_xyz_body_rotation(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.WrapObject_get_xyz_body_rotation(self, *args)

    def upd_xyz_body_rotation(self, *args) -> "SimTK::Vec3 &":
        return _simulation.WrapObject_upd_xyz_body_rotation(self, *args)

    def set_xyz_body_rotation(self, *args) -> "void":
        return _simulation.WrapObject_set_xyz_body_rotation(self, *args)

    def copyProperty_translation(self, source: "WrapObject") -> "void":
        return _simulation.WrapObject_copyProperty_translation(self, source)

    def append_translation(self, value: "Vec3") -> "int":
        return _simulation.WrapObject_append_translation(self, value)

    def constructProperty_translation(self, initValue: "Vec3") -> "void":
        return _simulation.WrapObject_constructProperty_translation(self, initValue)

    def get_translation(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.WrapObject_get_translation(self, *args)

    def upd_translation(self, *args) -> "SimTK::Vec3 &":
        return _simulation.WrapObject_upd_translation(self, *args)

    def set_translation(self, *args) -> "void":
        return _simulation.WrapObject_set_translation(self, *args)

    def copyProperty_Appearance(self, source: "WrapObject") -> "void":
        return _simulation.WrapObject_copyProperty_Appearance(self, source)

    def append_Appearance(self, value: "Appearance") -> "int":
        return _simulation.WrapObject_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue: "Appearance") -> "void":
        return _simulation.WrapObject_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args) -> "OpenSim::Appearance const &":
        return _simulation.WrapObject_get_Appearance(self, *args)

    def upd_Appearance(self, *args) -> "OpenSim::Appearance &":
        return _simulation.WrapObject_upd_Appearance(self, *args)

    def set_Appearance(self, *args) -> "void":
        return _simulation.WrapObject_set_Appearance(self, *args)

    def copyProperty_quadrant(self, source: "WrapObject") -> "void":
        return _simulation.WrapObject_copyProperty_quadrant(self, source)

    def append_quadrant(self, value: "std::string const &") -> "int":
        return _simulation.WrapObject_append_quadrant(self, value)

    def constructProperty_quadrant(self, initValue: "std::string const &") -> "void":
        return _simulation.WrapObject_constructProperty_quadrant(self, initValue)

    def get_quadrant(self, *args) -> "std::string const &":
        return _simulation.WrapObject_get_quadrant(self, *args)

    def upd_quadrant(self, *args) -> "std::string &":
        return _simulation.WrapObject_upd_quadrant(self, *args)

    def set_quadrant(self, *args) -> "void":
        return _simulation.WrapObject_set_quadrant(self, *args)
    allQuadrants = _simulation.WrapObject_allQuadrants
    negativeX = _simulation.WrapObject_negativeX
    positiveX = _simulation.WrapObject_positiveX
    negativeY = _simulation.WrapObject_negativeY
    positiveY = _simulation.WrapObject_positiveY
    negativeZ = _simulation.WrapObject_negativeZ
    positiveZ = _simulation.WrapObject_positiveZ
    noWrap = _simulation.WrapObject_noWrap
    insideRadius = _simulation.WrapObject_insideRadius
    wrapped = _simulation.WrapObject_wrapped
    mandatoryWrap = _simulation.WrapObject_mandatoryWrap
    __swig_destroy__ = _simulation.delete_WrapObject

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.WrapObject_extendScale(self, s, scaleSet)

    def connectToModelAndBody(self, aModel: "Model", aBody: "PhysicalFrame") -> "void":
        return _simulation.WrapObject_connectToModelAndBody(self, aModel, aBody)

    def getFrame(self) -> "OpenSim::PhysicalFrame const &":
        return _simulation.WrapObject_getFrame(self)

    def setFrame(self, frame: "PhysicalFrame") -> "void":
        return _simulation.WrapObject_setFrame(self, frame)

    def getActiveUseDefault(self) -> "bool":
        return _simulation.WrapObject_getActiveUseDefault(self)

    def getQuadrantNameUseDefault(self) -> "bool":
        return _simulation.WrapObject_getQuadrantNameUseDefault(self)

    def getTransform(self) -> "SimTK::Transform const &":
        return _simulation.WrapObject_getTransform(self)

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapObject_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapObject_getDimensionsString(self)

    def wrapPathSegment(self, state: "State", aPoint1: "AbstractPathPoint", aPoint2: "AbstractPathPoint", aPathWrap: "PathWrap", aWrapResult: "OpenSim::WrapResult &") -> "int":
        r"""
        Calculate the wrapping of one path segment over one wrap object.
        :type state: :py:class:`State`
        :param state:   The State of the model
        :type aPoint1: :py:class:`AbstractPathPoint`
        :param aPoint1: The first path point
        :type aPoint2: :py:class:`AbstractPathPoint`
        :param aPoint2: The second path point
        :type aPathWrap: :py:class:`PathWrap`
        :param aPathWrap: An object holding the parameters for this path/wrap-object pairing
        :type aWrapResult: OpenSim::WrapResult
        :param aWrapResult: The result of the wrapping (tangent points, etc.)
        :rtype: int
        :return: The status, as a WrapAction enum
        """
        return _simulation.WrapObject_wrapPathSegment(self, state, aPoint1, aPoint2, aPathWrap, aWrapResult)

# Register WrapObject in _simulation:
_simulation.WrapObject_swigregister(WrapObject)

def WrapObject_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapObject *":
    return _simulation.WrapObject_safeDownCast(obj)

def WrapObject_getClassName() -> "std::string const &":
    return _simulation.WrapObject_getClassName()

class SetWrapObject(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::WrapObject,OpenSim::ModelComponent > *":
        return _simulation.SetWrapObject_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetWrapObject_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetWrapObject_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::WrapObject,OpenSim::ModelComponent > *":
        return _simulation.SetWrapObject_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetWrapObject_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetWrapObject

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::WrapObject,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetWrapObject_swiginit(self, _simulation.new_SetWrapObject(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetWrapObject_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetWrapObject_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetWrapObject_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetWrapObject_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetWrapObject_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetWrapObject_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "WrapObject") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetWrapObject_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "WrapObject") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetWrapObject_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "WrapObject") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetWrapObject_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`WrapObject`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetWrapObject_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetWrapObject_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "WrapObject", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`WrapObject`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetWrapObject_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::WrapObject &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`WrapObject`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`WrapObject`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetWrapObject_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetWrapObject_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetWrapObject_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetWrapObject_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetWrapObject_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetWrapObject_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetWrapObject_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetWrapObject_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetWrapObject_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetWrapObject_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetWrapObject in _simulation:
_simulation.SetWrapObject_swigregister(SetWrapObject)

def SetWrapObject_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::WrapObject,OpenSim::ModelComponent > *":
    return _simulation.SetWrapObject_safeDownCast(obj)

def SetWrapObject_getClassName() -> "std::string const &":
    return _simulation.SetWrapObject_getClassName()

class ModelComponentSetWrapObjects(SetWrapObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::WrapObject > *":
        return _simulation.ModelComponentSetWrapObjects_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetWrapObjects_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetWrapObjects_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::WrapObject > *":
        return _simulation.ModelComponentSetWrapObjects_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetWrapObjects_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetWrapObjects_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetWrapObjects_swiginit(self, _simulation.new_ModelComponentSetWrapObjects())
    __swig_destroy__ = _simulation.delete_ModelComponentSetWrapObjects

# Register ModelComponentSetWrapObjects in _simulation:
_simulation.ModelComponentSetWrapObjects_swigregister(ModelComponentSetWrapObjects)

def ModelComponentSetWrapObjects_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::WrapObject > *":
    return _simulation.ModelComponentSetWrapObjects_safeDownCast(obj)

def ModelComponentSetWrapObjects_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetWrapObjects_getClassName()

class WrapObjectSet(ModelComponentSetWrapObjects):
    r"""
    A class for holding a set of wrap objects.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapObjectSet *":
        return _simulation.WrapObjectSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapObjectSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapObjectSet_getClassName()

    def clone(self) -> "OpenSim::WrapObjectSet *":
        return _simulation.WrapObjectSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapObjectSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.WrapObjectSet_swiginit(self, _simulation.new_WrapObjectSet(*args))
    __swig_destroy__ = _simulation.delete_WrapObjectSet

# Register WrapObjectSet in _simulation:
_simulation.WrapObjectSet_swigregister(WrapObjectSet)

def WrapObjectSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapObjectSet *":
    return _simulation.WrapObjectSet_safeDownCast(obj)

def WrapObjectSet_getClassName() -> "std::string const &":
    return _simulation.WrapObjectSet_getClassName()

class PhysicalFrame(Frame):
    r"""
    A PhysicalFrame is a Frame that locates a physical element of the multi-
    body system that underlies a Model. A PhysicalFrame supports physical
    connections (e.g. Joints, Constraints) and is the Frame type upon which
    forces can be applied. A concrete example of a PhysicalFrame is a Body.
    Attributes of a Body (its center-of-mass, geometry, ...) are located in the
    Body frame. Bodies are connected by Joints and Constraints and Forces are
    readily applied to them. A location that represents an offset from the Body
    frame, can also be a PhysicalFrame (e.g. a PhysicalOffsetFrame).

    See also: PhysicalOffsetFrame

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PhysicalFrame *":
        return _simulation.PhysicalFrame_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PhysicalFrame_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PhysicalFrame_getClassName()

    def clone(self) -> "OpenSim::PhysicalFrame *":
        return _simulation.PhysicalFrame_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PhysicalFrame_getConcreteClassName(self)

    def copyProperty_WrapObjectSet(self, source: "PhysicalFrame") -> "void":
        return _simulation.PhysicalFrame_copyProperty_WrapObjectSet(self, source)

    def append_WrapObjectSet(self, value: "WrapObjectSet") -> "int":
        return _simulation.PhysicalFrame_append_WrapObjectSet(self, value)

    def constructProperty_WrapObjectSet(self, initValue: "WrapObjectSet") -> "void":
        return _simulation.PhysicalFrame_constructProperty_WrapObjectSet(self, initValue)

    def get_WrapObjectSet(self, *args) -> "OpenSim::WrapObjectSet const &":
        return _simulation.PhysicalFrame_get_WrapObjectSet(self, *args)

    def upd_WrapObjectSet(self, *args) -> "OpenSim::WrapObjectSet &":
        return _simulation.PhysicalFrame_upd_WrapObjectSet(self, *args)

    def set_WrapObjectSet(self, *args) -> "void":
        return _simulation.PhysicalFrame_set_WrapObjectSet(self, *args)
    __swig_destroy__ = _simulation.delete_PhysicalFrame

    def getMobilizedBodyIndex(self) -> "SimTK::MobilizedBodyIndex const &":
        r"""
        This method returns the MobilizedBodyIndex of the MobilizedBody for this
        PhysicalFrame. This index is only available after Model::initSystem() has
        been invoked.

        The MobilizedBodyIndex is necessary to access the underlying MobilizedBody
        in the System. It allows access to physical quantities (e.g. forces)
        associated with individual PhysicalFrames. For examples, the underlying
        MultibodySystem's net body forces are represented as a Vector of spatial
        forces (torque and force on each body) and it is indexed by the
        MobilizedBodyIndex.

        :rtype: int
        :return: index The MobilizedBodyIndex corresponding to this PhysicalFrame's
                       underlying MobilizedBody

        See also: getMobilizedBody, updMobilizedBody
        """
        return _simulation.PhysicalFrame_getMobilizedBodyIndex(self)

    def getMobilizedBody(self) -> "SimTK::MobilizedBody const &":
        r"""
        Access a readable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.PhysicalFrame_getMobilizedBody(self)

    def updMobilizedBody(self) -> "SimTK::MobilizedBody &":
        r"""
        Access a writable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.PhysicalFrame_updMobilizedBody(self)

    def getWrapObject(self, aName: "std::string const &") -> "OpenSim::WrapObject const *":
        r"""
        Deprecated methods for intermediate integration of Frames  Get the named wrap object, if it exists.

        :type aName: string
        :param aName: Name of the wrap object.
        :rtype: :py:class:`WrapObject`
        :return: const Pointer to the wrap object.
        """
        return _simulation.PhysicalFrame_getWrapObject(self, aName)

    def getWrapObjectSet(self) -> "OpenSim::WrapObjectSet const &":
        return _simulation.PhysicalFrame_getWrapObjectSet(self)

    def addWrapObject(self, wrapObject: "WrapObject") -> "void":
        r"""
         Add a wrap object to the Body. Note that the Body takes ownership of
        the WrapObject.
        """
        val = _simulation.PhysicalFrame_addWrapObject(self, wrapObject)

        wrapObject._markAdopted()


        return val


# Register PhysicalFrame in _simulation:
_simulation.PhysicalFrame_swigregister(PhysicalFrame)

def PhysicalFrame_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PhysicalFrame *":
    return _simulation.PhysicalFrame_safeDownCast(obj)

def PhysicalFrame_getClassName() -> "std::string const &":
    return _simulation.PhysicalFrame_getClassName()

class Ground(PhysicalFrame):
    r"""
    Ground is an inertial reference frame in which the
    motion of all Frames and points may conveniently and efficiently
    be expressed. As a PhysicalFrame, Ground supports physical connections
    (e.g. Joints, Constraints), and forces can be applied to it.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ground *":
        return _simulation.Ground_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Ground_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Ground_getClassName()

    def clone(self) -> "OpenSim::Ground *":
        return _simulation.Ground_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Ground_getConcreteClassName(self)

    def __init__(self):
        r""" Default Constructor"""
        _simulation.Ground_swiginit(self, _simulation.new_Ground())
    __swig_destroy__ = _simulation.delete_Ground

# Register Ground in _simulation:
_simulation.Ground_swigregister(Ground)

def Ground_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ground *":
    return _simulation.Ground_safeDownCast(obj)

def Ground_getClassName() -> "std::string const &":
    return _simulation.Ground_getClassName()

class PhysicalFrameWithOffset(PhysicalFrame):
    r"""
    An OffsetFrame is a Frame whose transform (translation and orientation)
    with respect to another (parent) Frame is constant in time. It acts as an
    extension of the parent Frame type so that an OffsetFrame<PhysicalFrame>,
    for example, can be treated as a PhysicalFrame. This enables Frames to be
    filtered by their type (e.g. Physical or not), regardless of whether or
    not the Frame is also an OffsetFrame. (A class whose super class is a
    template parameter is called a mixin class.)

    OffsetFrames also have the property that if they form a chain or a tree,
    each OffsetFrame shares the same Base which is the parent of the first/root
    OffsetFrame in the tree. This allows Solvers and algorithms to work directly
    with the Base which can be more efficient.

    OffsetFrame is an abstract class. Derive concrete subclasses in order to
    accommodate new Frame types that require their offsets to retain the same
    type as the parent. For example:

    .. code-block:: c++

        class PhysicalOffsetFrame : public OffsetFrame<PhysicalFrame>

    See also: PhysicalOffsetFrame.

    :param C: The type of the parent frame, as well as the super class. Must be
        of type Frame.

    Author: Matt DeMers
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::OffsetFrame< OpenSim::PhysicalFrame > *":
        return _simulation.PhysicalFrameWithOffset_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PhysicalFrameWithOffset_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PhysicalFrameWithOffset_getClassName()

    def clone(self) -> "OpenSim::OffsetFrame< OpenSim::PhysicalFrame > *":
        return _simulation.PhysicalFrameWithOffset_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PhysicalFrameWithOffset_getConcreteClassName(self)

    def copyProperty_translation(self, source: "PhysicalFrameWithOffset") -> "void":
        return _simulation.PhysicalFrameWithOffset_copyProperty_translation(self, source)

    def append_translation(self, value: "Vec3") -> "int":
        return _simulation.PhysicalFrameWithOffset_append_translation(self, value)

    def constructProperty_translation(self, initValue: "Vec3") -> "void":
        return _simulation.PhysicalFrameWithOffset_constructProperty_translation(self, initValue)

    def get_translation(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PhysicalFrameWithOffset_get_translation(self, *args)

    def upd_translation(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PhysicalFrameWithOffset_upd_translation(self, *args)

    def set_translation(self, *args) -> "void":
        return _simulation.PhysicalFrameWithOffset_set_translation(self, *args)

    def copyProperty_orientation(self, source: "PhysicalFrameWithOffset") -> "void":
        return _simulation.PhysicalFrameWithOffset_copyProperty_orientation(self, source)

    def append_orientation(self, value: "Vec3") -> "int":
        return _simulation.PhysicalFrameWithOffset_append_orientation(self, value)

    def constructProperty_orientation(self, initValue: "Vec3") -> "void":
        return _simulation.PhysicalFrameWithOffset_constructProperty_orientation(self, initValue)

    def get_orientation(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PhysicalFrameWithOffset_get_orientation(self, *args)

    def upd_orientation(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PhysicalFrameWithOffset_upd_orientation(self, *args)

    def set_orientation(self, *args) -> "void":
        return _simulation.PhysicalFrameWithOffset_set_orientation(self, *args)
    PropertyIndex_socket_parent = property(_simulation.PhysicalFrameWithOffset_PropertyIndex_socket_parent_get, _simulation.PhysicalFrameWithOffset_PropertyIndex_socket_parent_set)

    def connectSocket_parent(self, object: "OpenSimObject") -> "void":
        return _simulation.PhysicalFrameWithOffset_connectSocket_parent(self, object)

    def setParentFrame(self, parent: "PhysicalFrame") -> "void":
        r""" Sets the parent reference frame"""
        return _simulation.PhysicalFrameWithOffset_setParentFrame(self, parent)

    def getParentFrame(self) -> "OpenSim::PhysicalFrame const &":
        r""" Get the parent reference frame"""
        return _simulation.PhysicalFrameWithOffset_getParentFrame(self)

    def getOffsetTransform(self) -> "SimTK::Transform const &":
        r"""
        Get the transform that describes the translational and rotational offset
        of this frame (F frame) relative to its parent frame (B frame).  This method
        returns the transform converting quantities expressed in F frame to
        quantities expressed in the B frame. This is mathematically stated as,
        vec_P = X_BF*vec_F ,
        where X_BF is the transform returned by getTransform.

        This transform is computed using the translation and orientation
        properties of this object.

        :rtype: :py:class:`Transform`
        :return: offset  The transform between this frame and its parent frame.
        """
        return _simulation.PhysicalFrameWithOffset_getOffsetTransform(self)

    def setOffsetTransform(self, offset: "Transform") -> "void":
        r"""
        Sets the transform the translates and rotates this frame (F frame) from
        its parent frame (P frame). You should provide the transform X_PF
        such that vec_P = X_PF*vec_F.

        This transform is stored via the translation and orientation
        properties of this object.

        :type offset: :py:class:`Transform`
        :param offset:   The transform between this frame and its parent frame.
        """
        return _simulation.PhysicalFrameWithOffset_setOffsetTransform(self, offset)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r""" Scale the offset given scale factors for spatial (XYZ) dimensions."""
        return _simulation.PhysicalFrameWithOffset_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_PhysicalFrameWithOffset

# Register PhysicalFrameWithOffset in _simulation:
_simulation.PhysicalFrameWithOffset_swigregister(PhysicalFrameWithOffset)

def PhysicalFrameWithOffset_safeDownCast(obj: "OpenSimObject") -> "OpenSim::OffsetFrame< OpenSim::PhysicalFrame > *":
    return _simulation.PhysicalFrameWithOffset_safeDownCast(obj)

def PhysicalFrameWithOffset_getClassName() -> "std::string const &":
    return _simulation.PhysicalFrameWithOffset_getClassName()

class PhysicalOffsetFrame(PhysicalFrameWithOffset):
    r"""
    A PhysicalOffsetFrame is a PhysicalFrame whose transform is specified as a
    constant offset from another PhysicalFrame. PhysicalOffsetFrames can be used
    to specify the location of a Joint or Constraint on a Body or any other
    PhysicalFrame. For example, the location and orientation of the knee joint
    frame specified in the femur (thigh) and tibia (shank) Body reference frames.
    This class has the methods of both the OffsetFrame (template) and the
    PhysicalFrame class.

    NOTE: PhysicalOffsetFrame is closed to extensions. Consider extending
    OffsetFrame and/or use the mixin with a derived class of PhysicalFrame.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PhysicalOffsetFrame *":
        return _simulation.PhysicalOffsetFrame_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PhysicalOffsetFrame_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PhysicalOffsetFrame_getClassName()

    def clone(self) -> "OpenSim::PhysicalOffsetFrame *":
        return _simulation.PhysicalOffsetFrame_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PhysicalOffsetFrame_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_PhysicalOffsetFrame

    def __init__(self, *args):
        _simulation.PhysicalOffsetFrame_swiginit(self, _simulation.new_PhysicalOffsetFrame(*args))

# Register PhysicalOffsetFrame in _simulation:
_simulation.PhysicalOffsetFrame_swigregister(PhysicalOffsetFrame)

def PhysicalOffsetFrame_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PhysicalOffsetFrame *":
    return _simulation.PhysicalOffsetFrame_safeDownCast(obj)

def PhysicalOffsetFrame_getClassName() -> "std::string const &":
    return _simulation.PhysicalOffsetFrame_getClassName()

class SetFrames(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Frame,OpenSim::ModelComponent > *":
        return _simulation.SetFrames_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetFrames_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetFrames_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Frame,OpenSim::ModelComponent > *":
        return _simulation.SetFrames_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetFrames_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetFrames

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Frame,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetFrames_swiginit(self, _simulation.new_SetFrames(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetFrames_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetFrames_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetFrames_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetFrames_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Frame`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetFrames_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetFrames_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Frame") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Frame`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetFrames_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Frame") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Frame`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetFrames_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Frame") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Frame`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetFrames_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Frame`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetFrames_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetFrames_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Frame", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Frame`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetFrames_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Frame &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Frame`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Frame`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetFrames_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetFrames_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetFrames_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetFrames_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetFrames_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetFrames_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetFrames_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetFrames_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetFrames_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetFrames_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetFrames in _simulation:
_simulation.SetFrames_swigregister(SetFrames)

def SetFrames_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Frame,OpenSim::ModelComponent > *":
    return _simulation.SetFrames_safeDownCast(obj)

def SetFrames_getClassName() -> "std::string const &":
    return _simulation.SetFrames_getClassName()

class ModelComponentSetFrames(SetFrames):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Frame > *":
        return _simulation.ModelComponentSetFrames_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetFrames_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetFrames_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Frame > *":
        return _simulation.ModelComponentSetFrames_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetFrames_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetFrames_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetFrames_swiginit(self, _simulation.new_ModelComponentSetFrames())
    __swig_destroy__ = _simulation.delete_ModelComponentSetFrames

# Register ModelComponentSetFrames in _simulation:
_simulation.ModelComponentSetFrames_swigregister(ModelComponentSetFrames)

def ModelComponentSetFrames_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Frame > *":
    return _simulation.ModelComponentSetFrames_safeDownCast(obj)

def ModelComponentSetFrames_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetFrames_getClassName()

class Body(PhysicalFrame):
    r"""
    An OpenSim::Body is a PhysicalFrame (reference frame) with associated
    inertia specified by its mass, center-of-mass located in the PhysicalFrame,
    and its moment of inertia tensor about the center-of-mass.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Body *":
        return _simulation.Body_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Body_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Body_getClassName()

    def clone(self) -> "OpenSim::Body *":
        return _simulation.Body_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Body_getConcreteClassName(self)

    def copyProperty_mass(self, source: "Body") -> "void":
        return _simulation.Body_copyProperty_mass(self, source)

    def append_mass(self, value: "double const &") -> "int":
        return _simulation.Body_append_mass(self, value)

    def constructProperty_mass(self, initValue: "double const &") -> "void":
        return _simulation.Body_constructProperty_mass(self, initValue)

    def get_mass(self, *args) -> "double const &":
        return _simulation.Body_get_mass(self, *args)

    def upd_mass(self, *args) -> "double &":
        return _simulation.Body_upd_mass(self, *args)

    def set_mass(self, *args) -> "void":
        return _simulation.Body_set_mass(self, *args)

    def copyProperty_mass_center(self, source: "Body") -> "void":
        return _simulation.Body_copyProperty_mass_center(self, source)

    def append_mass_center(self, value: "Vec3") -> "int":
        return _simulation.Body_append_mass_center(self, value)

    def constructProperty_mass_center(self, initValue: "Vec3") -> "void":
        return _simulation.Body_constructProperty_mass_center(self, initValue)

    def get_mass_center(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Body_get_mass_center(self, *args)

    def upd_mass_center(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Body_upd_mass_center(self, *args)

    def set_mass_center(self, *args) -> "void":
        return _simulation.Body_set_mass_center(self, *args)

    def copyProperty_inertia(self, source: "Body") -> "void":
        return _simulation.Body_copyProperty_inertia(self, source)

    def append_inertia(self, value: "Vec6") -> "int":
        return _simulation.Body_append_inertia(self, value)

    def constructProperty_inertia(self, initValue: "Vec6") -> "void":
        return _simulation.Body_constructProperty_inertia(self, initValue)

    def get_inertia(self, *args) -> "SimTK::Vec6 const &":
        return _simulation.Body_get_inertia(self, *args)

    def upd_inertia(self, *args) -> "SimTK::Vec6 &":
        return _simulation.Body_upd_inertia(self, *args)

    def set_inertia(self, *args) -> "void":
        return _simulation.Body_set_inertia(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Body_swiginit(self, _simulation.new_Body(*args))

    def getMass(self) -> "double const &":
        r""" Access Properties of the Body  The mass of the body in kg"""
        return _simulation.Body_getMass(self)

    def setMass(self, mass: "double const &") -> "void":
        return _simulation.Body_setMass(self, mass)

    def getMassCenter(self) -> "SimTK::Vec3 const &":
        r""" The body center of mass location (Vec3) in the Body frame."""
        return _simulation.Body_getMassCenter(self)

    def setMassCenter(self, com: "Vec3") -> "void":
        return _simulation.Body_setMassCenter(self, com)

    def getInertia(self) -> "SimTK::Inertia const &":
        r""" The body's inertia about the center of mass location."""
        return _simulation.Body_getInertia(self)

    def setInertia(self, aInertia: "Inertia") -> "void":
        return _simulation.Body_setInertia(self, aInertia)

    def getMassProperties(self) -> "SimTK::MassProperties":
        r"""
        Assemble body inertial properties: mass, center of mass location, moment
               of inertia about the origin of the body and return as
               SimTK::MassProperties.
        """
        return _simulation.Body_getMassProperties(self)

    def scale(self, scaleFactors: "Vec3", scaleMass: "bool"=False) -> "void":
        r""" Scale the Body's center of mass location and its inertial properties."""
        return _simulation.Body_scale(self, scaleFactors, scaleMass)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the Body's center of mass location only. Note that
               scaleInertialProperties() must be called after this method to update the
               Body's mass and inertia tensor.
        """
        return _simulation.Body_extendScale(self, s, scaleSet)

    def scaleInertialProperties(self, *args) -> "void":
        return _simulation.Body_scaleInertialProperties(self, *args)

    def scaleMass(self, aScaleFactor: "double") -> "void":
        return _simulation.Body_scaleMass(self, aScaleFactor)
    __swig_destroy__ = _simulation.delete_Body

# Register Body in _simulation:
_simulation.Body_swigregister(Body)

def Body_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Body *":
    return _simulation.Body_safeDownCast(obj)

def Body_getClassName() -> "std::string const &":
    return _simulation.Body_getClassName()

class SetBodies(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Body,OpenSim::ModelComponent > *":
        return _simulation.SetBodies_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetBodies_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetBodies_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Body,OpenSim::ModelComponent > *":
        return _simulation.SetBodies_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetBodies_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetBodies

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Body,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetBodies_swiginit(self, _simulation.new_SetBodies(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetBodies_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetBodies_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetBodies_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetBodies_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Body`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetBodies_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetBodies_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Body") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Body`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodies_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Body") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Body`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodies_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Body") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Body`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetBodies_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Body`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetBodies_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetBodies_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Body", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Body`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetBodies_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Body &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Body`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Body`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetBodies_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetBodies_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetBodies_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetBodies_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetBodies_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetBodies_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetBodies_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetBodies_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetBodies_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetBodies_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetBodies in _simulation:
_simulation.SetBodies_swigregister(SetBodies)

def SetBodies_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Body,OpenSim::ModelComponent > *":
    return _simulation.SetBodies_safeDownCast(obj)

def SetBodies_getClassName() -> "std::string const &":
    return _simulation.SetBodies_getClassName()

class ModelComponentSetBodies(SetBodies):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Body > *":
        return _simulation.ModelComponentSetBodies_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetBodies_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetBodies_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Body > *":
        return _simulation.ModelComponentSetBodies_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetBodies_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetBodies_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetBodies_swiginit(self, _simulation.new_ModelComponentSetBodies())
    __swig_destroy__ = _simulation.delete_ModelComponentSetBodies

# Register ModelComponentSetBodies in _simulation:
_simulation.ModelComponentSetBodies_swigregister(ModelComponentSetBodies)

def ModelComponentSetBodies_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Body > *":
    return _simulation.ModelComponentSetBodies_safeDownCast(obj)

def ModelComponentSetBodies_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetBodies_getClassName()

class BodySet(ModelComponentSetBodies):
    r"""
    A class for holding a set of bodies.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodySet *":
        return _simulation.BodySet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BodySet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BodySet_getClassName()

    def clone(self) -> "OpenSim::BodySet *":
        return _simulation.BodySet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BodySet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.BodySet_swiginit(self, _simulation.new_BodySet(*args))
    __swig_destroy__ = _simulation.delete_BodySet

# Register BodySet in _simulation:
_simulation.BodySet_swigregister(BodySet)

def BodySet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodySet *":
    return _simulation.BodySet_safeDownCast(obj)

def BodySet_getClassName() -> "std::string const &":
    return _simulation.BodySet_getClassName()

class BodyScale(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how
    to scale a body segment.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyScale *":
        return _simulation.BodyScale_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BodyScale_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BodyScale_getClassName()

    def clone(self) -> "OpenSim::BodyScale *":
        return _simulation.BodyScale_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BodyScale_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.BodyScale_swiginit(self, _simulation.new_BodyScale(*args))
    __swig_destroy__ = _simulation.delete_BodyScale

    def copyData(self, aBodyScale: "BodyScale") -> "void":
        return _simulation.BodyScale_copyData(self, aBodyScale)

    def getAxisNames(self) -> "OpenSim::Array< std::string > &":
        return _simulation.BodyScale_getAxisNames(self)

    def setAxisNames(self, aAxisNames: "ArrayStr") -> "void":
        return _simulation.BodyScale_setAxisNames(self, aAxisNames)

# Register BodyScale in _simulation:
_simulation.BodyScale_swigregister(BodyScale)

def BodyScale_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyScale *":
    return _simulation.BodyScale_safeDownCast(obj)

def BodyScale_getClassName() -> "std::string const &":
    return _simulation.BodyScale_getClassName()

class SetBodyScales(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::BodyScale,OpenSim::Object > *":
        return _simulation.SetBodyScales_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetBodyScales_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetBodyScales_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::BodyScale,OpenSim::Object > *":
        return _simulation.SetBodyScales_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetBodyScales_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetBodyScales

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::BodyScale,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetBodyScales_swiginit(self, _simulation.new_SetBodyScales(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetBodyScales_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetBodyScales_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetBodyScales_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetBodyScales_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetBodyScales_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetBodyScales_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "BodyScale") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodyScales_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "BodyScale") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetBodyScales_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "BodyScale") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetBodyScales_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`BodyScale`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetBodyScales_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetBodyScales_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "BodyScale", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`BodyScale`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetBodyScales_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::BodyScale &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`BodyScale`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`BodyScale`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetBodyScales_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetBodyScales_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetBodyScales_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetBodyScales_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetBodyScales_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetBodyScales_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetBodyScales_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetBodyScales_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetBodyScales_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetBodyScales_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetBodyScales in _simulation:
_simulation.SetBodyScales_swigregister(SetBodyScales)

def SetBodyScales_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::BodyScale,OpenSim::Object > *":
    return _simulation.SetBodyScales_safeDownCast(obj)

def SetBodyScales_getClassName() -> "std::string const &":
    return _simulation.SetBodyScales_getClassName()

class BodyScaleSet(SetBodyScales):
    r"""
    A class for holding a set of body scales.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyScaleSet *":
        return _simulation.BodyScaleSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BodyScaleSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BodyScaleSet_getClassName()

    def clone(self) -> "OpenSim::BodyScaleSet *":
        return _simulation.BodyScaleSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BodyScaleSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.BodyScaleSet_swiginit(self, _simulation.new_BodyScaleSet(*args))
    __swig_destroy__ = _simulation.delete_BodyScaleSet

    def adoptAndAppend(self, aBodyScale):
        aBodyScale._markAdopted()
        return super(BodyScaleSet, self).adoptAndAppend(aBodyScale)


# Register BodyScaleSet in _simulation:
_simulation.BodyScaleSet_swigregister(BodyScaleSet)

def BodyScaleSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyScaleSet *":
    return _simulation.BodyScaleSet_safeDownCast(obj)

def BodyScaleSet_getClassName() -> "std::string const &":
    return _simulation.BodyScaleSet_getClassName()

class SimbodyEngine(opensim.common.OpenSimObject):
    r"""
    A wrapper class to use the SimTK Simbody dynamics engine as the underlying
    engine for OpenSim.

    Authors: Frank C. Anderson, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SimbodyEngine *":
        return _simulation.SimbodyEngine_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SimbodyEngine_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SimbodyEngine_getClassName()

    def clone(self) -> "OpenSim::SimbodyEngine *":
        return _simulation.SimbodyEngine_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SimbodyEngine_getConcreteClassName(self)
    _model = property(_simulation.SimbodyEngine__model_get, _simulation.SimbodyEngine__model_set, doc=r""" Pointer to the model that owns this dynamics engine.""")
    __swig_destroy__ = _simulation.delete_SimbodyEngine

    def __init__(self, *args):
        _simulation.SimbodyEngine_swiginit(self, _simulation.new_SimbodyEngine(*args))

    def getModel(self) -> "OpenSim::Model &":
        return _simulation.SimbodyEngine_getModel(self)

    def setModel(self, aModel: "Model") -> "void":
        return _simulation.SimbodyEngine_setModel(self, aModel)

    def connectSimbodyEngineToModel(self, aModel: "Model") -> "void":
        return _simulation.SimbodyEngine_connectSimbodyEngineToModel(self, aModel)

    def computeReactions(self, s: "State", rForces: "VectorVec3", rTorques: "VectorVec3") -> "void":
        return _simulation.SimbodyEngine_computeReactions(self, s, rForces, rTorques)

    def formCompleteStorages(self, s: "State", aQIn: "Storage", rQComplete: "OpenSim::Storage *&", rUComplete: "OpenSim::Storage *&") -> "void":
        r"""
        From a potentially partial specification of the generalized coordinates,
        form a complete storage of the generalized coordinates (q's) and
        generalized speeds (u's) in radians and radians/s respectively.

        :type s: :py:class:`State`
        :param s: Used as working memory.
        :type aQIn: :py:class:`Storage`
        :param aQIn: Storage containing the q's or a subset of the q's.
        :type rQComplete: :py:class:`Storage`
        :param rQComplete: Storage containing all the q's.  If q's were not
            in aQIn, the values are set to 0.0.  When a q is constrained, its value
            is altered to be consistent with the constraint.  The caller is responsible
            for deleting the memory associated with this storage. Units are radians.
        :type rUComplete: :py:class:`Storage`
        :param rUComplete: Storage containing all the u's.  The generalized speeds
            are obtained by spline fitting the q's and differentiating the splines.
            When a u is constrained, its value is altered to be consistent with the
            constraint.  The caller is responsible for deleting the memory
            associated with this storage. Units are radians/s.
        """
        return _simulation.SimbodyEngine_formCompleteStorages(self, s, aQIn, rQComplete, rUComplete)

    def convertDegreesToRadians(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertDegreesToRadians(self, *args)

    def convertRadiansToDegrees(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertRadiansToDegrees(self, *args)

    def convertAnglesToDirectionCosines(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertAnglesToDirectionCosines(self, *args)

    def convertDirectionCosinesToAngles(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertDirectionCosinesToAngles(self, *args)

    def convertDirectionCosinesToQuaternions(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertDirectionCosinesToQuaternions(self, *args)

    def convertQuaternionsToDirectionCosines(self, *args) -> "void":
        return _simulation.SimbodyEngine_convertQuaternionsToDirectionCosines(self, *args)

    def getPosition(self, s: "State", aBody: "PhysicalFrame", aPoint: "Vec3", rPos: "Vec3") -> "void":
        r""" **(Deprecated)** Use Frame::getPositionInGround() instead."""
        return _simulation.SimbodyEngine_getPosition(self, s, aBody, aPoint, rPos)

    def getVelocity(self, s: "State", aBody: "PhysicalFrame", aPoint: "Vec3", rVel: "Vec3") -> "void":
        r""" **(Deprecated)** Use Frame::getVelocityInGround() instead."""
        return _simulation.SimbodyEngine_getVelocity(self, s, aBody, aPoint, rVel)

    def getAcceleration(self, s: "State", aBody: "PhysicalFrame", aPoint: "Vec3", rAcc: "Vec3") -> "void":
        r""" **(Deprecated)** Use Frame::getAccelerationInGround() instead."""
        return _simulation.SimbodyEngine_getAcceleration(self, s, aBody, aPoint, rAcc)

    def getDirectionCosines(self, *args) -> "void":
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::getTransformInGround().R() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::getTransformInGround().R() instead.
        """
        return _simulation.SimbodyEngine_getDirectionCosines(self, *args)

    def getAngularVelocity(self, s: "State", aBody: "PhysicalFrame", rAngVel: "Vec3") -> "void":
        r""" **(Deprecated)** Use Frame::getVelocityInGround()[0] instead."""
        return _simulation.SimbodyEngine_getAngularVelocity(self, s, aBody, rAngVel)

    def getAngularVelocityBodyLocal(self, s: "State", aBody: "PhysicalFrame", rAngVel: "Vec3") -> "void":
        r""" **(Deprecated)** See Frame::getVelocityInGround()[0]."""
        return _simulation.SimbodyEngine_getAngularVelocityBodyLocal(self, s, aBody, rAngVel)

    def getAngularAcceleration(self, s: "State", aBody: "PhysicalFrame", rAngAcc: "Vec3") -> "void":
        r""" **(Deprecated)** Use Frame::getAccelerationInGround()[0] instead."""
        return _simulation.SimbodyEngine_getAngularAcceleration(self, s, aBody, rAngAcc)

    def getAngularAccelerationBodyLocal(self, s: "State", aBody: "PhysicalFrame", rAngAcc: "Vec3") -> "void":
        r""" **(Deprecated)** See Frame::getAccelerationInGround()[0]."""
        return _simulation.SimbodyEngine_getAngularAccelerationBodyLocal(self, s, aBody, rAngAcc)

    def getTransform(self, s: "State", aBody: "PhysicalFrame") -> "SimTK::Transform":
        r""" **(Deprecated)** Use Frame::getTransformInGround() instead."""
        return _simulation.SimbodyEngine_getTransform(self, s, aBody)

    def transform(self, *args) -> "void":
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::expressVectorInAnotherFrame() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::expressVectorInAnotherFrame() instead.
        """
        return _simulation.SimbodyEngine_transform(self, *args)

    def transformPosition(self, *args) -> "void":
        r"""
        *Overload 1:*
        **(Deprecated)** Use Frame::findStationLocationInAnotherFrame() instead.

        |

        *Overload 2:*
        **(Deprecated)** Use Frame::findStationLocationInAnotherFrame() instead.

        |

        *Overload 3:*
        **(Deprecated)** Use Frame::findStationLocationInGround() instead.

        |

        *Overload 4:*
        **(Deprecated)** Use Frame::findStationLocationInGround() instead.
        """
        return _simulation.SimbodyEngine_transformPosition(self, *args)

    def calcDistance(self, *args) -> "double":
        r"""
        *Overload 1:*
        **(Deprecated)** Use Point::calcDistanceBetween() or Frame::findStationLocationInGround() instead

        |

        *Overload 2:*
        **(Deprecated)** Use Point::calcDistanceBetween() or Frame::findStationLocationInGround() instead
        """
        return _simulation.SimbodyEngine_calcDistance(self, *args)

# Register SimbodyEngine in _simulation:
_simulation.SimbodyEngine_swigregister(SimbodyEngine)

def SimbodyEngine_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SimbodyEngine *":
    return _simulation.SimbodyEngine_safeDownCast(obj)

def SimbodyEngine_getClassName() -> "std::string const &":
    return _simulation.SimbodyEngine_getClassName()

class TransformAxis(opensim.common.OpenSimObject):
    r"""
    A class expressing a transformation of a child body in relation to a parent
    body along either a translation or about a rotation axis. The TransformAxis
    function specified the spatial displacement that is achieved as a function
    of the generalized coordinate(s).

    Author: Peter Loan, Frank C. Anderson, Jeffrey A. Reinbolt, Ajay Seth,
            Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TransformAxis *":
        return _simulation.TransformAxis_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TransformAxis_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TransformAxis_getClassName()

    def clone(self) -> "OpenSim::TransformAxis *":
        return _simulation.TransformAxis_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TransformAxis_getConcreteClassName(self)

    def copyProperty_coordinates(self, source: "TransformAxis") -> "void":
        r"""
        The "coordinates" property holds a list of strings representing the
           generalized coordinate names that serve as the independent variables of
           the transform function. *
        """
        return _simulation.TransformAxis_copyProperty_coordinates(self, source)

    def get_coordinates(self, i: "int") -> "std::string const &":
        return _simulation.TransformAxis_get_coordinates(self, i)

    def upd_coordinates(self, i: "int") -> "std::string &":
        return _simulation.TransformAxis_upd_coordinates(self, i)

    def set_coordinates(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.TransformAxis_set_coordinates(self, i, value)

    def append_coordinates(self, value: "std::string const &") -> "int":
        return _simulation.TransformAxis_append_coordinates(self, value)

    def constructProperty_coordinates(self) -> "void":
        return _simulation.TransformAxis_constructProperty_coordinates(self)

    def copyProperty_axis(self, source: "TransformAxis") -> "void":
        r"""
        The "axis" property holds the axis direction of the rotation or
           translation axis of the transform as a Vec3. *
        """
        return _simulation.TransformAxis_copyProperty_axis(self, source)

    def append_axis(self, value: "Vec3") -> "int":
        return _simulation.TransformAxis_append_axis(self, value)

    def constructProperty_axis(self, initValue: "Vec3") -> "void":
        return _simulation.TransformAxis_constructProperty_axis(self, initValue)

    def get_axis(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.TransformAxis_get_axis(self, *args)

    def upd_axis(self, *args) -> "SimTK::Vec3 &":
        return _simulation.TransformAxis_upd_axis(self, *args)

    def set_axis(self, *args) -> "void":
        return _simulation.TransformAxis_set_axis(self, *args)

    def copyProperty_function(self, source: "TransformAxis") -> "void":
        r"""
        The "function" property holds the transform function of the
           generalized coordinate(s) used to represent the amount of displacement
           about/along the specified axis. If none is specified a Constant function
           is applied. *
        """
        return _simulation.TransformAxis_copyProperty_function(self, source)

    def append_function(self, value: "Function") -> "int":
        return _simulation.TransformAxis_append_function(self, value)

    def constructProperty_function(self, initValue: "Function") -> "void":
        return _simulation.TransformAxis_constructProperty_function(self, initValue)

    def get_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.TransformAxis_get_function(self, *args)

    def upd_function(self, *args) -> "OpenSim::Function &":
        return _simulation.TransformAxis_upd_function(self, *args)

    def set_function(self, *args) -> "void":
        return _simulation.TransformAxis_set_function(self, *args)

    def __init__(self, *args):
        _simulation.TransformAxis_swiginit(self, _simulation.new_TransformAxis(*args))

    def setCoordinateNames(self, coordNames: "ArrayStr") -> "void":
        r"""
        %Set the names of the generalized coordinates that affect the motion
           along the axis controlled by this %TransformAxis object.
           :type coordNames: OpenSim::Array< std::string >
           :param coordNames:   Names of the generalized coordinates. *
        """
        return _simulation.TransformAxis_setCoordinateNames(self, coordNames)

    def getCoordinateNames(self) -> "OpenSim::Property< std::string > const &":
        r"""
        Get the generalized coordinate names associated with this object.
           The returned value is a references to the Property<string> that contains
           the list of coordinate names.
           See also: get_coordinates() *
        """
        return _simulation.TransformAxis_getCoordinateNames(self)

    def getCoordinateNamesInArray(self) -> "OpenSim::Array< std::string >":
        r""" Copy the coordinate names into an OpenSim::Array for convenience. *"""
        return _simulation.TransformAxis_getCoordinateNamesInArray(self)

    def setAxis(self, axis: "Vec3") -> "void":
        r""" %Set the value of the "axis" property. *"""
        return _simulation.TransformAxis_setAxis(self, axis)

    def getAxis(self, *args) -> "double":
        r"""
        *Overload 1:*
        Return the current value of the "axis" property. *

        |

        *Overload 2:*
        Alternate signature that writes the axis value to its argument. *

        |

        *Overload 3:*
        Get one component (0,1, or 2) of the axis vector. *
        """
        return _simulation.TransformAxis_getAxis(self, *args)

    def hasFunction(self) -> "bool":
        r"""
        Determine whether a custom function has been specified to map between
           the generalized coordinate and the amount of transformation along the
           specified axis. *
        """
        return _simulation.TransformAxis_hasFunction(self)

    def getFunction(self) -> "OpenSim::Function const &":
        r"""
        Get the custom function that maps between the generalized coordinates
           and the amount of displacement along the specified axis. If no function
           has been specified, this throws an exception; check first with hasFunction()
           if you aren't sure. *
        """
        return _simulation.TransformAxis_getFunction(self)

    def updFunction(self) -> "OpenSim::Function &":
        r""" Get writable access to the transform function. *"""
        return _simulation.TransformAxis_updFunction(self)

    def setFunction(self, *args) -> "void":
        r"""
        *Overload 1:*
        %Set the custom function that maps between the generalized coordinates
           and the amount of displacement about/along the specified axis. This object
           adopts ownership of the Function object, don't delete it yourself! It will
           be deleted when this %TransformAxis object is deleted. *

        |

        *Overload 2:*
        %Set the custom function that maps between the generalized coordinates
           and the amount of transformation about/along the specified axis. This method
           creates a *copy* of the supplied Function object, which is unaffected.
           Use the other signature if you want this %TransformAxis to take over
           ownership of the Function object. *
        """
        return _simulation.TransformAxis_setFunction(self, *args)

    def getJoint(self) -> "OpenSim::Joint const &":
        r"""
        Return a reference to the Joint to which this %TransformAxis
           applies. *
        """
        return _simulation.TransformAxis_getJoint(self)

    def getValue(self, s: "State") -> "double":
        return _simulation.TransformAxis_getValue(self, s)

    def connectToJoint(self, owningJoint: "Joint") -> "void":
        r"""
        Connect the %TransformAxis to its owning Joint after the model has
           been deserialized or copied. *
        """
        return _simulation.TransformAxis_connectToJoint(self, owningJoint)
    __swig_destroy__ = _simulation.delete_TransformAxis

# Register TransformAxis in _simulation:
_simulation.TransformAxis_swigregister(TransformAxis)

def TransformAxis_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TransformAxis *":
    return _simulation.TransformAxis_safeDownCast(obj)

def TransformAxis_getClassName() -> "std::string const &":
    return _simulation.TransformAxis_getClassName()

class SpatialTransform(opensim.common.OpenSimObject):
    r"""
    A class encapsulating the spatial transformation between two bodies that
    defines the behavior of a custom joint.

    Authors: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SpatialTransform *":
        return _simulation.SpatialTransform_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SpatialTransform_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SpatialTransform_getClassName()

    def clone(self) -> "OpenSim::SpatialTransform *":
        return _simulation.SpatialTransform_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SpatialTransform_getConcreteClassName(self)

    def copyProperty_rotation1(self, source: "SpatialTransform") -> "void":
        r"""
        Define the individual transform axes (6) that specify the spatial
           transform; each is a TransformAxis object. *
        """
        return _simulation.SpatialTransform_copyProperty_rotation1(self, source)

    def append_rotation1(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_rotation1(self, value)

    def constructProperty_rotation1(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_rotation1(self, initValue)

    def get_rotation1(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_rotation1(self, *args)

    def upd_rotation1(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_rotation1(self, *args)

    def set_rotation1(self, *args) -> "void":
        return _simulation.SpatialTransform_set_rotation1(self, *args)

    def copyProperty_rotation2(self, source: "SpatialTransform") -> "void":
        return _simulation.SpatialTransform_copyProperty_rotation2(self, source)

    def append_rotation2(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_rotation2(self, value)

    def constructProperty_rotation2(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_rotation2(self, initValue)

    def get_rotation2(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_rotation2(self, *args)

    def upd_rotation2(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_rotation2(self, *args)

    def set_rotation2(self, *args) -> "void":
        return _simulation.SpatialTransform_set_rotation2(self, *args)

    def copyProperty_rotation3(self, source: "SpatialTransform") -> "void":
        return _simulation.SpatialTransform_copyProperty_rotation3(self, source)

    def append_rotation3(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_rotation3(self, value)

    def constructProperty_rotation3(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_rotation3(self, initValue)

    def get_rotation3(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_rotation3(self, *args)

    def upd_rotation3(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_rotation3(self, *args)

    def set_rotation3(self, *args) -> "void":
        return _simulation.SpatialTransform_set_rotation3(self, *args)

    def copyProperty_translation1(self, source: "SpatialTransform") -> "void":
        return _simulation.SpatialTransform_copyProperty_translation1(self, source)

    def append_translation1(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_translation1(self, value)

    def constructProperty_translation1(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_translation1(self, initValue)

    def get_translation1(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_translation1(self, *args)

    def upd_translation1(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_translation1(self, *args)

    def set_translation1(self, *args) -> "void":
        return _simulation.SpatialTransform_set_translation1(self, *args)

    def copyProperty_translation2(self, source: "SpatialTransform") -> "void":
        return _simulation.SpatialTransform_copyProperty_translation2(self, source)

    def append_translation2(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_translation2(self, value)

    def constructProperty_translation2(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_translation2(self, initValue)

    def get_translation2(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_translation2(self, *args)

    def upd_translation2(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_translation2(self, *args)

    def set_translation2(self, *args) -> "void":
        return _simulation.SpatialTransform_set_translation2(self, *args)

    def copyProperty_translation3(self, source: "SpatialTransform") -> "void":
        return _simulation.SpatialTransform_copyProperty_translation3(self, source)

    def append_translation3(self, value: "TransformAxis") -> "int":
        return _simulation.SpatialTransform_append_translation3(self, value)

    def constructProperty_translation3(self, initValue: "TransformAxis") -> "void":
        return _simulation.SpatialTransform_constructProperty_translation3(self, initValue)

    def get_translation3(self, *args) -> "OpenSim::TransformAxis const &":
        return _simulation.SpatialTransform_get_translation3(self, *args)

    def upd_translation3(self, *args) -> "OpenSim::TransformAxis &":
        return _simulation.SpatialTransform_upd_translation3(self, *args)

    def set_translation3(self, *args) -> "void":
        return _simulation.SpatialTransform_set_translation3(self, *args)

    def __init__(self):
        _simulation.SpatialTransform_swiginit(self, _simulation.new_SpatialTransform())

    def connectToJoint(self, owningJoint: "CustomJoint") -> "void":
        r"""
        This tells the SpatialTransform the CustomJoint to which it belongs;
           this is not copied on copy construction or assignment. *
        """
        return _simulation.SpatialTransform_connectToJoint(self, owningJoint)

    def constructIndependentAxes(self, nAxes: "int", startIndex: "int") -> "void":
        r""" Make sure axes are not parallel. *"""
        return _simulation.SpatialTransform_constructIndependentAxes(self, nAxes, startIndex)

    def getCoordinateNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Construct a list of all unique coordinate names used by any of the
           contained TransformAxis objects. *
        """
        return _simulation.SpatialTransform_getCoordinateNames(self)

    def getFunctions(self) -> "std::vector< SimTK::Function const *,std::allocator< SimTK::Function const * > >":
        r"""
        For each axis, construct a list of the coordinate indices that dictate
           motion along that axis. * Create a new SimTK::Function corresponding to each axis; these are
           heap allocated and it is up to the caller to delete them. *
        """
        return _simulation.SpatialTransform_getFunctions(self)

    def getAxes(self) -> "std::vector< SimTK::Vec3,std::allocator< SimTK::Vec3 > >":
        r""" Get the axis direction associated with each TransformAxis. *"""
        return _simulation.SpatialTransform_getAxes(self)

    def scale(self, scaleFactors: "Vec3") -> "void":
        return _simulation.SpatialTransform_scale(self, scaleFactors)

    def getTransformAxis(self, whichAxis: "int") -> "OpenSim::TransformAxis const &":
        r"""
        Select one of the 6 axis, numbered 0-5 with rotation first, then
           translation. *
        """
        return _simulation.SpatialTransform_getTransformAxis(self, whichAxis)

    def updTransformAxis(self, whichAxis: "int") -> "OpenSim::TransformAxis &":
        r""" Same, but returns a writable reference to the TransformAxis. *"""
        return _simulation.SpatialTransform_updTransformAxis(self, whichAxis)
    __swig_destroy__ = _simulation.delete_SpatialTransform

# Register SpatialTransform in _simulation:
_simulation.SpatialTransform_swigregister(SpatialTransform)

def SpatialTransform_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SpatialTransform *":
    return _simulation.SpatialTransform_safeDownCast(obj)

def SpatialTransform_getClassName() -> "std::string const &":
    return _simulation.SpatialTransform_getClassName()

class Coordinate(ModelComponent):
    r"""
    A Coordinate is a ModelComponent for managing the access and behavior
    of a model's generalized coordinate including its value, speed and
    acceleration (once system accelerations have been realized).
    As a ModelComponent it provides resources to enable a Coordinate to be
    locked, prescribed, or clamped (limited to a min-to-max range).

    Authors: Ajay Seth, Ayman Habib, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Coordinate *":
        return _simulation.Coordinate_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Coordinate_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Coordinate_getClassName()

    def clone(self) -> "OpenSim::Coordinate *":
        return _simulation.Coordinate_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Coordinate_getConcreteClassName(self)

    def copyProperty_default_value(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_default_value(self, source)

    def append_default_value(self, value: "double const &") -> "int":
        return _simulation.Coordinate_append_default_value(self, value)

    def constructProperty_default_value(self, initValue: "double const &") -> "void":
        return _simulation.Coordinate_constructProperty_default_value(self, initValue)

    def get_default_value(self, *args) -> "double const &":
        return _simulation.Coordinate_get_default_value(self, *args)

    def upd_default_value(self, *args) -> "double &":
        return _simulation.Coordinate_upd_default_value(self, *args)

    def set_default_value(self, *args) -> "void":
        return _simulation.Coordinate_set_default_value(self, *args)

    def copyProperty_default_speed_value(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_default_speed_value(self, source)

    def append_default_speed_value(self, value: "double const &") -> "int":
        return _simulation.Coordinate_append_default_speed_value(self, value)

    def constructProperty_default_speed_value(self, initValue: "double const &") -> "void":
        return _simulation.Coordinate_constructProperty_default_speed_value(self, initValue)

    def get_default_speed_value(self, *args) -> "double const &":
        return _simulation.Coordinate_get_default_speed_value(self, *args)

    def upd_default_speed_value(self, *args) -> "double &":
        return _simulation.Coordinate_upd_default_speed_value(self, *args)

    def set_default_speed_value(self, *args) -> "void":
        return _simulation.Coordinate_set_default_speed_value(self, *args)

    def copyProperty_range(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_range(self, source)

    def get_range(self, i: "int") -> "double const &":
        return _simulation.Coordinate_get_range(self, i)

    def upd_range(self, i: "int") -> "double &":
        return _simulation.Coordinate_upd_range(self, i)

    def set_range(self, i: "int", value: "double const &") -> "void":
        return _simulation.Coordinate_set_range(self, i, value)

    def append_range(self, value: "double const &") -> "int":
        return _simulation.Coordinate_append_range(self, value)

    def copyProperty_clamped(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_clamped(self, source)

    def append_clamped(self, value: "bool const &") -> "int":
        return _simulation.Coordinate_append_clamped(self, value)

    def constructProperty_clamped(self, initValue: "bool const &") -> "void":
        return _simulation.Coordinate_constructProperty_clamped(self, initValue)

    def get_clamped(self, *args) -> "bool const &":
        return _simulation.Coordinate_get_clamped(self, *args)

    def upd_clamped(self, *args) -> "bool &":
        return _simulation.Coordinate_upd_clamped(self, *args)

    def set_clamped(self, *args) -> "void":
        return _simulation.Coordinate_set_clamped(self, *args)

    def copyProperty_locked(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_locked(self, source)

    def append_locked(self, value: "bool const &") -> "int":
        return _simulation.Coordinate_append_locked(self, value)

    def constructProperty_locked(self, initValue: "bool const &") -> "void":
        return _simulation.Coordinate_constructProperty_locked(self, initValue)

    def get_locked(self, *args) -> "bool const &":
        return _simulation.Coordinate_get_locked(self, *args)

    def upd_locked(self, *args) -> "bool &":
        return _simulation.Coordinate_upd_locked(self, *args)

    def set_locked(self, *args) -> "void":
        return _simulation.Coordinate_set_locked(self, *args)

    def copyProperty_prescribed_function(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_prescribed_function(self, source)

    def append_prescribed_function(self, value: "Function") -> "int":
        return _simulation.Coordinate_append_prescribed_function(self, value)

    def constructProperty_prescribed_function(self, *args) -> "void":
        return _simulation.Coordinate_constructProperty_prescribed_function(self, *args)

    def get_prescribed_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.Coordinate_get_prescribed_function(self, *args)

    def upd_prescribed_function(self, *args) -> "OpenSim::Function &":
        return _simulation.Coordinate_upd_prescribed_function(self, *args)

    def set_prescribed_function(self, *args) -> "void":
        return _simulation.Coordinate_set_prescribed_function(self, *args)

    def copyProperty_prescribed(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_prescribed(self, source)

    def append_prescribed(self, value: "bool const &") -> "int":
        return _simulation.Coordinate_append_prescribed(self, value)

    def constructProperty_prescribed(self, initValue: "bool const &") -> "void":
        return _simulation.Coordinate_constructProperty_prescribed(self, initValue)

    def get_prescribed(self, *args) -> "bool const &":
        return _simulation.Coordinate_get_prescribed(self, *args)

    def upd_prescribed(self, *args) -> "bool &":
        return _simulation.Coordinate_upd_prescribed(self, *args)

    def set_prescribed(self, *args) -> "void":
        return _simulation.Coordinate_set_prescribed(self, *args)

    def copyProperty_is_free_to_satisfy_constraints(self, source: "Coordinate") -> "void":
        return _simulation.Coordinate_copyProperty_is_free_to_satisfy_constraints(self, source)

    def append_is_free_to_satisfy_constraints(self, value: "bool const &") -> "int":
        return _simulation.Coordinate_append_is_free_to_satisfy_constraints(self, value)

    def constructProperty_is_free_to_satisfy_constraints(self, initValue: "bool const &") -> "void":
        return _simulation.Coordinate_constructProperty_is_free_to_satisfy_constraints(self, initValue)

    def get_is_free_to_satisfy_constraints(self, *args) -> "bool const &":
        return _simulation.Coordinate_get_is_free_to_satisfy_constraints(self, *args)

    def upd_is_free_to_satisfy_constraints(self, *args) -> "bool &":
        return _simulation.Coordinate_upd_is_free_to_satisfy_constraints(self, *args)

    def set_is_free_to_satisfy_constraints(self, *args) -> "void":
        return _simulation.Coordinate_set_is_free_to_satisfy_constraints(self, *args)
    _has_output_value = property(_simulation.Coordinate__has_output_value_get, _simulation.Coordinate__has_output_value_set)
    _has_output_speed = property(_simulation.Coordinate__has_output_speed_get, _simulation.Coordinate__has_output_speed_set)
    _has_output_acceleration = property(_simulation.Coordinate__has_output_acceleration_get, _simulation.Coordinate__has_output_acceleration_set)
    Undefined = _simulation.Coordinate_Undefined
    Rotational = _simulation.Coordinate_Rotational
    Translational = _simulation.Coordinate_Translational
    Coupled = _simulation.Coordinate_Coupled

    def getJoint(self) -> "OpenSim::Joint const &":
        r"""* access to the Coordinate's owning joint"""
        return _simulation.Coordinate_getJoint(self)

    def getMotionType(self) -> "OpenSim::Coordinate::MotionType":
        r"""
        access to the generalized Coordinate's motion type
               This can be Rotational, Translational, or Coupled (both)
        """
        return _simulation.Coordinate_getMotionType(self)

    def getValue(self, s: "State") -> "double":
        r""" get the value of the Coordinate from the state"""
        return _simulation.Coordinate_getValue(self, s)

    def setValue(self, s: "State", aValue: "double", enforceContraints: "bool"=True) -> "void":
        r"""
        Set the value of the Coordinate on to the state.
               Optional flag to enforce the constraints immediately (true by default),
               which can adjust all coordinate values in the state to satisfy model
               constraints. Use getValue(s) to see if/how the value was adjusted to
               satisfy the kinematic constraints. If setting multiple Coordinate values
               consecutively, e.g. in a loop, set the flag to false and then call
               Model::assemble(state) once all Coordinate values have been set.
               Alternatively, use Model::setStateVariableValues() to set all coordinate
               values and their speeds at once followed by Model::assemble(state).

               The provided value will be clamped to the coordinate's range if
               the coordinate is clamped and enforceConstraints is true.
        """
        return _simulation.Coordinate_setValue(self, s, aValue, enforceContraints)

    def getSpeedValue(self, s: "State") -> "double":
        r""" get the speed value of the Coordinate from the state"""
        return _simulation.Coordinate_getSpeedValue(self, s)

    def setSpeedValue(self, s: "State", aValue: "double") -> "void":
        return _simulation.Coordinate_setSpeedValue(self, s, aValue)

    def getSpeedName(self) -> "std::string const &":
        r"""
        return the name (label) used to identify the Coordinate's speed
               state variable. Returns the string "<coordinate_name>/speed"
        """
        return _simulation.Coordinate_getSpeedName(self)

    def getDefaultValue(self) -> "double":
        r"""
        get the default value for this coordinate. This is the value
               used if no value has been set prior to a simulation.
        """
        return _simulation.Coordinate_getDefaultValue(self)

    def setDefaultValue(self, aDefaultValue: "double") -> "void":
        return _simulation.Coordinate_setDefaultValue(self, aDefaultValue)

    def getDefaultSpeedValue(self) -> "double":
        r"""
        get the default speed value for this coordinate. This is the value
               used if no value has been set prior to a simulation.
        """
        return _simulation.Coordinate_getDefaultSpeedValue(self)

    def setDefaultSpeedValue(self, aDefaultSpeedValue: "double") -> "void":
        return _simulation.Coordinate_setDefaultSpeedValue(self, aDefaultSpeedValue)

    def getAccelerationValue(self, s: "State") -> "double":
        r"""
        get acceleration of the coordinate is dependent on having
               realized the model and state to the acceleration stage
        """
        return _simulation.Coordinate_getAccelerationValue(self, s)

    def getClamped(self, s: "State") -> "bool":
        r"""
        determine or set whether or not the Coordinate is
               "clamped" between a range of values.
        """
        return _simulation.Coordinate_getClamped(self, s)

    def setClamped(self, s: "State", aLocked: "bool") -> "void":
        return _simulation.Coordinate_setClamped(self, s, aLocked)

    def getDefaultClamped(self) -> "bool":
        r""" get/set whether or not the Coordinate is clamped by default"""
        return _simulation.Coordinate_getDefaultClamped(self)

    def setDefaultClamped(self, aClamped: "bool") -> "void":
        return _simulation.Coordinate_setDefaultClamped(self, aClamped)

    def getRangeMin(self) -> "double":
        r""" get the value for the Coordinate's range of motion"""
        return _simulation.Coordinate_getRangeMin(self)

    def getRangeMax(self) -> "double":
        return _simulation.Coordinate_getRangeMax(self)

    def setRangeMin(self, aMin: "double") -> "void":
        return _simulation.Coordinate_setRangeMin(self, aMin)

    def setRangeMax(self, aMax: "double") -> "void":
        return _simulation.Coordinate_setRangeMax(self, aMax)

    def getLocked(self, s: "State") -> "bool":
        r"""
        determine or set whether or not the Coordinate is
               "locked" for a given state of the Model.
        """
        return _simulation.Coordinate_getLocked(self, s)

    def setLocked(self, s: "State", aLocked: "bool") -> "void":
        return _simulation.Coordinate_setLocked(self, s, aLocked)

    def getDefaultLocked(self) -> "bool":
        r""" get/set whether or not the Coordinate is locked by default"""
        return _simulation.Coordinate_getDefaultLocked(self)

    def setDefaultLocked(self, aLocked: "bool") -> "void":
        return _simulation.Coordinate_setDefaultLocked(self, aLocked)

    def isPrescribed(self, s: "State") -> "bool":
        r"""
        determine or set whether or not the Coordinate is
               "prescribed" for a given state of the Model.
        """
        return _simulation.Coordinate_isPrescribed(self, s)

    def setIsPrescribed(self, s: "State", isPrescribed: "bool") -> "void":
        return _simulation.Coordinate_setIsPrescribed(self, s, isPrescribed)

    def getDefaultIsPrescribed(self) -> "bool":
        r""" get/set whether or not the Coordinate is locked by default"""
        return _simulation.Coordinate_getDefaultIsPrescribed(self)

    def setDefaultIsPrescribed(self, isPrescribed: "bool") -> "void":
        return _simulation.Coordinate_setDefaultIsPrescribed(self, isPrescribed)

    def setPrescribedFunction(self, function: "Function") -> "void":
        r"""
        Specify an OpenSim Function specifies the prescribed motion for this
               Coordinate as a function of time. Note, this function must provide
               valid first and second order derivatives.
        """
        return _simulation.Coordinate_setPrescribedFunction(self, function)

    def getPrescribedFunction(self) -> "OpenSim::Function const &":
        return _simulation.Coordinate_getPrescribedFunction(self)

    def isDependent(self, s: "State") -> "bool":
        r"""
        Return true if coordinate is dependent on other coordinates via a coupler
               constraint OR it has been flagged as free to change when satisfying
               the model's kinematic constraints in general.
        """
        return _simulation.Coordinate_isDependent(self, s)

    def isConstrained(self, s: "State") -> "bool":
        r""" Return true if coordinate is locked, prescribed, or dependent on other coordinates"""
        return _simulation.Coordinate_isConstrained(self, s)

    def getMobilizerQIndex(self) -> "int":
        r"""*"""
        return _simulation.Coordinate_getMobilizerQIndex(self)

    def getBodyIndex(self) -> "SimTK::MobilizedBodyIndex":
        return _simulation.Coordinate_getBodyIndex(self)

    def getUserSpecifiedMotionTypePriorTo40(self) -> "OpenSim::Coordinate::MotionType const &":
        r"""*"""
        return _simulation.Coordinate_getUserSpecifiedMotionTypePriorTo40(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Coordinate_swiginit(self, _simulation.new_Coordinate(*args))
    __swig_destroy__ = _simulation.delete_Coordinate

# Register Coordinate in _simulation:
_simulation.Coordinate_swigregister(Coordinate)

def Coordinate_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Coordinate *":
    return _simulation.Coordinate_safeDownCast(obj)

def Coordinate_getClassName() -> "std::string const &":
    return _simulation.Coordinate_getClassName()

class SetCoordinates(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Coordinate,OpenSim::Object > *":
        return _simulation.SetCoordinates_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetCoordinates_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetCoordinates_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Coordinate,OpenSim::Object > *":
        return _simulation.SetCoordinates_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetCoordinates_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetCoordinates

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Coordinate,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetCoordinates_swiginit(self, _simulation.new_SetCoordinates(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetCoordinates_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetCoordinates_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetCoordinates_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetCoordinates_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetCoordinates_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetCoordinates_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Coordinate") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetCoordinates_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Coordinate") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetCoordinates_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Coordinate") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetCoordinates_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Coordinate`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetCoordinates_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetCoordinates_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Coordinate", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Coordinate`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetCoordinates_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Coordinate`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Coordinate`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetCoordinates_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetCoordinates_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetCoordinates_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetCoordinates_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetCoordinates_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetCoordinates_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetCoordinates_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetCoordinates_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetCoordinates_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetCoordinates_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetCoordinates in _simulation:
_simulation.SetCoordinates_swigregister(SetCoordinates)

def SetCoordinates_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Coordinate,OpenSim::Object > *":
    return _simulation.SetCoordinates_safeDownCast(obj)

def SetCoordinates_getClassName() -> "std::string const &":
    return _simulation.SetCoordinates_getClassName()

class CoordinateSet(SetCoordinates):
    r"""
    A class for holding a set of coordinates.

    Authors: Peter Loan, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateSet *":
        return _simulation.CoordinateSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.CoordinateSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.CoordinateSet_getClassName()

    def clone(self) -> "OpenSim::CoordinateSet *":
        return _simulation.CoordinateSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.CoordinateSet_getConcreteClassName(self)

    def populate(self, model: "Model") -> "void":
        r"""
        Populate this %Set as a flat list of all Model Coordinates given
        the a Model with Joints, which owns the Coordinates.
        """
        return _simulation.CoordinateSet_populate(self, model)

    def getSpeedNames(self, rNames: "ArrayStr") -> "void":
        return _simulation.CoordinateSet_getSpeedNames(self, rNames)

    def __init__(self, *args):
        _simulation.CoordinateSet_swiginit(self, _simulation.new_CoordinateSet(*args))
    __swig_destroy__ = _simulation.delete_CoordinateSet

# Register CoordinateSet in _simulation:
_simulation.CoordinateSet_swigregister(CoordinateSet)

def CoordinateSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateSet *":
    return _simulation.CoordinateSet_safeDownCast(obj)

def CoordinateSet_getClassName() -> "std::string const &":
    return _simulation.CoordinateSet_getClassName()

class JointFramesAreTheSame(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", sameName: "std::string const &"):
        _simulation.JointFramesAreTheSame_swiginit(self, _simulation.new_JointFramesAreTheSame(file, line, func, thisName, sameName))
    __swig_destroy__ = _simulation.delete_JointFramesAreTheSame

# Register JointFramesAreTheSame in _simulation:
_simulation.JointFramesAreTheSame_swigregister(JointFramesAreTheSame)

class Joint(ModelComponent):
    r"""
    An OpenSim Joint is an OpenSim::ModelComponent which connects two PhysicalFrames
    together and specifies their relative permissible motion as described in
    internal coordinates. The base Joint specifies two frames (e.g. one per body),
    which the joint spans. The relative motion (including the # of coordinates)
    are defined by concrete Joints, which specify the permissible kinematics of
    a child joint frame (on a child body) with respect to a parent joint frame
    (on a parent body). The designation of parent and child are used only to
    identify the directionality of the joint and in which frame the joint
    coordinates are expressed.

    For example, A PinJoint between a parent frame, P, and a child frame, B,
    has a coordinate value of zero when the two frames are aligned and
    positive coordinate values are the angle between the frames' X-axes given
    a positive Z-rotation of the child frame about the coincident Z-axis in
    the parent frame.

    Note: the parent and child frames must be added to the model by the time
          you call initSystem() on the model.

    Concrete Joints can specify relative translations and even coupled
    rotations and translations (see EllipsoidJoint and CustomJoint). For more
    details on how the underlying formulation supports coupled curvilinear
    joints, see "Minimal formulation of joint motion for biomechanisms", 2010
    A Seth, M Sherman, P Eastman, S Delp; Nonlinear dynamics 62 (1), 291-303

    **C++ example**

    .. code-block:: c++

        Define a pin joint that attaches pendulum (an OpenSim::Body) to ground.
        PinJoint* myPin = new PinJoint("pendulumToGround", myModel.getGround(),
                                       pendulum);

    **Python example**

    .. code-block:: python

            # Define a ball joint between blockA and blockB.
            abJoint = osim.BallJoint('JointName', blockA, blockB)

    If you want to connect to an existing PhysicalFrame (e.g., a Body or Ground)
    but not to its origin, you can create and connect to a PhysicalOffsetFrame; the
    following convenience constructor does this for you:

    **C++ example**

    .. code-block:: c++

        Define a pin joint that attaches the end of pendulum to the ground origin.
        PinJoint* myPin = new PinJoint("pendulumToGround",
                                       myModel.getGround(),   //parent PhysicalFrame
                                       Vec3(0),               //location in parent
                                       Vec3(0),               //orientation in parent
                                       pendulum,              //child PhysicalFrame
                                       Vec3(0,-length/2.,0),  //location in child
                                       Vec3(0));              //orientation in child


    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Joint *":
        return _simulation.Joint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Joint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Joint_getClassName()

    def clone(self) -> "OpenSim::Joint *":
        return _simulation.Joint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Joint_getConcreteClassName(self)

    def copyProperty_coordinates(self, source: "Joint") -> "void":
        return _simulation.Joint_copyProperty_coordinates(self, source)

    def get_coordinates(self, i: "int") -> "OpenSim::Coordinate const &":
        return _simulation.Joint_get_coordinates(self, i)

    def upd_coordinates(self, i: "int") -> "OpenSim::Coordinate &":
        return _simulation.Joint_upd_coordinates(self, i)

    def set_coordinates(self, i: "int", value: "Coordinate") -> "void":
        return _simulation.Joint_set_coordinates(self, i, value)

    def append_coordinates(self, value: "Coordinate") -> "int":
        return _simulation.Joint_append_coordinates(self, value)

    def constructProperty_coordinates(self) -> "void":
        return _simulation.Joint_constructProperty_coordinates(self)

    def copyProperty_frames(self, source: "Joint") -> "void":
        return _simulation.Joint_copyProperty_frames(self, source)

    def get_frames(self, i: "int") -> "OpenSim::PhysicalOffsetFrame const &":
        return _simulation.Joint_get_frames(self, i)

    def upd_frames(self, i: "int") -> "OpenSim::PhysicalOffsetFrame &":
        return _simulation.Joint_upd_frames(self, i)

    def set_frames(self, i: "int", value: "PhysicalOffsetFrame") -> "void":
        return _simulation.Joint_set_frames(self, i, value)

    def append_frames(self, value: "PhysicalOffsetFrame") -> "int":
        return _simulation.Joint_append_frames(self, value)

    def constructProperty_frames(self) -> "void":
        return _simulation.Joint_constructProperty_frames(self)
    PropertyIndex_socket_parent_frame = property(_simulation.Joint_PropertyIndex_socket_parent_frame_get, _simulation.Joint_PropertyIndex_socket_parent_frame_set)

    def connectSocket_parent_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.Joint_connectSocket_parent_frame(self, object)
    PropertyIndex_socket_child_frame = property(_simulation.Joint_PropertyIndex_socket_child_frame_get, _simulation.Joint_PropertyIndex_socket_child_frame_set)

    def connectSocket_child_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.Joint_connectSocket_child_frame(self, object)
    _has_output_power = property(_simulation.Joint__has_output_power_get, _simulation.Joint__has_output_power_set)
    _has_output_reaction_on_parent = property(_simulation.Joint__has_output_reaction_on_parent_get, _simulation.Joint__has_output_reaction_on_parent_set)
    _has_output_reaction_on_child = property(_simulation.Joint__has_output_reaction_on_child_get, _simulation.Joint__has_output_reaction_on_child_set)
    __swig_destroy__ = _simulation.delete_Joint

    def getChildFrame(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Get the child joint frame.

        :rtype: :py:class:`PhysicalFrame`
        :return: const PhysicalFrame reference.
        """
        return _simulation.Joint_getChildFrame(self)

    def getParentFrame(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Get the parent frame to which this joint attaches.

        :rtype: :py:class:`PhysicalFrame`
        :return: const ref to parent PhysicalFrame.
        """
        return _simulation.Joint_getParentFrame(self)

    def getCoordinate(self) -> "OpenSim::Coordinate const &":
        r"""
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.
        """
        return _simulation.Joint_getCoordinate(self)

    def updCoordinate(self) -> "OpenSim::Coordinate &":
        r"""
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.
        """
        return _simulation.Joint_updCoordinate(self)

    def numCoordinates(self) -> "int":
        return _simulation.Joint_numCoordinates(self)

    def isCoordinateUsed(self, aCoordinate: "Coordinate") -> "bool":
        return _simulation.Joint_isCoordinateUsed(self, aCoordinate)

    def addFrame(self, frame: "PhysicalOffsetFrame") -> "void":
        r"""
         Add a frame to the *frames* property in this Joint. The frame is
        adopted, and should have been dynamically allocated.
        Use this function instead of append_frames().
        """
        return _simulation.Joint_addFrame(self, frame)

    def calcEquivalentSpatialForce(self, state: "State", mobilityForces: "Vector") -> "SimTK::SpatialVec":
        r"""
        Given some system mobility (generalized) forces, calculate the
           equivalent spatial body force for this Joint. Keep in mind that there are
           typically nm < 6 mobilities per joint with an infinite set of solutions that
           can map nm gen forces to 6 spatial force components (3 for torque + 3 for
           force). The solution returned provides the "most" effective force and torque
           in the joint frame. This means the smallest magnitude force and/or torque
           that will result in the same generalized force. If a generalized force is
           defined along/about a joint axis, then this should be evident in the
           reported results as a force or torque on the same axis.  NOTE: Joints
           comprised of multiple mobilizers and/or constraints, should override this
           method and account for multiple internal components.

           :type state: :py:class:`State`
           :param state: containing the generalized coordinate and speed values
           :type mobilityForces: :py:class:`Vector`
           :param mobilityForces: for the system as computed by inverse dynamics,
                                     for example
           :rtype: :py:class:`SpatialVec`
           :return: spatial force, FB_G, acting on the body connected by this joint at
               its location B, expressed in ground.
        """
        return _simulation.Joint_calcEquivalentSpatialForce(self, state, mobilityForces)

    def calcReactionOnParentExpressedInGround(self, state: "State") -> "SimTK::SpatialVec":
        r"""
        Joint Reaction forces  Calculate the joint reaction force and moment acting on the parent frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on parent frame, P,
                           and expressed in ground, G.
        """
        return _simulation.Joint_calcReactionOnParentExpressedInGround(self, state)

    def calcReactionOnChildExpressedInGround(self, state: "State") -> "SimTK::SpatialVec":
        r"""
        Calculate the joint reaction force and moment acting on the child frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on child frame, C,
                           and expressed in ground, G.
        """
        return _simulation.Joint_calcReactionOnChildExpressedInGround(self, state)

    def calcPower(self, s: "State") -> "double":
        r"""
        Joints in general do not contribute power since the reaction space
               forces are orthogonal to the mobility space. However, when joint motion
               is prescribed, the internal forces that move the joint will do work. In
               that case, the power is non-zero and the supplied SimTK::State
               must already have been realized to %Acceleration stage so that
               constraint forces are available.
        """
        return _simulation.Joint_calcPower(self, s)

# Register Joint in _simulation:
_simulation.Joint_swigregister(Joint)

def Joint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Joint *":
    return _simulation.Joint_safeDownCast(obj)

def Joint_getClassName() -> "std::string const &":
    return _simulation.Joint_getClassName()

class JointHasNoCoordinates(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _simulation.JointHasNoCoordinates_swiginit(self, _simulation.new_JointHasNoCoordinates(file, line, func))
    __swig_destroy__ = _simulation.delete_JointHasNoCoordinates

# Register JointHasNoCoordinates in _simulation:
_simulation.JointHasNoCoordinates_swigregister(JointHasNoCoordinates)

class SetJoints(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Joint,OpenSim::ModelComponent > *":
        return _simulation.SetJoints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetJoints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetJoints_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Joint,OpenSim::ModelComponent > *":
        return _simulation.SetJoints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetJoints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetJoints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Joint,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetJoints_swiginit(self, _simulation.new_SetJoints(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetJoints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetJoints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetJoints_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetJoints_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Joint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetJoints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetJoints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Joint") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Joint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetJoints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Joint") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Joint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetJoints_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Joint") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Joint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetJoints_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Joint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetJoints_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetJoints_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Joint", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Joint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetJoints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Joint &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Joint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Joint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetJoints_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetJoints_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetJoints_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetJoints_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetJoints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetJoints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetJoints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetJoints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetJoints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetJoints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetJoints in _simulation:
_simulation.SetJoints_swigregister(SetJoints)

def SetJoints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Joint,OpenSim::ModelComponent > *":
    return _simulation.SetJoints_safeDownCast(obj)

def SetJoints_getClassName() -> "std::string const &":
    return _simulation.SetJoints_getClassName()

class ModelComponentSetJoints(SetJoints):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Joint > *":
        return _simulation.ModelComponentSetJoints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetJoints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetJoints_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Joint > *":
        return _simulation.ModelComponentSetJoints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetJoints_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetJoints_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetJoints_swiginit(self, _simulation.new_ModelComponentSetJoints())
    __swig_destroy__ = _simulation.delete_ModelComponentSetJoints

# Register ModelComponentSetJoints in _simulation:
_simulation.ModelComponentSetJoints_swigregister(ModelComponentSetJoints)

def ModelComponentSetJoints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Joint > *":
    return _simulation.ModelComponentSetJoints_safeDownCast(obj)

def ModelComponentSetJoints_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetJoints_getClassName()

class JointSet(ModelComponentSetJoints):
    r"""
    A class for holding a set of joints.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::JointSet *":
        return _simulation.JointSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.JointSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.JointSet_getClassName()

    def clone(self) -> "OpenSim::JointSet *":
        return _simulation.JointSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.JointSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.JointSet_swiginit(self, _simulation.new_JointSet(*args))
    __swig_destroy__ = _simulation.delete_JointSet

# Register JointSet in _simulation:
_simulation.JointSet_swigregister(JointSet)

def JointSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::JointSet *":
    return _simulation.JointSet_safeDownCast(obj)

def JointSet_getClassName() -> "std::string const &":
    return _simulation.JointSet_getClassName()

class Constraint(ModelComponent):
    r"""
    A parent class for implementing a Simbody Constraint.
    Specific constraints should be derived from this class.

    Author: Frank C. Anderson
    Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Constraint *":
        return _simulation.Constraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Constraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Constraint_getClassName()

    def clone(self) -> "OpenSim::Constraint *":
        return _simulation.Constraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Constraint_getConcreteClassName(self)

    def copyProperty_isEnforced(self, source: "Constraint") -> "void":
        return _simulation.Constraint_copyProperty_isEnforced(self, source)

    def append_isEnforced(self, value: "bool const &") -> "int":
        return _simulation.Constraint_append_isEnforced(self, value)

    def constructProperty_isEnforced(self, initValue: "bool const &") -> "void":
        return _simulation.Constraint_constructProperty_isEnforced(self, initValue)

    def get_isEnforced(self, *args) -> "bool const &":
        return _simulation.Constraint_get_isEnforced(self, *args)

    def upd_isEnforced(self, *args) -> "bool &":
        return _simulation.Constraint_upd_isEnforced(self, *args)

    def set_isEnforced(self, *args) -> "void":
        return _simulation.Constraint_set_isEnforced(self, *args)
    __swig_destroy__ = _simulation.delete_Constraint

    def updateFromConstraint(self, s: "State", aConstraint: "Constraint") -> "void":
        return _simulation.Constraint_updateFromConstraint(self, s, aConstraint)

    def isEnforced(self, s: "State") -> "bool":
        r"""Determine whether or not this Constraint is being enforced."""
        return _simulation.Constraint_isEnforced(self, s)

    def setIsEnforced(self, s: "State", isEnforced: "bool") -> "bool":
        r"""
        Set whether or not this Constraint is enforced.
        The realization Stage is dropped to Instance whenever the 'isEnforced'
        flag is changed, but setting the same value has no effect.
        """
        return _simulation.Constraint_setIsEnforced(self, s, isEnforced)

    def calcConstraintForces(self, s: "State", bodyForcesInAncestor: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        return _simulation.Constraint_calcConstraintForces(self, s, bodyForcesInAncestor, mobilityForces)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods to query the Constraint forces (defaults to the Lagrange
        multipliers) applied to the MultibodySystem. The names of the quantities
        (column labels) are returned by this first method, getRecordLabels()
        """
        return _simulation.Constraint_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given a SimTK::State, extract all the values necessary to report
        constraint forces (e.g. multipliers). Subclasses can override to report
        the location, frame, etc.. of force application. This method is used in
        conjunction with getRecordLabels() and must return an Array of equal
        size.
        """
        return _simulation.Constraint_getRecordValues(self, state)

    def setContactPointForInducedAccelerations(self, s: "State", point: "Vec3") -> "void":
        r"""
        This method specifies the interface that a constraint must implement
        in order to be used by the Induced Accelerations Analysis
        """
        return _simulation.Constraint_setContactPointForInducedAccelerations(self, s, point)

# Register Constraint in _simulation:
_simulation.Constraint_swigregister(Constraint)

def Constraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Constraint *":
    return _simulation.Constraint_safeDownCast(obj)

def Constraint_getClassName() -> "std::string const &":
    return _simulation.Constraint_getClassName()

class SetConstraints(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Constraint,OpenSim::ModelComponent > *":
        return _simulation.SetConstraints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetConstraints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetConstraints_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Constraint,OpenSim::ModelComponent > *":
        return _simulation.SetConstraints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetConstraints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetConstraints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Constraint,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetConstraints_swiginit(self, _simulation.new_SetConstraints(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetConstraints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetConstraints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetConstraints_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetConstraints_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Constraint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetConstraints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetConstraints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Constraint") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetConstraints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Constraint") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Constraint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetConstraints_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Constraint") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetConstraints_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Constraint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetConstraints_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetConstraints_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Constraint", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Constraint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetConstraints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Constraint &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Constraint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Constraint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetConstraints_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetConstraints_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetConstraints_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetConstraints_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetConstraints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetConstraints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetConstraints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetConstraints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetConstraints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetConstraints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetConstraints in _simulation:
_simulation.SetConstraints_swigregister(SetConstraints)

def SetConstraints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Constraint,OpenSim::ModelComponent > *":
    return _simulation.SetConstraints_safeDownCast(obj)

def SetConstraints_getClassName() -> "std::string const &":
    return _simulation.SetConstraints_getClassName()

class ModelComponentSetConstraints(SetConstraints):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Constraint > *":
        return _simulation.ModelComponentSetConstraints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetConstraints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetConstraints_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Constraint > *":
        return _simulation.ModelComponentSetConstraints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetConstraints_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetConstraints_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetConstraints_swiginit(self, _simulation.new_ModelComponentSetConstraints())
    __swig_destroy__ = _simulation.delete_ModelComponentSetConstraints

# Register ModelComponentSetConstraints in _simulation:
_simulation.ModelComponentSetConstraints_swigregister(ModelComponentSetConstraints)

def ModelComponentSetConstraints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Constraint > *":
    return _simulation.ModelComponentSetConstraints_safeDownCast(obj)

def ModelComponentSetConstraints_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetConstraints_getClassName()

class ConstraintSet(ModelComponentSetConstraints):
    r"""
    A class for holding a set of constraints.

    Authors: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConstraintSet *":
        return _simulation.ConstraintSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ConstraintSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ConstraintSet_getClassName()

    def clone(self) -> "OpenSim::ConstraintSet *":
        return _simulation.ConstraintSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ConstraintSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ConstraintSet_swiginit(self, _simulation.new_ConstraintSet(*args))
    __swig_destroy__ = _simulation.delete_ConstraintSet

# Register ConstraintSet in _simulation:
_simulation.ConstraintSet_swigregister(ConstraintSet)

def ConstraintSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConstraintSet *":
    return _simulation.ConstraintSet_safeDownCast(obj)

def ConstraintSet_getClassName() -> "std::string const &":
    return _simulation.ConstraintSet_getClassName()

class Force(ModelComponent):
    r"""
    This abstract class represents a force applied to bodies or generalized
    coordinates during a simulation. Each subclass represents a different type
    of force. The actual force computation is done by a SimTK::Force, which is
    created by extendAddToSystem().

    Author: Peter Eastman
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Force *":
        return _simulation.Force_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Force_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Force_getClassName()

    def clone(self) -> "OpenSim::Force *":
        return _simulation.Force_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Force_getConcreteClassName(self)

    def copyProperty_appliesForce(self, source: "Force") -> "void":
        return _simulation.Force_copyProperty_appliesForce(self, source)

    def append_appliesForce(self, value: "bool const &") -> "int":
        return _simulation.Force_append_appliesForce(self, value)

    def constructProperty_appliesForce(self, initValue: "bool const &") -> "void":
        return _simulation.Force_constructProperty_appliesForce(self, initValue)

    def get_appliesForce(self, *args) -> "bool const &":
        return _simulation.Force_get_appliesForce(self, *args)

    def upd_appliesForce(self, *args) -> "bool &":
        return _simulation.Force_upd_appliesForce(self, *args)

    def set_appliesForce(self, *args) -> "void":
        return _simulation.Force_set_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Force__has_output_potential_energy_get, _simulation.Force__has_output_potential_energy_set)

    def shouldBeParallelized(self) -> "bool":
        r"""
        Tell SimBody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Force_shouldBeParallelized(self)

    def appliesForce(self, s: "State") -> "bool":
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Force_appliesForce(self, s)

    def setAppliesForce(self, s: "State", applyForce: "bool") -> "void":
        r""" %Set whether or not the Force is applied."""
        return _simulation.Force_setAppliesForce(self, s, applyForce)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods to query a Force for the value actually applied during
        simulation. The names of the quantities (column labels) is returned by
        this first function getRecordLabels().
        """
        return _simulation.Force_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.Force_getRecordValues(self, state)

    def hasGeometryPath(self) -> "bool":
        r"""
        Return a flag indicating whether the Force is applied along a Path. If
           you override this method to return true for a specific subclass, it must
           also implement the getGeometryPath() method. *
        """
        return _simulation.Force_hasGeometryPath(self)
    __swig_destroy__ = _simulation.delete_Force

# Register Force in _simulation:
_simulation.Force_swigregister(Force)

def Force_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Force *":
    return _simulation.Force_safeDownCast(obj)

def Force_getClassName() -> "std::string const &":
    return _simulation.Force_getClassName()

class SetForces(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Force,OpenSim::ModelComponent > *":
        return _simulation.SetForces_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetForces_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetForces_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Force,OpenSim::ModelComponent > *":
        return _simulation.SetForces_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetForces_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetForces

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Force,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetForces_swiginit(self, _simulation.new_SetForces(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetForces_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetForces_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetForces_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetForces_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Force`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetForces_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetForces_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Force") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Force`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetForces_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Force") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Force`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetForces_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Force") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Force`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetForces_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Force`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetForces_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetForces_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Force", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Force`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetForces_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Force &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Force`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Force`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetForces_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetForces_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetForces_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetForces_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetForces_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetForces_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetForces_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetForces_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetForces_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetForces_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetForces in _simulation:
_simulation.SetForces_swigregister(SetForces)

def SetForces_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Force,OpenSim::ModelComponent > *":
    return _simulation.SetForces_safeDownCast(obj)

def SetForces_getClassName() -> "std::string const &":
    return _simulation.SetForces_getClassName()

class ModelComponentSetForces(SetForces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Force > *":
        return _simulation.ModelComponentSetForces_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetForces_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetForces_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Force > *":
        return _simulation.ModelComponentSetForces_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetForces_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetForces_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetForces_swiginit(self, _simulation.new_ModelComponentSetForces())
    __swig_destroy__ = _simulation.delete_ModelComponentSetForces

# Register ModelComponentSetForces in _simulation:
_simulation.ModelComponentSetForces_swigregister(ModelComponentSetForces)

def ModelComponentSetForces_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Force > *":
    return _simulation.ModelComponentSetForces_safeDownCast(obj)

def ModelComponentSetForces_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetForces_getClassName()

class ForceSet(ModelComponentSetForces):
    r"""
    A class for holding and managing a set of forces for a model.
    This class is based on ModelComponentSet

    Authors: Ajay Seth, Jack Middleton
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceSet *":
        return _simulation.ForceSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ForceSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ForceSet_getClassName()

    def clone(self) -> "OpenSim::ForceSet *":
        return _simulation.ForceSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ForceSet_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ForceSet

    def extendConnectToModel(self, aModel: "Model") -> "void":
        return _simulation.ForceSet_extendConnectToModel(self, aModel)

    def remove(self, aIndex: "int") -> "bool":
        return _simulation.ForceSet_remove(self, aIndex)

    def appendNative(self, aForce: "Force") -> "bool":
        return _simulation.ForceSet_appendNative(self, aForce)

    def append(self, aForceSet: "ForceSet", aAllowDuplicateNames: "bool"=False) -> "bool":
        return _simulation.ForceSet_append(self, aForceSet, aAllowDuplicateNames)

    def set(self, aIndex: "int", aForce: "Force", preserveGroups: "bool"=False) -> "bool":
        return _simulation.ForceSet_set(self, aIndex, aForce, preserveGroups)

    def insert(self, aIndex: "int", aObject: "Force") -> "bool":
        return _simulation.ForceSet_insert(self, aIndex, aObject)

    def getActuators(self) -> "OpenSim::Set< OpenSim::Actuator > const &":
        return _simulation.ForceSet_getActuators(self)

    def updActuators(self) -> "OpenSim::Set< OpenSim::Actuator > &":
        return _simulation.ForceSet_updActuators(self)

    def getMuscles(self) -> "OpenSim::Set< Muscle > const &":
        return _simulation.ForceSet_getMuscles(self)

    def updMuscles(self) -> "OpenSim::Set< Muscle > &":
        return _simulation.ForceSet_updMuscles(self)

    def getStateVariableNames(self, rNames: "ArrayStr") -> "void":
        return _simulation.ForceSet_getStateVariableNames(self, rNames)

    def check(self) -> "bool":
        return _simulation.ForceSet_check(self)

    def __init__(self, *args):
        _simulation.ForceSet_swiginit(self, _simulation.new_ForceSet(*args))

    def adoptAndAppend(self, aForce):
        aForce._markAdopted()
        return super(ForceSet, self).adoptAndAppend(aForce)


    def append(self, aForce):
        aForce._markAdopted()
        return self.appendNative(aForce)


# Register ForceSet in _simulation:
_simulation.ForceSet_swigregister(ForceSet)

def ForceSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceSet *":
    return _simulation.ForceSet_safeDownCast(obj)

def ForceSet_getClassName() -> "std::string const &":
    return _simulation.ForceSet_getClassName()

class ExternalForce(Force):
    r"""
    An ExternalForce is a Force class specialized at applying an external force
    and/or torque to a body as described by arrays (columns) of a Storage object.
    The source of the Storage may be experimental sensor recording or user
    generated data. The Storage must be able to supply (1) an array of time, (2)
    arrays for the x,y,z, components of force and/or torque in time. Optionally,
    (3) arrays for the point of force application in time. An ExternalForce
    must specify the identifier (e.g. Force1.x Force1.y Force1.z) for the force
    components (columns) listed in the Storage either by individual labels or
    collectively (e.g. as "Force1"). Similarly, identifiers for the applied
    torque and optionally the point of force application must be specified.

    If an identifier is supplied and it cannot uniquely identify the force data
    (e.g. the force, torque, or point) in the Storage, then an Exception is
    thrown.

    An ExternalForce must apply at least a force or a torque and therefore both
    identifiers cannot be empty.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExternalForce *":
        return _simulation.ExternalForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ExternalForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ExternalForce_getClassName()

    def clone(self) -> "OpenSim::ExternalForce *":
        return _simulation.ExternalForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ExternalForce_getConcreteClassName(self)

    def copyProperty_applied_to_body(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_applied_to_body(self, source)

    def append_applied_to_body(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_applied_to_body(self, value)

    def constructProperty_applied_to_body(self, initValue: "std::string const &") -> "void":
        return _simulation.ExternalForce_constructProperty_applied_to_body(self, initValue)

    def get_applied_to_body(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_applied_to_body(self, *args)

    def upd_applied_to_body(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_applied_to_body(self, *args)

    def set_applied_to_body(self, *args) -> "void":
        return _simulation.ExternalForce_set_applied_to_body(self, *args)

    def copyProperty_force_expressed_in_body(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_force_expressed_in_body(self, source)

    def append_force_expressed_in_body(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_force_expressed_in_body(self, value)

    def constructProperty_force_expressed_in_body(self, initValue: "std::string const &") -> "void":
        return _simulation.ExternalForce_constructProperty_force_expressed_in_body(self, initValue)

    def get_force_expressed_in_body(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_force_expressed_in_body(self, *args)

    def upd_force_expressed_in_body(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_force_expressed_in_body(self, *args)

    def set_force_expressed_in_body(self, *args) -> "void":
        return _simulation.ExternalForce_set_force_expressed_in_body(self, *args)

    def copyProperty_point_expressed_in_body(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_point_expressed_in_body(self, source)

    def append_point_expressed_in_body(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_point_expressed_in_body(self, value)

    def constructProperty_point_expressed_in_body(self, initValue: "std::string const &") -> "void":
        return _simulation.ExternalForce_constructProperty_point_expressed_in_body(self, initValue)

    def get_point_expressed_in_body(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_point_expressed_in_body(self, *args)

    def upd_point_expressed_in_body(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_point_expressed_in_body(self, *args)

    def set_point_expressed_in_body(self, *args) -> "void":
        return _simulation.ExternalForce_set_point_expressed_in_body(self, *args)

    def copyProperty_force_identifier(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_force_identifier(self, source)

    def append_force_identifier(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_force_identifier(self, value)

    def constructProperty_force_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_constructProperty_force_identifier(self, *args)

    def get_force_identifier(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_force_identifier(self, *args)

    def upd_force_identifier(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_force_identifier(self, *args)

    def set_force_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_set_force_identifier(self, *args)

    def copyProperty_point_identifier(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_point_identifier(self, source)

    def append_point_identifier(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_point_identifier(self, value)

    def constructProperty_point_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_constructProperty_point_identifier(self, *args)

    def get_point_identifier(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_point_identifier(self, *args)

    def upd_point_identifier(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_point_identifier(self, *args)

    def set_point_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_set_point_identifier(self, *args)

    def copyProperty_torque_identifier(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_torque_identifier(self, source)

    def append_torque_identifier(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_torque_identifier(self, value)

    def constructProperty_torque_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_constructProperty_torque_identifier(self, *args)

    def get_torque_identifier(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_torque_identifier(self, *args)

    def upd_torque_identifier(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_torque_identifier(self, *args)

    def set_torque_identifier(self, *args) -> "void":
        return _simulation.ExternalForce_set_torque_identifier(self, *args)

    def copyProperty_data_source_name(self, source: "ExternalForce") -> "void":
        return _simulation.ExternalForce_copyProperty_data_source_name(self, source)

    def append_data_source_name(self, value: "std::string const &") -> "int":
        return _simulation.ExternalForce_append_data_source_name(self, value)

    def constructProperty_data_source_name(self, *args) -> "void":
        return _simulation.ExternalForce_constructProperty_data_source_name(self, *args)

    def get_data_source_name(self, *args) -> "std::string const &":
        return _simulation.ExternalForce_get_data_source_name(self, *args)

    def upd_data_source_name(self, *args) -> "std::string &":
        return _simulation.ExternalForce_upd_data_source_name(self, *args)

    def set_data_source_name(self, *args) -> "void":
        return _simulation.ExternalForce_set_data_source_name(self, *args)

    def __init__(self, *args):
        _simulation.ExternalForce_swiginit(self, _simulation.new_ExternalForce(*args))

    def setDataSource(self, dataSource: "Storage") -> "void":
        r"""
        Associate the data source from which the force, point and/or torque data
        is to be extracted.
        """
        return _simulation.ExternalForce_setDataSource(self, dataSource)

    def getDataSourceName(self) -> "std::string const &":
        r""" Get the name of the data source for the force data. *"""
        return _simulation.ExternalForce_getDataSourceName(self)

    def setAppliedToBodyName(self, applyToName: "std::string const &") -> "void":
        r""" Specify or obtain the body to which the force will be applied"""
        return _simulation.ExternalForce_setAppliedToBodyName(self, applyToName)

    def getAppliedToBodyName(self) -> "std::string const &":
        return _simulation.ExternalForce_getAppliedToBodyName(self)

    def setPointExpressedInBodyName(self, pointInBodyName: "std::string const &") -> "void":
        r""" Specify or obtain the body in which the point of application is expressed"""
        return _simulation.ExternalForce_setPointExpressedInBodyName(self, pointInBodyName)

    def getPointExpressedInBodyName(self) -> "std::string const &":
        return _simulation.ExternalForce_getPointExpressedInBodyName(self)

    def setForceExpressedInBodyName(self, forceInBodyName: "std::string const &") -> "void":
        r""" Specify or obtain the body in which the force is expressed"""
        return _simulation.ExternalForce_setForceExpressedInBodyName(self, forceInBodyName)

    def getForceExpressedInBodyName(self) -> "std::string const &":
        return _simulation.ExternalForce_getForceExpressedInBodyName(self)

    def setForceIdentifier(self, aForceIdentifier: "std::string const") -> "void":
        r"""Identifiers"""
        return _simulation.ExternalForce_setForceIdentifier(self, aForceIdentifier)

    def setPointIdentifier(self, aPointIdentifier: "std::string const") -> "void":
        return _simulation.ExternalForce_setPointIdentifier(self, aPointIdentifier)

    def setTorqueIdentifier(self, aTorqueIdentifier: "std::string const") -> "void":
        return _simulation.ExternalForce_setTorqueIdentifier(self, aTorqueIdentifier)

    def getForceIdentifier(self) -> "std::string const &":
        return _simulation.ExternalForce_getForceIdentifier(self)

    def getPointIdentifier(self) -> "std::string const &":
        return _simulation.ExternalForce_getPointIdentifier(self)

    def getTorqueIdentifier(self) -> "std::string const &":
        return _simulation.ExternalForce_getTorqueIdentifier(self)

    def getForceAtTime(self, aTime: "double") -> "SimTK::Vec3":
        r"""Convenience methods to access external forces at a given time"""
        return _simulation.ExternalForce_getForceAtTime(self, aTime)

    def getPointAtTime(self, aTime: "double") -> "SimTK::Vec3":
        return _simulation.ExternalForce_getPointAtTime(self, aTime)

    def getTorqueAtTime(self, aTime: "double") -> "SimTK::Vec3":
        return _simulation.ExternalForce_getTorqueAtTime(self, aTime)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods used for reporting.
        First identify the labels for individual components
        """
        return _simulation.ExternalForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.ExternalForce_getRecordValues(self, state)

    def appliesForce(self) -> "bool":
        r"""
        Methods to query the force properties to find out if it's a body vs.
        point force and/or if it applies a torque.
        """
        return _simulation.ExternalForce_appliesForce(self)

    def specifiesPoint(self) -> "bool":
        return _simulation.ExternalForce_specifiesPoint(self)

    def appliesTorque(self) -> "bool":
        return _simulation.ExternalForce_appliesTorque(self)
    __swig_destroy__ = _simulation.delete_ExternalForce

# Register ExternalForce in _simulation:
_simulation.ExternalForce_swigregister(ExternalForce)

def ExternalForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExternalForce *":
    return _simulation.ExternalForce_safeDownCast(obj)

def ExternalForce_getClassName() -> "std::string const &":
    return _simulation.ExternalForce_getClassName()

class SetExternalForces(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ExternalForce,OpenSim::ModelComponent > *":
        return _simulation.SetExternalForces_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetExternalForces_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetExternalForces_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::ExternalForce,OpenSim::ModelComponent > *":
        return _simulation.SetExternalForces_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetExternalForces_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetExternalForces

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ExternalForce,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetExternalForces_swiginit(self, _simulation.new_SetExternalForces(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetExternalForces_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetExternalForces_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetExternalForces_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetExternalForces_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetExternalForces_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetExternalForces_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "ExternalForce") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetExternalForces_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "ExternalForce") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetExternalForces_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "ExternalForce") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetExternalForces_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ExternalForce`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetExternalForces_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetExternalForces_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "ExternalForce", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ExternalForce`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetExternalForces_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::ExternalForce &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ExternalForce`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ExternalForce`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetExternalForces_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetExternalForces_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetExternalForces_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetExternalForces_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetExternalForces_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetExternalForces_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetExternalForces_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetExternalForces_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetExternalForces_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetExternalForces_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetExternalForces in _simulation:
_simulation.SetExternalForces_swigregister(SetExternalForces)

def SetExternalForces_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ExternalForce,OpenSim::ModelComponent > *":
    return _simulation.SetExternalForces_safeDownCast(obj)

def SetExternalForces_getClassName() -> "std::string const &":
    return _simulation.SetExternalForces_getClassName()

class ModelComponentSetExternalForces(SetExternalForces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ExternalForce > *":
        return _simulation.ModelComponentSetExternalForces_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetExternalForces_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetExternalForces_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::ExternalForce > *":
        return _simulation.ModelComponentSetExternalForces_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetExternalForces_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetExternalForces_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetExternalForces_swiginit(self, _simulation.new_ModelComponentSetExternalForces())
    __swig_destroy__ = _simulation.delete_ModelComponentSetExternalForces

# Register ModelComponentSetExternalForces in _simulation:
_simulation.ModelComponentSetExternalForces_swigregister(ModelComponentSetExternalForces)

def ModelComponentSetExternalForces_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ExternalForce > *":
    return _simulation.ModelComponentSetExternalForces_safeDownCast(obj)

def ModelComponentSetExternalForces_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetExternalForces_getClassName()

class TwoFrameLinkerForce(Force):
    r"""
    TwoFrameLinker is a utility class to extend a Component such that it connects
    two Frames. For example, a WeldConstraint and BushingForces operate between
    two frames to restrict their motion. A TwoFrameLinker<Force, PhysicalFrame>,
    for example, is a Force that operates between two PhyscialFrames and it is
    the base class for BushingForces.
    (A class whose super class is a template parameter is called a mixin class.)

    .. code-block:: c++

           class BushingForce : public TwoFrameLinker<Force, PhysicalFrame>

    :param C: The base class.
    :param F: The type of frame that the class links together.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TwoFrameLinker< OpenSim::Force,OpenSim::PhysicalFrame > *":
        return _simulation.TwoFrameLinkerForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TwoFrameLinkerForce_getClassName()

    def clone(self) -> "OpenSim::TwoFrameLinker< OpenSim::Force,OpenSim::PhysicalFrame > *":
        return _simulation.TwoFrameLinkerForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TwoFrameLinkerForce_getConcreteClassName(self)

    def copyProperty_frames(self, source: "TwoFrameLinkerForce") -> "void":
        r""" Frames added to satisfy the sockets of this TwoFrameLinker Component"""
        return _simulation.TwoFrameLinkerForce_copyProperty_frames(self, source)

    def get_frames(self, i: "int") -> "OpenSim::PhysicalFrame const &":
        return _simulation.TwoFrameLinkerForce_get_frames(self, i)

    def upd_frames(self, i: "int") -> "OpenSim::PhysicalFrame &":
        return _simulation.TwoFrameLinkerForce_upd_frames(self, i)

    def set_frames(self, i: "int", value: "PhysicalFrame") -> "void":
        return _simulation.TwoFrameLinkerForce_set_frames(self, i, value)

    def append_frames(self, value: "PhysicalFrame") -> "int":
        return _simulation.TwoFrameLinkerForce_append_frames(self, value)

    def constructProperty_frames(self) -> "void":
        return _simulation.TwoFrameLinkerForce_constructProperty_frames(self)
    PropertyIndex_socket_frame1 = property(_simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame1_get, _simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame1_set)

    def connectSocket_frame1(self, object: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerForce_connectSocket_frame1(self, object)
    PropertyIndex_socket_frame2 = property(_simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame2_get, _simulation.TwoFrameLinkerForce_PropertyIndex_socket_frame2_set)

    def connectSocket_frame2(self, object: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerForce_connectSocket_frame2(self, object)

    def getFrame1(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Access the first frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForce_getFrame1(self)

    def getFrame2(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Access the second frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerForce_getFrame2(self)

    def computeRelativeOffset(self, s: "State") -> "SimTK::Transform":
        r"""
        Compute the relative offset Transform between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForce_computeRelativeOffset(self, s)

    def computeRelativeVelocity(self, s: "State") -> "SimTK::SpatialVec":
        r"""
        Compute the relative spatial velocity between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerForce_computeRelativeVelocity(self, s)

    def computeDeflection(self, s: "State") -> "SimTK::Vec6":
        r"""
        Compute the deflection (spatial separation) of the two frames connected
               by the TwoFrameLinker. Angular deflections expressed as XYZ body-fixed
               Euler angles of frame2 w.r.t frame1.
               NOTE: When using deflections to compute spatial forces, these forces
                   may not be valid for large deflections, because Euler angles are
                   unable to uniquely distinguish an X rotation angle of +/-180 degs,
                   and subsequent rotations that are +/-90 degs. It is mainly useful
                   for calculating errors for constraints and forces for computing
                   restoration forces.
            :rtype: :py:class:`Vec6`
            :return: dq     Vec6 of (3) angular and (3) translational deflections.
        """
        return _simulation.TwoFrameLinkerForce_computeDeflection(self, s)

    def computeDeflectionRate(self, s: "State") -> "SimTK::Vec6":
        r"""
        Compute the deflection rate (dqdot) of the two frames connected by
               this TwoFrameLinker component. Angular velocity is expressed as Euler
               (XYZ body-fixed) angle derivatives. Note that the derivatives
               become singular as the second Euler angle approaches 90 degs.
           :rtype: :py:class:`Vec6`
           :return: dqdot  Vec6 of (3) angular and (3) translational deflection rates.
        """
        return _simulation.TwoFrameLinkerForce_computeDeflectionRate(self, s)
    __swig_destroy__ = _simulation.delete_TwoFrameLinkerForce

# Register TwoFrameLinkerForce in _simulation:
_simulation.TwoFrameLinkerForce_swigregister(TwoFrameLinkerForce)

def TwoFrameLinkerForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TwoFrameLinker< OpenSim::Force,OpenSim::PhysicalFrame > *":
    return _simulation.TwoFrameLinkerForce_safeDownCast(obj)

def TwoFrameLinkerForce_getClassName() -> "std::string const &":
    return _simulation.TwoFrameLinkerForce_getClassName()

class TwoFrameLinkerConstraint(Constraint):
    r"""
    TwoFrameLinker is a utility class to extend a Component such that it connects
    two Frames. For example, a WeldConstraint and BushingForces operate between
    two frames to restrict their motion. A TwoFrameLinker<Force, PhysicalFrame>,
    for example, is a Force that operates between two PhyscialFrames and it is
    the base class for BushingForces.
    (A class whose super class is a template parameter is called a mixin class.)

    .. code-block:: c++

           class BushingForce : public TwoFrameLinker<Force, PhysicalFrame>

    :param C: The base class.
    :param F: The type of frame that the class links together.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TwoFrameLinker< OpenSim::Constraint,OpenSim::PhysicalFrame > *":
        return _simulation.TwoFrameLinkerConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TwoFrameLinkerConstraint_getClassName()

    def clone(self) -> "OpenSim::TwoFrameLinker< OpenSim::Constraint,OpenSim::PhysicalFrame > *":
        return _simulation.TwoFrameLinkerConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TwoFrameLinkerConstraint_getConcreteClassName(self)

    def copyProperty_frames(self, source: "TwoFrameLinkerConstraint") -> "void":
        r""" Frames added to satisfy the sockets of this TwoFrameLinker Component"""
        return _simulation.TwoFrameLinkerConstraint_copyProperty_frames(self, source)

    def get_frames(self, i: "int") -> "OpenSim::PhysicalFrame const &":
        return _simulation.TwoFrameLinkerConstraint_get_frames(self, i)

    def upd_frames(self, i: "int") -> "OpenSim::PhysicalFrame &":
        return _simulation.TwoFrameLinkerConstraint_upd_frames(self, i)

    def set_frames(self, i: "int", value: "PhysicalFrame") -> "void":
        return _simulation.TwoFrameLinkerConstraint_set_frames(self, i, value)

    def append_frames(self, value: "PhysicalFrame") -> "int":
        return _simulation.TwoFrameLinkerConstraint_append_frames(self, value)

    def constructProperty_frames(self) -> "void":
        return _simulation.TwoFrameLinkerConstraint_constructProperty_frames(self)
    PropertyIndex_socket_frame1 = property(_simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame1_get, _simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame1_set)

    def connectSocket_frame1(self, object: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerConstraint_connectSocket_frame1(self, object)
    PropertyIndex_socket_frame2 = property(_simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame2_get, _simulation.TwoFrameLinkerConstraint_PropertyIndex_socket_frame2_set)

    def connectSocket_frame2(self, object: "OpenSimObject") -> "void":
        return _simulation.TwoFrameLinkerConstraint_connectSocket_frame2(self, object)

    def getFrame1(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Access the first frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerConstraint_getFrame1(self)

    def getFrame2(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Access the second frame the TwoFrameLinker component connects.
               Note, if an offset was introduced at construction, then this will be
               the offset frame.
        """
        return _simulation.TwoFrameLinkerConstraint_getFrame2(self)

    def computeRelativeOffset(self, s: "State") -> "SimTK::Transform":
        r"""
        Compute the relative offset Transform between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerConstraint_computeRelativeOffset(self, s)

    def computeRelativeVelocity(self, s: "State") -> "SimTK::SpatialVec":
        r"""
        Compute the relative spatial velocity between the two frames linked by
               this TwoFrameLinker component at a given State, expressed in frame1.
        """
        return _simulation.TwoFrameLinkerConstraint_computeRelativeVelocity(self, s)

    def computeDeflection(self, s: "State") -> "SimTK::Vec6":
        r"""
        Compute the deflection (spatial separation) of the two frames connected
               by the TwoFrameLinker. Angular deflections expressed as XYZ body-fixed
               Euler angles of frame2 w.r.t frame1.
               NOTE: When using deflections to compute spatial forces, these forces
                   may not be valid for large deflections, because Euler angles are
                   unable to uniquely distinguish an X rotation angle of +/-180 degs,
                   and subsequent rotations that are +/-90 degs. It is mainly useful
                   for calculating errors for constraints and forces for computing
                   restoration forces.
            :rtype: :py:class:`Vec6`
            :return: dq     Vec6 of (3) angular and (3) translational deflections.
        """
        return _simulation.TwoFrameLinkerConstraint_computeDeflection(self, s)

    def computeDeflectionRate(self, s: "State") -> "SimTK::Vec6":
        r"""
        Compute the deflection rate (dqdot) of the two frames connected by
               this TwoFrameLinker component. Angular velocity is expressed as Euler
               (XYZ body-fixed) angle derivatives. Note that the derivatives
               become singular as the second Euler angle approaches 90 degs.
           :rtype: :py:class:`Vec6`
           :return: dqdot  Vec6 of (3) angular and (3) translational deflection rates.
        """
        return _simulation.TwoFrameLinkerConstraint_computeDeflectionRate(self, s)
    __swig_destroy__ = _simulation.delete_TwoFrameLinkerConstraint

# Register TwoFrameLinkerConstraint in _simulation:
_simulation.TwoFrameLinkerConstraint_swigregister(TwoFrameLinkerConstraint)

def TwoFrameLinkerConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TwoFrameLinker< OpenSim::Constraint,OpenSim::PhysicalFrame > *":
    return _simulation.TwoFrameLinkerConstraint_safeDownCast(obj)

def TwoFrameLinkerConstraint_getClassName() -> "std::string const &":
    return _simulation.TwoFrameLinkerConstraint_getClassName()

class FreeJoint(Joint):
    r"""
    A class implementing a Free joint.  The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Free.
    Free joint allows unrestricted motion with three rotations and three translations.
    Rotations are modeled similarly to BallJoint -using quaternions with no
    singularities- while the translational generalized coordinates are XYZ
    Translations along the parent axis. Generalized speeds are equal to the computed
    angular velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation of
    position (:math:`\vec{u} \neq \dot{\vec{q}}`).

    Image: freeJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FreeJoint *":
        return _simulation.FreeJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FreeJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FreeJoint_getClassName()

    def clone(self) -> "OpenSim::FreeJoint *":
        return _simulation.FreeJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FreeJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.FreeJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.FreeJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.FreeJoint_Coord_Rotation3Z
    r""" 2"""
    Coord_TranslationX = _simulation.FreeJoint_Coord_TranslationX
    r""" 3"""
    Coord_TranslationY = _simulation.FreeJoint_Coord_TranslationY
    r""" 4"""
    Coord_TranslationZ = _simulation.FreeJoint_Coord_TranslationZ
    r""" 5"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.FreeJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.FreeJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.FreeJoint_swiginit(self, _simulation.new_FreeJoint(*args))
    __swig_destroy__ = _simulation.delete_FreeJoint

# Register FreeJoint in _simulation:
_simulation.FreeJoint_swigregister(FreeJoint)

def FreeJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FreeJoint *":
    return _simulation.FreeJoint_safeDownCast(obj)

def FreeJoint_getClassName() -> "std::string const &":
    return _simulation.FreeJoint_getClassName()

class CustomJoint(Joint):
    r"""
    A class implementing a custom joint.  The underlying implementation in Simbody
    is a SimTK::MobilizedBody::FunctionBased. Custom joints offer a generic joint
    representation, which can be used to model both conventional (pins, slider,
    universal, etc.) as well as more complex biomechanical joints. The behavior of
    a custom joint is specified by its SpatialTransform. A SpatialTransform is com-
    prised of 6 TransformAxes (3 rotations and 3 translations) that define the
    spatial position of Child in Parent as a function of coordinates. Each transform
    axis has a function of joint coordinates that describes the motion about or along
    the transform axis. The order of the spatial transform is fixed with rotations
    first followed by translations. Subsequently, coupled motion (i.e., describing
    motion of two degrees of freedom as a function of one coordinate) is handled by
    transform axis functions that depend on the same coordinate(s).

    Author: Ajay Seth, Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CustomJoint *":
        return _simulation.CustomJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.CustomJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.CustomJoint_getClassName()

    def clone(self) -> "OpenSim::CustomJoint *":
        return _simulation.CustomJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.CustomJoint_getConcreteClassName(self)

    def copyProperty_SpatialTransform(self, source: "CustomJoint") -> "void":
        r"""
        Spatial transform defining how the child body moves with respect
           to the parent body as a function of the generalized coordinates.
           Motion over 6 (independent) spatial axes must be defined.
        """
        return _simulation.CustomJoint_copyProperty_SpatialTransform(self, source)

    def append_SpatialTransform(self, value: "SpatialTransform") -> "int":
        return _simulation.CustomJoint_append_SpatialTransform(self, value)

    def constructProperty_SpatialTransform(self, initValue: "SpatialTransform") -> "void":
        return _simulation.CustomJoint_constructProperty_SpatialTransform(self, initValue)

    def get_SpatialTransform(self, *args) -> "OpenSim::SpatialTransform const &":
        return _simulation.CustomJoint_get_SpatialTransform(self, *args)

    def upd_SpatialTransform(self, *args) -> "OpenSim::SpatialTransform &":
        return _simulation.CustomJoint_upd_SpatialTransform(self, *args)

    def set_SpatialTransform(self, *args) -> "void":
        return _simulation.CustomJoint_set_SpatialTransform(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor

        |

        *Overload 2:*
        Construct joint with supplied coordinates and transform axes

        |

        *Overload 3:*
        Joint constructor with explicit parent and child offsets in terms of
               their location and orientation.
        """
        _simulation.CustomJoint_swiginit(self, _simulation.new_CustomJoint(*args))

    def getSpatialTransform(self) -> "OpenSim::SpatialTransform const &":
        return _simulation.CustomJoint_getSpatialTransform(self)

    def updSpatialTransform(self) -> "OpenSim::SpatialTransform &":
        return _simulation.CustomJoint_updSpatialTransform(self)

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
        """
        return _simulation.CustomJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
        """
        return _simulation.CustomJoint_updCoordinate(self, *args)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.CustomJoint_extendScale(self, s, scaleSet)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        r""" Override of the default implementation to account for versioning."""
        return _simulation.CustomJoint_updateFromXMLNode(self, aNode, versionNumber)
    __swig_destroy__ = _simulation.delete_CustomJoint

# Register CustomJoint in _simulation:
_simulation.CustomJoint_swigregister(CustomJoint)

def CustomJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CustomJoint *":
    return _simulation.CustomJoint_safeDownCast(obj)

def CustomJoint_getClassName() -> "std::string const &":
    return _simulation.CustomJoint_getClassName()

class EllipsoidJoint(Joint):
    r"""
    A class implementing a Ellipsoid joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Ellipsoid. An Ellipsoid joint provides three
    mobilities – coordinated rotation and translation along the surface of an ellipsoid
     fixed to the parent body. The ellipsoid surface is determined by an input Vec3 which
    describes the ellipsoid radius. Generalized speeds are equal to the computed angular
    velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation of
    position (:math:`\vec{u} \neq \dot{\vec{q}}`)

    Image: ellipsoid.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::EllipsoidJoint *":
        return _simulation.EllipsoidJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.EllipsoidJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.EllipsoidJoint_getClassName()

    def clone(self) -> "OpenSim::EllipsoidJoint *":
        return _simulation.EllipsoidJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.EllipsoidJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.EllipsoidJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.EllipsoidJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.EllipsoidJoint_Coord_Rotation3Z
    r""" 2"""

    def copyProperty_radii_x_y_z(self, source: "EllipsoidJoint") -> "void":
        return _simulation.EllipsoidJoint_copyProperty_radii_x_y_z(self, source)

    def append_radii_x_y_z(self, value: "Vec3") -> "int":
        return _simulation.EllipsoidJoint_append_radii_x_y_z(self, value)

    def constructProperty_radii_x_y_z(self, initValue: "Vec3") -> "void":
        return _simulation.EllipsoidJoint_constructProperty_radii_x_y_z(self, initValue)

    def get_radii_x_y_z(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.EllipsoidJoint_get_radii_x_y_z(self, *args)

    def upd_radii_x_y_z(self, *args) -> "SimTK::Vec3 &":
        return _simulation.EllipsoidJoint_upd_radii_x_y_z(self, *args)

    def set_radii_x_y_z(self, *args) -> "void":
        return _simulation.EllipsoidJoint_set_radii_x_y_z(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience Joint like Constructor

        |

        *Overload 2:*
        Deprecated Joint Constructor
        """
        _simulation.EllipsoidJoint_swiginit(self, _simulation.new_EllipsoidJoint(*args))

    def setEllipsoidRadii(self, radii: "Vec3") -> "void":
        return _simulation.EllipsoidJoint_setEllipsoidRadii(self, radii)

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.EllipsoidJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.EllipsoidJoint_updCoordinate(self, *args)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.EllipsoidJoint_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_EllipsoidJoint

# Register EllipsoidJoint in _simulation:
_simulation.EllipsoidJoint_swigregister(EllipsoidJoint)

def EllipsoidJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::EllipsoidJoint *":
    return _simulation.EllipsoidJoint_safeDownCast(obj)

def EllipsoidJoint_getClassName() -> "std::string const &":
    return _simulation.EllipsoidJoint_getClassName()

class BallJoint(Joint):
    r"""
    A class implementing a Ball joint. The underlying implementation in Simbody is
    SimTK::MobilizedBody::Ball. The Ball joint implements a fixed 1-2-3 (X-Y-Z)
    body-fixed Euler sequence, without translations, for generalized coordinate
    calculation. Ball joint uses quaternions in calculation and are therefore
    singularity-free (unlike GimbalJoint). Generalized speeds are equal to the
    computed angular velocities (:math:`\vec{u} = \vec{\omega}`), not a differentiation
    of position (:math:`\vec{u} \neq \dot{\vec{q}}`).

    Image: ballJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BallJoint *":
        return _simulation.BallJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BallJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BallJoint_getClassName()

    def clone(self) -> "OpenSim::BallJoint *":
        return _simulation.BallJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BallJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.BallJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.BallJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.BallJoint_Coord_Rotation3Z
    r""" 2"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.BallJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.BallJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.BallJoint_swiginit(self, _simulation.new_BallJoint(*args))
    __swig_destroy__ = _simulation.delete_BallJoint

# Register BallJoint in _simulation:
_simulation.BallJoint_swigregister(BallJoint)

def BallJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BallJoint *":
    return _simulation.BallJoint_safeDownCast(obj)

def BallJoint_getClassName() -> "std::string const &":
    return _simulation.BallJoint_getClassName()

class PinJoint(Joint):
    r"""
    A Class implementing a Pin joint. The underlying implementation in Simbody is a
    SimTK::MobilizedBody::Pin. Pin provides one DOF about the common Z-axis of the
    joint (not body) frames in the parent and child body. If you want rotation about
    a different direction, rotate the joint and body frames such that the z axes
    are in the desired direction.

    Image: pinJoint.gif

     Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PinJoint *":
        return _simulation.PinJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PinJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PinJoint_getClassName()

    def clone(self) -> "OpenSim::PinJoint *":
        return _simulation.PinJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PinJoint_getConcreteClassName(self)
    Coord_RotationZ = _simulation.PinJoint_Coord_RotationZ
    r""" 0"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PinJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PinJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.PinJoint_swiginit(self, _simulation.new_PinJoint(*args))
    __swig_destroy__ = _simulation.delete_PinJoint

# Register PinJoint in _simulation:
_simulation.PinJoint_swigregister(PinJoint)

def PinJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PinJoint *":
    return _simulation.PinJoint_safeDownCast(obj)

def PinJoint_getClassName() -> "std::string const &":
    return _simulation.PinJoint_getClassName()

class SliderJoint(Joint):
    r"""
    A class implementing a Slider joint. The underlying implementation in Simbody
    is a SimTK::MobilizedBody::Slider. The Slider provides a single coordinate
    along the common X-axis of the parent and child joint frames.

    Image: sliderJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SliderJoint *":
        return _simulation.SliderJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SliderJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SliderJoint_getClassName()

    def clone(self) -> "OpenSim::SliderJoint *":
        return _simulation.SliderJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SliderJoint_getConcreteClassName(self)
    Coord_TranslationX = _simulation.SliderJoint_Coord_TranslationX
    r""" 0"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.SliderJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to the Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.SliderJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.SliderJoint_swiginit(self, _simulation.new_SliderJoint(*args))
    __swig_destroy__ = _simulation.delete_SliderJoint

# Register SliderJoint in _simulation:
_simulation.SliderJoint_swigregister(SliderJoint)

def SliderJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SliderJoint *":
    return _simulation.SliderJoint_safeDownCast(obj)

def SliderJoint_getClassName() -> "std::string const &":
    return _simulation.SliderJoint_getClassName()

class WeldJoint(Joint):
    r"""
    A class implementing a Weld joint. The underlying implementation in Simbody is
    a SimTK::MobilizedBody::Weld. There is no relative motion of bodies joined by
    a weld. Weld joints are often used to create composite bodies from
    smaller simpler bodies. You can also get the reaction force at the weld in the
    usual manner.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WeldJoint *":
        return _simulation.WeldJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WeldJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WeldJoint_getClassName()

    def clone(self) -> "OpenSim::WeldJoint *":
        return _simulation.WeldJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WeldJoint_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.WeldJoint_swiginit(self, _simulation.new_WeldJoint(*args))
    __swig_destroy__ = _simulation.delete_WeldJoint

# Register WeldJoint in _simulation:
_simulation.WeldJoint_swigregister(WeldJoint)

def WeldJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WeldJoint *":
    return _simulation.WeldJoint_safeDownCast(obj)

def WeldJoint_getClassName() -> "std::string const &":
    return _simulation.WeldJoint_getClassName()

class GimbalJoint(Joint):
    r"""
    A class implementing a Gimbal joint. The underlying implementation Simbody is a
    SimTK::MobilizedBody::Gimbal. The opensim Gimbal joint implementation uses a
     X-Y-Z body fixed Euler sequence for generalized coordinates calculation.
    Gimbal joints have a singularity when Y is near :math:`\frac{\pi}{2}`.
    Generalized speeds are equal to the Euler angle derivatives  (:math:`\vec{u} = \dot{\vec{q}}`)

    Image: gimbalJoint.gif

    Author: Tim Dorn
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::GimbalJoint *":
        return _simulation.GimbalJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.GimbalJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.GimbalJoint_getClassName()

    def clone(self) -> "OpenSim::GimbalJoint *":
        return _simulation.GimbalJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.GimbalJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.GimbalJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.GimbalJoint_Coord_Rotation2Y
    r""" 1"""
    Coord_Rotation3Z = _simulation.GimbalJoint_Coord_Rotation3Z
    r""" 2"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.GimbalJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.GimbalJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.GimbalJoint_swiginit(self, _simulation.new_GimbalJoint(*args))
    __swig_destroy__ = _simulation.delete_GimbalJoint

# Register GimbalJoint in _simulation:
_simulation.GimbalJoint_swigregister(GimbalJoint)

def GimbalJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::GimbalJoint *":
    return _simulation.GimbalJoint_safeDownCast(obj)

def GimbalJoint_getClassName() -> "std::string const &":
    return _simulation.GimbalJoint_getClassName()

class UniversalJoint(Joint):
    r"""
    A class implementing a Universal joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Universal.
    Universal provides two DoF: rotation about the x axis of the joint frames,
    followed by a rotation about the new y axis. The joint is badly behaved when the
    second rotation is near 90 degrees.

    Image: universalJoint.gif

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::UniversalJoint *":
        return _simulation.UniversalJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.UniversalJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.UniversalJoint_getClassName()

    def clone(self) -> "OpenSim::UniversalJoint *":
        return _simulation.UniversalJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.UniversalJoint_getConcreteClassName(self)
    Coord_Rotation1X = _simulation.UniversalJoint_Coord_Rotation1X
    r""" 0"""
    Coord_Rotation2Y = _simulation.UniversalJoint_Coord_Rotation2Y
    r""" 1"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.UniversalJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.UniversalJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.UniversalJoint_swiginit(self, _simulation.new_UniversalJoint(*args))
    __swig_destroy__ = _simulation.delete_UniversalJoint

# Register UniversalJoint in _simulation:
_simulation.UniversalJoint_swigregister(UniversalJoint)

def UniversalJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::UniversalJoint *":
    return _simulation.UniversalJoint_safeDownCast(obj)

def UniversalJoint_getClassName() -> "std::string const &":
    return _simulation.UniversalJoint_getClassName()

class PlanarJoint(Joint):
    r"""
    A class implementing a Planar joint. The underlying implementation
    in Simbody is a SimTK::MobilizedBody::Planar. A Planar joint provides three
    ordered mobilities; rotation about Z and translation in X then Y.

    Image: planarJoint.gif

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PlanarJoint *":
        return _simulation.PlanarJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PlanarJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PlanarJoint_getClassName()

    def clone(self) -> "OpenSim::PlanarJoint *":
        return _simulation.PlanarJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PlanarJoint_getConcreteClassName(self)
    Coord_RotationZ = _simulation.PlanarJoint_Coord_RotationZ
    r""" 0"""
    Coord_TranslationX = _simulation.PlanarJoint_Coord_TranslationX
    r""" 1"""
    Coord_TranslationY = _simulation.PlanarJoint_Coord_TranslationY
    r""" 2"""

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*
        Get a const reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PlanarJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
        Convenience method to get a writable reference to the Coordinate
               associated with a single-degree-of-freedom Joint. If the Joint has more
               than one Coordinate, you must use upd_coordinates() or provide the
               appropriate argument to the updCoordinate() method defined in the
               derived class.

        |

        *Overload 2:*
        Get a writable reference to a Coordinate associated with this Joint.
               See also: Coord
        """
        return _simulation.PlanarJoint_updCoordinate(self, *args)

    def __init__(self, *args):
        _simulation.PlanarJoint_swiginit(self, _simulation.new_PlanarJoint(*args))
    __swig_destroy__ = _simulation.delete_PlanarJoint

# Register PlanarJoint in _simulation:
_simulation.PlanarJoint_swigregister(PlanarJoint)

def PlanarJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PlanarJoint *":
    return _simulation.PlanarJoint_safeDownCast(obj)

def PlanarJoint_getClassName() -> "std::string const &":
    return _simulation.PlanarJoint_getClassName()

class ScapulothoracicJoint(Joint):
    r"""
    A class implementing a 4-DOF ScapulothoracicJoint.

    Motion of the scapula is described by an ellipsoid surface fixed to the
    thorax upon which the joint frame of scapul rides. The DOFs are:

    abduction/adduction
        Motion on the surface. described by latitude and longitudinal angles.

    elevation/depression
        Motion on the surface. described by latitude and longitudinal angles.

    upward rotation
        Rotation about the normal to the ellipsoid surface

    winging
        rotation about and axis fixed to the scapula frame. Defaults to
        scapula-y

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScapulothoracicJoint *":
        return _simulation.ScapulothoracicJoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ScapulothoracicJoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ScapulothoracicJoint_getClassName()

    def clone(self) -> "OpenSim::ScapulothoracicJoint *":
        return _simulation.ScapulothoracicJoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ScapulothoracicJoint_getConcreteClassName(self)

    def copyProperty_thoracic_ellipsoid_radii_x_y_z(self, source: "ScapulothoracicJoint") -> "void":
        return _simulation.ScapulothoracicJoint_copyProperty_thoracic_ellipsoid_radii_x_y_z(self, source)

    def append_thoracic_ellipsoid_radii_x_y_z(self, value: "Vec3") -> "int":
        return _simulation.ScapulothoracicJoint_append_thoracic_ellipsoid_radii_x_y_z(self, value)

    def constructProperty_thoracic_ellipsoid_radii_x_y_z(self, initValue: "Vec3") -> "void":
        return _simulation.ScapulothoracicJoint_constructProperty_thoracic_ellipsoid_radii_x_y_z(self, initValue)

    def get_thoracic_ellipsoid_radii_x_y_z(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ScapulothoracicJoint_get_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def upd_thoracic_ellipsoid_radii_x_y_z(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ScapulothoracicJoint_upd_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def set_thoracic_ellipsoid_radii_x_y_z(self, *args) -> "void":
        return _simulation.ScapulothoracicJoint_set_thoracic_ellipsoid_radii_x_y_z(self, *args)

    def copyProperty_scapula_winging_axis_origin(self, source: "ScapulothoracicJoint") -> "void":
        return _simulation.ScapulothoracicJoint_copyProperty_scapula_winging_axis_origin(self, source)

    def get_scapula_winging_axis_origin(self, i: "int") -> "double const &":
        return _simulation.ScapulothoracicJoint_get_scapula_winging_axis_origin(self, i)

    def upd_scapula_winging_axis_origin(self, i: "int") -> "double &":
        return _simulation.ScapulothoracicJoint_upd_scapula_winging_axis_origin(self, i)

    def set_scapula_winging_axis_origin(self, i: "int", value: "double const &") -> "void":
        return _simulation.ScapulothoracicJoint_set_scapula_winging_axis_origin(self, i, value)

    def append_scapula_winging_axis_origin(self, value: "double const &") -> "int":
        return _simulation.ScapulothoracicJoint_append_scapula_winging_axis_origin(self, value)

    def copyProperty_scapula_winging_axis_direction(self, source: "ScapulothoracicJoint") -> "void":
        return _simulation.ScapulothoracicJoint_copyProperty_scapula_winging_axis_direction(self, source)

    def append_scapula_winging_axis_direction(self, value: "double const &") -> "int":
        return _simulation.ScapulothoracicJoint_append_scapula_winging_axis_direction(self, value)

    def constructProperty_scapula_winging_axis_direction(self, initValue: "double const &") -> "void":
        return _simulation.ScapulothoracicJoint_constructProperty_scapula_winging_axis_direction(self, initValue)

    def get_scapula_winging_axis_direction(self, *args) -> "double const &":
        return _simulation.ScapulothoracicJoint_get_scapula_winging_axis_direction(self, *args)

    def upd_scapula_winging_axis_direction(self, *args) -> "double &":
        return _simulation.ScapulothoracicJoint_upd_scapula_winging_axis_direction(self, *args)

    def set_scapula_winging_axis_direction(self, *args) -> "void":
        return _simulation.ScapulothoracicJoint_set_scapula_winging_axis_direction(self, *args)
    Coord_Abduction = _simulation.ScapulothoracicJoint_Coord_Abduction
    Coord_Elevation = _simulation.ScapulothoracicJoint_Coord_Elevation
    Coord_UpwardRotation = _simulation.ScapulothoracicJoint_Coord_UpwardRotation
    Coord_Winging = _simulation.ScapulothoracicJoint_Coord_Winging

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default contructor

        |

        *Overload 2:*
        Convenience Joint-like Constructor

        |

        *Overload 3:*
        Convenience constructor
        """
        _simulation.ScapulothoracicJoint_swiginit(self, _simulation.new_ScapulothoracicJoint(*args))

    def getCoordinate(self, *args) -> "OpenSim::Coordinate const &":
        r"""
        *Overload 1:*
         Convenience method to get a const reference to the Coordinate associated
                with a single-degree-of-freedom Joint. If the Joint has more than one
                Coordinate, you must use get_coordinates() or provide the appropriate
                argument to the getCoordinate() method defined in the derived class.

        |

        *Overload 2:*

        Get a const reference to a Coordinate associated with this Joint.
        See also: Coord
        """
        return _simulation.ScapulothoracicJoint_getCoordinate(self, *args)

    def updCoordinate(self, *args) -> "OpenSim::Coordinate &":
        r"""
        *Overload 1:*
         Convenience method to get a writable reference to the Coordinate
                associated with a single-degree-of-freedom Joint. If the Joint has more
                than one Coordinate, you must use upd_coordinates() or provide the
                appropriate argument to the updCoordinate() method defined in the
                derived class.

        |

        *Overload 2:*

        Get a writable reference to a Coordinate associated with this Joint.
        See also: Coord
        """
        return _simulation.ScapulothoracicJoint_updCoordinate(self, *args)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.ScapulothoracicJoint_extendScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_ScapulothoracicJoint

# Register ScapulothoracicJoint in _simulation:
_simulation.ScapulothoracicJoint_swigregister(ScapulothoracicJoint)

def ScapulothoracicJoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScapulothoracicJoint *":
    return _simulation.ScapulothoracicJoint_safeDownCast(obj)

def ScapulothoracicJoint_getClassName() -> "std::string const &":
    return _simulation.ScapulothoracicJoint_getClassName()

class WeldConstraint(TwoFrameLinkerConstraint):
    r"""
    A class implementing a Weld Constraint. A WeldConstraint eliminates up to
    6 dofs of a model by fixing two PhysicalFrames together at their origins
    aligning their axes.  PhysicalFrames are generally Ground, Body, or
    PhysicalOffsetFrame attached to a PhysicalFrame.
    The underlying Constraint in Simbody is a SimTK::Constraint::Weld.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WeldConstraint *":
        return _simulation.WeldConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WeldConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WeldConstraint_getClassName()

    def clone(self) -> "OpenSim::WeldConstraint *":
        return _simulation.WeldConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WeldConstraint_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default Constructor. Create an unnamed WeldConstraint with frame
               sockets that are unsatisfied.

        |

        *Overload 2:*
        Convenience Constructor.
           Create a WeldConstraint between two PhysicalFrames, frame1 and frame2.
           :type name: string, in
           :param name:         the name of this WeldConstraint
           :type frame1Name: string, in
           :param frame1Name:   the name of the first PhysicalFrame being constrained
           :type frame2Name: string, in
           :param frame2Name:   the name of the second PhysicalFrame being constrained

        |

        *Overload 3:*
        Backwards compatible Convenience Constructor
           Construct a WeldConstraint where the weld frames are specified in terms of their
           location and orientation in their respective PhysicalFrames.

           :type name: string, in
           :param name:             the name of this WeldConstraint
           :type frame1: :py:class:`PhysicalFrame`, in
           :param frame1:           the first PhysicalFrame that the weld constrains
           :type locationInFrame1: :py:class:`Vec3`, in
           :param locationInFrame1:    Vec3 of the location of the weld in the first frame
           :type orientationInFrame1: :py:class:`Vec3`, in
           :param orientationInFrame1: Vec3 of the XYZ body-fixed Euler angles of the
                                              weld frame orientation in frame 1.
           :type frame2: :py:class:`PhysicalFrame`, in
           :param frame2:               the second PhysicalFrame that the weld constrains
           :type locationInFrame2: :py:class:`Vec3`, in
           :param locationInFrame2:    Vec3 of the location of the weld in the second frame
           :type orientationInFrame2: :py:class:`Vec3`, in
           :param orientationInFrame2: Vec3 of the XYZ body-fixed Euler angles
                                              of the weld frame orientation in frame2.

        |

        *Overload 4:*
        Convenience Constructor
           Construct a WeldConstraint where the weld frames are specified in terms of their
           transforms in their respective PhysicalFrames.

           :type name: string, in
           :param name:         the name of this WeldConstraint
           :type frame1: :py:class:`PhysicalFrame`, in
           :param frame1:       the first PhysicalFrame that the weld constrains
           :type transformInFrame1: :py:class:`Transform`, in
           :param transformInFrame1:    Transform of the weld in the first frame
           :type frame2: :py:class:`PhysicalFrame`, in
           :param frame2:       the second PhysicalFrame that the weld constrains
           :type transformInFrame2: :py:class:`Transform`, in
           :param transformInFrame2:    Transform of the weld in the second frame
        """
        _simulation.WeldConstraint_swiginit(self, _simulation.new_WeldConstraint(*args))
    __swig_destroy__ = _simulation.delete_WeldConstraint

    def setContactPointForInducedAccelerations(self, s: "State", point: "Vec3") -> "void":
        r"""
        Advanced Method for computing induced accelerations given the constraint
               applied at the point of contact specified.
        """
        return _simulation.WeldConstraint_setContactPointForInducedAccelerations(self, s, point)

# Register WeldConstraint in _simulation:
_simulation.WeldConstraint_swigregister(WeldConstraint)

def WeldConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WeldConstraint *":
    return _simulation.WeldConstraint_safeDownCast(obj)

def WeldConstraint_getClassName() -> "std::string const &":
    return _simulation.WeldConstraint_getClassName()

class PointConstraint(Constraint):
    r"""
    A class implementing a Point Constraint. The constraint keeps two points,
    one on each of two separate PhysicalFrame%s, coincident and free to rotate
    about that point.

    The underlying SimTK::Constraint in Simbody is a SimTK::Constraint::Point.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointConstraint *":
        return _simulation.PointConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PointConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PointConstraint_getClassName()

    def clone(self) -> "OpenSim::PointConstraint *":
        return _simulation.PointConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PointConstraint_getConcreteClassName(self)

    def copyProperty_location_body_1(self, source: "PointConstraint") -> "void":
        return _simulation.PointConstraint_copyProperty_location_body_1(self, source)

    def append_location_body_1(self, value: "Vec3") -> "int":
        return _simulation.PointConstraint_append_location_body_1(self, value)

    def constructProperty_location_body_1(self, initValue: "Vec3") -> "void":
        return _simulation.PointConstraint_constructProperty_location_body_1(self, initValue)

    def get_location_body_1(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointConstraint_get_location_body_1(self, *args)

    def upd_location_body_1(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointConstraint_upd_location_body_1(self, *args)

    def set_location_body_1(self, *args) -> "void":
        return _simulation.PointConstraint_set_location_body_1(self, *args)

    def copyProperty_location_body_2(self, source: "PointConstraint") -> "void":
        return _simulation.PointConstraint_copyProperty_location_body_2(self, source)

    def append_location_body_2(self, value: "Vec3") -> "int":
        return _simulation.PointConstraint_append_location_body_2(self, value)

    def constructProperty_location_body_2(self, initValue: "Vec3") -> "void":
        return _simulation.PointConstraint_constructProperty_location_body_2(self, initValue)

    def get_location_body_2(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointConstraint_get_location_body_2(self, *args)

    def upd_location_body_2(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointConstraint_upd_location_body_2(self, *args)

    def set_location_body_2(self, *args) -> "void":
        return _simulation.PointConstraint_set_location_body_2(self, *args)
    PropertyIndex_socket_body_1 = property(_simulation.PointConstraint_PropertyIndex_socket_body_1_get, _simulation.PointConstraint_PropertyIndex_socket_body_1_set)

    def connectSocket_body_1(self, object: "OpenSimObject") -> "void":
        return _simulation.PointConstraint_connectSocket_body_1(self, object)
    PropertyIndex_socket_body_2 = property(_simulation.PointConstraint_PropertyIndex_socket_body_2_get, _simulation.PointConstraint_PropertyIndex_socket_body_2_set)

    def connectSocket_body_2(self, object: "OpenSimObject") -> "void":
        return _simulation.PointConstraint_connectSocket_body_2(self, object)

    def __init__(self, *args):
        r"""
        Convenience Constructor.

        :type body1: :py:class:`PhysicalFrame`
        :param body1:          first PhysicalFrame connected by the constraint
        :type locationBody1: :py:class:`Vec3`
        :param locationBody1:  point fixed on body1 where the constraint is applied
        :type body2: :py:class:`PhysicalFrame`
        :param body2:          second PhysicalFrame connected by the constraint
        :type locationBody2: :py:class:`Vec3`
        :param locationBody2:: point fixed on body2 where the constraint is applied
        """
        _simulation.PointConstraint_swiginit(self, _simulation.new_PointConstraint(*args))
    __swig_destroy__ = _simulation.delete_PointConstraint

    def setBody1ByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.PointConstraint_setBody1ByName(self, aBodyName)

    def setBody1PointLocation(self, location: "Vec3") -> "void":
        return _simulation.PointConstraint_setBody1PointLocation(self, location)

    def setBody2ByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.PointConstraint_setBody2ByName(self, aBodyName)

    def setBody2PointLocation(self, location: "Vec3") -> "void":
        return _simulation.PointConstraint_setBody2PointLocation(self, location)

    def setContactPointForInducedAccelerations(self, s: "State", point: "Vec3") -> "void":
        r"""
         Method to set point location of contact during an induced acceleration
        analysis
        """
        return _simulation.PointConstraint_setContactPointForInducedAccelerations(self, s, point)

# Register PointConstraint in _simulation:
_simulation.PointConstraint_swigregister(PointConstraint)

def PointConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointConstraint *":
    return _simulation.PointConstraint_safeDownCast(obj)

def PointConstraint_getClassName() -> "std::string const &":
    return _simulation.PointConstraint_getClassName()

class ConstantDistanceConstraint(Constraint):
    r"""
    A class implementing a constraint that maintains a constant distance between
    between two points on separate PhysicalFrames.
    The underlying SimTK::Constraint in Simbody is a SimTK::Constraint::Rod.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConstantDistanceConstraint *":
        return _simulation.ConstantDistanceConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ConstantDistanceConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ConstantDistanceConstraint_getClassName()

    def clone(self) -> "OpenSim::ConstantDistanceConstraint *":
        return _simulation.ConstantDistanceConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ConstantDistanceConstraint_getConcreteClassName(self)

    def copyProperty_location_body_1(self, source: "ConstantDistanceConstraint") -> "void":
        return _simulation.ConstantDistanceConstraint_copyProperty_location_body_1(self, source)

    def append_location_body_1(self, value: "Vec3") -> "int":
        return _simulation.ConstantDistanceConstraint_append_location_body_1(self, value)

    def constructProperty_location_body_1(self, initValue: "Vec3") -> "void":
        return _simulation.ConstantDistanceConstraint_constructProperty_location_body_1(self, initValue)

    def get_location_body_1(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ConstantDistanceConstraint_get_location_body_1(self, *args)

    def upd_location_body_1(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ConstantDistanceConstraint_upd_location_body_1(self, *args)

    def set_location_body_1(self, *args) -> "void":
        return _simulation.ConstantDistanceConstraint_set_location_body_1(self, *args)

    def copyProperty_location_body_2(self, source: "ConstantDistanceConstraint") -> "void":
        return _simulation.ConstantDistanceConstraint_copyProperty_location_body_2(self, source)

    def append_location_body_2(self, value: "Vec3") -> "int":
        return _simulation.ConstantDistanceConstraint_append_location_body_2(self, value)

    def constructProperty_location_body_2(self, initValue: "Vec3") -> "void":
        return _simulation.ConstantDistanceConstraint_constructProperty_location_body_2(self, initValue)

    def get_location_body_2(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ConstantDistanceConstraint_get_location_body_2(self, *args)

    def upd_location_body_2(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ConstantDistanceConstraint_upd_location_body_2(self, *args)

    def set_location_body_2(self, *args) -> "void":
        return _simulation.ConstantDistanceConstraint_set_location_body_2(self, *args)

    def copyProperty_constant_distance(self, source: "ConstantDistanceConstraint") -> "void":
        return _simulation.ConstantDistanceConstraint_copyProperty_constant_distance(self, source)

    def append_constant_distance(self, value: "double const &") -> "int":
        return _simulation.ConstantDistanceConstraint_append_constant_distance(self, value)

    def constructProperty_constant_distance(self, initValue: "double const &") -> "void":
        return _simulation.ConstantDistanceConstraint_constructProperty_constant_distance(self, initValue)

    def get_constant_distance(self, *args) -> "double const &":
        return _simulation.ConstantDistanceConstraint_get_constant_distance(self, *args)

    def upd_constant_distance(self, *args) -> "double &":
        return _simulation.ConstantDistanceConstraint_upd_constant_distance(self, *args)

    def set_constant_distance(self, *args) -> "void":
        return _simulation.ConstantDistanceConstraint_set_constant_distance(self, *args)
    PropertyIndex_socket_body_1 = property(_simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_1_get, _simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_1_set)

    def connectSocket_body_1(self, object: "OpenSimObject") -> "void":
        return _simulation.ConstantDistanceConstraint_connectSocket_body_1(self, object)
    PropertyIndex_socket_body_2 = property(_simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_2_get, _simulation.ConstantDistanceConstraint_PropertyIndex_socket_body_2_set)

    def connectSocket_body_2(self, object: "OpenSimObject") -> "void":
        return _simulation.ConstantDistanceConstraint_connectSocket_body_2(self, object)

    def __init__(self, *args):
        r"""
        Convenience Constructor.

        :type body1: :py:class:`PhysicalFrame`
        :param body1:          first PhysicalFrame connected by the constraint
        :type locationBody1: :py:class:`Vec3`
        :param locationBody1:  point fixed on body1 where the constraint is applied
        :type body2: :py:class:`PhysicalFrame`
        :param body2:          second PhysicalFrame connected by the constraint
        :type locationBody2: :py:class:`Vec3`
        :param locationBody2:: point fixed on body2 where the constraint is applied
        :type distance: float
        :param distance:       nonzero fixed distance between the points
        """
        _simulation.ConstantDistanceConstraint_swiginit(self, _simulation.new_ConstantDistanceConstraint(*args))
    __swig_destroy__ = _simulation.delete_ConstantDistanceConstraint

    def getBody1(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        The Physical frames that the constraint is connected to are
               accessible after connectToModel() has been called on the Model.
        """
        return _simulation.ConstantDistanceConstraint_getBody1(self)

    def getBody2(self) -> "OpenSim::PhysicalFrame const &":
        return _simulation.ConstantDistanceConstraint_getBody2(self)

    def setBody1ByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.ConstantDistanceConstraint_setBody1ByName(self, aBodyName)

    def setBody1PointLocation(self, location: "Vec3") -> "void":
        return _simulation.ConstantDistanceConstraint_setBody1PointLocation(self, location)

    def setBody2ByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.ConstantDistanceConstraint_setBody2ByName(self, aBodyName)

    def setBody2PointLocation(self, location: "Vec3") -> "void":
        return _simulation.ConstantDistanceConstraint_setBody2PointLocation(self, location)

    def setConstantDistance(self, distance: "double") -> "void":
        return _simulation.ConstantDistanceConstraint_setConstantDistance(self, distance)

# Register ConstantDistanceConstraint in _simulation:
_simulation.ConstantDistanceConstraint_swigregister(ConstantDistanceConstraint)

def ConstantDistanceConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConstantDistanceConstraint *":
    return _simulation.ConstantDistanceConstraint_safeDownCast(obj)

def ConstantDistanceConstraint_getClassName() -> "std::string const &":
    return _simulation.ConstantDistanceConstraint_getClassName()

class CoordinateCouplerConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateCouplerConstraint *":
        return _simulation.CoordinateCouplerConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.CoordinateCouplerConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.CoordinateCouplerConstraint_getClassName()

    def clone(self) -> "OpenSim::CoordinateCouplerConstraint *":
        return _simulation.CoordinateCouplerConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.CoordinateCouplerConstraint_getConcreteClassName(self)

    def __init__(self):
        _simulation.CoordinateCouplerConstraint_swiginit(self, _simulation.new_CoordinateCouplerConstraint())
    __swig_destroy__ = _simulation.delete_CoordinateCouplerConstraint

    def setIndependentCoordinateNames(self, aCoordNames: "ArrayStr") -> "void":
        r"""
        Access the list of names of the right hand side (independent) coordinates.
               Note the constraint function, must be able to handle multiple
               coordinate values if more than one coordinate name is provided.
        """
        return _simulation.CoordinateCouplerConstraint_setIndependentCoordinateNames(self, aCoordNames)

    def getIndependentCoordinateNames(self) -> "OpenSim::Array< std::string > const":
        return _simulation.CoordinateCouplerConstraint_getIndependentCoordinateNames(self)

    def setDependentCoordinateName(self, aCoordName: "std::string const &") -> "void":
        return _simulation.CoordinateCouplerConstraint_setDependentCoordinateName(self, aCoordName)

    def getDependentCoordinateName(self) -> "std::string const &":
        return _simulation.CoordinateCouplerConstraint_getDependentCoordinateName(self)

    def getFunction(self) -> "OpenSim::Function const &":
        return _simulation.CoordinateCouplerConstraint_getFunction(self)

    def setFunction(self, *args) -> "void":
        return _simulation.CoordinateCouplerConstraint_setFunction(self, *args)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the CoordinateCouplerConstraint using the scale factors assigned
               to the Body associated with the CoordinateCouplerConstraint's dependent
               coordinate. Scaling is performed only if the dependent coordinate is a
               translation.
        """
        return _simulation.CoordinateCouplerConstraint_extendScale(self, s, scaleSet)

# Register CoordinateCouplerConstraint in _simulation:
_simulation.CoordinateCouplerConstraint_swigregister(CoordinateCouplerConstraint)

def CoordinateCouplerConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateCouplerConstraint *":
    return _simulation.CoordinateCouplerConstraint_safeDownCast(obj)

def CoordinateCouplerConstraint_getClassName() -> "std::string const &":
    return _simulation.CoordinateCouplerConstraint_getClassName()

class PointOnLineConstraint(Constraint):
    r"""
    A class implementing a Point On Line Constraint.  The underlying Constraint
    in Simbody is a SimTK::Constraint::PointOnLine.

    Author: Samuel Hamner
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointOnLineConstraint *":
        return _simulation.PointOnLineConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PointOnLineConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PointOnLineConstraint_getClassName()

    def clone(self) -> "OpenSim::PointOnLineConstraint *":
        return _simulation.PointOnLineConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PointOnLineConstraint_getConcreteClassName(self)

    def copyProperty_line_direction_vec(self, source: "PointOnLineConstraint") -> "void":
        return _simulation.PointOnLineConstraint_copyProperty_line_direction_vec(self, source)

    def append_line_direction_vec(self, value: "Vec3") -> "int":
        return _simulation.PointOnLineConstraint_append_line_direction_vec(self, value)

    def constructProperty_line_direction_vec(self, initValue: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_constructProperty_line_direction_vec(self, initValue)

    def get_line_direction_vec(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointOnLineConstraint_get_line_direction_vec(self, *args)

    def upd_line_direction_vec(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointOnLineConstraint_upd_line_direction_vec(self, *args)

    def set_line_direction_vec(self, *args) -> "void":
        return _simulation.PointOnLineConstraint_set_line_direction_vec(self, *args)

    def copyProperty_point_on_line(self, source: "PointOnLineConstraint") -> "void":
        return _simulation.PointOnLineConstraint_copyProperty_point_on_line(self, source)

    def append_point_on_line(self, value: "Vec3") -> "int":
        return _simulation.PointOnLineConstraint_append_point_on_line(self, value)

    def constructProperty_point_on_line(self, initValue: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_constructProperty_point_on_line(self, initValue)

    def get_point_on_line(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointOnLineConstraint_get_point_on_line(self, *args)

    def upd_point_on_line(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointOnLineConstraint_upd_point_on_line(self, *args)

    def set_point_on_line(self, *args) -> "void":
        return _simulation.PointOnLineConstraint_set_point_on_line(self, *args)

    def copyProperty_point_on_follower(self, source: "PointOnLineConstraint") -> "void":
        return _simulation.PointOnLineConstraint_copyProperty_point_on_follower(self, source)

    def append_point_on_follower(self, value: "Vec3") -> "int":
        return _simulation.PointOnLineConstraint_append_point_on_follower(self, value)

    def constructProperty_point_on_follower(self, initValue: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_constructProperty_point_on_follower(self, initValue)

    def get_point_on_follower(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointOnLineConstraint_get_point_on_follower(self, *args)

    def upd_point_on_follower(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointOnLineConstraint_upd_point_on_follower(self, *args)

    def set_point_on_follower(self, *args) -> "void":
        return _simulation.PointOnLineConstraint_set_point_on_follower(self, *args)
    PropertyIndex_socket_line_body = property(_simulation.PointOnLineConstraint_PropertyIndex_socket_line_body_get, _simulation.PointOnLineConstraint_PropertyIndex_socket_line_body_set)

    def connectSocket_line_body(self, object: "OpenSimObject") -> "void":
        return _simulation.PointOnLineConstraint_connectSocket_line_body(self, object)
    PropertyIndex_socket_follower_body = property(_simulation.PointOnLineConstraint_PropertyIndex_socket_follower_body_get, _simulation.PointOnLineConstraint_PropertyIndex_socket_follower_body_set)

    def connectSocket_follower_body(self, object: "OpenSimObject") -> "void":
        return _simulation.PointOnLineConstraint_connectSocket_follower_body(self, object)

    def __init__(self, *args):
        _simulation.PointOnLineConstraint_swiginit(self, _simulation.new_PointOnLineConstraint(*args))
    __swig_destroy__ = _simulation.delete_PointOnLineConstraint

    def setLineBodyByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.PointOnLineConstraint_setLineBodyByName(self, aBodyName)

    def setFollowerBodyByName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.PointOnLineConstraint_setFollowerBodyByName(self, aBodyName)

    def setLineDirection(self, direction: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_setLineDirection(self, direction)

    def setPointOnLine(self, point: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_setPointOnLine(self, point)

    def setPointOnFollower(self, point: "Vec3") -> "void":
        return _simulation.PointOnLineConstraint_setPointOnFollower(self, point)

# Register PointOnLineConstraint in _simulation:
_simulation.PointOnLineConstraint_swigregister(PointOnLineConstraint)

def PointOnLineConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointOnLineConstraint *":
    return _simulation.PointOnLineConstraint_safeDownCast(obj)

def PointOnLineConstraint_getClassName() -> "std::string const &":
    return _simulation.PointOnLineConstraint_getClassName()

class Controller(ModelComponent):
    r"""
    Controller is an abstract ModelComponent that defines the interface for
    an OpenSim Controller. A controller computes and sets the values of the
    controls for the actuators under its control.
    The defining method of a Controller is its computeControls() method.
    See also: computeControls()

    Notes: Controllers currently do not use the Socket mechanism to locate
    and connect to the Actuators that Controllers depend on. As a result,
    for now, Controllers do not support controlling multiple actuators with
    the same name.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Controller *":
        return _simulation.Controller_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Controller_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Controller_getClassName()

    def clone(self) -> "OpenSim::Controller *":
        return _simulation.Controller_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Controller_getConcreteClassName(self)

    def copyProperty_enabled(self, source: "Controller") -> "void":
        r"""
        Controller is enabled (active) by default.
           NOTE: Prior to OpenSim 4.0, this property was named **isDisabled**.
                 If **isDisabled** is **true**, **enabled** is **false**.
                 If **isDisabled** is **false**, **enabled** is **true**.
        """
        return _simulation.Controller_copyProperty_enabled(self, source)

    def append_enabled(self, value: "bool const &") -> "int":
        return _simulation.Controller_append_enabled(self, value)

    def constructProperty_enabled(self, initValue: "bool const &") -> "void":
        return _simulation.Controller_constructProperty_enabled(self, initValue)

    def get_enabled(self, *args) -> "bool const &":
        return _simulation.Controller_get_enabled(self, *args)

    def upd_enabled(self, *args) -> "bool &":
        return _simulation.Controller_upd_enabled(self, *args)

    def set_enabled(self, *args) -> "void":
        return _simulation.Controller_set_enabled(self, *args)

    def copyProperty_actuator_list(self, source: "Controller") -> "void":
        return _simulation.Controller_copyProperty_actuator_list(self, source)

    def get_actuator_list(self, i: "int") -> "std::string const &":
        return _simulation.Controller_get_actuator_list(self, i)

    def upd_actuator_list(self, i: "int") -> "std::string &":
        return _simulation.Controller_upd_actuator_list(self, i)

    def set_actuator_list(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.Controller_set_actuator_list(self, i, value)

    def append_actuator_list(self, value: "std::string const &") -> "int":
        return _simulation.Controller_append_actuator_list(self, value)

    def constructProperty_actuator_list(self) -> "void":
        return _simulation.Controller_constructProperty_actuator_list(self)

    def isEnabled(self) -> "bool":
        r"""
         Get whether or not this controller is enabled.
        :rtype: boolean
        :return: true when controller is enabled.
        """
        return _simulation.Controller_isEnabled(self)

    def setEnabled(self, enableFlag: "bool") -> "void":
        r"""
         Enable this controller.
        :type enableFlag: boolean
        :param enableFlag: Enable the controller if true.
        """
        return _simulation.Controller_setEnabled(self, enableFlag)

    def setActuators(self, actuators: "SetActuators") -> "void":
        r""" replace the current set of actuators with the provided set"""
        return _simulation.Controller_setActuators(self, actuators)

    def addActuator(self, actuator: "Actuator") -> "void":
        r""" add to the current set of actuators"""
        return _simulation.Controller_addActuator(self, actuator)

    def getActuatorSet(self) -> "OpenSim::Set< OpenSim::Actuator const > const &":
        r""" get a const reference to the current set of const actuators"""
        return _simulation.Controller_getActuatorSet(self)

    def updActuators(self) -> "OpenSim::Set< OpenSim::Actuator const > &":
        r""" get a writable reference to the set of const actuators for this controller"""
        return _simulation.Controller_updActuators(self)

    def computeControls(self, s: "State", controls: "Vector") -> "void":
        r"""
         Compute the control for actuator
         This method defines the behavior for any concrete controller
         and therefore must be implemented by concrete subclasses.

        :type s: :py:class:`State`
        :param s:         system state
        :type controls: :py:class:`Vector`
        :param controls:  writable model controls (all actuators)
        """
        return _simulation.Controller_computeControls(self, s, controls)

    def getNumControls(self) -> "int":
        return _simulation.Controller_getNumControls(self)
    __swig_destroy__ = _simulation.delete_Controller

# Register Controller in _simulation:
_simulation.Controller_swigregister(Controller)

def Controller_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Controller *":
    return _simulation.Controller_safeDownCast(obj)

def Controller_getClassName() -> "std::string const &":
    return _simulation.Controller_getClassName()

class SetControllers(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Controller,OpenSim::ModelComponent > *":
        return _simulation.SetControllers_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetControllers_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetControllers_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Controller,OpenSim::ModelComponent > *":
        return _simulation.SetControllers_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetControllers_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetControllers

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Controller,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetControllers_swiginit(self, _simulation.new_SetControllers(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetControllers_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetControllers_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControllers_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControllers_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Controller`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControllers_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetControllers_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Controller") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Controller`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControllers_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Controller") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Controller`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControllers_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Controller") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Controller`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControllers_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Controller`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControllers_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetControllers_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Controller", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Controller`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetControllers_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Controller &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Controller`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Controller`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControllers_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetControllers_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetControllers_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetControllers_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetControllers_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetControllers_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetControllers_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetControllers_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetControllers_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetControllers_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetControllers in _simulation:
_simulation.SetControllers_swigregister(SetControllers)

def SetControllers_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Controller,OpenSim::ModelComponent > *":
    return _simulation.SetControllers_safeDownCast(obj)

def SetControllers_getClassName() -> "std::string const &":
    return _simulation.SetControllers_getClassName()

class ModelComponentSetControllers(SetControllers):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Controller > *":
        return _simulation.ModelComponentSetControllers_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetControllers_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetControllers_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Controller > *":
        return _simulation.ModelComponentSetControllers_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetControllers_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetControllers_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetControllers_swiginit(self, _simulation.new_ModelComponentSetControllers())
    __swig_destroy__ = _simulation.delete_ModelComponentSetControllers

# Register ModelComponentSetControllers in _simulation:
_simulation.ModelComponentSetControllers_swigregister(ModelComponentSetControllers)

def ModelComponentSetControllers_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Controller > *":
    return _simulation.ModelComponentSetControllers_safeDownCast(obj)

def ModelComponentSetControllers_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetControllers_getClassName()

class ControllerSet(ModelComponentSetControllers):
    r"""
    A class for holding and managing a set of controllers for a model.

    Authors: Jack Middleton, Ajay Seth
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControllerSet *":
        return _simulation.ControllerSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ControllerSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ControllerSet_getClassName()

    def clone(self) -> "OpenSim::ControllerSet *":
        return _simulation.ControllerSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ControllerSet_getConcreteClassName(self)

    def constructStorage(self) -> "void":
        return _simulation.ControllerSet_constructStorage(self)

    def storeControls(self, s: "State", step: "int") -> "void":
        return _simulation.ControllerSet_storeControls(self, s, step)

    def printControlStorage(self, fileName: "std::string const &") -> "void":
        return _simulation.ControllerSet_printControlStorage(self, fileName)

    def getControlTable(self) -> "OpenSim::TimeSeriesTable":
        return _simulation.ControllerSet_getControlTable(self)

    def setActuators(self, actuators: "SetActuators") -> "void":
        return _simulation.ControllerSet_setActuators(self, actuators)

    def setDesiredStates(self, yStore: "Storage") -> "void":
        return _simulation.ControllerSet_setDesiredStates(self, yStore)

    def computeControls(self, s: "State", controls: "Vector") -> "void":
        return _simulation.ControllerSet_computeControls(self, s, controls)

    def printInfo(self) -> "void":
        return _simulation.ControllerSet_printInfo(self)

    def __init__(self, *args):
        _simulation.ControllerSet_swiginit(self, _simulation.new_ControllerSet(*args))
    __swig_destroy__ = _simulation.delete_ControllerSet

# Register ControllerSet in _simulation:
_simulation.ControllerSet_swigregister(ControllerSet)

def ControllerSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControllerSet *":
    return _simulation.ControllerSet_safeDownCast(obj)

def ControllerSet_getClassName() -> "std::string const &":
    return _simulation.ControllerSet_getClassName()

class ExternalLoads(ModelComponentSetExternalForces):
    r"""
    A convenience class for managing ExternaForce(s) to be applied to a model.
    This includes creating instances and manipulating the data source
    of individual ExternalForces so that they satisfy conditions imposed
    by particular Tools. For example, ForwardTool, CMC/RRA, achieve better
    tracking (slower divergence) if the ground reaction forces are applied
    to a point that is expressed in the foot frame according to "ideal"
    kinematics. ExternalLoads provides convenience methods to perform this
    "mapping" which is beyond the scope of an individual ExternalForce, but is
    too much detail to have each Tool implement.

    An individual ExternalForce has a property for its data source name, but
    under the management of ExternalLoads, the data source identified by
    ExternalLoads is used to set the data source on each ExternalForce.
    If multiple data sources are required for different groups of external forces
    then use multiple ExternalLoads.

    Authors: Ajay Seth, Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExternalLoads *":
        return _simulation.ExternalLoads_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ExternalLoads_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ExternalLoads_getClassName()

    def clone(self) -> "OpenSim::ExternalLoads *":
        return _simulation.ExternalLoads_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ExternalLoads_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ExternalLoads_swiginit(self, _simulation.new_ExternalLoads(*args))
    __swig_destroy__ = _simulation.delete_ExternalLoads

    def copyData(self, otherExternalLoads: "ExternalLoads") -> "void":
        return _simulation.ExternalLoads_copyData(self, otherExternalLoads)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        r""" Override of the default implementation to account for versioning."""
        return _simulation.ExternalLoads_updateFromXMLNode(self, aNode, versionNumber)

    def extendConnectToModel(self, aModel: "Model") -> "void":
        return _simulation.ExternalLoads_extendConnectToModel(self, aModel)

    def getDataFileName(self) -> "std::string const &":
        return _simulation.ExternalLoads_getDataFileName(self)

    def setDataFileName(self, aNewFile: "std::string const &") -> "void":
        return _simulation.ExternalLoads_setDataFileName(self, aNewFile)

    def transformPointsExpressedInGroundToAppliedBodies(self, *args) -> "void":
        return _simulation.ExternalLoads_transformPointsExpressedInGroundToAppliedBodies(self, *args)

    def transformPointExpressedInGroundToAppliedBody(self, exForce: "ExternalForce", kinematics: "Storage", startTime: "double", endTime: "double") -> "OpenSim::ExternalForce *":
        return _simulation.ExternalLoads_transformPointExpressedInGroundToAppliedBody(self, exForce, kinematics, startTime, endTime)

    def clearLoadedFromFile(self) -> "void":
        r"""
        ExternalLoads remembers the file it was loaded from, even after being
        copied. This file path is used to find the datafile relative to the
        location of the ExternalLoads file itself. This function can clear
        the memory of the file that the original ExternalLoads came from.
        In general, users should not need to use this function.
        """
        return _simulation.ExternalLoads_clearLoadedFromFile(self)

# Register ExternalLoads in _simulation:
_simulation.ExternalLoads_swigregister(ExternalLoads)

def ExternalLoads_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExternalLoads *":
    return _simulation.ExternalLoads_safeDownCast(obj)

def ExternalLoads_getClassName() -> "std::string const &":
    return _simulation.ExternalLoads_getClassName()

class PrescribedForce(Force):
    r"""
     This applies to a PhysicalFrame a force and/or torque that is specified as a
    function of time. It is defined by three sets of functions, all of which are
    optional:

      - Three functions that specify the (x,y,z) components of a force vector
        to apply (at a given point) as a function of time. If these functions are
        not provided, no force is applied.

      - Three functions that specify the (x,y,z) components of a point location at
        which the force should be applied. If these functions are not provided, the
        force is applied at the frame's origin.

      - Three functions that specify the (x,y,z) components of a pure torque
        vector to apply. This is in addition to any torque resulting from the
        applied force. If these functions are not provided, no additional torque
        is applied.

    Author: Peter Eastman, Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PrescribedForce *":
        return _simulation.PrescribedForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PrescribedForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PrescribedForce_getClassName()

    def clone(self) -> "OpenSim::PrescribedForce *":
        return _simulation.PrescribedForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PrescribedForce_getConcreteClassName(self)

    def copyProperty_pointIsGlobal(self, source: "PrescribedForce") -> "void":
        r"""
        "pointIsGlobal" property is a flag indicating whether the point
           calculated by the Functions in pointFunctions are returned in the global
           frame rather than in the body frame which is the default. *
        """
        return _simulation.PrescribedForce_copyProperty_pointIsGlobal(self, source)

    def append_pointIsGlobal(self, value: "bool const &") -> "int":
        return _simulation.PrescribedForce_append_pointIsGlobal(self, value)

    def constructProperty_pointIsGlobal(self, initValue: "bool const &") -> "void":
        return _simulation.PrescribedForce_constructProperty_pointIsGlobal(self, initValue)

    def get_pointIsGlobal(self, *args) -> "bool const &":
        return _simulation.PrescribedForce_get_pointIsGlobal(self, *args)

    def upd_pointIsGlobal(self, *args) -> "bool &":
        return _simulation.PrescribedForce_upd_pointIsGlobal(self, *args)

    def set_pointIsGlobal(self, *args) -> "void":
        return _simulation.PrescribedForce_set_pointIsGlobal(self, *args)

    def copyProperty_forceIsGlobal(self, source: "PrescribedForce") -> "void":
        r"""
        "forceIsGlobal" property is a flag indicating whether the force and
           torque returned by the Functions in forceFunctions and torqueFunctions,
           resp., are returned in the global frame (the default). Otherwise they
           are returned in the body frame. *
        """
        return _simulation.PrescribedForce_copyProperty_forceIsGlobal(self, source)

    def append_forceIsGlobal(self, value: "bool const &") -> "int":
        return _simulation.PrescribedForce_append_forceIsGlobal(self, value)

    def constructProperty_forceIsGlobal(self, initValue: "bool const &") -> "void":
        return _simulation.PrescribedForce_constructProperty_forceIsGlobal(self, initValue)

    def get_forceIsGlobal(self, *args) -> "bool const &":
        return _simulation.PrescribedForce_get_forceIsGlobal(self, *args)

    def upd_forceIsGlobal(self, *args) -> "bool &":
        return _simulation.PrescribedForce_upd_forceIsGlobal(self, *args)

    def set_forceIsGlobal(self, *args) -> "void":
        return _simulation.PrescribedForce_set_forceIsGlobal(self, *args)

    def copyProperty_forceFunctions(self, source: "PrescribedForce") -> "void":
        r"""
        These are three functions providing the x,y,z measure numbers of the
           force vector being applied to the body. The coordinate frame in which
           this vector is interpreted depends on the "forceIsGlobal" property. *
        """
        return _simulation.PrescribedForce_copyProperty_forceFunctions(self, source)

    def append_forceFunctions(self, value: "FunctionSet") -> "int":
        return _simulation.PrescribedForce_append_forceFunctions(self, value)

    def constructProperty_forceFunctions(self, initValue: "FunctionSet") -> "void":
        return _simulation.PrescribedForce_constructProperty_forceFunctions(self, initValue)

    def get_forceFunctions(self, *args) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_get_forceFunctions(self, *args)

    def upd_forceFunctions(self, *args) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_upd_forceFunctions(self, *args)

    def set_forceFunctions(self, *args) -> "void":
        return _simulation.PrescribedForce_set_forceFunctions(self, *args)

    def copyProperty_pointFunctions(self, source: "PrescribedForce") -> "void":
        r"""
        These are three functions providing the x,y,z measure numbers of the
           point at which the force should be applied. The coordinate frame in which
           this position vector is interpreted depends on the "pointIsGlobal"
           property. *
        """
        return _simulation.PrescribedForce_copyProperty_pointFunctions(self, source)

    def append_pointFunctions(self, value: "FunctionSet") -> "int":
        return _simulation.PrescribedForce_append_pointFunctions(self, value)

    def constructProperty_pointFunctions(self, initValue: "FunctionSet") -> "void":
        return _simulation.PrescribedForce_constructProperty_pointFunctions(self, initValue)

    def get_pointFunctions(self, *args) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_get_pointFunctions(self, *args)

    def upd_pointFunctions(self, *args) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_upd_pointFunctions(self, *args)

    def set_pointFunctions(self, *args) -> "void":
        return _simulation.PrescribedForce_set_pointFunctions(self, *args)

    def copyProperty_torqueFunctions(self, source: "PrescribedForce") -> "void":
        r"""
        These are three functions providing the x,y,z measure numbers of the
           torque vector being applied to the body. The coordinate frame in which
           this vector is interpreted depends on the "torqueIsGlobal" property. *
        """
        return _simulation.PrescribedForce_copyProperty_torqueFunctions(self, source)

    def append_torqueFunctions(self, value: "FunctionSet") -> "int":
        return _simulation.PrescribedForce_append_torqueFunctions(self, value)

    def constructProperty_torqueFunctions(self, initValue: "FunctionSet") -> "void":
        return _simulation.PrescribedForce_constructProperty_torqueFunctions(self, initValue)

    def get_torqueFunctions(self, *args) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_get_torqueFunctions(self, *args)

    def upd_torqueFunctions(self, *args) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_upd_torqueFunctions(self, *args)

    def set_torqueFunctions(self, *args) -> "void":
        return _simulation.PrescribedForce_set_torqueFunctions(self, *args)
    PropertyIndex_socket_frame = property(_simulation.PrescribedForce_PropertyIndex_socket_frame_get, _simulation.PrescribedForce_PropertyIndex_socket_frame_set)

    def connectSocket_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.PrescribedForce_connectSocket_frame(self, object)
    _has_output_force_applied = property(_simulation.PrescribedForce__has_output_force_applied_get, _simulation.PrescribedForce__has_output_force_applied_set, doc=r"""
    The force applied by the PrescribedForce, this depends only on time.
       The frame in which this vector is interpreted depends on the "forceIsGlobal" property.
    """)
    _has_output_torque_applied = property(_simulation.PrescribedForce__has_output_torque_applied_get, _simulation.PrescribedForce__has_output_torque_applied_set, doc=r"""
    The torque applied by the PrescribedForce, this depends only on time.
       The frame in which this vector is interpreted depends on the "forceIsGlobal" property.
    """)
    _has_output_point_of_application = property(_simulation.PrescribedForce__has_output_point_of_application_get, _simulation.PrescribedForce__has_output_point_of_application_set, doc=r"""
    The point where force is applied by the PrescribedForce, this depends only on time.
       The frame of this vector depends on the "pointIsGlobal" property.
    """)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct a PrescribedForce. By default, the force, torque, and point
        functions are all unspecified, meaning that it applies no force or
        torque.  To specify them, call setForceFunctions(), setTorqueFunctions(),
        and setPointFunctions().

        :type name: string
        :param name:      the name of the PrescribedForce
        :type frame: :py:class:`PhysicalFrame`
        :param frame:     the PhysicalFrame to apply the force to

        |

        *Overload 2:*
         Construct from an XML element. *
        """
        _simulation.PrescribedForce_swiginit(self, _simulation.new_PrescribedForce(*args))

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        r""" Copy in properties from XML. *"""
        return _simulation.PrescribedForce_updateFromXMLNode(self, aNode, versionNumber)

    def setFrameName(self, aBodyName: "std::string const &") -> "void":
        return _simulation.PrescribedForce_setFrameName(self, aBodyName)

    def getFrameName(self) -> "std::string const &":
        return _simulation.PrescribedForce_getFrameName(self)

    def setBodyName(self, aBodyName: "std::string const &") -> "void":
        r""" Backward compatibility pre 4.0 *"""
        return _simulation.PrescribedForce_setBodyName(self, aBodyName)

    def getBodyName(self) -> "std::string const &":
        return _simulation.PrescribedForce_getBodyName(self)

    def setForceFunctions(self, forceX: "Function", forceY: "Function", forceZ: "Function") -> "void":
        r"""
        %Set the functions which specify the force to apply.  By default the
        force is specified in inertial coordinates.
        This can be changed by calling setForceIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type forceX: :py:class:`Function`
        :param forceX:   a function of time which calculates the X component of
                                 the force to apply
        :type forceY: :py:class:`Function`
        :param forceY:   a function of time which calculates the Y component of
                                 the force to apply
        :type forceZ: :py:class:`Function`
        :param forceZ:   a function of time which calculates the Z component of
                                 the force to apply
        """
        return _simulation.PrescribedForce_setForceFunctions(self, forceX, forceY, forceZ)

    def getForceFunctions(self) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_getForceFunctions(self)

    def updForceFunctions(self) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_updForceFunctions(self)

    def getForceFunctionNames(self, aFunctionNames: "ArrayStr") -> "void":
        return _simulation.PrescribedForce_getForceFunctionNames(self, aFunctionNames)

    def setForceFunctionNames(self, aFunctionNames: "ArrayStr", kineticsStore: "Storage") -> "void":
        return _simulation.PrescribedForce_setForceFunctionNames(self, aFunctionNames, kineticsStore)

    def clearForceFunctions(self) -> "void":
        return _simulation.PrescribedForce_clearForceFunctions(self)

    def setPointFunctions(self, pointX: "Function", pointY: "Function", pointZ: "Function") -> "void":
        r"""
        %Set the functions which specify the point at which to apply the force.
        By default the point is specified in the body's local coordinates.
        This can be changed by calling setPointIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type pointX: :py:class:`Function`
        :param pointX:   a function of time which calculates the X coordinate of
                                 the point at which to apply the force
        :type pointY: :py:class:`Function`
        :param pointY:   a function of time which calculates the Y coordinate of
                                 the point at which to apply the force
        :type pointZ: :py:class:`Function`
        :param pointZ:   a function of time which calculates the Z coordinate of
                                 the point at which to apply the force
        """
        return _simulation.PrescribedForce_setPointFunctions(self, pointX, pointY, pointZ)

    def getPointFunctions(self) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_getPointFunctions(self)

    def updPointFunctions(self) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_updPointFunctions(self)

    def getPointFunctionNames(self, aFunctionNames: "ArrayStr") -> "void":
        return _simulation.PrescribedForce_getPointFunctionNames(self, aFunctionNames)

    def setPointFunctionNames(self, aFunctionNames: "ArrayStr", kineticsStore: "Storage") -> "void":
        return _simulation.PrescribedForce_setPointFunctionNames(self, aFunctionNames, kineticsStore)

    def clearPointFunctions(self) -> "void":
        return _simulation.PrescribedForce_clearPointFunctions(self)

    def setTorqueFunctions(self, torqueX: "Function", torqueY: "Function", torqueZ: "Function") -> "void":
        r"""
        %Set the functions which specify the torque to apply. By default the
        torque is specified in inertial coordinates.
        This can be changed by calling setForceIsInGlobalFrame().

        All of the Function objects should have been allocated on the heap with
        the "new" operator. This object takes over ownership of them, and will
        delete them when it is deleted itself.

        :type torqueX: :py:class:`Function`
        :param torqueX:   a function of time which calculates the X component of
                                 the torque to apply
        :type torqueY: :py:class:`Function`
        :param torqueY:   a function of time which calculates the Y component of
                                 the torque to apply
        :type torqueZ: :py:class:`Function`
        :param torqueZ:   a function of time which calculates the Z component of
                                 the torque to apply
        """
        return _simulation.PrescribedForce_setTorqueFunctions(self, torqueX, torqueY, torqueZ)

    def getTorqueFunctions(self) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedForce_getTorqueFunctions(self)

    def updTorqueFunctions(self) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedForce_updTorqueFunctions(self)

    def getTorqueFunctionNames(self, aFunctionNames: "ArrayStr") -> "void":
        return _simulation.PrescribedForce_getTorqueFunctionNames(self, aFunctionNames)

    def setTorqueFunctionNames(self, aFunctionNames: "ArrayStr", kineticsStore: "Storage") -> "void":
        return _simulation.PrescribedForce_setTorqueFunctionNames(self, aFunctionNames, kineticsStore)

    def clearTorqueFunctions(self) -> "void":
        return _simulation.PrescribedForce_clearTorqueFunctions(self)

    def getForceIsInGlobalFrame(self) -> "bool":
        r"""
        Get whether the force and torque are specified in inertial coordinates
           or in the body's local coordinates. *
        """
        return _simulation.PrescribedForce_getForceIsInGlobalFrame(self)

    def setForceIsInGlobalFrame(self, isGlobal: "bool") -> "void":
        r"""
        %Set whether the force and torque are specified in inertial coordinates
           or in the body's local coordinates. *
        """
        return _simulation.PrescribedForce_setForceIsInGlobalFrame(self, isGlobal)

    def getPointIsInGlobalFrame(self) -> "bool":
        r"""
        Get whether the point is specified in inertial coordinates or in the
           body's local coordinates. *
        """
        return _simulation.PrescribedForce_getPointIsInGlobalFrame(self)

    def setPointIsInGlobalFrame(self, isGlobal: "bool") -> "void":
        r"""
        %Set whether the point is specified in inertial coordinates or in the
           body's local coordinates. *
        """
        return _simulation.PrescribedForce_setPointIsInGlobalFrame(self, isGlobal)

    def getFrame(self) -> "OpenSim::PhysicalFrame const &":
        r""" Get the frame that the prescribed force is acting upon. *"""
        return _simulation.PrescribedForce_getFrame(self)

    def getForceAtTime(self, aTime: "double") -> "SimTK::Vec3":
        r"""
        Convenience method to evaluate the prescribed force functions at
           an arbitrary time. Returns zero if there aren't three functions defined. *
        """
        return _simulation.PrescribedForce_getForceAtTime(self, aTime)

    def getPointAtTime(self, aTime: "double") -> "SimTK::Vec3":
        r"""
        Convenience method to evaluate the prescribed force application point
           functions at an arbitrary time. Returns zero if there aren't three
           functions defined. *
        """
        return _simulation.PrescribedForce_getPointAtTime(self, aTime)

    def getTorqueAtTime(self, aTime: "double") -> "SimTK::Vec3":
        r"""
        Convenience method to evaluate the prescribed torque functions at
           an arbitrary time. Returns zero if there aren't three functions defined. *
        """
        return _simulation.PrescribedForce_getTorqueAtTime(self, aTime)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Methods used for reporting"""
        return _simulation.PrescribedForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels() and should return same size Array.
        """
        return _simulation.PrescribedForce_getRecordValues(self, state)

    def getForceApplied(self, state: "State") -> "SimTK::Vec3":
        r""" Methods to support outputs"""
        return _simulation.PrescribedForce_getForceApplied(self, state)

    def getTorqueApplied(self, state: "State") -> "SimTK::Vec3":
        return _simulation.PrescribedForce_getTorqueApplied(self, state)

    def getApplicationPoint(self, state: "State") -> "SimTK::Vec3":
        return _simulation.PrescribedForce_getApplicationPoint(self, state)
    __swig_destroy__ = _simulation.delete_PrescribedForce

# Register PrescribedForce in _simulation:
_simulation.PrescribedForce_swigregister(PrescribedForce)

def PrescribedForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PrescribedForce *":
    return _simulation.PrescribedForce_safeDownCast(obj)

def PrescribedForce_getClassName() -> "std::string const &":
    return _simulation.PrescribedForce_getClassName()

class CoordinateLimitForce(Force):
    r"""
    Generate a force that acts to limit the range of motion of a coordinate.
    Force is experienced at upper and lower limits of the coordinate value
    according to a constant stiffnesses K_upper and K_lower, with a C2 continuous
    transition from 0 to K. The transition parameter defines how far beyond the
    limit the stiffness becomes constant. The integrator will like smoother
    (i.e. larger transition regions).

    Damping factor is also phased in through the transition region from 0 to the
    value provided.

    Limiting force is guaranteed to be zero within the upper and lower limits.

    The potential energy stored in the spring component of the force is
    accessible as well as the power (nd optionally energy) dissipated.
    The function has the following shape:

    Image: coordinate_limit_force.png

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateLimitForce *":
        return _simulation.CoordinateLimitForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.CoordinateLimitForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.CoordinateLimitForce_getClassName()

    def clone(self) -> "OpenSim::CoordinateLimitForce *":
        return _simulation.CoordinateLimitForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.CoordinateLimitForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value: "std::string const &") -> "int":
        return _simulation.CoordinateLimitForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, initValue: "std::string const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_coordinate(self, initValue)

    def get_coordinate(self, *args) -> "std::string const &":
        return _simulation.CoordinateLimitForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args) -> "std::string &":
        return _simulation.CoordinateLimitForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_coordinate(self, *args)

    def copyProperty_upper_stiffness(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_upper_stiffness(self, source)

    def append_upper_stiffness(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_upper_stiffness(self, value)

    def constructProperty_upper_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_upper_stiffness(self, initValue)

    def get_upper_stiffness(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_upper_stiffness(self, *args)

    def upd_upper_stiffness(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_upper_stiffness(self, *args)

    def set_upper_stiffness(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_upper_stiffness(self, *args)

    def copyProperty_upper_limit(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_upper_limit(self, source)

    def append_upper_limit(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_upper_limit(self, value)

    def constructProperty_upper_limit(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_upper_limit(self, initValue)

    def get_upper_limit(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_upper_limit(self, *args)

    def upd_upper_limit(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_upper_limit(self, *args)

    def set_upper_limit(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_upper_limit(self, *args)

    def copyProperty_lower_stiffness(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_lower_stiffness(self, source)

    def append_lower_stiffness(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_lower_stiffness(self, value)

    def constructProperty_lower_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_lower_stiffness(self, initValue)

    def get_lower_stiffness(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_lower_stiffness(self, *args)

    def upd_lower_stiffness(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_lower_stiffness(self, *args)

    def set_lower_stiffness(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_lower_stiffness(self, *args)

    def copyProperty_lower_limit(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_lower_limit(self, source)

    def append_lower_limit(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_lower_limit(self, value)

    def constructProperty_lower_limit(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_lower_limit(self, initValue)

    def get_lower_limit(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_lower_limit(self, *args)

    def upd_lower_limit(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_lower_limit(self, *args)

    def set_lower_limit(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_lower_limit(self, *args)

    def copyProperty_damping(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_damping(self, source)

    def append_damping(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_damping(self, value)

    def constructProperty_damping(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_damping(self, initValue)

    def get_damping(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_damping(self, *args)

    def upd_damping(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_damping(self, *args)

    def set_damping(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_damping(self, *args)

    def copyProperty_transition(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_transition(self, source)

    def append_transition(self, value: "double const &") -> "int":
        return _simulation.CoordinateLimitForce_append_transition(self, value)

    def constructProperty_transition(self, initValue: "double const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_transition(self, initValue)

    def get_transition(self, *args) -> "double const &":
        return _simulation.CoordinateLimitForce_get_transition(self, *args)

    def upd_transition(self, *args) -> "double &":
        return _simulation.CoordinateLimitForce_upd_transition(self, *args)

    def set_transition(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_transition(self, *args)

    def copyProperty_compute_dissipation_energy(self, source: "CoordinateLimitForce") -> "void":
        return _simulation.CoordinateLimitForce_copyProperty_compute_dissipation_energy(self, source)

    def append_compute_dissipation_energy(self, value: "bool const &") -> "int":
        return _simulation.CoordinateLimitForce_append_compute_dissipation_energy(self, value)

    def constructProperty_compute_dissipation_energy(self, initValue: "bool const &") -> "void":
        return _simulation.CoordinateLimitForce_constructProperty_compute_dissipation_energy(self, initValue)

    def get_compute_dissipation_energy(self, *args) -> "bool const &":
        return _simulation.CoordinateLimitForce_get_compute_dissipation_energy(self, *args)

    def upd_compute_dissipation_energy(self, *args) -> "bool &":
        return _simulation.CoordinateLimitForce_upd_compute_dissipation_energy(self, *args)

    def set_compute_dissipation_energy(self, *args) -> "void":
        return _simulation.CoordinateLimitForce_set_compute_dissipation_energy(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor.
           Generate a force that acts to limit the range of motion of a coordinate
           Force experienced at upper and lower limits of the coordinate (q) value
           is according to a linear stiffnesses K_upper and K_lower, with a C2 continuous
           transition from 0 to K. The transition parameter (dq) defines how far
           beyond the limit the stiffness becomes purely linear. The integrator will
           like smoother (i.e. larger transition regions).
           :type coordName: string, in
           :param coordName:   Coordinate whose range is to be limited.
           :type q_upper: float, in
           :param q_upper:     Coordinate's upper limit value.
           :type K_upper: float, in
           :param K_upper:     Upper limit stiffness when coordinate > q_upper
           :type q_lower: float, in
           :param q_lower:     Coordinate's lower limit value.
           :type K_lower: float, in
           :param K_lower:     Lower limit stiffness when coordinate < q_lower
           :type damping: float, in
           :param damping:     Damping factor when coordinate is beyond the limits
           :type dq: float, in
           :param dq:          Transition region (displacement) for force to be
                                       engaged.
           :type computeDissipationEnergy: boolean, in, optional
           :param computeDissipationEnergy:
                                       Whether to compute dissipated energy (false).


        |

        *Overload 3:*
        Convenience constructor.
           Generate a force that acts to limit the range of motion of a coordinate
           Force experienced at upper and lower limits of the coordinate (q) value
           is according to a linear stiffnesses K_upper and K_lower, with a C2 continuous
           transition from 0 to K. The transition parameter (dq) defines how far
           beyond the limit the stiffness becomes purely linear. The integrator will
           like smoother (i.e. larger transition regions).
           :type coordName: string, in
           :param coordName:   Coordinate whose range is to be limited.
           :type q_upper: float, in
           :param q_upper:     Coordinate's upper limit value.
           :type K_upper: float, in
           :param K_upper:     Upper limit stiffness when coordinate > q_upper
           :type q_lower: float, in
           :param q_lower:     Coordinate's lower limit value.
           :type K_lower: float, in
           :param K_lower:     Lower limit stiffness when coordinate < q_lower
           :type damping: float, in
           :param damping:     Damping factor when coordinate is beyond the limits
           :type dq: float, in
           :param dq:          Transition region (displacement) for force to be
                                       engaged.
           :param computeDissipationEnergy:
                                       Whether to compute dissipated energy (false).
        """
        _simulation.CoordinateLimitForce_swiginit(self, _simulation.new_CoordinateLimitForce(*args))
    __swig_destroy__ = _simulation.delete_CoordinateLimitForce

    def setUpperStiffness(self, aUpperStiffness: "double") -> "void":
        r"""
        Stiffness of the passive limit force when coordinate exceeds upper
           limit. Note, rotational stiffness expected in N*m/degree.
        """
        return _simulation.CoordinateLimitForce_setUpperStiffness(self, aUpperStiffness)

    def getUpperStiffness(self) -> "double":
        return _simulation.CoordinateLimitForce_getUpperStiffness(self)

    def setUpperLimit(self, aUpperLimit: "double") -> "void":
        r""" Upper limit of the coordinate range of motion (rotations in degrees)."""
        return _simulation.CoordinateLimitForce_setUpperLimit(self, aUpperLimit)

    def getUpperLimit(self) -> "double":
        return _simulation.CoordinateLimitForce_getUpperLimit(self)

    def setLowerStiffness(self, aLowerStiffness: "double") -> "void":
        r"""
        Stiffness of the passive limit force when coordinate exceeds lower
           limit. Note, rotational stiffness expected in N*m/degree.
        """
        return _simulation.CoordinateLimitForce_setLowerStiffness(self, aLowerStiffness)

    def getLowerStiffness(self) -> "double":
        return _simulation.CoordinateLimitForce_getLowerStiffness(self)

    def setLowerLimit(self, aLowerLimit: "double") -> "void":
        r""" Lower limit of the coordinate range of motion (rotations in degrees)."""
        return _simulation.CoordinateLimitForce_setLowerLimit(self, aLowerLimit)

    def getLowerLimit(self) -> "double":
        return _simulation.CoordinateLimitForce_getLowerLimit(self)

    def setDamping(self, aDamping: "double") -> "void":
        r"""
        Damping factor on the coordinate's speed applied only when limit is
           exceeded. For translational has units N/(m/s) and rotational has
           Nm/(degree/s).
        """
        return _simulation.CoordinateLimitForce_setDamping(self, aDamping)

    def getDamping(self) -> "double":
        return _simulation.CoordinateLimitForce_getDamping(self)

    def setTransition(self, aTransition: "double") -> "void":
        r"""
        Transition region width with lengths is m and angles in degrees).
           Specifies the transition from zero to a constant stiffness as
           coordinate exceeds its limit.
        """
        return _simulation.CoordinateLimitForce_setTransition(self, aTransition)

    def getTransition(self) -> "double":
        return _simulation.CoordinateLimitForce_getTransition(self)

    def setComputeDissipationEnergy(self, flag: "bool") -> "void":
        r"""
        Option to compute the dissipation energy due to damping in the
           CoordinateLimitForce. If true the dissipation power is automatically
           integrated to provide energy. Default is false.
        """
        return _simulation.CoordinateLimitForce_setComputeDissipationEnergy(self, flag)

    def isComputingDissipationEnergy(self) -> "bool":
        return _simulation.CoordinateLimitForce_isComputingDissipationEnergy(self)

    def getPowerDissipation(self, s: "State") -> "double":
        r"""
        Obtain the rate at which energy is being dissipated by this
           CoordinateLimit, that is, the power being lost. This is in units of
           energy/time which is watts in J/s.
           :type s: :py:class:`State`, in
           :param s:
                   The State from which to obtain the current value of the power
                   dissipation.
           :rtype: float
           :return: 
                   The dissipated power (a nonnegative scalar).
           See also: getDissipatedEnergy() for the time-integrated power loss *
        """
        return _simulation.CoordinateLimitForce_getPowerDissipation(self, s)

    def getDissipatedEnergy(self, s: "State") -> "double":
        r"""
        Obtain energy dissipated by this CoordinateLimitForce over time
           in units of energy in J.
           :type s: :py:class:`State`, in
           :param s:
                   The State from which to obtain the current value of
                   dissipated energy
           :rtype: float
           :return: 
                   The dissipated energy (a nonnegative scalar). *
        """
        return _simulation.CoordinateLimitForce_getDissipatedEnergy(self, s)

    def calcLimitForce(self, s: "State") -> "double":
        r""" Force calculation operator. *"""
        return _simulation.CoordinateLimitForce_calcLimitForce(self, s)

    def computePotentialEnergy(self, s: "State") -> "double":
        r"""
        Contribute this Force component's potential energy to the accounting
           of the total system energy. *
        """
        return _simulation.CoordinateLimitForce_computePotentialEnergy(self, s)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods to query a Force for the value actually applied during simulation
        The names of quantities (column labels) are  returned by getRecordLabels()
        """
        return _simulation.CoordinateLimitForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report forces, application location
        frame, etc. used in conjunction with getRecordLabels and should return same size Array
        """
        return _simulation.CoordinateLimitForce_getRecordValues(self, state)

# Register CoordinateLimitForce in _simulation:
_simulation.CoordinateLimitForce_swigregister(CoordinateLimitForce)

def CoordinateLimitForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateLimitForce *":
    return _simulation.CoordinateLimitForce_safeDownCast(obj)

def CoordinateLimitForce_getClassName() -> "std::string const &":
    return _simulation.CoordinateLimitForce_getClassName()

class ContactGeometry(ModelComponent):
    r"""
     This class represents the physical shape of an object for use in contact
    modeling.  It is an abstract class, with subclasses for particular geometric
    representations. The geometry is attached to a PhysicalFrame, which is
    specified using a Socket named "frame".

    Note that ContactGeometry is not scaled with the Model.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactGeometry *":
        return _simulation.ContactGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ContactGeometry_getClassName()

    def clone(self) -> "OpenSim::ContactGeometry *":
        return _simulation.ContactGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ContactGeometry_getConcreteClassName(self)

    def copyProperty_location(self, source: "ContactGeometry") -> "void":
        return _simulation.ContactGeometry_copyProperty_location(self, source)

    def append_location(self, value: "Vec3") -> "int":
        return _simulation.ContactGeometry_append_location(self, value)

    def constructProperty_location(self, initValue: "Vec3") -> "void":
        return _simulation.ContactGeometry_constructProperty_location(self, initValue)

    def get_location(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ContactGeometry_get_location(self, *args)

    def upd_location(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ContactGeometry_upd_location(self, *args)

    def set_location(self, *args) -> "void":
        return _simulation.ContactGeometry_set_location(self, *args)

    def copyProperty_orientation(self, source: "ContactGeometry") -> "void":
        return _simulation.ContactGeometry_copyProperty_orientation(self, source)

    def append_orientation(self, value: "Vec3") -> "int":
        return _simulation.ContactGeometry_append_orientation(self, value)

    def constructProperty_orientation(self, initValue: "Vec3") -> "void":
        return _simulation.ContactGeometry_constructProperty_orientation(self, initValue)

    def get_orientation(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ContactGeometry_get_orientation(self, *args)

    def upd_orientation(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ContactGeometry_upd_orientation(self, *args)

    def set_orientation(self, *args) -> "void":
        return _simulation.ContactGeometry_set_orientation(self, *args)

    def copyProperty_Appearance(self, source: "ContactGeometry") -> "void":
        return _simulation.ContactGeometry_copyProperty_Appearance(self, source)

    def append_Appearance(self, value: "Appearance") -> "int":
        return _simulation.ContactGeometry_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue: "Appearance") -> "void":
        return _simulation.ContactGeometry_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args) -> "OpenSim::Appearance const &":
        return _simulation.ContactGeometry_get_Appearance(self, *args)

    def upd_Appearance(self, *args) -> "OpenSim::Appearance &":
        return _simulation.ContactGeometry_upd_Appearance(self, *args)

    def set_Appearance(self, *args) -> "void":
        return _simulation.ContactGeometry_set_Appearance(self, *args)
    PropertyIndex_socket_frame = property(_simulation.ContactGeometry_PropertyIndex_socket_frame_get, _simulation.ContactGeometry_PropertyIndex_socket_frame_set)

    def connectSocket_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.ContactGeometry_connectSocket_frame(self, object)

    def getFrame(self) -> "OpenSim::PhysicalFrame const &":
        r""" Get the PhysicalFrame this geometry is attached to."""
        return _simulation.ContactGeometry_getFrame(self)

    def setFrame(self, frame: "PhysicalFrame") -> "void":
        r""" %Set the PhysicalFrame this geometry is attached to."""
        return _simulation.ContactGeometry_setFrame(self, frame)

    def createSimTKContactGeometry(self) -> "SimTK::ContactGeometry":
        r""" Create a new SimTK::ContactGeometry based on this object."""
        return _simulation.ContactGeometry_createSimTKContactGeometry(self)

    def getTransform(self) -> "SimTK::Transform":
        r"""
         Get a Transform representing the position and orientation of the
        geometry relative to the PhysicalFrame `F` to which this geometry is
        connected.

        If you want the transform of this geometry relative to the Frame (or
        Ground) `B` in which this geometry is fixed, you can use the following
        code:

        .. code-block:: c++

            const auto& X_BF = geom.getFrame().findTransformInBaseFrame();
            const auto X_FP = geom.getTransform();
            const auto X_BP = X_BF * X_FP;

        Prior to OpenSim 4.0, there wwas no intermediate PhysicalFrame `F`, so
        this method essentially returned `X_BP`.
        """
        return _simulation.ContactGeometry_getTransform(self)

    def scale(self, aScaleSet: "ScaleSet") -> "void":
        r"""
        Scale a ContactGeometry based on XYZ scale factors for the bodies.

        :type aScaleSet: :py:class:`ScaleSet`
        :param aScaleSet: Set of XYZ scale factors for the bodies.
        """
        return _simulation.ContactGeometry_scale(self, aScaleSet)

    def getLocation(self) -> "SimTK::Vec3 const &":
        r""" **(Deprecated)** Use get_location() instead."""
        return _simulation.ContactGeometry_getLocation(self)

    def setLocation(self, location: "Vec3") -> "void":
        r""" **(Deprecated)** Use set_location() instead."""
        return _simulation.ContactGeometry_setLocation(self, location)

    def getOrientation(self) -> "SimTK::Vec3 const &":
        r""" **(Deprecated)** Use get_orientation() instead."""
        return _simulation.ContactGeometry_getOrientation(self)

    def setOrientation(self, orientation: "Vec3") -> "void":
        r""" **(Deprecated)** Use set_orientation() instead."""
        return _simulation.ContactGeometry_setOrientation(self, orientation)

    def getBody(self) -> "OpenSim::PhysicalFrame const &":
        r"""
         **(Deprecated)** Use getFrame() instead.
        Get the Body this geometry is attached to.
        """
        return _simulation.ContactGeometry_getBody(self)

    def setBody(self, body: "PhysicalFrame") -> "void":
        r"""
         **(Deprecated)** Use setFrame() instead.
        %Set the Body this geometry is attached to.
        """
        return _simulation.ContactGeometry_setBody(self, body)
    __swig_destroy__ = _simulation.delete_ContactGeometry

# Register ContactGeometry in _simulation:
_simulation.ContactGeometry_swigregister(ContactGeometry)

def ContactGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactGeometry *":
    return _simulation.ContactGeometry_safeDownCast(obj)

def ContactGeometry_getClassName() -> "std::string const &":
    return _simulation.ContactGeometry_getClassName()

class SetContactGeometry(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ContactGeometry,OpenSim::ModelComponent > *":
        return _simulation.SetContactGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetContactGeometry_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::ContactGeometry,OpenSim::ModelComponent > *":
        return _simulation.SetContactGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetContactGeometry_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetContactGeometry

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::ContactGeometry,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetContactGeometry_swiginit(self, _simulation.new_SetContactGeometry(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetContactGeometry_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetContactGeometry_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetContactGeometry_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetContactGeometry_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetContactGeometry_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetContactGeometry_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "ContactGeometry") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "ContactGeometry") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "ContactGeometry") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetContactGeometry_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "ContactGeometry", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ContactGeometry`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetContactGeometry_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::ContactGeometry &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`ContactGeometry`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ContactGeometry`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetContactGeometry_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetContactGeometry_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetContactGeometry_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetContactGeometry_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetContactGeometry_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetContactGeometry_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetContactGeometry_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetContactGeometry_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetContactGeometry_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetContactGeometry_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetContactGeometry in _simulation:
_simulation.SetContactGeometry_swigregister(SetContactGeometry)

def SetContactGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::ContactGeometry,OpenSim::ModelComponent > *":
    return _simulation.SetContactGeometry_safeDownCast(obj)

def SetContactGeometry_getClassName() -> "std::string const &":
    return _simulation.SetContactGeometry_getClassName()

class ModelComponentSetContactGeometry(SetContactGeometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ContactGeometry > *":
        return _simulation.ModelComponentSetContactGeometry_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetContactGeometry_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetContactGeometry_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::ContactGeometry > *":
        return _simulation.ModelComponentSetContactGeometry_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetContactGeometry_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetContactGeometry_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetContactGeometry_swiginit(self, _simulation.new_ModelComponentSetContactGeometry())
    __swig_destroy__ = _simulation.delete_ModelComponentSetContactGeometry

# Register ModelComponentSetContactGeometry in _simulation:
_simulation.ModelComponentSetContactGeometry_swigregister(ModelComponentSetContactGeometry)

def ModelComponentSetContactGeometry_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::ContactGeometry > *":
    return _simulation.ModelComponentSetContactGeometry_safeDownCast(obj)

def ModelComponentSetContactGeometry_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetContactGeometry_getClassName()

class ContactGeometrySet(ModelComponentSetContactGeometry):
    r"""
    A class for holding a set of ContactGeometry components.

    Authors: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactGeometrySet *":
        return _simulation.ContactGeometrySet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ContactGeometrySet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ContactGeometrySet_getClassName()

    def clone(self) -> "OpenSim::ContactGeometrySet *":
        return _simulation.ContactGeometrySet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ContactGeometrySet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ContactGeometrySet_swiginit(self, _simulation.new_ContactGeometrySet(*args))
    __swig_destroy__ = _simulation.delete_ContactGeometrySet

# Register ContactGeometrySet in _simulation:
_simulation.ContactGeometrySet_swigregister(ContactGeometrySet)

def ContactGeometrySet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactGeometrySet *":
    return _simulation.ContactGeometrySet_safeDownCast(obj)

def ContactGeometrySet_getClassName() -> "std::string const &":
    return _simulation.ContactGeometrySet_getClassName()

class ContactHalfSpace(ContactGeometry):
    r"""
    This class represents a half space (that is, everything to one side of an
    infinite plane) for use in contact modeling.  In its local coordinate
    system, all points for which x>0 are considered to be inside the geometry.
    Its location and orientation properties can be used to move and rotate it to
    represent other half spaces.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactHalfSpace *":
        return _simulation.ContactHalfSpace_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ContactHalfSpace_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ContactHalfSpace_getClassName()

    def clone(self) -> "OpenSim::ContactHalfSpace *":
        return _simulation.ContactHalfSpace_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ContactHalfSpace_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactHalfSpace.

        |

        *Overload 2:*

        Construct a ContactHalfSpace.  All points in its local coordinate system
        for which x>0 are considered to be inside the geometry.

        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to

        |

        *Overload 3:*

        Construct a ContactHalfSpace.  All points in its local coordinate system
        for which x>0 are considered to be inside the geometry.

        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactHalfSpace_swiginit(self, _simulation.new_ContactHalfSpace(*args))

    def createSimTKContactGeometry(self) -> "SimTK::ContactGeometry":
        return _simulation.ContactHalfSpace_createSimTKContactGeometry(self)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", s: "State", geometry: "ArrayDecorativeGeometry") -> "void":
        return _simulation.ContactHalfSpace_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactHalfSpace

# Register ContactHalfSpace in _simulation:
_simulation.ContactHalfSpace_swigregister(ContactHalfSpace)

def ContactHalfSpace_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactHalfSpace *":
    return _simulation.ContactHalfSpace_safeDownCast(obj)

def ContactHalfSpace_getClassName() -> "std::string const &":
    return _simulation.ContactHalfSpace_getClassName()

class ContactMesh(ContactGeometry):
    r"""
    This class represents a polygonal mesh for use in contact modeling.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactMesh *":
        return _simulation.ContactMesh_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ContactMesh_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ContactMesh_getClassName()

    def clone(self) -> "OpenSim::ContactMesh *":
        return _simulation.ContactMesh_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ContactMesh_getConcreteClassName(self)

    def copyProperty_filename(self, source: "ContactMesh") -> "void":
        return _simulation.ContactMesh_copyProperty_filename(self, source)

    def append_filename(self, value: "std::string const &") -> "int":
        return _simulation.ContactMesh_append_filename(self, value)

    def constructProperty_filename(self, initValue: "std::string const &") -> "void":
        return _simulation.ContactMesh_constructProperty_filename(self, initValue)

    def get_filename(self, *args) -> "std::string const &":
        return _simulation.ContactMesh_get_filename(self, *args)

    def upd_filename(self, *args) -> "std::string &":
        return _simulation.ContactMesh_upd_filename(self, *args)

    def set_filename(self, *args) -> "void":
        return _simulation.ContactMesh_set_filename(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactMesh.

        |

        *Overload 2:*

        Construct a ContactMesh.

        :type filename: string
        :param filename:     the name of the file to load the mesh from
        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to

        |

        *Overload 3:*

        Construct a ContactMesh.

        :type filename: string
        :param filename:     the name of the file to load the mesh from
        :type location: :py:class:`Vec3`
        :param location:     the location of the mesh within the PhysicalFrame it
                                is attached to
        :type orientation: :py:class:`Vec3`
        :param orientation:  the orientation of the mesh within the PhysicalFrame
                                it is attached to
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this mesh is attached to
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactMesh_swiginit(self, _simulation.new_ContactMesh(*args))

    def createSimTKContactGeometry(self) -> "SimTK::ContactGeometry":
        return _simulation.ContactMesh_createSimTKContactGeometry(self)

    def getFilename(self) -> "std::string const &":
        r"""Get the name of the file the mesh is loaded from."""
        return _simulation.ContactMesh_getFilename(self)

    def setFilename(self, filename: "std::string const &") -> "void":
        r"""%Set the name of the file to load the mesh from."""
        return _simulation.ContactMesh_setFilename(self, filename)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", s: "State", geometry: "ArrayDecorativeGeometry") -> "void":
        return _simulation.ContactMesh_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactMesh

# Register ContactMesh in _simulation:
_simulation.ContactMesh_swigregister(ContactMesh)

def ContactMesh_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactMesh *":
    return _simulation.ContactMesh_safeDownCast(obj)

def ContactMesh_getClassName() -> "std::string const &":
    return _simulation.ContactMesh_getClassName()

class ContactSphere(ContactGeometry):
    r"""
    This class represents a spherical object for use in contact modeling.

    Author: Peter Eastman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactSphere *":
        return _simulation.ContactSphere_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ContactSphere_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ContactSphere_getClassName()

    def clone(self) -> "OpenSim::ContactSphere *":
        return _simulation.ContactSphere_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ContactSphere_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an empty, uninitialized ContactSphere.

        |

        *Overload 2:*

        Construct a ContactSphere.

        :type radius: float
        :param radius:       the radius of the sphere
        :type location: :py:class:`Vec3`
        :param location:     the location of the center of the sphere expressed
                                in `frame`.
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this geometry is attached to;
                                this constructor connects this ContactSphere to
                                the provided `frame`.

        |

        *Overload 3:*

        Construct a ContactSphere.

        :type radius: float
        :param radius:       the radius of the sphere
        :type location: :py:class:`Vec3`
        :param location:     the location of the center of the sphere expressed
                                in `frame`.
        :type frame: :py:class:`PhysicalFrame`
        :param frame:        the PhysicalFrame this geometry is attached to;
                                this constructor connects this ContactSphere to
                                the provided `frame`.
        :type name: string
        :param name:         the name of this object
        """
        _simulation.ContactSphere_swiginit(self, _simulation.new_ContactSphere(*args))

    def createSimTKContactGeometry(self) -> "SimTK::ContactGeometry":
        return _simulation.ContactSphere_createSimTKContactGeometry(self)

    def getRadius(self) -> "double":
        r"""Get the radius of the sphere."""
        return _simulation.ContactSphere_getRadius(self)

    def setRadius(self, radius: "double") -> "void":
        r"""%Set the radius of the sphere."""
        return _simulation.ContactSphere_setRadius(self, radius)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", s: "State", geometry: "ArrayDecorativeGeometry") -> "void":
        return _simulation.ContactSphere_generateDecorations(self, fixed, hints, s, geometry)
    __swig_destroy__ = _simulation.delete_ContactSphere

# Register ContactSphere in _simulation:
_simulation.ContactSphere_swigregister(ContactSphere)

def ContactSphere_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ContactSphere *":
    return _simulation.ContactSphere_safeDownCast(obj)

def ContactSphere_getClassName() -> "std::string const &":
    return _simulation.ContactSphere_getClassName()

class ElasticFoundationForce(Force):
    r"""
     This Force subclass implements an elastic foundation contact model. It
    places a spring at the center of each face of each ContactMesh it acts on.
    Those springs interact with all objects (both meshes and other objects) the
    mesh comes in contact with.

    Author: Peter Eastman *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ElasticFoundationForce *":
        return _simulation.ElasticFoundationForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ElasticFoundationForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ElasticFoundationForce_getClassName()

    def clone(self) -> "OpenSim::ElasticFoundationForce *":
        return _simulation.ElasticFoundationForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ElasticFoundationForce_getConcreteClassName(self)

    def copyProperty_contact_parameters(self, source: "ElasticFoundationForce") -> "void":
        return _simulation.ElasticFoundationForce_copyProperty_contact_parameters(self, source)

    def append_contact_parameters(self, value: "OpenSim::ElasticFoundationForce::ContactParametersSet const &") -> "int":
        return _simulation.ElasticFoundationForce_append_contact_parameters(self, value)

    def constructProperty_contact_parameters(self, initValue: "OpenSim::ElasticFoundationForce::ContactParametersSet const &") -> "void":
        return _simulation.ElasticFoundationForce_constructProperty_contact_parameters(self, initValue)

    def get_contact_parameters(self, *args) -> "OpenSim::ElasticFoundationForce::ContactParametersSet const &":
        return _simulation.ElasticFoundationForce_get_contact_parameters(self, *args)

    def upd_contact_parameters(self, *args) -> "OpenSim::ElasticFoundationForce::ContactParametersSet &":
        return _simulation.ElasticFoundationForce_upd_contact_parameters(self, *args)

    def set_contact_parameters(self, *args) -> "void":
        return _simulation.ElasticFoundationForce_set_contact_parameters(self, *args)

    def copyProperty_transition_velocity(self, source: "ElasticFoundationForce") -> "void":
        return _simulation.ElasticFoundationForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value: "double const &") -> "int":
        return _simulation.ElasticFoundationForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue: "double const &") -> "void":
        return _simulation.ElasticFoundationForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args) -> "double const &":
        return _simulation.ElasticFoundationForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args) -> "double &":
        return _simulation.ElasticFoundationForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args) -> "void":
        return _simulation.ElasticFoundationForce_set_transition_velocity(self, *args)

    def __init__(self, *args):
        _simulation.ElasticFoundationForce_swiginit(self, _simulation.new_ElasticFoundationForce(*args))

    def extendAddToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r"""Create a SimTK::Force which implements this Force."""
        return _simulation.ElasticFoundationForce_extendAddToSystem(self, system)

    def updContactParametersSet(self) -> "OpenSim::ElasticFoundationForce::ContactParametersSet &":
        return _simulation.ElasticFoundationForce_updContactParametersSet(self)

    def getContactParametersSet(self) -> "OpenSim::ElasticFoundationForce::ContactParametersSet const &":
        return _simulation.ElasticFoundationForce_getContactParametersSet(self)

    def addContactParameters(self, params: "OpenSim::ElasticFoundationForce::ContactParameters *") -> "void":
        r""" Takes over ownership of the passed-in object. *"""
        return _simulation.ElasticFoundationForce_addContactParameters(self, params)

    def getTransitionVelocity(self) -> "double":
        r"""Get the transition velocity for switching between static and dynamic friction."""
        return _simulation.ElasticFoundationForce_getTransitionVelocity(self)

    def setTransitionVelocity(self, velocity: "double") -> "void":
        r"""%Set the transition velocity for switching between static and dynamic friction."""
        return _simulation.ElasticFoundationForce_setTransitionVelocity(self, velocity)

    def getStiffness(self) -> "double":
        r"""Access to ContactParameters. Methods assume size 1 of ContactParametersSet and add one ContactParameter if needed"""
        return _simulation.ElasticFoundationForce_getStiffness(self)

    def setStiffness(self, stiffness: "double") -> "void":
        return _simulation.ElasticFoundationForce_setStiffness(self, stiffness)

    def getDissipation(self) -> "double":
        return _simulation.ElasticFoundationForce_getDissipation(self)

    def setDissipation(self, dissipation: "double") -> "void":
        return _simulation.ElasticFoundationForce_setDissipation(self, dissipation)

    def getStaticFriction(self) -> "double":
        return _simulation.ElasticFoundationForce_getStaticFriction(self)

    def setStaticFriction(self, friction: "double") -> "void":
        return _simulation.ElasticFoundationForce_setStaticFriction(self, friction)

    def getDynamicFriction(self) -> "double":
        return _simulation.ElasticFoundationForce_getDynamicFriction(self)

    def setDynamicFriction(self, friction: "double") -> "void":
        return _simulation.ElasticFoundationForce_setDynamicFriction(self, friction)

    def getViscousFriction(self) -> "double":
        return _simulation.ElasticFoundationForce_getViscousFriction(self)

    def setViscousFriction(self, friction: "double") -> "void":
        return _simulation.ElasticFoundationForce_setViscousFriction(self, friction)

    def addGeometry(self, name: "std::string const &") -> "void":
        return _simulation.ElasticFoundationForce_addGeometry(self, name)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ElasticFoundationForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ElasticFoundationForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ElasticFoundationForce

# Register ElasticFoundationForce in _simulation:
_simulation.ElasticFoundationForce_swigregister(ElasticFoundationForce)

def ElasticFoundationForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ElasticFoundationForce *":
    return _simulation.ElasticFoundationForce_safeDownCast(obj)

def ElasticFoundationForce_getClassName() -> "std::string const &":
    return _simulation.ElasticFoundationForce_getClassName()

class HuntCrossleyForce(Force):
    r"""
     This force subclass implements a Hunt-Crossley contact model. It uses Hertz
    contact theory to model the interactions between a set of ContactSpheres and
    ContactHalfSpaces.

    Author: Peter Eastman *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::HuntCrossleyForce *":
        return _simulation.HuntCrossleyForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.HuntCrossleyForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.HuntCrossleyForce_getClassName()

    def clone(self) -> "OpenSim::HuntCrossleyForce *":
        return _simulation.HuntCrossleyForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.HuntCrossleyForce_getConcreteClassName(self)

    def copyProperty_contact_parameters(self, source: "HuntCrossleyForce") -> "void":
        return _simulation.HuntCrossleyForce_copyProperty_contact_parameters(self, source)

    def append_contact_parameters(self, value: "OpenSim::HuntCrossleyForce::ContactParametersSet const &") -> "int":
        return _simulation.HuntCrossleyForce_append_contact_parameters(self, value)

    def constructProperty_contact_parameters(self, initValue: "OpenSim::HuntCrossleyForce::ContactParametersSet const &") -> "void":
        return _simulation.HuntCrossleyForce_constructProperty_contact_parameters(self, initValue)

    def get_contact_parameters(self, *args) -> "OpenSim::HuntCrossleyForce::ContactParametersSet const &":
        return _simulation.HuntCrossleyForce_get_contact_parameters(self, *args)

    def upd_contact_parameters(self, *args) -> "OpenSim::HuntCrossleyForce::ContactParametersSet &":
        return _simulation.HuntCrossleyForce_upd_contact_parameters(self, *args)

    def set_contact_parameters(self, *args) -> "void":
        return _simulation.HuntCrossleyForce_set_contact_parameters(self, *args)

    def copyProperty_transition_velocity(self, source: "HuntCrossleyForce") -> "void":
        return _simulation.HuntCrossleyForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value: "double const &") -> "int":
        return _simulation.HuntCrossleyForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue: "double const &") -> "void":
        return _simulation.HuntCrossleyForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args) -> "double const &":
        return _simulation.HuntCrossleyForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args) -> "double &":
        return _simulation.HuntCrossleyForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args) -> "void":
        return _simulation.HuntCrossleyForce_set_transition_velocity(self, *args)

    def __init__(self):
        _simulation.HuntCrossleyForce_swiginit(self, _simulation.new_HuntCrossleyForce())

    def updContactParametersSet(self) -> "OpenSim::HuntCrossleyForce::ContactParametersSet &":
        return _simulation.HuntCrossleyForce_updContactParametersSet(self)

    def getContactParametersSet(self) -> "OpenSim::HuntCrossleyForce::ContactParametersSet const &":
        return _simulation.HuntCrossleyForce_getContactParametersSet(self)

    def addContactParameters(self, params: "OpenSim::HuntCrossleyForce::ContactParameters *") -> "void":
        r""" Takes over ownership of the passed-in object. *"""
        return _simulation.HuntCrossleyForce_addContactParameters(self, params)

    def getTransitionVelocity(self) -> "double":
        r"""Get the transition velocity for switching between static and dynamic friction."""
        return _simulation.HuntCrossleyForce_getTransitionVelocity(self)

    def setTransitionVelocity(self, velocity: "double") -> "void":
        r"""%Set the transition velocity for switching between static and dynamic friction."""
        return _simulation.HuntCrossleyForce_setTransitionVelocity(self, velocity)

    def getStiffness(self) -> "double":
        r"""Access to ContactParameters. Methods assume size 1 of ContactParametersSet and add one ContactParameter if needed"""
        return _simulation.HuntCrossleyForce_getStiffness(self)

    def setStiffness(self, stiffness: "double") -> "void":
        return _simulation.HuntCrossleyForce_setStiffness(self, stiffness)

    def getDissipation(self) -> "double":
        return _simulation.HuntCrossleyForce_getDissipation(self)

    def setDissipation(self, dissipation: "double") -> "void":
        return _simulation.HuntCrossleyForce_setDissipation(self, dissipation)

    def getStaticFriction(self) -> "double":
        return _simulation.HuntCrossleyForce_getStaticFriction(self)

    def setStaticFriction(self, friction: "double") -> "void":
        return _simulation.HuntCrossleyForce_setStaticFriction(self, friction)

    def getDynamicFriction(self) -> "double":
        return _simulation.HuntCrossleyForce_getDynamicFriction(self)

    def setDynamicFriction(self, friction: "double") -> "void":
        return _simulation.HuntCrossleyForce_setDynamicFriction(self, friction)

    def getViscousFriction(self) -> "double":
        return _simulation.HuntCrossleyForce_getViscousFriction(self)

    def setViscousFriction(self, friction: "double") -> "void":
        return _simulation.HuntCrossleyForce_setViscousFriction(self, friction)

    def addGeometry(self, name: "std::string const &") -> "void":
        return _simulation.HuntCrossleyForce_addGeometry(self, name)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.HuntCrossleyForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.HuntCrossleyForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_HuntCrossleyForce

# Register HuntCrossleyForce in _simulation:
_simulation.HuntCrossleyForce_swigregister(HuntCrossleyForce)

def HuntCrossleyForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::HuntCrossleyForce *":
    return _simulation.HuntCrossleyForce_safeDownCast(obj)

def HuntCrossleyForce_getClassName() -> "std::string const &":
    return _simulation.HuntCrossleyForce_getClassName()

class SmoothSphereHalfSpaceForce(Force):
    r"""
     This compliant contact force model is similar to HuntCrossleyForce, except
    that this model applies force even when not in contact. Unlike
    HuntCrossleyForce, the normal force is differentiable as a function of
    penetration depth. This component is designed for use in gradient-based
    optimizations, in which the model is required to be differentiable. This
    component models contact between a single sphere and a single half space.
    This force does NOT use ContactGeometry objects; the description of the
    contact geometries is done through properties of this component.



    This force applies a constant contact force even when the sphere and half-space
    are not contacting. This constant force is set with the constant_contact_force
    property. Its default value is appropriate for walking; the value may need to
    be adjusted for different contact scenarios or models with a very light mass.

    See also: SimTK::SmoothSphereHalfSpaceForce

    The graph below compares the smooth approximation of the Hertz force to that
    from HuntCrossleyForce.

     <style>div.image
    img[src="SmoothSphereHalfSpaceForce_HertzForce.png"]{width:750px;}</style>

    Image: SmoothSphereHalfSpaceForce_HertzForce.png("Curves produced using E=1e6, R=0.8, cf=1e-5, and bd=300")

    The graph below compares the smooth approximation of the dissipative force to
     that from HuntCrossleyForce.

     <style>div.image
    img[src="SmoothSphereHalfSpaceForce_HuntCrossleyForce.png"]{width:750px;}</style>

    Image: SmoothSphereHalfSpaceForce_HuntCrossleyForce.png("Curves produced using x=0.1, E=1e6, R=0.8, c=2, cf=1e-5, bd=300, and bv=50")

    Serrancoli, G., Falisse, A., Dembia, C., Vantilt, J., Tanghe, K., Lefeber, D.,
    Jonkers, I., De Schutter, J., De Groote, F. (2019). Subject-exoskeleton contact
    model calibration leads to accurate interaction force predictions. IEEE
    Transactions on Neural Systems and Rehabilitation Engineering, 1–1.
    doi:10.1109/tnsre.2019.2924536
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SmoothSphereHalfSpaceForce *":
        return _simulation.SmoothSphereHalfSpaceForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SmoothSphereHalfSpaceForce_getClassName()

    def clone(self) -> "OpenSim::SmoothSphereHalfSpaceForce *":
        return _simulation.SmoothSphereHalfSpaceForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SmoothSphereHalfSpaceForce_getConcreteClassName(self)

    def copyProperty_stiffness(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_stiffness(self, source)

    def append_stiffness(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_stiffness(self, *args)

    def upd_stiffness(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_stiffness(self, *args)

    def set_stiffness(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_dissipation(self, source)

    def append_dissipation(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_dissipation(self, *args)

    def upd_dissipation(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_dissipation(self, *args)

    def set_dissipation(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_dissipation(self, *args)

    def copyProperty_static_friction(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_static_friction(self, source)

    def append_static_friction(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_static_friction(self, value)

    def constructProperty_static_friction(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_static_friction(self, initValue)

    def get_static_friction(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_static_friction(self, *args)

    def upd_static_friction(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_static_friction(self, *args)

    def set_static_friction(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_static_friction(self, *args)

    def copyProperty_dynamic_friction(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_dynamic_friction(self, source)

    def append_dynamic_friction(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_dynamic_friction(self, value)

    def constructProperty_dynamic_friction(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_dynamic_friction(self, initValue)

    def get_dynamic_friction(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_dynamic_friction(self, *args)

    def upd_dynamic_friction(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_dynamic_friction(self, *args)

    def set_dynamic_friction(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_dynamic_friction(self, *args)

    def copyProperty_viscous_friction(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_viscous_friction(self, source)

    def append_viscous_friction(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_viscous_friction(self, value)

    def constructProperty_viscous_friction(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_viscous_friction(self, initValue)

    def get_viscous_friction(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_viscous_friction(self, *args)

    def upd_viscous_friction(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_viscous_friction(self, *args)

    def set_viscous_friction(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_viscous_friction(self, *args)

    def copyProperty_transition_velocity(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_transition_velocity(self, source)

    def append_transition_velocity(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_transition_velocity(self, value)

    def constructProperty_transition_velocity(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_transition_velocity(self, initValue)

    def get_transition_velocity(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_transition_velocity(self, *args)

    def upd_transition_velocity(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_transition_velocity(self, *args)

    def set_transition_velocity(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_transition_velocity(self, *args)

    def copyProperty_constant_contact_force(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_constant_contact_force(self, source)

    def append_constant_contact_force(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_constant_contact_force(self, value)

    def constructProperty_constant_contact_force(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_constant_contact_force(self, initValue)

    def get_constant_contact_force(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_constant_contact_force(self, *args)

    def upd_constant_contact_force(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_constant_contact_force(self, *args)

    def set_constant_contact_force(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_constant_contact_force(self, *args)

    def copyProperty_hertz_smoothing(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_hertz_smoothing(self, source)

    def append_hertz_smoothing(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_hertz_smoothing(self, value)

    def constructProperty_hertz_smoothing(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_hertz_smoothing(self, initValue)

    def get_hertz_smoothing(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_hertz_smoothing(self, *args)

    def upd_hertz_smoothing(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_hertz_smoothing(self, *args)

    def set_hertz_smoothing(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_hertz_smoothing(self, *args)

    def copyProperty_hunt_crossley_smoothing(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_hunt_crossley_smoothing(self, source)

    def append_hunt_crossley_smoothing(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_hunt_crossley_smoothing(self, value)

    def constructProperty_hunt_crossley_smoothing(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_hunt_crossley_smoothing(self, initValue)

    def get_hunt_crossley_smoothing(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_hunt_crossley_smoothing(self, *args)

    def upd_hunt_crossley_smoothing(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_hunt_crossley_smoothing(self, *args)

    def set_hunt_crossley_smoothing(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_hunt_crossley_smoothing(self, *args)

    def copyProperty_force_visualization_radius(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_force_visualization_radius(self, source)

    def append_force_visualization_radius(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_force_visualization_radius(self, value)

    def constructProperty_force_visualization_radius(self, initValue: "double const &") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_force_visualization_radius(self, initValue)

    def get_force_visualization_radius(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_force_visualization_radius(self, *args)

    def upd_force_visualization_radius(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_force_visualization_radius(self, *args)

    def set_force_visualization_radius(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_force_visualization_radius(self, *args)

    def copyProperty_force_visualization_scale_factor(self, source: "SmoothSphereHalfSpaceForce") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_copyProperty_force_visualization_scale_factor(self, source)

    def append_force_visualization_scale_factor(self, value: "double const &") -> "int":
        return _simulation.SmoothSphereHalfSpaceForce_append_force_visualization_scale_factor(self, value)

    def constructProperty_force_visualization_scale_factor(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_constructProperty_force_visualization_scale_factor(self, *args)

    def get_force_visualization_scale_factor(self, *args) -> "double const &":
        return _simulation.SmoothSphereHalfSpaceForce_get_force_visualization_scale_factor(self, *args)

    def upd_force_visualization_scale_factor(self, *args) -> "double &":
        return _simulation.SmoothSphereHalfSpaceForce_upd_force_visualization_scale_factor(self, *args)

    def set_force_visualization_scale_factor(self, *args) -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_set_force_visualization_scale_factor(self, *args)
    PropertyIndex_socket_sphere = property(_simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_sphere_get, _simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_sphere_set)

    def connectSocket_sphere(self, object: "OpenSimObject") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_connectSocket_sphere(self, object)
    PropertyIndex_socket_half_space = property(_simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_half_space_get, _simulation.SmoothSphereHalfSpaceForce_PropertyIndex_socket_half_space_set)

    def connectSocket_half_space(self, object: "OpenSimObject") -> "void":
        return _simulation.SmoothSphereHalfSpaceForce_connectSocket_half_space(self, object)

    def __init__(self, *args):
        _simulation.SmoothSphereHalfSpaceForce_swiginit(self, _simulation.new_SmoothSphereHalfSpaceForce(*args))

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Obtain names of the quantities (column labels) of the force values to
        be reported. The order is the three forces (XYZ) and three torques (XYZ)
        applied on the sphere followed by the three forces (XYZ) and three
        torques (XYZ) applied on the half space. Forces and torques are
        expressed in the ground frame.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Obtain the values to be reported that correspond to the labels. The
        values are expressed in the ground frame.
        """
        return _simulation.SmoothSphereHalfSpaceForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_SmoothSphereHalfSpaceForce

# Register SmoothSphereHalfSpaceForce in _simulation:
_simulation.SmoothSphereHalfSpaceForce_swigregister(SmoothSphereHalfSpaceForce)

def SmoothSphereHalfSpaceForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SmoothSphereHalfSpaceForce *":
    return _simulation.SmoothSphereHalfSpaceForce_safeDownCast(obj)

def SmoothSphereHalfSpaceForce_getClassName() -> "std::string const &":
    return _simulation.SmoothSphereHalfSpaceForce_getClassName()

class Actuator(Force):
    r"""
    Base class for an actuator (e.g., a torque motor, muscle, ...) that requires
    a generic external input (a vector of controls) to generate force. This class
    therefore covers scalarActautor as a special case with scalar control value.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Actuator *":
        return _simulation.Actuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Actuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Actuator_getClassName()

    def clone(self) -> "OpenSim::Actuator *":
        return _simulation.Actuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Actuator_getConcreteClassName(self)

    def numControls(self) -> "int":
        return _simulation.Actuator_numControls(self)

    def getDefaultControls(self) -> "SimTK::Vector const":
        r""" Actuator default controls are zero"""
        return _simulation.Actuator_getDefaultControls(self)

    def getControls(self, modelControls: "Vector", actuatorControls: "Vector") -> "void":
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Actuator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Actuator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Actuator_addInControls(self, actuatorControls, modelControls)

    def getPower(self, s: "State") -> "double":
        return _simulation.Actuator_getPower(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        return _simulation.Actuator_computeEquilibrium(self, s)
    __swig_destroy__ = _simulation.delete_Actuator

# Register Actuator in _simulation:
_simulation.Actuator_swigregister(Actuator)

def Actuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Actuator *":
    return _simulation.Actuator_safeDownCast(obj)

def Actuator_getClassName() -> "std::string const &":
    return _simulation.Actuator_getClassName()

class ScalarActuator(Actuator):
    r"""
    This is a derived class from the base class actuator (e.g., a torque motor,
    muscle, ...) that requires exactly one external input (control) to generate
    a scalar value force, such as a torque/force magnitude or a tension.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScalarActuator *":
        return _simulation.ScalarActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ScalarActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ScalarActuator_getClassName()

    def clone(self) -> "OpenSim::ScalarActuator *":
        return _simulation.ScalarActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ScalarActuator_getConcreteClassName(self)

    def copyProperty_min_control(self, source: "ScalarActuator") -> "void":
        r""" Default is -Infinity (no limit). *"""
        return _simulation.ScalarActuator_copyProperty_min_control(self, source)

    def append_min_control(self, value: "double const &") -> "int":
        return _simulation.ScalarActuator_append_min_control(self, value)

    def constructProperty_min_control(self, initValue: "double const &") -> "void":
        return _simulation.ScalarActuator_constructProperty_min_control(self, initValue)

    def get_min_control(self, *args) -> "double const &":
        return _simulation.ScalarActuator_get_min_control(self, *args)

    def upd_min_control(self, *args) -> "double &":
        return _simulation.ScalarActuator_upd_min_control(self, *args)

    def set_min_control(self, *args) -> "void":
        return _simulation.ScalarActuator_set_min_control(self, *args)

    def copyProperty_max_control(self, source: "ScalarActuator") -> "void":
        r""" Default is Infinity (no limit). *"""
        return _simulation.ScalarActuator_copyProperty_max_control(self, source)

    def append_max_control(self, value: "double const &") -> "int":
        return _simulation.ScalarActuator_append_max_control(self, value)

    def constructProperty_max_control(self, initValue: "double const &") -> "void":
        return _simulation.ScalarActuator_constructProperty_max_control(self, initValue)

    def get_max_control(self, *args) -> "double const &":
        return _simulation.ScalarActuator_get_max_control(self, *args)

    def upd_max_control(self, *args) -> "double &":
        return _simulation.ScalarActuator_upd_max_control(self, *args)

    def set_max_control(self, *args) -> "void":
        return _simulation.ScalarActuator_set_max_control(self, *args)
    _has_output_actuation = property(_simulation.ScalarActuator__has_output_actuation_get, _simulation.ScalarActuator__has_output_actuation_set)
    _has_output_speed = property(_simulation.ScalarActuator__has_output_speed_get, _simulation.ScalarActuator__has_output_speed_set)

    def getControl(self, s: "State") -> "double":
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.ScalarActuator_getControl(self, s)

    def numControls(self) -> "int":
        return _simulation.ScalarActuator_numControls(self)

    def setActuation(self, s: "State", aActuation: "double") -> "void":
        return _simulation.ScalarActuator_setActuation(self, s, aActuation)

    def getActuation(self, s: "State") -> "double":
        return _simulation.ScalarActuator_getActuation(self, s)

    def setSpeed(self, s: "State", aspeed: "double") -> "void":
        return _simulation.ScalarActuator_setSpeed(self, s, aspeed)

    def getSpeed(self, s: "State") -> "double":
        return _simulation.ScalarActuator_getSpeed(self, s)

    def getPower(self, s: "State") -> "double":
        return _simulation.ScalarActuator_getPower(self, s)

    def getStress(self, s: "State") -> "double":
        return _simulation.ScalarActuator_getStress(self, s)

    def getOptimalForce(self) -> "double":
        return _simulation.ScalarActuator_getOptimalForce(self)

    def setMinControl(self, aMinControl: "double const &") -> "void":
        r""" Methods to manage the bounds on ScalarActuator's control"""
        return _simulation.ScalarActuator_setMinControl(self, aMinControl)

    def getMinControl(self) -> "double":
        return _simulation.ScalarActuator_getMinControl(self)

    def setMaxControl(self, aMaxControl: "double const &") -> "void":
        return _simulation.ScalarActuator_setMaxControl(self, aMaxControl)

    def getMaxControl(self) -> "double":
        return _simulation.ScalarActuator_getMaxControl(self)

    def overrideActuation(self, s: "State", flag: "bool") -> "void":
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.ScalarActuator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s: "State") -> "bool":
        r""" return ScalarActuator's override status"""
        return _simulation.ScalarActuator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s: "State", value: "double") -> "void":
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.ScalarActuator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s: "State") -> "double":
        r"""return override actuation"""
        return _simulation.ScalarActuator_getOverrideActuation(self, s)
    __swig_destroy__ = _simulation.delete_ScalarActuator

# Register ScalarActuator in _simulation:
_simulation.ScalarActuator_swigregister(ScalarActuator)

def ScalarActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScalarActuator *":
    return _simulation.ScalarActuator_safeDownCast(obj)

def ScalarActuator_getClassName() -> "std::string const &":
    return _simulation.ScalarActuator_getClassName()

class SetActuators(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Actuator,OpenSim::Object > *":
        return _simulation.SetActuators_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetActuators_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetActuators_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Actuator,OpenSim::Object > *":
        return _simulation.SetActuators_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetActuators_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetActuators

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Actuator,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetActuators_swiginit(self, _simulation.new_SetActuators(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetActuators_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetActuators_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetActuators_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetActuators_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Actuator`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetActuators_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetActuators_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Actuator") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetActuators_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Actuator") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Actuator`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetActuators_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Actuator") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetActuators_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Actuator`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetActuators_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetActuators_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Actuator", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Actuator`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetActuators_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Actuator &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Actuator`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Actuator`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetActuators_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetActuators_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetActuators_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetActuators_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetActuators_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetActuators_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetActuators_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetActuators_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetActuators_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetActuators_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetActuators in _simulation:
_simulation.SetActuators_swigregister(SetActuators)

def SetActuators_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Actuator,OpenSim::Object > *":
    return _simulation.SetActuators_safeDownCast(obj)

def SetActuators_getClassName() -> "std::string const &":
    return _simulation.SetActuators_getClassName()

class Analysis(opensim.common.OpenSimObject):
    r"""
    An abstract class for specifying the interface for an analysis
    plugin.

    Author: Frank C. Anderson, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Analysis *":
        return _simulation.Analysis_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Analysis_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Analysis_getClassName()

    def clone(self) -> "OpenSim::Analysis *":
        return _simulation.Analysis_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Analysis_getConcreteClassName(self)
    _model = property(_simulation.Analysis__model_get, _simulation.Analysis__model_set)
    _statesStore = property(_simulation.Analysis__statesStore_get, _simulation.Analysis__statesStore_set)
    __swig_destroy__ = _simulation.delete_Analysis

    def begin(self, s: "State") -> "int":
        return _simulation.Analysis_begin(self, s)

    def step(self, s: "State", stepNumber: "int") -> "int":
        return _simulation.Analysis_step(self, s, stepNumber)

    def end(self, s: "State") -> "int":
        return _simulation.Analysis_end(self, s)

    def setModel(self, aModel: "Model") -> "void":
        r"""
        set pointer to model to be analyzed.
        :type aModel: :py:class:`Model`
        :param aModel:
        """
        return _simulation.Analysis_setModel(self, aModel)

    def setStatesStore(self, aStatesStore: "Storage") -> "void":
        r"""
        set states storage for analysis.
        :type aStatesStore: :py:class:`Storage`
        :param aStatesStore:
        """
        return _simulation.Analysis_setStatesStore(self, aStatesStore)

    def setOn(self, aTrueFalse: "bool") -> "void":
        return _simulation.Analysis_setOn(self, aTrueFalse)

    def getOn(self) -> "bool":
        return _simulation.Analysis_getOn(self)

    def setStartTime(self, aStartTime: "double") -> "void":
        return _simulation.Analysis_setStartTime(self, aStartTime)

    def getStartTime(self) -> "double":
        return _simulation.Analysis_getStartTime(self)

    def setEndTime(self, aEndTime: "double") -> "void":
        return _simulation.Analysis_setEndTime(self, aEndTime)

    def getEndTime(self) -> "double":
        return _simulation.Analysis_getEndTime(self)

    def setInDegrees(self, aTrueFalse: "bool") -> "void":
        r"""
        %Set whether or not to write the output of angles in degrees.
        This flag must be set before an analysis is performed to ensure that
        the results are in the proper format.
        :type aTrueFalse: boolean
        :param aTrueFalse: Output will be in degrees if "true" and in radians
            if "false".
        """
        return _simulation.Analysis_setInDegrees(self, aTrueFalse)

    def getInDegrees(self) -> "bool":
        return _simulation.Analysis_getInDegrees(self)

    def proceed(self, aStep: "int"=0) -> "bool":
        return _simulation.Analysis_proceed(self, aStep)

    def setStepInterval(self, aStepInterval: "int") -> "void":
        return _simulation.Analysis_setStepInterval(self, aStepInterval)

    def getStepInterval(self) -> "int":
        return _simulation.Analysis_getStepInterval(self)

    def setColumnLabels(self, aLabels: "ArrayStr") -> "void":
        r"""
        %Set the column labels for this analysis.
        :type aLabels: OpenSim::Array< std::string >
        :param aLabels: an Array of strings (labels).
        """
        return _simulation.Analysis_setColumnLabels(self, aLabels)

    def getColumnLabels(self) -> "OpenSim::Array< std::string > const &":
        return _simulation.Analysis_getColumnLabels(self)

    def getStorageList(self) -> "OpenSim::ArrayPtrs< OpenSim::Storage > &":
        return _simulation.Analysis_getStorageList(self)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _simulation.Analysis_setPrintResultFiles(self, aToWrite)

    def getPrintResultFiles(self) -> "bool":
        return _simulation.Analysis_getPrintResultFiles(self)

    def printResults(self, *args) -> "int":
        r"""
        Print the results of the analysis.

        :type aBaseName: string
        :param aBaseName: Base name of file to which to print the data.
        :type aDir: string, optional
        :param aDir:      Directory name.
        :type aDT: float, optional
        :param aDT:       Time interval between results (linear interpolation
                             is used). If not supplied as an argument or negative,
                             all time steps are printed without interpolation.
        :type aExtension: string, optional
        :param aExtension:    File extension if not the default ".sto".

        :rtype: int
        :return: -1 on error, 0 otherwise.
        """
        return _simulation.Analysis_printResults(self, *args)

# Register Analysis in _simulation:
_simulation.Analysis_swigregister(Analysis)

def Analysis_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Analysis *":
    return _simulation.Analysis_safeDownCast(obj)

def Analysis_getClassName() -> "std::string const &":
    return _simulation.Analysis_getClassName()

class SetAnalysis(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Analysis,OpenSim::Object > *":
        return _simulation.SetAnalysis_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetAnalysis_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetAnalysis_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Analysis,OpenSim::Object > *":
        return _simulation.SetAnalysis_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetAnalysis_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetAnalysis

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Analysis,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetAnalysis_swiginit(self, _simulation.new_SetAnalysis(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetAnalysis_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetAnalysis_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetAnalysis_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetAnalysis_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Analysis`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetAnalysis_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetAnalysis_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Analysis") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetAnalysis_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Analysis") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Analysis`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetAnalysis_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Analysis") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetAnalysis_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Analysis`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetAnalysis_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetAnalysis_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Analysis", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Analysis`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetAnalysis_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Analysis &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Analysis`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Analysis`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetAnalysis_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetAnalysis_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetAnalysis_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetAnalysis_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetAnalysis_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetAnalysis_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetAnalysis_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetAnalysis_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetAnalysis_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetAnalysis_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetAnalysis in _simulation:
_simulation.SetAnalysis_swigregister(SetAnalysis)

def SetAnalysis_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Analysis,OpenSim::Object > *":
    return _simulation.SetAnalysis_safeDownCast(obj)

def SetAnalysis_getClassName() -> "std::string const &":
    return _simulation.SetAnalysis_getClassName()

class AnalysisSet(SetAnalysis):
    r"""
    A class for holding and managing a set of integration callbacks for
    a model.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalysisSet *":
        return _simulation.AnalysisSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.AnalysisSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.AnalysisSet_getClassName()

    def clone(self) -> "OpenSim::AnalysisSet *":
        return _simulation.AnalysisSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.AnalysisSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.AnalysisSet_swiginit(self, _simulation.new_AnalysisSet(*args))
    __swig_destroy__ = _simulation.delete_AnalysisSet

    def setModel(self, aModel: "Model") -> "void":
        return _simulation.AnalysisSet_setModel(self, aModel)

    def getModel(self) -> "OpenSim::Model &":
        return _simulation.AnalysisSet_getModel(self)

    def setOn(self, *args) -> "void":
        return _simulation.AnalysisSet_setOn(self, *args)

    def getOn(self) -> "OpenSim::Array< bool >":
        return _simulation.AnalysisSet_getOn(self)

    def begin(self, s: "State") -> "void":
        return _simulation.AnalysisSet_begin(self, s)

    def step(self, s: "State", stepNumber: "int") -> "void":
        return _simulation.AnalysisSet_step(self, s, stepNumber)

    def end(self, s: "State") -> "void":
        return _simulation.AnalysisSet_end(self, s)

    def printResults(self, *args) -> "void":
        return _simulation.AnalysisSet_printResults(self, *args)

    @staticmethod
    def getAvailableAnalyses(analysisset: "AnalysisSet") -> "void":
        return _simulation.AnalysisSet_getAvailableAnalyses(analysisset)

    def adoptAndAppend(self, aAnalysis):
        aAnalysis._markAdopted()
        return super(AnalysisSet, self).adoptAndAppend(aAnalysis)


# Register AnalysisSet in _simulation:
_simulation.AnalysisSet_swigregister(AnalysisSet)

def AnalysisSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalysisSet *":
    return _simulation.AnalysisSet_safeDownCast(obj)

def AnalysisSet_getClassName() -> "std::string const &":
    return _simulation.AnalysisSet_getClassName()

def AnalysisSet_getAvailableAnalyses(analysisset: "AnalysisSet") -> "void":
    return _simulation.AnalysisSet_getAvailableAnalyses(analysisset)

class Control(opensim.common.OpenSimObject):
    r"""
    A class that represents a control in a dynamic simulation.

    This class is intended to be the base class for different types of controls,
    so many of its methods are virtual.

    In general, a control consists of a set of parameters.  These parameters
    are used to reconstruct a control curve.  For example, a control may be
    represented by a constant, a series of step functions, a set of linearly
    interpolated values, a set of spline control points, coefficients in
    a Fourier series, etc.

    Because there is not necessarily a 1-to-1 correspondence between the
    parameters used to represent a control curve and the value of the
    control curve, there are two basic ways to access the content of a control:
    getParameter() gets the value of a parameter, and getValue() gets the
    value at a particular time.

    A distinction is also made between controls that control a model and
    controls that control some other aspect of a simulation.  For example,
    a control for the excitation level of a muscle is a "model"
    control.  The value of this type of control is queried during the
    course of a simulation.  On the other hand, a control for
    the final time of a simulation is not usually a "model" control.
    Nor is a control for the initial value of a state variable, even if that
    state variable is the initial value of a muscle activation.  These
    "non-model" controls are used to set things before a simulation ever
    begins and are not queried during the course of a simulation.  The
    number of model controls can be queried by a call to
    Model::getNumControls().

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Control *":
        return _simulation.Control_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Control_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Control_getClassName()

    def clone(self) -> "OpenSim::Control *":
        return _simulation.Control_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Control_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_Control

    def setIsModelControl(self, aTrueFalse: "bool") -> "void":
        r"""
        Sets whether or not this control is a model control.  A model control is
        a control that is expected by a model. Controls that are not model
        controls may be, for example, controls that are used to set up a
        simulation.  Such examples might include an initial state of a model
        (e.g., joint angle, joint angular velocity, ...) or the final time of
        a simulation.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, the control is treated as a model control.
            If false, the control is not treated as a model control.
        """
        return _simulation.Control_setIsModelControl(self, aTrueFalse)

    def getIsModelControl(self) -> "bool":
        r""" See also: setIsModelControl()"""
        return _simulation.Control_getIsModelControl(self)

    def setExtrapolate(self, aTrueFalse: "bool") -> "void":
        r"""
        Sets whether or not to extrapolate for control curve evaluations that
        are outside the region of confidence for a control.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, extrapolate when needed and possible to
            determine the value of the control curve.
        """
        return _simulation.Control_setExtrapolate(self, aTrueFalse)

    def getExtrapolate(self) -> "bool":
        r""" See also: setExtrapolate()"""
        return _simulation.Control_getExtrapolate(self)

    def setFilterOn(self, aTrueFalse: "bool") -> "void":
        r"""
        Sets whether or not to apply a PD (proportional-derivative)
        filter to the control values.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, will apply a filter to the control
            values.  If false, a filter will not be used.
        """
        return _simulation.Control_setFilterOn(self, aTrueFalse)

    def getFilterOn(self) -> "bool":
        r""" See also: setFilterOn()"""
        return _simulation.Control_getFilterOn(self)

    def getNumParameters(self) -> "int":
        r"""
        Returns the number of parameters that are used to specify the
        control curve.
        """
        return _simulation.Control_getNumParameters(self)

    def setDefaultParameterMin(self, aMin: "double") -> "void":
        r"""
        Sets the default minimum value of a control parameter.
        The default minimum is used when no minimum value is specified.

        :type aMin: float
        :param aMin: Minimum value.
        """
        return _simulation.Control_setDefaultParameterMin(self, aMin)

    def getDefaultParameterMin(self) -> "double":
        r""" See also: setDefaultParameterMin()"""
        return _simulation.Control_getDefaultParameterMin(self)

    def setDefaultParameterMax(self, aMax: "double") -> "void":
        r"""
        Sets the default maximum value of a control parameter.
        The default maximum is used when no maximum value is specified.

        :type aMax: float
        :param aMax: Maximum value.
        """
        return _simulation.Control_setDefaultParameterMax(self, aMax)

    def getDefaultParameterMax(self) -> "double":
        r""" See also: setDefaultParameterMax()"""
        return _simulation.Control_getDefaultParameterMax(self)

    def setParameterMin(self, aI: "int", aMin: "double") -> "void":
        r"""
        Sets the minimum value that a control parameter  can take on.

        :type aI: int
        :param aI: Index of the parameter.
        :type aMin: float
        :param aMin: Minimum value the parameter can have.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI: "int") -> "double":
        r"""
        See also: setParameterMin()
        :type aI: int
        :param aI: Index of the parameter for which the minimum value is desired.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterMin(self, aI)

    def setParameterMax(self, aI: "int", aMax: "double") -> "void":
        r"""
        %Set the maximum value that a control parameter can take on.

        :type aI: int
        :param aI: Index of the parameter.
        :type aMax: float
        :param aMax: Maximum value the parameter can have.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI: "int") -> "double":
        r"""
        See also: setParameterMax()
        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterMax(self, aI)

    def getParameterTime(self, aI: "int") -> "double":
        r"""
        Gets the time at which a parameter is specified.

        Parameters for some types of control curves do not have a time at which
        they are specified.  For example, in a Fourier series the control
        parameters are the coefficients in the expansion, and each term in
        the expansion corresponds not to a specific time but to a frequency.
        Another example is a constant that has the same value for all times.
        In these cases, this method returns SimTK::NaN.

        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI: "int", rTLower: "double &", rTUpper: "double &") -> "void":
        r"""
        Gets the time neighborhood (i.e., the lower and upper bounds of time)
        in which a control parameter affects the value of the control curve.

        Changes in the specified parameter are guaranteed not to change the value
        of the control curve below the lower bound time or above the upper bound
        time.  If a parameter influences the value of the control curve for all
        times, -%SimTK::Infinity and %SimTK::Infinity are returned for
        the upper and lower bound times, respectively.

        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: Time below which the curve is not affected by the
            specified parameter.
        :type rTUpper: float
        :param rTUpper: Time above which the curve is not affected by the
            specified parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args) -> "int":
        r"""
        *Overload 1:*

        Gets the list of parameters that affect the control curve at a
        specified time.

        :type aT: float
        :param aT: Time in question.
        :type rList: OpenSim::Array< int >
        :param rList: The returned list of parameters.
        :rtype: int
        :return: Length of rList.

        |

        *Overload 2:*

        Gets the list of parameters that affect the control curve between two
        specified times and that do NOT affect the control curve below the lower
        of these two times.

        This method is useful when solving for a set of controls for a dynamic
        simulation.  When solving for a set of controls, one always wants to
        go forward in time.  Therefore, one does not want to change control
        parameters that affect the control curve at past times.

        A control parameter is included in the list only if it affects
        the control curve in the specified time interval AND does NOT
        affect the control curve below the lower bound of the
        specified time interval.  So, it is possible that some of the
        parameters on the returned list could affect the control curve at
        times greater than the upper bound of the specified time interval.

        :type aTLower: float
        :param aTLower: Lower time bound.
        :type aTUpper: float
        :param aTUpper: Upper time bound.
        :type rList: OpenSim::Array< int >
        :param rList: List of indices of the control parameters that
            affect the curve between aTLower and aTUpper but not before aTLower.
        :rtype: int
        :return: Length of rList.
        """
        return _simulation.Control_getParameterList(self, *args)

    def getParameterValue(self, aI: "int") -> "double":
        r""" See also: setParameterValue()"""
        return _simulation.Control_getParameterValue(self, aI)

    def setParameterValue(self, aI: "int", aX: "double") -> "void":
        r"""
        Sets the value of a control parameter.

        :type aI: int
        :param aI: Index of the parameter.
        :type aX: float
        :param aX: Value of the parameter. Meaning depends on the subclass.
        :raises: Exception if aI is invalid.
        """
        return _simulation.Control_setParameterValue(self, aI, aX)

    def getControlValue(self, aT: "double"=0.0) -> "double":
        r"""
        Gets the value of this control at time aT.
        If the value of the curve is not defined,
        SimTK::NaN is returned.  If the control is set to extrapolate,
        (see getExtrapolate()), and the time is before that of the first node or
        after that of the last node, then an extrapolation is performed to
        determine the value of the control curve.  Otherwise, the value of
        either the first control node or last control node is returned.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        """
        return _simulation.Control_getControlValue(self, aT)

    def setControlValue(self, aT: "double", aX: "double") -> "void":
        r"""
        Sets the value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aX: float
        :param aX: Control value.
        """
        return _simulation.Control_setControlValue(self, aT, aX)

    def getControlValueMin(self, aT: "double"=0.0) -> "double":
        r"""
        Gets the minimum allowed value of this control at time aT.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        :rtype: float
        :return: Minimum allowed control value.  If the value of the curve
            is not defined,
            _defaultMin is returned.  If the control is set to extrapolate,
            (see getExtraplate()), and the time is before the first node or
            after the last node, then an extrapolation is performed to determine
            the value of the control curve.  Otherwise, the value of either the
            first control node or last control node is returned.
        """
        return _simulation.Control_getControlValueMin(self, aT)

    def setControlValueMin(self, aT: "double", aMin: "double") -> "void":
        r"""
        Sets the minimum value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aMin: float
        :param aMin: Minimum allowed control value at time aT.
        """
        return _simulation.Control_setControlValueMin(self, aT, aMin)

    def getControlValueMax(self, aT: "double"=0.0) -> "double":
        r"""
        Gets the maximum allowed value of this control at time aT.

        :type aT: float, optional
        :param aT: Time at which to get the control.
        :rtype: float
        :return: Maximum allowed control value.  If the value of the curve is not defined,
            _defaultMax is returned.  If the control is set to extrapolate,
            getExtraplate, and the time is before the first node or
            after the last node, then an extrapolation is performed to determine
            the value of the control curve.  Otherwise, the value of either the
            first control node or last control node is returned.
        """
        return _simulation.Control_getControlValueMax(self, aT)

    def setControlValueMax(self, aT: "double", aMax: "double") -> "void":
        r"""
        Sets the maximum value of this control curve at time aT.

        :type aT: float
        :param aT: Time at which to set the control.
        :type aMax: float
        :param aMax: Maximum allowed control value.
        """
        return _simulation.Control_setControlValueMax(self, aT, aMax)

    def getFirstTime(self) -> "double":
        r"""
        Gets the first time for which a parameter is specified. Should be
        overridden by derived classes that have a defined min time.

        :rtype: float
        :return: 0.
        """
        return _simulation.Control_getFirstTime(self)

    def getLastTime(self) -> "double":
        r"""
        Gets the last time for which a parameter is specified. Should be overridden
        by derived classes that have a defined max time.

        :rtype: float
        :return: 0.
        """
        return _simulation.Control_getLastTime(self)

    def simplify(self, aProperties: "PropertySet const &") -> "void":
        r"""
        Simplify the control (e.g., reduce the number of points in the control
        curve) based on a set of specified properties.  Each implementation
        is free to require whatever properties are needed to perform
        the simplification.  Refer to the documentation in derived classes
        to see what properties are required.

        :type aProperties: PropertySet
        :param aProperties: PropertySet used to perform the simplify
            operation.
        :raises: Exception This method does nothing.  It must be overridden
            in derived classes.
        """
        return _simulation.Control_simplify(self, aProperties)

    def filter(self, aT: "double") -> "void":
        r"""
        Filter the control curve at a particular time.

        :type aT: float
        :param aT: Time at which to compute a new, filtered control value
        """
        return _simulation.Control_filter(self, aT)

# Register Control in _simulation:
_simulation.Control_swigregister(Control)

def Control_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Control *":
    return _simulation.Control_safeDownCast(obj)

def Control_getClassName() -> "std::string const &":
    return _simulation.Control_getClassName()

class SetControls(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Control,OpenSim::Object > *":
        return _simulation.SetControls_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetControls_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetControls_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Control,OpenSim::Object > *":
        return _simulation.SetControls_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetControls_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetControls

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Control,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetControls_swiginit(self, _simulation.new_SetControls(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetControls_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetControls_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControls_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControls_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Control`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControls_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetControls_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Control") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Control`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControls_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Control") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Control`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControls_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Control") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Control`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControls_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Control`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControls_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetControls_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Control", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Control`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetControls_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Control &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Control`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Control`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControls_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetControls_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetControls_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetControls_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetControls_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetControls_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetControls_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetControls_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetControls_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetControls_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetControls in _simulation:
_simulation.SetControls_swigregister(SetControls)

def SetControls_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Control,OpenSim::Object > *":
    return _simulation.SetControls_safeDownCast(obj)

def SetControls_getClassName() -> "std::string const &":
    return _simulation.SetControls_getClassName()

class ControlSet(SetControls):
    r"""
    A class for holding and managing a set of controls for a dynamic
    simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlSet *":
        return _simulation.ControlSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ControlSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ControlSet_getClassName()

    def clone(self) -> "OpenSim::ControlSet *":
        return _simulation.ControlSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ControlSet_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ControlSet

    def __init__(self, *args):
        _simulation.ControlSet_swiginit(self, _simulation.new_ControlSet(*args))

    def getSize(self, aForModelControls: "bool"=True) -> "int":
        return _simulation.ControlSet_getSize(self, aForModelControls)

    def getControlList(self, aType: "char const *", rList: "ArrayInt", aForModelControls: "bool"=True) -> "void":
        return _simulation.ControlSet_getControlList(self, aType, rList, aForModelControls)

    def getControlValues(self, aT: "double", rX: "ArrayDouble", aForModelControls: "bool"=True) -> "void":
        return _simulation.ControlSet_getControlValues(self, aT, rX, aForModelControls)

    def setControlValues(self, aT: "double", aX: "ArrayDouble", aForModelControls: "bool"=True) -> "void":
        return _simulation.ControlSet_setControlValues(self, aT, aX, aForModelControls)

    def getNumParameters(self, aForModelControls: "bool"=True) -> "int":
        return _simulation.ControlSet_getNumParameters(self, aForModelControls)

    def getParameterList(self, *args) -> "void":
        return _simulation.ControlSet_getParameterList(self, *args)

    def getParameterMins(self, rMins: "ArrayDouble", aList: "ArrayInt"=None) -> "void":
        return _simulation.ControlSet_getParameterMins(self, rMins, aList)

    def getParameterMaxs(self, rMaxs: "ArrayDouble", aList: "ArrayInt"=None) -> "void":
        return _simulation.ControlSet_getParameterMaxs(self, rMaxs, aList)

    def getParameterValues(self, rP: "ArrayDouble", aList: "ArrayInt"=None) -> "void":
        return _simulation.ControlSet_getParameterValues(self, rP, aList)

    def setParameterValues(self, aP: "ArrayDouble", aList: "ArrayInt"=None) -> "void":
        return _simulation.ControlSet_setParameterValues(self, aP, aList)

    def simplify(self, aProperties: "PropertySet const &") -> "void":
        return _simulation.ControlSet_simplify(self, aProperties)

    def filter(self, aT: "double") -> "void":
        return _simulation.ControlSet_filter(self, aT)

    def constructStorage(self, aN: "int", aT1: "double", aT2: "double", aForModelControls: "bool") -> "OpenSim::Storage *":
        return _simulation.ControlSet_constructStorage(self, aN, aT1, aT2, aForModelControls)

    def mapParameterToControl(self, aIndex: "int") -> "int":
        return _simulation.ControlSet_mapParameterToControl(self, aIndex)

    def mapParameterToParameter(self, aIndex: "int") -> "int":
        return _simulation.ControlSet_mapParameterToParameter(self, aIndex)

    def generateParameterMaps(self) -> "void":
        return _simulation.ControlSet_generateParameterMaps(self)

    def adoptAndAppend(self, aControl):
        aControl._markAdopted()
        return super(ControlSet, self).adoptAndAppend(aControl)


# Register ControlSet in _simulation:
_simulation.ControlSet_swigregister(ControlSet)

def ControlSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlSet *":
    return _simulation.ControlSet_safeDownCast(obj)

def ControlSet_getClassName() -> "std::string const &":
    return _simulation.ControlSet_getClassName()

class ControlConstant(Control):
    r"""
    A class that represents a constant control curve.  That is, the value
    of the control curve is the same at any value of time.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlConstant *":
        return _simulation.ControlConstant_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ControlConstant_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ControlConstant_getClassName()

    def clone(self) -> "OpenSim::ControlConstant *":
        return _simulation.ControlConstant_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ControlConstant_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ControlConstant

    def getNumParameters(self) -> "int":
        return _simulation.ControlConstant_getNumParameters(self)

    def setParameterMin(self, aI: "int", aMin: "double") -> "void":
        return _simulation.ControlConstant_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI: "int") -> "double":
        return _simulation.ControlConstant_getParameterMin(self, aI)

    def setParameterMax(self, aI: "int", aMax: "double") -> "void":
        return _simulation.ControlConstant_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI: "int") -> "double":
        return _simulation.ControlConstant_getParameterMax(self, aI)

    def getParameterTime(self, aI: "int") -> "double":
        r"""
        For ControlConstant, parameters are not associated with any specific time.

        :type aI: int
        :param aI: Index of the parameter.
        :rtype: float
        :return: SimTK::NaN
        """
        return _simulation.ControlConstant_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI: "int", rTLower: "double &", rTUpper: "double &") -> "void":
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: -%SimTK::Infinity
        :type rTUpper: float
        :param rTUpper: %SimTK::Infinity
        """
        return _simulation.ControlConstant_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args) -> "int":
        return _simulation.ControlConstant_getParameterList(self, *args)

    def setParameterValue(self, aI: "int", aX: "double") -> "void":
        r"""
        :type aI: int
        :param aI: Only 0 is valid for ControlConstant.
        :type aX: float
        :param aX: The constant value of this control curve.
        """
        return _simulation.ControlConstant_setParameterValue(self, aI, aX)

    def getParameterValue(self, aI: "int") -> "double":
        r"""
        See also: setParameterValue()
        :type aI: int
        :param aI: Only 0 is valid for ControlConstant.
        :rtype: float
        :return: The constant value of this control curve.
        """
        return _simulation.ControlConstant_getParameterValue(self, aI)

    def setControlValue(self, aT: "double", aX: "double") -> "void":
        r"""
        :type aT: float
        :param aT: Not used since the control value is constant in time.
        :type aX: float
        :param aX: Control value.
        """
        return _simulation.ControlConstant_setControlValue(self, aT, aX)

    def getControlValue(self, aT: "double") -> "double":
        r"""
        :type aT: float
        :param aT: Not used since the control value is constant in time.
        """
        return _simulation.ControlConstant_getControlValue(self, aT)

    def getControlValueMin(self, aT: "double"=0.0) -> "double":
        return _simulation.ControlConstant_getControlValueMin(self, aT)

    def setControlValueMin(self, aT: "double", aX: "double") -> "void":
        return _simulation.ControlConstant_setControlValueMin(self, aT, aX)

    def getControlValueMax(self, aT: "double"=0.0) -> "double":
        return _simulation.ControlConstant_getControlValueMax(self, aT)

    def setControlValueMax(self, aT: "double", aX: "double") -> "void":
        return _simulation.ControlConstant_setControlValueMax(self, aT, aX)

# Register ControlConstant in _simulation:
_simulation.ControlConstant_swigregister(ControlConstant)

def ControlConstant_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlConstant *":
    return _simulation.ControlConstant_safeDownCast(obj)

def ControlConstant_getClassName() -> "std::string const &":
    return _simulation.ControlConstant_getClassName()

class ControlLinearNode(opensim.common.OpenSimObject):
    r"""
    A control node used to reconstruct a piecewise linear control.

    The member variables consist of a time, a value, a minimum value, and
    a maximum value.  So that an Array<T> can be instantiated for
    ControlLinearNode, this class implements a default constructor, a copy
    constructor, the assignment operator (=), the equality operator (==),
    and the less than operator (<).  The time at which a control node
    occurs is used to determine the results of the operators == and <.

    Author: Frank C. Anderson
    Version: 1.0
    See also: ControlLinear
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlLinearNode *":
        return _simulation.ControlLinearNode_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ControlLinearNode_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ControlLinearNode_getClassName()

    def clone(self) -> "OpenSim::ControlLinearNode *":
        return _simulation.ControlLinearNode_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ControlLinearNode_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ControlLinearNode_swiginit(self, _simulation.new_ControlLinearNode(*args))
    __swig_destroy__ = _simulation.delete_ControlLinearNode

    def setTime(self, aT: "double") -> "void":
        return _simulation.ControlLinearNode_setTime(self, aT)

    def getTime(self) -> "double":
        return _simulation.ControlLinearNode_getTime(self)

    def setValue(self, aValue: "double") -> "void":
        return _simulation.ControlLinearNode_setValue(self, aValue)

    def getValue(self) -> "double":
        return _simulation.ControlLinearNode_getValue(self)

    def toString(self) -> "char *":
        return _simulation.ControlLinearNode_toString(self)

# Register ControlLinearNode in _simulation:
_simulation.ControlLinearNode_swigregister(ControlLinearNode)

def ControlLinearNode_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlLinearNode *":
    return _simulation.ControlLinearNode_safeDownCast(obj)

def ControlLinearNode_getClassName() -> "std::string const &":
    return _simulation.ControlLinearNode_getClassName()

class SetControlNodes(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_SetControlNodes

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >
        :param aArray: Array to be copied.
        """
        _simulation.SetControlNodes_swiginit(self, _simulation.new_SetControlNodes(*args))

    def clearAndDestroy(self) -> "void":
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _simulation.SetControlNodes_clearAndDestroy(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetControlNodes_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetControlNodes_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _simulation.SetControlNodes_size(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetControlNodes_getIndex(self, *args)

    def append(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetControlNodes_append(self, *args)

    def insert(self, aIndex: "int", aObject: "ControlLinearNode") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetControlNodes_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetControlNodes_remove(self, *args)

    def set(self, aIndex: "int", aObject: "ControlLinearNode") -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`ControlLinearNode`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _simulation.SetControlNodes_set(self, aIndex, aObject)

    def get(self, *args) -> "OpenSim::ControlLinearNode *":
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetControlNodes_get(self, *args)

    def getLast(self) -> "OpenSim::ControlLinearNode *":
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`ControlLinearNode`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`ControlLinearNode`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.SetControlNodes_getLast(self)

    def searchBinary(self, aObject: "OpenSim::ArrayPtrs< OpenSim::ControlLinearNode >::ConstT &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _simulation.SetControlNodes_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register SetControlNodes in _simulation:
_simulation.SetControlNodes_swigregister(SetControlNodes)

class ControlLinear(Control):
    r"""
    A class that represents a piece-wise linear control curve.

    The curve is specified by an array of control nodes (see class
    ControlLinearNode) that occur at monotonically increasing times.
    The value of the control curve is computed by linearly interpolating
    the values of the appropriate control nodes.

    For this Control, *parameters* are the values of the
    ControlLinearNode's.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlLinear *":
        return _simulation.ControlLinear_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ControlLinear_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ControlLinear_getClassName()

    def clone(self) -> "OpenSim::ControlLinear *":
        return _simulation.ControlLinear_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ControlLinear_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ControlLinear_swiginit(self, _simulation.new_ControlLinear(*args))
    __swig_destroy__ = _simulation.delete_ControlLinear

    def copyData(self, aControl: "ControlLinear") -> "void":
        r"""
        Copy the member variables of the specified ControlLinear over
        to this ControlLinear.
        """
        return _simulation.ControlLinear_copyData(self, aControl)

    def setUseSteps(self, aTrueFalse: "bool") -> "void":
        r"""
        Sets whether or not step functions are used between control nodes or
        linear interpolation.  When step functions are used, the value of the
        control curve between two nodes is the value of the node that occurs
        **later** in time.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, step functions will be used to determine the
            value between adjacent nodes.  If false, linear interpolation will be used.
        """
        return _simulation.ControlLinear_setUseSteps(self, aTrueFalse)

    def getUseSteps(self) -> "bool":
        r"""See also: setUseSteps()"""
        return _simulation.ControlLinear_getUseSteps(self)

    def setKp(self, aKp: "double") -> "void":
        r"""
        Sets the position gain for PD follower filter.  This value is relevant
        only if the PD follower filter will be used.

        See also: setFilterOn()

        :type aKp: float
        :param aKp: Value of position gain for the PD follower filter.
        """
        return _simulation.ControlLinear_setKp(self, aKp)

    def getKp(self) -> "double":
        r""" See also: setKp()"""
        return _simulation.ControlLinear_getKp(self)

    def setKv(self, aKv: "double") -> "void":
        r"""
        Sets the velocity gain for PD follower filter.  This value is relevant
        only if the PD follower filter will be used.

        See also: setFilterOn()

        :type aKv: float
        :param aKv: Value of velocity gain for the PD follower filter.
        """
        return _simulation.ControlLinear_setKv(self, aKv)

    def getKv(self) -> "double":
        r""" See also: setKv()"""
        return _simulation.ControlLinear_getKv(self)

    def getNumParameters(self) -> "int":
        return _simulation.ControlLinear_getNumParameters(self)

    def setParameterMin(self, aI: "int", aMin: "double") -> "void":
        return _simulation.ControlLinear_setParameterMin(self, aI, aMin)

    def getParameterMin(self, aI: "int") -> "double":
        return _simulation.ControlLinear_getParameterMin(self, aI)

    def setParameterMax(self, aI: "int", aMax: "double") -> "void":
        return _simulation.ControlLinear_setParameterMax(self, aI, aMax)

    def getParameterMax(self, aI: "int") -> "double":
        return _simulation.ControlLinear_getParameterMax(self, aI)

    def getParameterTime(self, aI: "int") -> "double":
        r"""
        Get the time at which a parameter (control curve value) is specified.

        Not for minimum or maximum values of parameters; only for specified
        values of the control curve, as set via setParameterValue() or
        setControlValue().

        :type aI: int
        :param aI: Index of the parameter.
        :raises: Exception if aI is invalid.
        """
        return _simulation.ControlLinear_getParameterTime(self, aI)

    def getParameterNeighborhood(self, aI: "int", rTLower: "double &", rTUpper: "double &") -> "void":
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type rTLower: float
        :param rTLower: The time of parameter aI-1 or of
            aI if there is no parameter aI-1.  If there are no ControlLinearNode's
            at all or if aI is invalid, rTLower is given the value SimTK::NaN.
        :type rTUpper: float
        :param rTUpper: The time of parameter aI+1 or of
            aI if there is no parameter aI+1.  If there are no ControlLinearNode's
            at all or if aI is invalid, rTUpper is given the value SimTK::NaN.
        """
        return _simulation.ControlLinear_getParameterNeighborhood(self, aI, rTLower, rTUpper)

    def getParameterList(self, *args) -> "int":
        return _simulation.ControlLinear_getParameterList(self, *args)

    def setParameterValue(self, aI: "int", aP: "double") -> "void":
        r"""
        :type aI: int
        :param aI: Index of the parameter.
        :type aP: float
        :param aP: The parameter value is simply the value of
            the aI-th ControlLinearNode (which is the value of the control curve).
        """
        return _simulation.ControlLinear_setParameterValue(self, aI, aP)

    def getParameterValue(self, aI: "int") -> "double":
        r""" See also: setParameterValue()"""
        return _simulation.ControlLinear_getParameterValue(self, aI)

    def setControlValue(self, aT: "double", aX: "double") -> "void":
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing ControlLinearNode,
        in which case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValue(self, aT, aX)

    def getControlValue(self, aT: "double") -> "double":
        return _simulation.ControlLinear_getControlValue(self, aT)

    def getControlValueMin(self, aT: "double"=0.0) -> "double":
        return _simulation.ControlLinear_getControlValueMin(self, aT)

    def setControlValueMin(self, aT: "double", aX: "double") -> "void":
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing control node, in which
        case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValueMin(self, aT, aX)

    def getControlValueMax(self, aT: "double"=0.0) -> "double":
        return _simulation.ControlLinear_getControlValueMax(self, aT)

    def setControlValueMax(self, aT: "double", aX: "double") -> "void":
        r"""
        This method adds a set of control parameters at the specified time unless
        the specified time equals the time of an existing control node, in which
        case the parameters of that control node are changed.
        """
        return _simulation.ControlLinear_setControlValueMax(self, aT, aX)

    def clearControlNodes(self) -> "void":
        return _simulation.ControlLinear_clearControlNodes(self)

    def getControlValues(self) -> "OpenSim::ArrayPtrs< OpenSim::ControlLinearNode > &":
        return _simulation.ControlLinear_getControlValues(self)

    def getControlMinValues(self) -> "OpenSim::ArrayPtrs< OpenSim::ControlLinearNode > &":
        return _simulation.ControlLinear_getControlMinValues(self)

    def getControlMaxValues(self) -> "OpenSim::ArrayPtrs< OpenSim::ControlLinearNode > &":
        return _simulation.ControlLinear_getControlMaxValues(self)

    def insertNewValueNode(self, index: "int", newNode: "ControlLinearNode") -> "void":
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewValueNode(self, index, newNode)

    def insertNewMinNode(self, index: "int", newNode: "ControlLinearNode") -> "void":
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewMinNode(self, index, newNode)

    def insertNewMaxNode(self, index: "int", newNode: "ControlLinearNode") -> "void":
        r""" Called from GUI to work around early garbage collection."""
        return _simulation.ControlLinear_insertNewMaxNode(self, index, newNode)

    def getFirstTime(self) -> "double":
        r"""The time corresponding to the first ControlLinearNode."""
        return _simulation.ControlLinear_getFirstTime(self)

    def getLastTime(self) -> "double":
        r"""The time corresponding to the last ControlLinearNode"""
        return _simulation.ControlLinear_getLastTime(self)

    def simplify(self, *args) -> "bool":
        r"""
        *Overload 1:*

        The number of control nodes is reduced by first applying a lowpass filter
        to the sequence of control nodes using a specified cutoff frequency and
        then removing nodes that keep the curve within a specified distance
        to the low-pass filtered curve.

        The PropertySet should contain:


        |TYPE|NAME|
        |PropertyDbl|cutoff_frequency|
        |PropertyDbl|distance|


        :type aProperties: PropertySet
        :param aProperties: PropertySet containing the needed properties for
            this method.
        :raises: Exception if an error is encountered.

        |

        *Overload 2:*

        Another interface to simplify that:
        (1) does not require properties, and (2) returns bool on failure
        for a more graceful batch simplification.
        """
        return _simulation.ControlLinear_simplify(self, *args)

    def filter(self, aT: "double") -> "void":
        r"""
        Filter the control curve at a particular time using a PD follower filter.

        See also: setFilterOn()

        :type aT: float
        :param aT: Time at which to compute a new, filtered control value
        """
        return _simulation.ControlLinear_filter(self, aT)

    @staticmethod
    def Interpolate(aX1: "double", aY1: "double", aX2: "double", aY2: "double", aX: "double") -> "double":
        r"""
        Linearly interpolate or extrapolate given two points.

        :type aX1: float
        :param aX1: X coordinate of point 1.
        :type aY1: float
        :param aY1: Y coordinate of point 1.
        :type aX2: float
        :param aX2: X coordinate of point 2.
        :type aY2: float
        :param aY2: Y coordinate of point 2.
        :type aX: float
        :param aX: X coordinate whose corresponding Y coordinate is desired.
        :rtype: float
        :return: Y value corresponding to aX.
        """
        return _simulation.ControlLinear_Interpolate(aX1, aY1, aX2, aY2, aX)

# Register ControlLinear in _simulation:
_simulation.ControlLinear_swigregister(ControlLinear)

def ControlLinear_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ControlLinear *":
    return _simulation.ControlLinear_safeDownCast(obj)

def ControlLinear_getClassName() -> "std::string const &":
    return _simulation.ControlLinear_getClassName()

def ControlLinear_Interpolate(aX1: "double", aY1: "double", aX2: "double", aY2: "double", aX: "double") -> "double":
    r"""
    Linearly interpolate or extrapolate given two points.

    :type aX1: float
    :param aX1: X coordinate of point 1.
    :type aY1: float
    :param aY1: Y coordinate of point 1.
    :type aX2: float
    :param aX2: X coordinate of point 2.
    :type aY2: float
    :param aY2: Y coordinate of point 2.
    :type aX: float
    :param aX: X coordinate whose corresponding Y coordinate is desired.
    :rtype: float
    :return: Y value corresponding to aX.
    """
    return _simulation.ControlLinear_Interpolate(aX1, aY1, aX2, aY2, aX)

class PrescribedController(Controller):
    r"""
    PrescribedController is a concrete Controller that specifies functions that
    prescribe the control values of its actuators as a function of time.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PrescribedController *":
        return _simulation.PrescribedController_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PrescribedController_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PrescribedController_getClassName()

    def clone(self) -> "OpenSim::PrescribedController *":
        return _simulation.PrescribedController_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PrescribedController_getConcreteClassName(self)

    def copyProperty_ControlFunctions(self, source: "PrescribedController") -> "void":
        r""" FunctionSet of prescribed controls associated with each actuator"""
        return _simulation.PrescribedController_copyProperty_ControlFunctions(self, source)

    def append_ControlFunctions(self, value: "FunctionSet") -> "int":
        return _simulation.PrescribedController_append_ControlFunctions(self, value)

    def constructProperty_ControlFunctions(self, initValue: "FunctionSet") -> "void":
        return _simulation.PrescribedController_constructProperty_ControlFunctions(self, initValue)

    def get_ControlFunctions(self, *args) -> "OpenSim::FunctionSet const &":
        return _simulation.PrescribedController_get_ControlFunctions(self, *args)

    def upd_ControlFunctions(self, *args) -> "OpenSim::FunctionSet &":
        return _simulation.PrescribedController_upd_ControlFunctions(self, *args)

    def set_ControlFunctions(self, *args) -> "void":
        return _simulation.PrescribedController_set_ControlFunctions(self, *args)

    def copyProperty_controls_file(self, source: "PrescribedController") -> "void":
        r""" (Optional) prescribed controls from a storage file"""
        return _simulation.PrescribedController_copyProperty_controls_file(self, source)

    def append_controls_file(self, value: "std::string const &") -> "int":
        return _simulation.PrescribedController_append_controls_file(self, value)

    def constructProperty_controls_file(self, *args) -> "void":
        return _simulation.PrescribedController_constructProperty_controls_file(self, *args)

    def get_controls_file(self, *args) -> "std::string const &":
        return _simulation.PrescribedController_get_controls_file(self, *args)

    def upd_controls_file(self, *args) -> "std::string &":
        return _simulation.PrescribedController_upd_controls_file(self, *args)

    def set_controls_file(self, *args) -> "void":
        return _simulation.PrescribedController_set_controls_file(self, *args)

    def copyProperty_interpolation_method(self, source: "PrescribedController") -> "void":
        r""" (Optional) interpolation method for controls in storage."""
        return _simulation.PrescribedController_copyProperty_interpolation_method(self, source)

    def append_interpolation_method(self, value: "int const &") -> "int":
        return _simulation.PrescribedController_append_interpolation_method(self, value)

    def constructProperty_interpolation_method(self, *args) -> "void":
        return _simulation.PrescribedController_constructProperty_interpolation_method(self, *args)

    def get_interpolation_method(self, *args) -> "int const &":
        return _simulation.PrescribedController_get_interpolation_method(self, *args)

    def upd_interpolation_method(self, *args) -> "int &":
        return _simulation.PrescribedController_upd_interpolation_method(self, *args)

    def set_interpolation_method(self, *args) -> "void":
        return _simulation.PrescribedController_set_interpolation_method(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor

        |

        *Overload 2:*
         Convenience constructor get controls from file
        :type controlsFileName: string
        :param controlsFileName:  string containing the controls storage (.sto)
        :type interpMethodType: int, optional
        :param interpMethodType:  int 0-constant, 1-linear, 3-cubic, 5-quintic
                                     defaults to linear.

        |

        *Overload 3:*
         Convenience constructor get controls from file
        :type controlsFileName: string
        :param controlsFileName:  string containing the controls storage (.sto)
        :param interpMethodType:  int 0-constant, 1-linear, 3-cubic, 5-quintic
                                     defaults to linear.
        """
        _simulation.PrescribedController_swiginit(self, _simulation.new_PrescribedController(*args))
    __swig_destroy__ = _simulation.delete_PrescribedController

    def computeControls(self, s: "State", controls: "Vector") -> "void":
        r"""
        Compute the control values for all actuators under the control of this
        Controller.

        :type s: :py:class:`State`
        :param s:             system state
        :type controls: :py:class:`Vector`
        :param controls:      model controls
        """
        return _simulation.PrescribedController_computeControls(self, s, controls)

    def prescribeControlForActuator(self, *args) -> "void":
        r"""
        *Overload 1:*

        Assign a prescribed control function for the desired actuator identified
        by its index. Controller takes ownership of the function.
        :type index: int
        :param index:                the actuator's index in the controller's set
        :type prescribedFunction: :py:class:`Function`
        :param prescribedFunction:   the actuator's control function

        |

        *Overload 2:*

        Assign a prescribed control function for the desired actuator identified
        by its name. Controller takes ownership of the function.
        :type actName: string
        :param actName:                the actuator's name in the controller's set
        :type prescribedFunction: :py:class:`Function`
        :param prescribedFunction:     the actuator's control function
        """
        val = _simulation.PrescribedController_prescribeControlForActuator(self, *args)

        args[1]._markAdopted()


        return val


# Register PrescribedController in _simulation:
_simulation.PrescribedController_swigregister(PrescribedController)

def PrescribedController_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PrescribedController *":
    return _simulation.PrescribedController_safeDownCast(obj)

def PrescribedController_getClassName() -> "std::string const &":
    return _simulation.PrescribedController_getClassName()

class Manager(object):
    r"""
    A class that manages the execution of a simulation. This class uses a
    SimTK::Integrator and SimTK::TimeStepper to perform the simulation. By
    default, a Runge-Kutta-Merson integrator is used, but can be changed by
    using setIntegratorMethod().

    In order to prevent an inconsistency between the Integrator and TimeStepper,
    we only create a TimeStepper once, specifically when we call
    initialize(). To ensure this, the Manager will throw
    an exception if initialize() is called more than once. Note
    that editing the SimTK::State after calling initialize()
    will not affect the simulation.

    Note that this interface means that you cannot "reinitialize" a Manager.
    If you make changes to the SimTK::State, a new Manager must be created
    before integrating again.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor that takes a model only and internally uses a
        SimTK::RungeKuttaMersonIntegrator with default settings (accuracy,
        constraint tolerance, etc.).

        |

        *Overload 2:*
         Convenience constructor for creating and initializing a Manager (by
        calling initialize()).
        Do not use this constructor if you intend to change integrator settings;
        changes to the integrator may not take effect after initializing.

        |

        *Overload 3:*
         **(Deprecated)** A Constructor that does not take a model or
        controllerSet. This constructor also does not set an integrator; you
        must call setIntegrator() on your own. You should use one of the other
        constructors.
        """
        _simulation.Manager_swiginit(self, _simulation.new_Manager(*args))

    def setSessionName(self, name: "std::string const &") -> "void":
        return _simulation.Manager_setSessionName(self, name)

    def setModel(self, model: "Model") -> "void":
        return _simulation.Manager_setModel(self, model)

    def getSessionName(self) -> "std::string const &":
        return _simulation.Manager_getSessionName(self)

    def toString(self) -> "std::string const &":
        return _simulation.Manager_toString(self)

    def setPerformAnalyses(self, performAnalyses: "bool") -> "void":
        return _simulation.Manager_setPerformAnalyses(self, performAnalyses)

    def setWriteToStorage(self, writeToStorage: "bool") -> "void":
        return _simulation.Manager_setWriteToStorage(self, writeToStorage)
    IntegratorMethod_ExplicitEuler = _simulation.Manager_IntegratorMethod_ExplicitEuler
    r""" 0 : For details, see SimTK::ExplicitEulerIntegrator."""
    IntegratorMethod_RungeKutta2 = _simulation.Manager_IntegratorMethod_RungeKutta2
    r""" 1 : For details, see SimTK::RungeKutta2Integrator."""
    IntegratorMethod_RungeKutta3 = _simulation.Manager_IntegratorMethod_RungeKutta3
    r""" 2 : For details, see SimTK::RungeKutta3Integrator."""
    IntegratorMethod_RungeKuttaFeldberg = _simulation.Manager_IntegratorMethod_RungeKuttaFeldberg
    r""" 3 : For details, see SimTK::RungeKuttaFeldbergIntegrator."""
    IntegratorMethod_RungeKuttaMerson = _simulation.Manager_IntegratorMethod_RungeKuttaMerson
    r""" 4 : For details, see SimTK::RungeKuttaMersonIntegrator."""
    IntegratorMethod_SemiExplicitEuler2 = _simulation.Manager_IntegratorMethod_SemiExplicitEuler2
    r""" 5 : For details, see SimTK::SemiExplicitEuler2Integrator."""
    IntegratorMethod_Verlet = _simulation.Manager_IntegratorMethod_Verlet
    r""" 6 : For details, see SimTK::VerletIntegrator."""

    def setIntegratorMethod(self, integMethod: "OpenSim::Manager::IntegratorMethod") -> "void":
        r"""
         Sets the integrator method used via IntegratorMethod enum. The
        integrator will be set to its default options, even if the caller
        requests the same integrator method. Note that this function must
        be called before `Manager::initialize()`.

              **C++ example**

              .. code-block:: c++

                  auto manager = Manager(model);
                  manager.setIntegratorMethod(Manager::IntegratorMethod::SemiExplicitEuler2);

              **Python example**

              .. code-block:: python

                  import opensim
                  manager = opensim.Manager(model)
                  manager.setIntegratorMethod(opensim.Manager.IntegratorMethod_SemiExplicitEuler2)

              **MATLAB example**

              .. code-block:: c++

                  import org.opensim.modeling.*
                  manager = Manager(model);
                  manager.setIntegratorMethod(5);
        """
        return _simulation.Manager_setIntegratorMethod(self, integMethod)

    def getIntegrator(self) -> "SimTK::Integrator &":
        return _simulation.Manager_getIntegrator(self)

    def setIntegratorAccuracy(self, accuracy: "double") -> "void":
        r"""
         Sets the accuracy of the integrator.
        For more details, see `SimTK::Integrator::setAccuracy(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorAccuracy(self, accuracy)

    def setIntegratorMinimumStepSize(self, hmin: "double") -> "void":
        r"""
         Sets the minimum step size of the integrator.
        For more details, see `SimTK::Integrator::setMinimumStepSize(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorMinimumStepSize(self, hmin)

    def setIntegratorMaximumStepSize(self, hmax: "double") -> "void":
        r"""
         Sets the maximum step size of the integrator.
        For more details, see `SimTK::Integrator::setMaximumStepSize(SimTK::Real)`.
        """
        return _simulation.Manager_setIntegratorMaximumStepSize(self, hmax)

    def setIntegratorInternalStepLimit(self, nSteps: "int") -> "void":
        r"""
         Sets the limit of steps the integrator can take per call of `stepTo()`.
        Note that Manager::integrate() calls `stepTo()` for each interval when a fixed
        step size is used.
        For more details, see SimTK::Integrator::setInternalStepLimit(int).
        """
        return _simulation.Manager_setIntegratorInternalStepLimit(self, nSteps)

    def setUseSpecifiedDT(self, aTrueFalse: "bool") -> "void":
        
        return _simulation.Manager_setUseSpecifiedDT(self, aTrueFalse)

    def getUseSpecifiedDT(self) -> "bool":
        return _simulation.Manager_getUseSpecifiedDT(self)

    def setUseConstantDT(self, aTrueFalse: "bool") -> "void":
        return _simulation.Manager_setUseConstantDT(self, aTrueFalse)

    def getUseConstantDT(self) -> "bool":
        return _simulation.Manager_getUseConstantDT(self)

    def getDTArray(self) -> "OpenSim::Array< double > const &":
        return _simulation.Manager_getDTArray(self)

    def setDTArray(self, aDT: "Vector", aTI: "double"=0.0) -> "void":
        return _simulation.Manager_setDTArray(self, aDT, aTI)

    def getDTArrayDT(self, aStep: "int") -> "double":
        return _simulation.Manager_getDTArrayDT(self, aStep)

    def printDTArray(self, aFileName: "char const *"=None) -> "void":
        return _simulation.Manager_printDTArray(self, aFileName)

    def getTimeArray(self) -> "OpenSim::Array< double > const &":
        return _simulation.Manager_getTimeArray(self)

    def getTimeArrayTime(self, aStep: "int") -> "double":
        return _simulation.Manager_getTimeArrayTime(self, aStep)

    def getTimeArrayStep(self, aTime: "double") -> "int":
        return _simulation.Manager_getTimeArrayStep(self, aTime)

    def printTimeArray(self, aFileName: "char const *"=None) -> "void":
        return _simulation.Manager_printTimeArray(self, aFileName)

    def resetTimeAndDTArrays(self, aTime: "double") -> "void":
        return _simulation.Manager_resetTimeAndDTArrays(self, aTime)

    def getNextTimeArrayTime(self, aTime: "double") -> "double":
        return _simulation.Manager_getNextTimeArrayTime(self, aTime)

    def initialize(self, s: "State") -> "void":
        r"""
        Initializes the Manager by creating and initializing the underlying
        SimTK::TimeStepper. This must be called before calling
        Manager::integrate() Subsequent changes to the State object passed in
        here will not affect the simulation. Calling this function multiple
        times with the same Manager will trigger an Exception.

        Changes to the integrator (e.g., setIntegratorAccuracy()) after calling
        initialize() may not have any effect.
        """
        return _simulation.Manager_initialize(self, s)

    def integrate(self, finalTime: "double") -> "SimTK::State const &":
        r"""
        Integrate the equations of motion for the specified model, given the current
        state (at which the integration will start) and a finalTime. You must call
        Manager::initialize() before calling this function.

        If you must update states or controls in a loop, you must recreate the
        manager within the loop (such discontinuous changes are considered "events"
        and cannot be handled during integration of the otherwise continuous system).
        The proper way to handle this situation is to create a SimTK::EventHandler.

        Example: Integrating from time = 1s to time = 2s

        .. code-block:: c++

            SimTK::State state = model.initSystem();
            Manager manager(model);
            state.setTime(1.0);
            manager.initialize(state);
            state = manager.integrate(2.0);

        Example: Integrating from time = 1s to time = 2s using the
                 convenience constructor

        .. code-block:: c++

            SimTK::State state = model.initSystem();
            state.setTime(1.0);
            Manager manager(model, state);
            state = manager.integrate(2.0);

        Example: Integrate from time = 0s to time = 10s, in 2s increments

        .. code-block:: c++

            dTime = 2.0;
            finalTime = 10.0;
            int n = int(round(finalTime/dTime));
            state.setTime(0.0);
            manager.initialize(state);
            for (int i = 1; i <= n; ++i) {
                state = manager.integrate(i*dTime);
            }

        Example: Integrate from time = 0s to time = 10s, updating the state
                 (e.g., the model's first coordinate value) every 2s

        .. code-block:: c++

            dTime = 2.0;
            finalTime = 10.0;
            int n = int(round(finalTime/dTime));
            state.setTime(0.0);
            for (int i = 0; i < n; ++i) {
                model.getCoordinateSet().get(0).setValue(state, 0.1*i);
                Manager manager(model);
                state.setTime(i*dTime);
                manager.initialize(state);
                state = manager.integrate((i+1)*dTime);
            }
        """
        return _simulation.Manager_integrate(self, finalTime)

    def getState(self) -> "SimTK::State const &":
        r"""
         Get the current State from the Integrator associated with this
        Manager.
        """
        return _simulation.Manager_getState(self)

    def getFixedStepSize(self, tArrayStep: "int") -> "double":
        return _simulation.Manager_getFixedStepSize(self, tArrayStep)

    def hasStateStorage(self) -> "bool":
        return _simulation.Manager_hasStateStorage(self)

    def setStateStorage(self, aStorage: "Storage") -> "void":
        r"""
        Set the Storage object to be used for storing states. The Manager takes
           ownership of the passed-in Storage.
        """
        return _simulation.Manager_setStateStorage(self, aStorage)

    def getStateStorage(self) -> "OpenSim::Storage &":
        return _simulation.Manager_getStateStorage(self)

    def getStatesTable(self) -> "OpenSim::TimeSeriesTable":
        return _simulation.Manager_getStatesTable(self)

    def halt(self) -> "void":
        return _simulation.Manager_halt(self)

    def clearHalt(self) -> "void":
        return _simulation.Manager_clearHalt(self)

    def checkHalt(self) -> "bool":
        return _simulation.Manager_checkHalt(self)
    __swig_destroy__ = _simulation.delete_Manager

# Register Manager in _simulation:
_simulation.Manager_swigregister(Manager)

class AbstractTool(opensim.common.OpenSimObject):
    r"""
    An abstract class for specifying the interface for an investigation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractTool *":
        return _simulation.AbstractTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.AbstractTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.AbstractTool_getClassName()

    def clone(self) -> "OpenSim::AbstractTool *":
        return _simulation.AbstractTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.AbstractTool_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_AbstractTool

    def setModel(self, aModel: "Model") -> "void":
        r"""
        %Set the model to be investigated.
        NOTE: setup() should have been called on the model prior to calling this method
        """
        return _simulation.AbstractTool_setModel(self, aModel)

    def getModel(self) -> "OpenSim::Model &":
        r"""Get the model to be investigated."""
        return _simulation.AbstractTool_getModel(self)

    def getReplaceForceSet(self) -> "bool":
        return _simulation.AbstractTool_getReplaceForceSet(self)

    def setReplaceForceSet(self, aReplace: "bool") -> "void":
        return _simulation.AbstractTool_setReplaceForceSet(self, aReplace)

    def getNextAvailableForceName(self, *args) -> "std::string":
        return _simulation.AbstractTool_getNextAvailableForceName(self, *args)

    def getExternalLoads(self) -> "OpenSim::ExternalLoads const &":
        return _simulation.AbstractTool_getExternalLoads(self)

    def updExternalLoads(self) -> "OpenSim::ExternalLoads &":
        return _simulation.AbstractTool_updExternalLoads(self)

    def setExternalLoads(self, el: "ExternalLoads") -> "void":
        return _simulation.AbstractTool_setExternalLoads(self, el)

    def modelHasExternalLoads(self) -> "bool":
        return _simulation.AbstractTool_modelHasExternalLoads(self)

    def getExternalLoadsFileName(self) -> "std::string const &":
        return _simulation.AbstractTool_getExternalLoadsFileName(self)

    def setExternalLoadsFileName(self, aFileName: "std::string const &") -> "void":
        return _simulation.AbstractTool_setExternalLoadsFileName(self, aFileName)

    def getForceSetFiles(self) -> "OpenSim::Array< std::string > &":
        return _simulation.AbstractTool_getForceSetFiles(self)

    def setForceSetFiles(self, aForceSetFiles: "ArrayStr") -> "void":
        return _simulation.AbstractTool_setForceSetFiles(self, aForceSetFiles)

    def getOutputPrecision(self) -> "int":
        return _simulation.AbstractTool_getOutputPrecision(self)

    def setOutputPrecision(self, aPrecision: "int") -> "void":
        return _simulation.AbstractTool_setOutputPrecision(self, aPrecision)

    def getAnalysisSet(self) -> "OpenSim::AnalysisSet const &":
        return _simulation.AbstractTool_getAnalysisSet(self)

    def updAnalysisSet(self) -> "OpenSim::AnalysisSet &":
        return _simulation.AbstractTool_updAnalysisSet(self)

    def getControllerSet(self) -> "OpenSim::ControllerSet const &":
        return _simulation.AbstractTool_getControllerSet(self)

    def updControllerSet(self) -> "OpenSim::ControllerSet &":
        return _simulation.AbstractTool_updControllerSet(self)

    def getResultsDir(self) -> "std::string const &":
        r"""Get Results Directory"""
        return _simulation.AbstractTool_getResultsDir(self)

    def setResultsDir(self, aString: "std::string const &") -> "void":
        return _simulation.AbstractTool_setResultsDir(self, aString)

    def getInitialTime(self) -> "double":
        return _simulation.AbstractTool_getInitialTime(self)

    def getFinalTime(self) -> "double":
        return _simulation.AbstractTool_getFinalTime(self)

    def setInitialTime(self, aInitialTime: "double const") -> "void":
        return _simulation.AbstractTool_setInitialTime(self, aInitialTime)

    def setFinalTime(self, aFinalTime: "double const") -> "void":
        return _simulation.AbstractTool_setFinalTime(self, aFinalTime)

    def getStartTime(self) -> "double":
        return _simulation.AbstractTool_getStartTime(self)

    def setStartTime(self, aStartTime: "double const") -> "void":
        return _simulation.AbstractTool_setStartTime(self, aStartTime)

    def getMaximumNumberOfSteps(self) -> "int":
        return _simulation.AbstractTool_getMaximumNumberOfSteps(self)

    def setMaximumNumberOfSteps(self, aMaxSteps: "int") -> "void":
        return _simulation.AbstractTool_setMaximumNumberOfSteps(self, aMaxSteps)

    def getMaxDT(self) -> "double":
        return _simulation.AbstractTool_getMaxDT(self)

    def setMaxDT(self, aMaxDT: "double") -> "void":
        return _simulation.AbstractTool_setMaxDT(self, aMaxDT)

    def getMinDT(self) -> "double":
        return _simulation.AbstractTool_getMinDT(self)

    def setMinDT(self, aMinDT: "double") -> "void":
        return _simulation.AbstractTool_setMinDT(self, aMinDT)

    def getErrorTolerance(self) -> "double":
        return _simulation.AbstractTool_getErrorTolerance(self)

    def setErrorTolerance(self, aErrorTolerance: "double") -> "void":
        return _simulation.AbstractTool_setErrorTolerance(self, aErrorTolerance)

    def getModelFilename(self) -> "std::string const &":
        return _simulation.AbstractTool_getModelFilename(self)

    def setModelFilename(self, aModelFile: "std::string const &") -> "void":
        return _simulation.AbstractTool_setModelFilename(self, aModelFile)

    def getSolveForEquilibrium(self) -> "bool":
        return _simulation.AbstractTool_getSolveForEquilibrium(self)

    def setSolveForEquilibrium(self, aSolve: "bool") -> "void":
        return _simulation.AbstractTool_setSolveForEquilibrium(self, aSolve)

    def loadModel(self, aToolSetupFileName: "std::string const &", rOriginalForceSet: "ForceSet"=None) -> "void":
        r"""
        Load and construct a model based on the property settings of
        this investigation.
        """
        return _simulation.AbstractTool_loadModel(self, aToolSetupFileName, rOriginalForceSet)

    def updateModelForces(self, model: "Model", aToolSetupFileName: "std::string const &", rOriginalForceSet: "ForceSet"=None) -> "void":
        r"""Update the forces applied to a model."""
        return _simulation.AbstractTool_updateModelForces(self, model, aToolSetupFileName, rOriginalForceSet)

    def addAnalysisSetToModel(self) -> "void":
        r"""
        Adds Analysis objects from analysis set to model.

        NOTE: Makes copies of analyses.  Also, both this tool and the model have ownership of their analysis
        objects, therefore making a copy is necessary so a single analysis won't be deleted twice.

        To avoid leaking when the tool is run from the GUI, pointers to the model's copy of the analyses
        are kept around so that they can be removed at the end of tool execution.
         _analysisCopies is used to do this book keeping.
        """
        return _simulation.AbstractTool_addAnalysisSetToModel(self)

    def addControllerSetToModel(self) -> "void":
        return _simulation.AbstractTool_addControllerSetToModel(self)

    def removeControllerSetFromModel(self) -> "void":
        r"""Remove Analysis objects that were added earlier from analysis set to model."""
        return _simulation.AbstractTool_removeControllerSetFromModel(self)

    def removeAnalysisSetFromModel(self) -> "void":
        return _simulation.AbstractTool_removeAnalysisSetFromModel(self)

    def setToolOwnsModel(self, trueFalse: "bool const") -> "void":
        return _simulation.AbstractTool_setToolOwnsModel(self, trueFalse)

    def getToolOwnsModel(self) -> "bool":
        return _simulation.AbstractTool_getToolOwnsModel(self)

    def getControlsFileName(self) -> "std::string":
        return _simulation.AbstractTool_getControlsFileName(self)

    def setControlsFileName(self, controlsFilename: "std::string const &") -> "void":
        return _simulation.AbstractTool_setControlsFileName(self, controlsFilename)

    def run(self) -> "bool":
        return _simulation.AbstractTool_run(self)

    def printResults(self, *args) -> "void":
        r"""
        Print the results of the analysis.

        :type aBaseName: string
        :param aBaseName: Basename file to which to print the data.
        :type aDir: string, optional
        :param aDir: Directory to which to print the data into.
        :type aDT: float, optional
        :param aDT: Time interval between results (linear interpolation is used).
            If not included as an argument or negative, all time steps are printed
            without interpolation.
        :type aExtension: string, optional
        :param aExtension: Extension for written files.
        """
        return _simulation.AbstractTool_printResults(self, *args)

    def createExternalLoads(self, externalLoadsFileName: "std::string const &", model: "Model") -> "bool":
        return _simulation.AbstractTool_createExternalLoads(self, externalLoadsFileName, model)

    def removeExternalLoadsFromModel(self) -> "void":
        return _simulation.AbstractTool_removeExternalLoadsFromModel(self)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        return _simulation.AbstractTool_updateFromXMLNode(self, aNode, versionNumber)

    def loadQStorage(self, statesFileName: "std::string const &", rQStore: "Storage") -> "void":
        return _simulation.AbstractTool_loadQStorage(self, statesFileName, rQStore)

# Register AbstractTool in _simulation:
_simulation.AbstractTool_swigregister(AbstractTool)

def AbstractTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractTool *":
    return _simulation.AbstractTool_safeDownCast(obj)

def AbstractTool_getClassName() -> "std::string const &":
    return _simulation.AbstractTool_getClassName()

class Point(ModelComponent):
    r"""
    A Point is an OpenSim abstraction for any location in space. Points
    are intended to locate physical structures (such as points of constraints
    and points of muscle attachments) as well as embody the results of spatial
    calculations. For example, if your system involves contact, you can define
    a Point that describes the location of the center-of-pressure as one
    element rolls over another.

    A Point provides its location, velocity and acceleration in the Ground frame
    as a function of the Model's (SimTK::MultibodySystem's) state, which is
    accessible when the state has been realized to the corresponding
    SimTK::Stage (i.e. Position, Velocity and Acceleration).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Point *":
        return _simulation.Point_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Point_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Point_getClassName()

    def clone(self) -> "OpenSim::Point *":
        return _simulation.Point_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Point_getConcreteClassName(self)
    _has_output_location = property(_simulation.Point__has_output_location_get, _simulation.Point__has_output_location_set)
    _has_output_velocity = property(_simulation.Point__has_output_velocity_get, _simulation.Point__has_output_velocity_set)
    _has_output_acceleration = property(_simulation.Point__has_output_acceleration_get, _simulation.Point__has_output_acceleration_set)
    __swig_destroy__ = _simulation.delete_Point

    def getLocationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        *
            Get the location, r_GP, of this Point, P, relative to and expressed in
            the Ground. Point position only valid at Stage::Position or higher.
            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   location of the Point.
            :rtype: :py:class:`Vec3`
            :return: location   The location of the point expressed in the Ground.
        """
        return _simulation.Point_getLocationInGround(self, state)

    def getVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The velocity v_GP of this Point, P, relative to and expressed in Ground.
               Point's velocity is only valid at Stage::Velocity or higher.
           :type state: :py:class:`State`
           :param state:       The state applied to the model when determining the
                                  velocity of the Point.
           :rtype: :py:class:`Vec3`
           :return: velocity   The velocity of the point expressed in the Ground.
        """
        return _simulation.Point_getVelocityInGround(self, state)

    def getAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The acceleration a_GP, of this Point, P, relative to and expressed in
           Ground. Point's acceleration is only valid at Stage::Acceleration or higher.
           :type state: :py:class:`State`
           :param state:       The state applied to the model when determining the
                                  acceleration of the Point.
           :rtype: :py:class:`Vec3`
           :return: velocity   The acceleration of the point expressed in Ground
        """
        return _simulation.Point_getAccelerationInGround(self, state)

    def calcDistanceBetween(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculate the distance between this Point and some other Point
            :type state: :py:class:`State`
            :param state:      The current State of the model.
            :type other: :py:class:`Point`
            :param other:      The other Point to which we want to get the distance between.
            :rtype: float
            :return: distance  The distance (positive scalar).

        |

        *Overload 2:*
         Calculate the distance between this Point and some other described as a
            location in some other frame.
            :type state: :py:class:`State`
            :param state:      The current State of the model.
            :type frame: :py:class:`Frame`
            :param frame:      The other frame in which the location is defined.
            :type location: :py:class:`Vec3`
            :param location:   The location in the other frame.
            :rtype: float
            :return: distance  The distance (positive scalar).
        """
        return _simulation.Point_calcDistanceBetween(self, *args)

    def calcSpeedBetween(self, state: "State", other: "Point") -> "double":
        r"""
        Calculate the relative speed between this Point and some other Point.
           It is the derivative of the distance with respect to time.
           A positive speed is growing the distance and negative is coming closer.
           :type state: :py:class:`State`
           :param state:      The current State of the model.
           :type other: :py:class:`Point`
           :param other:      The other Point to which we want to get the speed between.
           :rtype: float
           :return: speed     The speed (distance time derivative) which is a scalar.
        """
        return _simulation.Point_calcSpeedBetween(self, state, other)

# Register Point in _simulation:
_simulation.Point_swigregister(Point)

def Point_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Point *":
    return _simulation.Point_safeDownCast(obj)

def Point_getClassName() -> "std::string const &":
    return _simulation.Point_getClassName()

class Station(Point):
    r"""
    A Station is a Point fixed to and located on a PhysicalFrame, which can be
    a Body, Ground or any PhysicalOffsetFrame. Stations are analogous to
    PhyscialOffsetFrames where joints, constraints and forces can be attached
    and/or applied.

    Author: Ayman Habib, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Station *":
        return _simulation.Station_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Station_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Station_getClassName()

    def clone(self) -> "OpenSim::Station *":
        return _simulation.Station_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Station_getConcreteClassName(self)

    def copyProperty_location(self, source: "Station") -> "void":
        return _simulation.Station_copyProperty_location(self, source)

    def append_location(self, value: "Vec3") -> "int":
        return _simulation.Station_append_location(self, value)

    def constructProperty_location(self, initValue: "Vec3") -> "void":
        return _simulation.Station_constructProperty_location(self, initValue)

    def get_location(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Station_get_location(self, *args)

    def upd_location(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Station_upd_location(self, *args)

    def set_location(self, *args) -> "void":
        return _simulation.Station_set_location(self, *args)
    PropertyIndex_socket_parent_frame = property(_simulation.Station_PropertyIndex_socket_parent_frame_get, _simulation.Station_PropertyIndex_socket_parent_frame_set)

    def connectSocket_parent_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.Station_connectSocket_parent_frame(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
           :type frame: :py:class:`PhysicalFrame`, in
           :param frame:     PhysicalFrame in which the Station is located.
           :type location: :py:class:`Vec3`, in
           :param location:  Vec3 location of the station in its PhysicalFrame
        """
        _simulation.Station_swiginit(self, _simulation.new_Station(*args))
    __swig_destroy__ = _simulation.delete_Station

    def getParentFrame(self) -> "OpenSim::PhysicalFrame const &":
        r""" get the parent PhysicalFrame in which the Station is defined"""
        return _simulation.Station_getParentFrame(self)

    def setParentFrame(self, aFrame: "PhysicalFrame") -> "void":
        r""" set the parent PhysicalFrame in which the Station is defined"""
        return _simulation.Station_setParentFrame(self, aFrame)

    def findLocationInFrame(self, s: "State", frame: "Frame") -> "SimTK::Vec3":
        r""" Find this Station's location in any Frame"""
        return _simulation.Station_findLocationInFrame(self, s, frame)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.Station_extendScale(self, s, scaleSet)

# Register Station in _simulation:
_simulation.Station_swigregister(Station)

def Station_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Station *":
    return _simulation.Station_safeDownCast(obj)

def Station_getClassName() -> "std::string const &":
    return _simulation.Station_getClassName()

class Marker(Station):
    r"""
    A class implementing a Mocap marker.

    Author: Ayman Habib, Peter Loan
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Marker *":
        return _simulation.Marker_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Marker_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Marker_getClassName()

    def clone(self) -> "OpenSim::Marker *":
        return _simulation.Marker_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Marker_getConcreteClassName(self)

    def copyProperty_fixed(self, source: "Marker") -> "void":
        return _simulation.Marker_copyProperty_fixed(self, source)

    def append_fixed(self, value: "bool const &") -> "int":
        return _simulation.Marker_append_fixed(self, value)

    def constructProperty_fixed(self, initValue: "bool const &") -> "void":
        return _simulation.Marker_constructProperty_fixed(self, initValue)

    def get_fixed(self, *args) -> "bool const &":
        return _simulation.Marker_get_fixed(self, *args)

    def upd_fixed(self, *args) -> "bool &":
        return _simulation.Marker_upd_fixed(self, *args)

    def set_fixed(self, *args) -> "void":
        return _simulation.Marker_set_fixed(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
           :type name: string, in
           :param name:      Marker name string.
           :type frame: :py:class:`PhysicalFrame`, in
           :param frame:     PhysicalFrame in which the Marker is located.
           :type location: :py:class:`Vec3`, in
           :param location:  Vec3 location of the station in its PhysicalFrame
        """
        _simulation.Marker_swiginit(self, _simulation.new_Marker(*args))
    __swig_destroy__ = _simulation.delete_Marker

    def getParentFrameName(self) -> "std::string const &":
        r""" Convenience method to get the 'parent_frame' Socket's connectee_name"""
        return _simulation.Marker_getParentFrameName(self)

    def setParentFrameName(self, parentFrameName: "std::string const &") -> "void":
        r"""
        Convenience method to set the 'parent_frame' Socket's connectee_name.
               The the named parent frame is not connected and finalizeConnections()
               must be invoked to establish the connection.
        """
        return _simulation.Marker_setParentFrameName(self, parentFrameName)

    def changeFrame(self, parentFrame: "PhysicalFrame") -> "void":
        r""" Change the parent PhysicalFrame that this marker is attached to."""
        return _simulation.Marker_changeFrame(self, parentFrame)

    def changeFramePreserveLocation(self, s: "State", newParentFrame: "PhysicalFrame") -> "void":
        r"""
        Change the parent PhysicalFrame that this marker is attached to. In
               addition, preserve the marker location in the inertial (Ground) frame
               by using the state to compute the location in the new parent frame and
               to set its location property.
        """
        return _simulation.Marker_changeFramePreserveLocation(self, s, newParentFrame)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        r""" Override of the default implementation to account for versioning."""
        return _simulation.Marker_updateFromXMLNode(self, aNode, versionNumber)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        return _simulation.Marker_generateDecorations(self, fixed, hints, state, appendToThis)

# Register Marker in _simulation:
_simulation.Marker_swigregister(Marker)

def Marker_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Marker *":
    return _simulation.Marker_safeDownCast(obj)

def Marker_getClassName() -> "std::string const &":
    return _simulation.Marker_getClassName()

class SetMarkers(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Marker,OpenSim::ModelComponent > *":
        return _simulation.SetMarkers_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetMarkers_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetMarkers_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Marker,OpenSim::ModelComponent > *":
        return _simulation.SetMarkers_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetMarkers_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMarkers

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Marker,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetMarkers_swiginit(self, _simulation.new_SetMarkers(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMarkers_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMarkers_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMarkers_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMarkers_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Marker`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMarkers_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetMarkers_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Marker") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Marker`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkers_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Marker") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Marker`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkers_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Marker") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Marker`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMarkers_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Marker`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMarkers_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetMarkers_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Marker", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Marker`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMarkers_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Marker &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Marker`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Marker`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMarkers_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMarkers_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMarkers_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetMarkers_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetMarkers_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMarkers_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetMarkers_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetMarkers_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetMarkers_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMarkers_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMarkers in _simulation:
_simulation.SetMarkers_swigregister(SetMarkers)

def SetMarkers_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Marker,OpenSim::ModelComponent > *":
    return _simulation.SetMarkers_safeDownCast(obj)

def SetMarkers_getClassName() -> "std::string const &":
    return _simulation.SetMarkers_getClassName()

class ModelComponentSetMarkers(SetMarkers):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Marker > *":
        return _simulation.ModelComponentSetMarkers_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetMarkers_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetMarkers_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Marker > *":
        return _simulation.ModelComponentSetMarkers_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetMarkers_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetMarkers_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetMarkers_swiginit(self, _simulation.new_ModelComponentSetMarkers())
    __swig_destroy__ = _simulation.delete_ModelComponentSetMarkers

# Register ModelComponentSetMarkers in _simulation:
_simulation.ModelComponentSetMarkers_swigregister(ModelComponentSetMarkers)

def ModelComponentSetMarkers_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Marker > *":
    return _simulation.ModelComponentSetMarkers_safeDownCast(obj)

def ModelComponentSetMarkers_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetMarkers_getClassName()

class MarkerSet(ModelComponentSetMarkers):
    r"""
    A class for holding a set of markers.

    Authors: Ayman Habib, Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerSet *":
        return _simulation.MarkerSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MarkerSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MarkerSet_getClassName()

    def clone(self) -> "OpenSim::MarkerSet *":
        return _simulation.MarkerSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MarkerSet_getConcreteClassName(self)

    def getMarkerNames(self, aMarkerNamesArray: "ArrayStr") -> "void":
        return _simulation.MarkerSet_getMarkerNames(self, aMarkerNamesArray)

    def addNamePrefix(self, prefix: "std::string const &") -> "void":
        r""" Add a prefix to marker names for all markers in the set*"""
        return _simulation.MarkerSet_addNamePrefix(self, prefix)

    def __init__(self, *args):
        _simulation.MarkerSet_swiginit(self, _simulation.new_MarkerSet(*args))

    def adoptAndAppend(self, aMarker):
        aMarker._markAdopted()
        return super(MarkerSet, self).adoptAndAppend(aMarker)

    __swig_destroy__ = _simulation.delete_MarkerSet

# Register MarkerSet in _simulation:
_simulation.MarkerSet_swigregister(MarkerSet)

def MarkerSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerSet *":
    return _simulation.MarkerSet_safeDownCast(obj)

def MarkerSet_getClassName() -> "std::string const &":
    return _simulation.MarkerSet_getClassName()

class WrapSphere(WrapObject):
    r"""
    A class implementing a sphere for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapSphere *":
        return _simulation.WrapSphere_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapSphere_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapSphere_getClassName()

    def clone(self) -> "OpenSim::WrapSphere *":
        return _simulation.WrapSphere_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapSphere_getConcreteClassName(self)

    def copyProperty_radius(self, source: "WrapSphere") -> "void":
        return _simulation.WrapSphere_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.WrapSphere_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapSphere_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.WrapSphere_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.WrapSphere_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.WrapSphere_set_radius(self, *args)

    def __init__(self):
        _simulation.WrapSphere_swiginit(self, _simulation.new_WrapSphere())
    __swig_destroy__ = _simulation.delete_WrapSphere

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapSphere_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapSphere_getDimensionsString(self)

    def getRadius(self) -> "double":
        return _simulation.WrapSphere_getRadius(self)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the sphere by the average of the scale factors in each direction.
               The base class (WrapObject) scales the origin of the sphere in the
               body's reference frame.
        """
        return _simulation.WrapSphere_extendScale(self, s, scaleSet)

# Register WrapSphere in _simulation:
_simulation.WrapSphere_swigregister(WrapSphere)

def WrapSphere_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapSphere *":
    return _simulation.WrapSphere_safeDownCast(obj)

def WrapSphere_getClassName() -> "std::string const &":
    return _simulation.WrapSphere_getClassName()

class WrapCylinder(WrapObject):
    r"""
    A class implementing a cylinder for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapCylinder *":
        return _simulation.WrapCylinder_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapCylinder_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapCylinder_getClassName()

    def clone(self) -> "OpenSim::WrapCylinder *":
        return _simulation.WrapCylinder_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapCylinder_getConcreteClassName(self)

    def copyProperty_radius(self, source: "WrapCylinder") -> "void":
        return _simulation.WrapCylinder_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.WrapCylinder_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapCylinder_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.WrapCylinder_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.WrapCylinder_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.WrapCylinder_set_radius(self, *args)

    def copyProperty_length(self, source: "WrapCylinder") -> "void":
        return _simulation.WrapCylinder_copyProperty_length(self, source)

    def append_length(self, value: "double const &") -> "int":
        return _simulation.WrapCylinder_append_length(self, value)

    def constructProperty_length(self, initValue: "double const &") -> "void":
        return _simulation.WrapCylinder_constructProperty_length(self, initValue)

    def get_length(self, *args) -> "double const &":
        return _simulation.WrapCylinder_get_length(self, *args)

    def upd_length(self, *args) -> "double &":
        return _simulation.WrapCylinder_upd_length(self, *args)

    def set_length(self, *args) -> "void":
        return _simulation.WrapCylinder_set_length(self, *args)

    def __init__(self):
        _simulation.WrapCylinder_swiginit(self, _simulation.new_WrapCylinder())
    __swig_destroy__ = _simulation.delete_WrapCylinder

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapCylinder_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapCylinder_getDimensionsString(self)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the cylinder's dimensions. The base class (WrapObject) scales the
               origin of the cylinder in the body's reference frame.
        """
        return _simulation.WrapCylinder_extendScale(self, s, scaleSet)

# Register WrapCylinder in _simulation:
_simulation.WrapCylinder_swigregister(WrapCylinder)

def WrapCylinder_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapCylinder *":
    return _simulation.WrapCylinder_safeDownCast(obj)

def WrapCylinder_getClassName() -> "std::string const &":
    return _simulation.WrapCylinder_getClassName()

class WrapTorus(WrapObject):
    r"""
    A class implementing a torus for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapTorus *":
        return _simulation.WrapTorus_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapTorus_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapTorus_getClassName()

    def clone(self) -> "OpenSim::WrapTorus *":
        return _simulation.WrapTorus_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapTorus_getConcreteClassName(self)

    def copyProperty_inner_radius(self, source: "WrapTorus") -> "void":
        return _simulation.WrapTorus_copyProperty_inner_radius(self, source)

    def append_inner_radius(self, value: "double const &") -> "int":
        return _simulation.WrapTorus_append_inner_radius(self, value)

    def constructProperty_inner_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapTorus_constructProperty_inner_radius(self, initValue)

    def get_inner_radius(self, *args) -> "double const &":
        return _simulation.WrapTorus_get_inner_radius(self, *args)

    def upd_inner_radius(self, *args) -> "double &":
        return _simulation.WrapTorus_upd_inner_radius(self, *args)

    def set_inner_radius(self, *args) -> "void":
        return _simulation.WrapTorus_set_inner_radius(self, *args)

    def copyProperty_outer_radius(self, source: "WrapTorus") -> "void":
        return _simulation.WrapTorus_copyProperty_outer_radius(self, source)

    def append_outer_radius(self, value: "double const &") -> "int":
        return _simulation.WrapTorus_append_outer_radius(self, value)

    def constructProperty_outer_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapTorus_constructProperty_outer_radius(self, initValue)

    def get_outer_radius(self, *args) -> "double const &":
        return _simulation.WrapTorus_get_outer_radius(self, *args)

    def upd_outer_radius(self, *args) -> "double &":
        return _simulation.WrapTorus_upd_outer_radius(self, *args)

    def set_outer_radius(self, *args) -> "void":
        return _simulation.WrapTorus_set_outer_radius(self, *args)

    def __init__(self):
        _simulation.WrapTorus_swiginit(self, _simulation.new_WrapTorus())
    __swig_destroy__ = _simulation.delete_WrapTorus

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapTorus_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapTorus_getDimensionsString(self)

    def getInnerRadius(self) -> "SimTK::Real":
        return _simulation.WrapTorus_getInnerRadius(self)

    def getOuterRadius(self) -> "SimTK::Real":
        return _simulation.WrapTorus_getOuterRadius(self)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the torus's dimensions. The base class (WrapObject) scales the
               origin of the torus in the body's reference frame.
        """
        return _simulation.WrapTorus_extendScale(self, s, scaleSet)

# Register WrapTorus in _simulation:
_simulation.WrapTorus_swigregister(WrapTorus)

def WrapTorus_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapTorus *":
    return _simulation.WrapTorus_safeDownCast(obj)

def WrapTorus_getClassName() -> "std::string const &":
    return _simulation.WrapTorus_getClassName()

class WrapEllipsoid(WrapObject):
    r"""
    A class implementing an ellipsoid for muscle wrapping.

    Author: Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapEllipsoid *":
        return _simulation.WrapEllipsoid_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapEllipsoid_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapEllipsoid_getClassName()

    def clone(self) -> "OpenSim::WrapEllipsoid *":
        return _simulation.WrapEllipsoid_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapEllipsoid_getConcreteClassName(self)

    def copyProperty_dimensions(self, source: "WrapEllipsoid") -> "void":
        return _simulation.WrapEllipsoid_copyProperty_dimensions(self, source)

    def append_dimensions(self, value: "Vec3") -> "int":
        return _simulation.WrapEllipsoid_append_dimensions(self, value)

    def constructProperty_dimensions(self, initValue: "Vec3") -> "void":
        return _simulation.WrapEllipsoid_constructProperty_dimensions(self, initValue)

    def get_dimensions(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.WrapEllipsoid_get_dimensions(self, *args)

    def upd_dimensions(self, *args) -> "SimTK::Vec3 &":
        return _simulation.WrapEllipsoid_upd_dimensions(self, *args)

    def set_dimensions(self, *args) -> "void":
        return _simulation.WrapEllipsoid_set_dimensions(self, *args)

    def __init__(self):
        _simulation.WrapEllipsoid_swiginit(self, _simulation.new_WrapEllipsoid())
    __swig_destroy__ = _simulation.delete_WrapEllipsoid

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapEllipsoid_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapEllipsoid_getDimensionsString(self)

    def getRadii(self) -> "SimTK::Vec3":
        return _simulation.WrapEllipsoid_getRadii(self)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the ellipsoid's dimensions. The base class (WrapObject) scales the
               origin of the ellipsoid in the body's reference frame.
        """
        return _simulation.WrapEllipsoid_extendScale(self, s, scaleSet)

# Register WrapEllipsoid in _simulation:
_simulation.WrapEllipsoid_swigregister(WrapEllipsoid)

def WrapEllipsoid_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapEllipsoid *":
    return _simulation.WrapEllipsoid_safeDownCast(obj)

def WrapEllipsoid_getClassName() -> "std::string const &":
    return _simulation.WrapEllipsoid_getClassName()

class PathWrap(ModelComponent):
    r"""
     Conditional comment: *
    A class implementing an instance of muscle wrapping. That is, it is owned
    by a particular muscle, and contains parameters for wrapping that muscle
    over a particular wrap object.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrap *":
        return _simulation.PathWrap_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathWrap_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathWrap_getClassName()

    def clone(self) -> "OpenSim::PathWrap *":
        return _simulation.PathWrap_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathWrap_getConcreteClassName(self)

    def copyProperty_wrap_object(self, source: "PathWrap") -> "void":
        return _simulation.PathWrap_copyProperty_wrap_object(self, source)

    def append_wrap_object(self, value: "std::string const &") -> "int":
        return _simulation.PathWrap_append_wrap_object(self, value)

    def constructProperty_wrap_object(self, initValue: "std::string const &") -> "void":
        return _simulation.PathWrap_constructProperty_wrap_object(self, initValue)

    def get_wrap_object(self, *args) -> "std::string const &":
        return _simulation.PathWrap_get_wrap_object(self, *args)

    def upd_wrap_object(self, *args) -> "std::string &":
        return _simulation.PathWrap_upd_wrap_object(self, *args)

    def set_wrap_object(self, *args) -> "void":
        return _simulation.PathWrap_set_wrap_object(self, *args)

    def copyProperty_method(self, source: "PathWrap") -> "void":
        return _simulation.PathWrap_copyProperty_method(self, source)

    def append_method(self, value: "std::string const &") -> "int":
        return _simulation.PathWrap_append_method(self, value)

    def constructProperty_method(self, initValue: "std::string const &") -> "void":
        return _simulation.PathWrap_constructProperty_method(self, initValue)

    def get_method(self, *args) -> "std::string const &":
        return _simulation.PathWrap_get_method(self, *args)

    def upd_method(self, *args) -> "std::string &":
        return _simulation.PathWrap_upd_method(self, *args)

    def set_method(self, *args) -> "void":
        return _simulation.PathWrap_set_method(self, *args)

    def copyProperty_range(self, source: "PathWrap") -> "void":
        return _simulation.PathWrap_copyProperty_range(self, source)

    def get_range(self, i: "int") -> "int const &":
        return _simulation.PathWrap_get_range(self, i)

    def upd_range(self, i: "int") -> "int &":
        return _simulation.PathWrap_upd_range(self, i)

    def set_range(self, i: "int", value: "int const &") -> "void":
        return _simulation.PathWrap_set_range(self, i, value)

    def append_range(self, value: "int const &") -> "int":
        return _simulation.PathWrap_append_range(self, value)
    hybrid = _simulation.PathWrap_hybrid
    midpoint = _simulation.PathWrap_midpoint
    axial = _simulation.PathWrap_axial

    def __init__(self):
        _simulation.PathWrap_swiginit(self, _simulation.new_PathWrap())
    __swig_destroy__ = _simulation.delete_PathWrap

    def getStartPoint(self) -> "int":
        return _simulation.PathWrap_getStartPoint(self)

    def getEndPoint(self) -> "int":
        return _simulation.PathWrap_getEndPoint(self)

    def getWrapObjectName(self) -> "std::string const &":
        return _simulation.PathWrap_getWrapObjectName(self)

    def getWrapObject(self) -> "OpenSim::WrapObject const *":
        return _simulation.PathWrap_getWrapObject(self)

    def setWrapObject(self, aWrapObject: "WrapObject") -> "void":
        return _simulation.PathWrap_setWrapObject(self, aWrapObject)

    def getWrapPoint1(self) -> "PathWrapPoint const &":
        return _simulation.PathWrap_getWrapPoint1(self)

    def getWrapPoint2(self) -> "PathWrapPoint const &":
        return _simulation.PathWrap_getWrapPoint2(self)

    def updWrapPoint1(self) -> "PathWrapPoint &":
        return _simulation.PathWrap_updWrapPoint1(self)

    def updWrapPoint2(self) -> "PathWrapPoint &":
        return _simulation.PathWrap_updWrapPoint2(self)

    def getMethod(self) -> "OpenSim::PathWrap::WrapMethod":
        return _simulation.PathWrap_getMethod(self)

    def setMethod(self, aMethod: "OpenSim::PathWrap::WrapMethod") -> "void":
        return _simulation.PathWrap_setMethod(self, aMethod)

    def getMethodName(self) -> "std::string const &":
        return _simulation.PathWrap_getMethodName(self)

    def getPreviousWrap(self) -> "OpenSim::WrapResult const &":
        return _simulation.PathWrap_getPreviousWrap(self)

    def setPreviousWrap(self, aWrapResult: "OpenSim::WrapResult const &") -> "void":
        return _simulation.PathWrap_setPreviousWrap(self, aWrapResult)

    def resetPreviousWrap(self) -> "void":
        return _simulation.PathWrap_resetPreviousWrap(self)

# Register PathWrap in _simulation:
_simulation.PathWrap_swigregister(PathWrap)

def PathWrap_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrap *":
    return _simulation.PathWrap_safeDownCast(obj)

def PathWrap_getClassName() -> "std::string const &":
    return _simulation.PathWrap_getClassName()

class SetPathWrap(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::PathWrap,OpenSim::Object > *":
        return _simulation.SetPathWrap_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetPathWrap_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetPathWrap_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::PathWrap,OpenSim::Object > *":
        return _simulation.SetPathWrap_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetPathWrap_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetPathWrap

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::PathWrap,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetPathWrap_swiginit(self, _simulation.new_SetPathWrap(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetPathWrap_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetPathWrap_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetPathWrap_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetPathWrap_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetPathWrap_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetPathWrap_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "PathWrap") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetPathWrap_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "PathWrap") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetPathWrap_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "PathWrap") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetPathWrap_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`PathWrap`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetPathWrap_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetPathWrap_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "PathWrap", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`PathWrap`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetPathWrap_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::PathWrap &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`PathWrap`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`PathWrap`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetPathWrap_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetPathWrap_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetPathWrap_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetPathWrap_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetPathWrap_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetPathWrap_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetPathWrap_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetPathWrap_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetPathWrap_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetPathWrap_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetPathWrap in _simulation:
_simulation.SetPathWrap_swigregister(SetPathWrap)

def SetPathWrap_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::PathWrap,OpenSim::Object > *":
    return _simulation.SetPathWrap_safeDownCast(obj)

def SetPathWrap_getClassName() -> "std::string const &":
    return _simulation.SetPathWrap_getClassName()

class PathWrapSet(SetPathWrap):
    r"""
     Conditional comment: *
    A class for holding a set of muscle wrap instances.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrapSet *":
        return _simulation.PathWrapSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathWrapSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathWrapSet_getClassName()

    def clone(self) -> "OpenSim::PathWrapSet *":
        return _simulation.PathWrapSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathWrapSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.PathWrapSet_swiginit(self, _simulation.new_PathWrapSet(*args))
    __swig_destroy__ = _simulation.delete_PathWrapSet

# Register PathWrapSet in _simulation:
_simulation.PathWrapSet_swigregister(PathWrapSet)

def PathWrapSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrapSet *":
    return _simulation.PathWrapSet_safeDownCast(obj)

def PathWrapSet_getClassName() -> "std::string const &":
    return _simulation.PathWrapSet_getClassName()

class WrapCylinderObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a cylinder obstacle for muscle wrapping, based on
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapCylinderObst *":
        return _simulation.WrapCylinderObst_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapCylinderObst_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapCylinderObst_getClassName()

    def clone(self) -> "OpenSim::WrapCylinderObst *":
        return _simulation.WrapCylinderObst_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapCylinderObst_getConcreteClassName(self)

    def copyProperty_radius(self, source: "WrapCylinderObst") -> "void":
        return _simulation.WrapCylinderObst_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.WrapCylinderObst_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapCylinderObst_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.WrapCylinderObst_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.WrapCylinderObst_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.WrapCylinderObst_set_radius(self, *args)

    def copyProperty_length(self, source: "WrapCylinderObst") -> "void":
        return _simulation.WrapCylinderObst_copyProperty_length(self, source)

    def append_length(self, value: "double const &") -> "int":
        return _simulation.WrapCylinderObst_append_length(self, value)

    def constructProperty_length(self, initValue: "double const &") -> "void":
        return _simulation.WrapCylinderObst_constructProperty_length(self, initValue)

    def get_length(self, *args) -> "double const &":
        return _simulation.WrapCylinderObst_get_length(self, *args)

    def upd_length(self, *args) -> "double &":
        return _simulation.WrapCylinderObst_upd_length(self, *args)

    def set_length(self, *args) -> "void":
        return _simulation.WrapCylinderObst_set_length(self, *args)

    def copyProperty_wrapDirection(self, source: "WrapCylinderObst") -> "void":
        return _simulation.WrapCylinderObst_copyProperty_wrapDirection(self, source)

    def append_wrapDirection(self, value: "std::string const &") -> "int":
        return _simulation.WrapCylinderObst_append_wrapDirection(self, value)

    def constructProperty_wrapDirection(self, initValue: "std::string const &") -> "void":
        return _simulation.WrapCylinderObst_constructProperty_wrapDirection(self, initValue)

    def get_wrapDirection(self, *args) -> "std::string const &":
        return _simulation.WrapCylinderObst_get_wrapDirection(self, *args)

    def upd_wrapDirection(self, *args) -> "std::string &":
        return _simulation.WrapCylinderObst_upd_wrapDirection(self, *args)

    def set_wrapDirection(self, *args) -> "void":
        return _simulation.WrapCylinderObst_set_wrapDirection(self, *args)

    def __init__(self):
        _simulation.WrapCylinderObst_swiginit(self, _simulation.new_WrapCylinderObst())
    __swig_destroy__ = _simulation.delete_WrapCylinderObst

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapCylinderObst_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapCylinderObst_getDimensionsString(self)

    def getRadius(self) -> "double":
        return _simulation.WrapCylinderObst_getRadius(self)

    def setRadius(self, aRadius: "double") -> "void":
        return _simulation.WrapCylinderObst_setRadius(self, aRadius)

    def getLength(self) -> "double":
        return _simulation.WrapCylinderObst_getLength(self)

    def setLength(self, aLength: "double") -> "void":
        return _simulation.WrapCylinderObst_setLength(self, aLength)

    def getWrapDirection(self) -> "int":
        return _simulation.WrapCylinderObst_getWrapDirection(self)

# Register WrapCylinderObst in _simulation:
_simulation.WrapCylinderObst_swigregister(WrapCylinderObst)

def WrapCylinderObst_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapCylinderObst *":
    return _simulation.WrapCylinderObst_safeDownCast(obj)

def WrapCylinderObst_getClassName() -> "std::string const &":
    return _simulation.WrapCylinderObst_getClassName()

class WrapSphereObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a sphere obstacle for muscle wrapping, based on the
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapSphereObst *":
        return _simulation.WrapSphereObst_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapSphereObst_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapSphereObst_getClassName()

    def clone(self) -> "OpenSim::WrapSphereObst *":
        return _simulation.WrapSphereObst_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapSphereObst_getConcreteClassName(self)

    def copyProperty_radius(self, source: "WrapSphereObst") -> "void":
        return _simulation.WrapSphereObst_copyProperty_radius(self, source)

    def append_radius(self, value: "double const &") -> "int":
        return _simulation.WrapSphereObst_append_radius(self, value)

    def constructProperty_radius(self, initValue: "double const &") -> "void":
        return _simulation.WrapSphereObst_constructProperty_radius(self, initValue)

    def get_radius(self, *args) -> "double const &":
        return _simulation.WrapSphereObst_get_radius(self, *args)

    def upd_radius(self, *args) -> "double &":
        return _simulation.WrapSphereObst_upd_radius(self, *args)

    def set_radius(self, *args) -> "void":
        return _simulation.WrapSphereObst_set_radius(self, *args)

    def copyProperty_length(self, source: "WrapSphereObst") -> "void":
        return _simulation.WrapSphereObst_copyProperty_length(self, source)

    def append_length(self, value: "double const &") -> "int":
        return _simulation.WrapSphereObst_append_length(self, value)

    def constructProperty_length(self, initValue: "double const &") -> "void":
        return _simulation.WrapSphereObst_constructProperty_length(self, initValue)

    def get_length(self, *args) -> "double const &":
        return _simulation.WrapSphereObst_get_length(self, *args)

    def upd_length(self, *args) -> "double &":
        return _simulation.WrapSphereObst_upd_length(self, *args)

    def set_length(self, *args) -> "void":
        return _simulation.WrapSphereObst_set_length(self, *args)

    def __init__(self):
        _simulation.WrapSphereObst_swiginit(self, _simulation.new_WrapSphereObst())
    __swig_destroy__ = _simulation.delete_WrapSphereObst

    def getRadius(self) -> "double":
        return _simulation.WrapSphereObst_getRadius(self)

    def setRadius(self, aRadius: "double") -> "void":
        return _simulation.WrapSphereObst_setRadius(self, aRadius)

    def getLength(self) -> "double":
        return _simulation.WrapSphereObst_getLength(self)

    def setLength(self, aLength: "double") -> "void":
        return _simulation.WrapSphereObst_setLength(self, aLength)

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapSphereObst_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapSphereObst_getDimensionsString(self)

# Register WrapSphereObst in _simulation:
_simulation.WrapSphereObst_swigregister(WrapSphereObst)

def WrapSphereObst_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapSphereObst *":
    return _simulation.WrapSphereObst_safeDownCast(obj)

def WrapSphereObst_getClassName() -> "std::string const &":
    return _simulation.WrapSphereObst_getClassName()

class WrapDoubleCylinderObst(WrapObject):
    r"""
     Conditional comment: *
    A class implementing a cylinder obstacle for muscle wrapping, based on
    algorithm presented in Garner & Pandy (2000).

    Author: Brian Garner, derived from Peter Loan
    updated for OpenSim 4.0 by Benjamin Michaud, 2019.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapDoubleCylinderObst *":
        return _simulation.WrapDoubleCylinderObst_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.WrapDoubleCylinderObst_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.WrapDoubleCylinderObst_getClassName()

    def clone(self) -> "OpenSim::WrapDoubleCylinderObst *":
        return _simulation.WrapDoubleCylinderObst_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.WrapDoubleCylinderObst_getConcreteClassName(self)

    def copyProperty_wrapVcylHomeBodyName(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapVcylHomeBodyName(self, source)

    def append_wrapVcylHomeBodyName(self, value: "std::string const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_wrapVcylHomeBodyName(self, value)

    def constructProperty_wrapVcylHomeBodyName(self, initValue: "std::string const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapVcylHomeBodyName(self, initValue)

    def get_wrapVcylHomeBodyName(self, *args) -> "std::string const &":
        return _simulation.WrapDoubleCylinderObst_get_wrapVcylHomeBodyName(self, *args)

    def upd_wrapVcylHomeBodyName(self, *args) -> "std::string &":
        return _simulation.WrapDoubleCylinderObst_upd_wrapVcylHomeBodyName(self, *args)

    def set_wrapVcylHomeBodyName(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_wrapVcylHomeBodyName(self, *args)

    def copyProperty_radiusUcyl(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_radiusUcyl(self, source)

    def append_radiusUcyl(self, value: "double const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_radiusUcyl(self, value)

    def constructProperty_radiusUcyl(self, initValue: "double const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_radiusUcyl(self, initValue)

    def get_radiusUcyl(self, *args) -> "double const &":
        return _simulation.WrapDoubleCylinderObst_get_radiusUcyl(self, *args)

    def upd_radiusUcyl(self, *args) -> "double &":
        return _simulation.WrapDoubleCylinderObst_upd_radiusUcyl(self, *args)

    def set_radiusUcyl(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_radiusUcyl(self, *args)

    def copyProperty_radiusVcyl(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_radiusVcyl(self, source)

    def append_radiusVcyl(self, value: "double const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_radiusVcyl(self, value)

    def constructProperty_radiusVcyl(self, initValue: "double const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_radiusVcyl(self, initValue)

    def get_radiusVcyl(self, *args) -> "double const &":
        return _simulation.WrapDoubleCylinderObst_get_radiusVcyl(self, *args)

    def upd_radiusVcyl(self, *args) -> "double &":
        return _simulation.WrapDoubleCylinderObst_upd_radiusVcyl(self, *args)

    def set_radiusVcyl(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_radiusVcyl(self, *args)

    def copyProperty_wrapUcylDirection(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapUcylDirection(self, source)

    def append_wrapUcylDirection(self, value: "std::string const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_wrapUcylDirection(self, value)

    def constructProperty_wrapUcylDirection(self, initValue: "std::string const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapUcylDirection(self, initValue)

    def get_wrapUcylDirection(self, *args) -> "std::string const &":
        return _simulation.WrapDoubleCylinderObst_get_wrapUcylDirection(self, *args)

    def upd_wrapUcylDirection(self, *args) -> "std::string &":
        return _simulation.WrapDoubleCylinderObst_upd_wrapUcylDirection(self, *args)

    def set_wrapUcylDirection(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_wrapUcylDirection(self, *args)

    def copyProperty_wrapVcylDirection(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_wrapVcylDirection(self, source)

    def append_wrapVcylDirection(self, value: "std::string const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_wrapVcylDirection(self, value)

    def constructProperty_wrapVcylDirection(self, initValue: "std::string const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_wrapVcylDirection(self, initValue)

    def get_wrapVcylDirection(self, *args) -> "std::string const &":
        return _simulation.WrapDoubleCylinderObst_get_wrapVcylDirection(self, *args)

    def upd_wrapVcylDirection(self, *args) -> "std::string &":
        return _simulation.WrapDoubleCylinderObst_upd_wrapVcylDirection(self, *args)

    def set_wrapVcylDirection(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_wrapVcylDirection(self, *args)

    def copyProperty_translationVcyl(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_translationVcyl(self, source)

    def append_translationVcyl(self, value: "Vec3") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_translationVcyl(self, value)

    def constructProperty_translationVcyl(self, initValue: "Vec3") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_translationVcyl(self, initValue)

    def get_translationVcyl(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.WrapDoubleCylinderObst_get_translationVcyl(self, *args)

    def upd_translationVcyl(self, *args) -> "SimTK::Vec3 &":
        return _simulation.WrapDoubleCylinderObst_upd_translationVcyl(self, *args)

    def set_translationVcyl(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_translationVcyl(self, *args)

    def copyProperty_xyz_body_rotationVcyl(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_xyz_body_rotationVcyl(self, source)

    def append_xyz_body_rotationVcyl(self, value: "Vec3") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_xyz_body_rotationVcyl(self, value)

    def constructProperty_xyz_body_rotationVcyl(self, initValue: "Vec3") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_xyz_body_rotationVcyl(self, initValue)

    def get_xyz_body_rotationVcyl(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.WrapDoubleCylinderObst_get_xyz_body_rotationVcyl(self, *args)

    def upd_xyz_body_rotationVcyl(self, *args) -> "SimTK::Vec3 &":
        return _simulation.WrapDoubleCylinderObst_upd_xyz_body_rotationVcyl(self, *args)

    def set_xyz_body_rotationVcyl(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_xyz_body_rotationVcyl(self, *args)

    def copyProperty_length(self, source: "WrapDoubleCylinderObst") -> "void":
        return _simulation.WrapDoubleCylinderObst_copyProperty_length(self, source)

    def append_length(self, value: "double const &") -> "int":
        return _simulation.WrapDoubleCylinderObst_append_length(self, value)

    def constructProperty_length(self, initValue: "double const &") -> "void":
        return _simulation.WrapDoubleCylinderObst_constructProperty_length(self, initValue)

    def get_length(self, *args) -> "double const &":
        return _simulation.WrapDoubleCylinderObst_get_length(self, *args)

    def upd_length(self, *args) -> "double &":
        return _simulation.WrapDoubleCylinderObst_upd_length(self, *args)

    def set_length(self, *args) -> "void":
        return _simulation.WrapDoubleCylinderObst_set_length(self, *args)

    def __init__(self):
        _simulation.WrapDoubleCylinderObst_swiginit(self, _simulation.new_WrapDoubleCylinderObst())
    __swig_destroy__ = _simulation.delete_WrapDoubleCylinderObst

    def getWrapTypeName(self) -> "char const *":
        return _simulation.WrapDoubleCylinderObst_getWrapTypeName(self)

    def getDimensionsString(self) -> "std::string":
        return _simulation.WrapDoubleCylinderObst_getDimensionsString(self)

    def connectToModelAndBody(self, aModel: "Model", aBody: "PhysicalFrame") -> "void":
        return _simulation.WrapDoubleCylinderObst_connectToModelAndBody(self, aModel, aBody)

# Register WrapDoubleCylinderObst in _simulation:
_simulation.WrapDoubleCylinderObst_swigregister(WrapDoubleCylinderObst)

def WrapDoubleCylinderObst_safeDownCast(obj: "OpenSimObject") -> "OpenSim::WrapDoubleCylinderObst *":
    return _simulation.WrapDoubleCylinderObst_safeDownCast(obj)

def WrapDoubleCylinderObst_getClassName() -> "std::string const &":
    return _simulation.WrapDoubleCylinderObst_getClassName()

class Probe(ModelComponent):
    r"""
    This class represents a Probe which is designed to query a Vector of model
    values given system state. This model quantity is specified as a
    SimTK::Vector by the pure virtual method computeProbeInputs(), which must be
    specified for each child Probe.  In addition, the Probe model component
    interface allows * operations * to be performed on this value
    (specified by the property: probe_operation), and then have this result
    scaled (by the scalar property: 'scale_factor').

    The data flow of the Probe is shown below:

      .. code-block:: c++


          ===========================
          |  SimTK::Vector          |       DEVELOPER NEEDS TO IMPLEMENT THIS
          |  computeProbeInputs(s)  |
          ===========================
                       |
                       |
                       |                    THIS FUNCTIONALITY BELOW IS
                       |                    PROVIDED BY THE PROBE INTERFACE
          |------------|---------------------------------------------------------|
          |            V                                                         |
          |   =========================         ======================           |
          |   |  Apply the operation  |  ---->  |  Scale the output  |           |
          |   |   'probe_operation'   |         |      'gain'        |           |
          |   =========================         ======================           |
          |                                               |                      |
          |                                               V                      |
          |                                     ========================         |
          |                                     |  SimTK::Vector       |         |
          |                                     |  getProbeOutputs(s)  |---------------->
          |                                     ========================         |
          |                                    This method is called by the      |
          |                                   ProbeReporter, or alternatively    |
          |                                        by the API developer          |
          |----------------------------------------------------------------------|

    The model query is performed at Stage::Report, so that model values are up
    to date and is based on the specific Probe's overridden method
    computeProbeInputs(s).  The final output of the probe is available by
    accessing getProbeOutputs(s).  Note that all queries, operations, and
    scaling are performed by SimTK::Measures.  Note also that to define a new
    child Probe class, three methods which are declared as pure virtual in this
    Probe abstract class need to be overridden:

    - computeProbeInputs()     ---   returns the input probe values (i.e., model
                                     queries).
    - getNumProbeInputs()      ---   returns the size of the vector of input
                                     probe values (i.e., model queries).
    - getProbeOutputLabels()   ---   returns the labels that correspond to each
                                     probe value.

    ** Available probe operations: **
    - 'value' (default): returns the probe input value.
    - 'integrate'      : returns the integral of the probe input value.
    - 'differentiate'  : returns the derivative of the probe input value.
    - 'minimum'        : returns the minimum of the probe input value.
    - 'minabs'         : returns the absolute minimum of the probe input value
                         (always positive).
    - 'maximum'        : returns the maximum of the probe input value.
    - 'maxabs'         : returns the absolute maximum of the probe input value
                         (always positive).

    The Probe interface differs from the Analysis interface in two fundamental
    ways:
    -  (1) Operations can be performed on probes (i.e., in addition to simply
           reporting a model value, model values (probe input values) may have
           operations performed on them such as integration and
           differentiation).

    -  (2) Analyses are not formally part of the model structure (i.e. they are
           not ModelComponents), and because of this, analysis results can not
           be accessed with the model and state value -- they can only be
           accessed by file at the end of a simulation. Probes, on the other
           hand, are ModelComponents and therefore can be accessed at any time
           during a simulation from the API, and can also be used to compute
           model values that are fed back into the system via custom
           designed Controllers. Note that Probe values can also be reported to
           file at the end of a simulation by attaching a ProbeReporter analysis
           to the simulation.


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Probe *":
        return _simulation.Probe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Probe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Probe_getClassName()

    def clone(self) -> "OpenSim::Probe *":
        return _simulation.Probe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Probe_getConcreteClassName(self)

    def copyProperty_enabled(self, source: "Probe") -> "void":
        r""" Enabled (true) by default. *"""
        return _simulation.Probe_copyProperty_enabled(self, source)

    def append_enabled(self, value: "bool const &") -> "int":
        return _simulation.Probe_append_enabled(self, value)

    def constructProperty_enabled(self, initValue: "bool const &") -> "void":
        return _simulation.Probe_constructProperty_enabled(self, initValue)

    def get_enabled(self, *args) -> "bool const &":
        return _simulation.Probe_get_enabled(self, *args)

    def upd_enabled(self, *args) -> "bool &":
        return _simulation.Probe_upd_enabled(self, *args)

    def set_enabled(self, *args) -> "void":
        return _simulation.Probe_set_enabled(self, *args)

    def copyProperty_probe_operation(self, source: "Probe") -> "void":
        return _simulation.Probe_copyProperty_probe_operation(self, source)

    def append_probe_operation(self, value: "std::string const &") -> "int":
        return _simulation.Probe_append_probe_operation(self, value)

    def constructProperty_probe_operation(self, initValue: "std::string const &") -> "void":
        return _simulation.Probe_constructProperty_probe_operation(self, initValue)

    def get_probe_operation(self, *args) -> "std::string const &":
        return _simulation.Probe_get_probe_operation(self, *args)

    def upd_probe_operation(self, *args) -> "std::string &":
        return _simulation.Probe_upd_probe_operation(self, *args)

    def set_probe_operation(self, *args) -> "void":
        return _simulation.Probe_set_probe_operation(self, *args)

    def copyProperty_initial_conditions_for_integration(self, source: "Probe") -> "void":
        return _simulation.Probe_copyProperty_initial_conditions_for_integration(self, source)

    def get_initial_conditions_for_integration(self, i: "int") -> "double const &":
        return _simulation.Probe_get_initial_conditions_for_integration(self, i)

    def upd_initial_conditions_for_integration(self, i: "int") -> "double &":
        return _simulation.Probe_upd_initial_conditions_for_integration(self, i)

    def set_initial_conditions_for_integration(self, i: "int", value: "double const &") -> "void":
        return _simulation.Probe_set_initial_conditions_for_integration(self, i, value)

    def append_initial_conditions_for_integration(self, value: "double const &") -> "int":
        return _simulation.Probe_append_initial_conditions_for_integration(self, value)

    def constructProperty_initial_conditions_for_integration(self) -> "void":
        return _simulation.Probe_constructProperty_initial_conditions_for_integration(self)

    def copyProperty_gain(self, source: "Probe") -> "void":
        return _simulation.Probe_copyProperty_gain(self, source)

    def append_gain(self, value: "double const &") -> "int":
        return _simulation.Probe_append_gain(self, value)

    def constructProperty_gain(self, initValue: "double const &") -> "void":
        return _simulation.Probe_constructProperty_gain(self, initValue)

    def get_gain(self, *args) -> "double const &":
        return _simulation.Probe_get_gain(self, *args)

    def upd_gain(self, *args) -> "double &":
        return _simulation.Probe_upd_gain(self, *args)

    def set_gain(self, *args) -> "void":
        return _simulation.Probe_set_gain(self, *args)
    _has_output_probe_outputs = property(_simulation.Probe__has_output_probe_outputs_get, _simulation.Probe__has_output_probe_outputs_set)

    def reset(self, s: "State") -> "void":
        r""" Reset (initialize) the underlying Probe SimTK::Measure."""
        return _simulation.Probe_reset(self, s)

    def getNumInternalMeasureStates(self) -> "int":
        r""" Get the number of states in the underlying SimTK::Measure."""
        return _simulation.Probe_getNumInternalMeasureStates(self)

    def isEnabled(self) -> "bool":
        r"""
        Returns true if the Probe is enabled and false if the probe is
               disabled.
        """
        return _simulation.Probe_isEnabled(self)

    def setEnabled(self, enabled: "bool") -> "void":
        r""" %Set the Probe as enabled (true) or disabled (false)."""
        return _simulation.Probe_setEnabled(self, enabled)

    def getOperation(self) -> "std::string":
        r""" Return the operation being performed on the probe value."""
        return _simulation.Probe_getOperation(self)

    def setOperation(self, probe_operation: "std::string") -> "void":
        r""" %Set the operation being performed on the probe value."""
        return _simulation.Probe_setOperation(self, probe_operation)

    def getInitialConditions(self) -> "SimTK::Vector":
        r""" Return the initial conditions (when the probe_operation is set to 'integrate')."""
        return _simulation.Probe_getInitialConditions(self)

    def setInitialConditions(self, initial_conditions_for_integration: "Vector") -> "void":
        r""" %Set the initial conditions (when the probe_operation is set to 'integrate')."""
        return _simulation.Probe_setInitialConditions(self, initial_conditions_for_integration)

    def getGain(self) -> "double":
        r""" Return the gain to apply to the probe output."""
        return _simulation.Probe_getGain(self)

    def setGain(self, gain: "double") -> "void":
        r""" %Set the gain to apply to the probe output."""
        return _simulation.Probe_setGain(self, gain)

    def getProbeOutputs(self, state: "State") -> "SimTK::Vector":
        r"""
        Returns the values of the probe after the operation has been performed.

           :type state: :py:class:`State`
           :param state:   System state from which value is computed.
           :rtype: :py:class:`Vector`
           :return: The SimTK::Vector of probe output values.*
        """
        return _simulation.Probe_getProbeOutputs(self, state)

    def updateFromXMLNode(self, node: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        return _simulation.Probe_updateFromXMLNode(self, node, versionNumber)
    __swig_destroy__ = _simulation.delete_Probe

# Register Probe in _simulation:
_simulation.Probe_swigregister(Probe)

def Probe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Probe *":
    return _simulation.Probe_safeDownCast(obj)

def Probe_getClassName() -> "std::string const &":
    return _simulation.Probe_getClassName()

class SetProbes(ModelComponent):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Probe,OpenSim::ModelComponent > *":
        return _simulation.SetProbes_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetProbes_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetProbes_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Probe,OpenSim::ModelComponent > *":
        return _simulation.SetProbes_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetProbes_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetProbes

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Probe,OpenSim::ModelComponent >
        :param aSet: Set to be copied.
        """
        _simulation.SetProbes_swiginit(self, _simulation.new_SetProbes(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetProbes_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetProbes_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetProbes_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetProbes_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Probe`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetProbes_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetProbes_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Probe") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Probe`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetProbes_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Probe") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Probe`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetProbes_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Probe") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Probe`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetProbes_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Probe`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetProbes_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetProbes_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Probe", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Probe`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetProbes_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Probe &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Probe`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Probe`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetProbes_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetProbes_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetProbes_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetProbes_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetProbes_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetProbes_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetProbes_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetProbes_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetProbes_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetProbes_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetProbes in _simulation:
_simulation.SetProbes_swigregister(SetProbes)

def SetProbes_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Probe,OpenSim::ModelComponent > *":
    return _simulation.SetProbes_safeDownCast(obj)

def SetProbes_getClassName() -> "std::string const &":
    return _simulation.SetProbes_getClassName()

class ModelComponentSetProbes(SetProbes):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Probe > *":
        return _simulation.ModelComponentSetProbes_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelComponentSetProbes_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelComponentSetProbes_getClassName()

    def clone(self) -> "OpenSim::ModelComponentSet< OpenSim::Probe > *":
        return _simulation.ModelComponentSetProbes_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentSetProbes_getConcreteClassName(self)

    def extendFinalizeFromProperties(self) -> "void":
        return _simulation.ModelComponentSetProbes_extendFinalizeFromProperties(self)

    def __init__(self):
        _simulation.ModelComponentSetProbes_swiginit(self, _simulation.new_ModelComponentSetProbes())
    __swig_destroy__ = _simulation.delete_ModelComponentSetProbes

# Register ModelComponentSetProbes in _simulation:
_simulation.ModelComponentSetProbes_swigregister(ModelComponentSetProbes)

def ModelComponentSetProbes_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelComponentSet< OpenSim::Probe > *":
    return _simulation.ModelComponentSetProbes_safeDownCast(obj)

def ModelComponentSetProbes_getClassName() -> "std::string const &":
    return _simulation.ModelComponentSetProbes_getClassName()

class ProbeSet(ModelComponentSetProbes):
    r"""
    A class for holding a set of probes.

    Authors: Tim Dorn
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ProbeSet *":
        return _simulation.ProbeSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ProbeSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ProbeSet_getClassName()

    def clone(self) -> "OpenSim::ProbeSet *":
        return _simulation.ProbeSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ProbeSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.ProbeSet_swiginit(self, _simulation.new_ProbeSet(*args))

    def adoptAndAppend(self, aProbe):
        aProbe._markAdopted()
        return super(ProbeSet, self).adoptAndAppend(aProbe)

    __swig_destroy__ = _simulation.delete_ProbeSet

# Register ProbeSet in _simulation:
_simulation.ProbeSet_swigregister(ProbeSet)

def ProbeSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ProbeSet *":
    return _simulation.ProbeSet_safeDownCast(obj)

def ProbeSet_getClassName() -> "std::string const &":
    return _simulation.ProbeSet_getClassName()

class SystemEnergyProbe(Probe):
    r"""
    SystemEnergyProbe is a ModelComponent Probe for computing an operation on a
    total system energy during a simulation.
    E.g. Work is the integral of power with respect to time.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SystemEnergyProbe *":
        return _simulation.SystemEnergyProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SystemEnergyProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SystemEnergyProbe_getClassName()

    def clone(self) -> "OpenSim::SystemEnergyProbe *":
        return _simulation.SystemEnergyProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SystemEnergyProbe_getConcreteClassName(self)

    def copyProperty_compute_kinetic_energy(self, source: "SystemEnergyProbe") -> "void":
        r""" Default is true. *"""
        return _simulation.SystemEnergyProbe_copyProperty_compute_kinetic_energy(self, source)

    def append_compute_kinetic_energy(self, value: "bool const &") -> "int":
        return _simulation.SystemEnergyProbe_append_compute_kinetic_energy(self, value)

    def constructProperty_compute_kinetic_energy(self, initValue: "bool const &") -> "void":
        return _simulation.SystemEnergyProbe_constructProperty_compute_kinetic_energy(self, initValue)

    def get_compute_kinetic_energy(self, *args) -> "bool const &":
        return _simulation.SystemEnergyProbe_get_compute_kinetic_energy(self, *args)

    def upd_compute_kinetic_energy(self, *args) -> "bool &":
        return _simulation.SystemEnergyProbe_upd_compute_kinetic_energy(self, *args)

    def set_compute_kinetic_energy(self, *args) -> "void":
        return _simulation.SystemEnergyProbe_set_compute_kinetic_energy(self, *args)

    def copyProperty_compute_potential_energy(self, source: "SystemEnergyProbe") -> "void":
        r""" Default is true. *"""
        return _simulation.SystemEnergyProbe_copyProperty_compute_potential_energy(self, source)

    def append_compute_potential_energy(self, value: "bool const &") -> "int":
        return _simulation.SystemEnergyProbe_append_compute_potential_energy(self, value)

    def constructProperty_compute_potential_energy(self, initValue: "bool const &") -> "void":
        return _simulation.SystemEnergyProbe_constructProperty_compute_potential_energy(self, initValue)

    def get_compute_potential_energy(self, *args) -> "bool const &":
        return _simulation.SystemEnergyProbe_get_compute_potential_energy(self, *args)

    def upd_compute_potential_energy(self, *args) -> "bool &":
        return _simulation.SystemEnergyProbe_upd_compute_potential_energy(self, *args)

    def set_compute_potential_energy(self, *args) -> "void":
        return _simulation.SystemEnergyProbe_set_compute_potential_energy(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.SystemEnergyProbe_swiginit(self, _simulation.new_SystemEnergyProbe(*args))

    def getComputeKineticEnergy(self) -> "bool":
        r"""
        Returns whether kinetic energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_getComputeKineticEnergy(self)

    def getComputePotentialEnergy(self) -> "bool":
        r"""
        Returns whether potential energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_getComputePotentialEnergy(self)

    def setComputeKineticEnergy(self, c: "bool") -> "void":
        r"""
        Sets whether kinetic energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_setComputeKineticEnergy(self, c)

    def setComputePotentialEnergy(self, c: "bool") -> "void":
        r"""
        Sets whether potential energy is to be included in the system energy
           computation.
        """
        return _simulation.SystemEnergyProbe_setComputePotentialEnergy(self, c)

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute the System energy which the Probe operation will be based on."""
        return _simulation.SystemEnergyProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.SystemEnergyProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.SystemEnergyProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_SystemEnergyProbe

# Register SystemEnergyProbe in _simulation:
_simulation.SystemEnergyProbe_swigregister(SystemEnergyProbe)

def SystemEnergyProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SystemEnergyProbe *":
    return _simulation.SystemEnergyProbe_safeDownCast(obj)

def SystemEnergyProbe_getClassName() -> "std::string const &":
    return _simulation.SystemEnergyProbe_getClassName()

class JointInternalPowerProbe(Probe):
    r"""
    JointInternalPowerProbe is a ModelComponent Probe for computing an operation on
    internal joint power or sum of joint powers in the model during a simulation.
    E.g. Joint internal work is the integral of joint internal power with respect to time,
    so by using the JointInternalPowerProbe with the 'integrate' operation, Joint internal
    work may be computed.

    Author: Tim Dorn
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::JointInternalPowerProbe *":
        return _simulation.JointInternalPowerProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.JointInternalPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.JointInternalPowerProbe_getClassName()

    def clone(self) -> "OpenSim::JointInternalPowerProbe *":
        return _simulation.JointInternalPowerProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.JointInternalPowerProbe_getConcreteClassName(self)

    def copyProperty_joint_names(self, source: "JointInternalPowerProbe") -> "void":
        r""" List of Joints to probe.  *"""
        return _simulation.JointInternalPowerProbe_copyProperty_joint_names(self, source)

    def get_joint_names(self, i: "int") -> "std::string const &":
        return _simulation.JointInternalPowerProbe_get_joint_names(self, i)

    def upd_joint_names(self, i: "int") -> "std::string &":
        return _simulation.JointInternalPowerProbe_upd_joint_names(self, i)

    def set_joint_names(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.JointInternalPowerProbe_set_joint_names(self, i, value)

    def append_joint_names(self, value: "std::string const &") -> "int":
        return _simulation.JointInternalPowerProbe_append_joint_names(self, value)

    def constructProperty_joint_names(self) -> "void":
        return _simulation.JointInternalPowerProbe_constructProperty_joint_names(self)

    def copyProperty_sum_powers_together(self, source: "JointInternalPowerProbe") -> "void":
        r"""
        Flag to specify whether to report the sum of all powers,
               or report each power value separately.  *
        """
        return _simulation.JointInternalPowerProbe_copyProperty_sum_powers_together(self, source)

    def append_sum_powers_together(self, value: "bool const &") -> "int":
        return _simulation.JointInternalPowerProbe_append_sum_powers_together(self, value)

    def constructProperty_sum_powers_together(self, initValue: "bool const &") -> "void":
        return _simulation.JointInternalPowerProbe_constructProperty_sum_powers_together(self, initValue)

    def get_sum_powers_together(self, *args) -> "bool const &":
        return _simulation.JointInternalPowerProbe_get_sum_powers_together(self, *args)

    def upd_sum_powers_together(self, *args) -> "bool &":
        return _simulation.JointInternalPowerProbe_upd_sum_powers_together(self, *args)

    def set_sum_powers_together(self, *args) -> "void":
        return _simulation.JointInternalPowerProbe_set_sum_powers_together(self, *args)

    def copyProperty_exponent(self, source: "JointInternalPowerProbe") -> "void":
        r"""
        Element-wise power exponent to apply to each joint power prior to the Probe operation.
           For example, if two joints J1 and J2 are given in joint_names, then the
           Probe value will be equal to JointPower_J1^exponent + JointPower_J2^exponent.  *
        """
        return _simulation.JointInternalPowerProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value: "double const &") -> "int":
        return _simulation.JointInternalPowerProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue: "double const &") -> "void":
        return _simulation.JointInternalPowerProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args) -> "double const &":
        return _simulation.JointInternalPowerProbe_get_exponent(self, *args)

    def upd_exponent(self, *args) -> "double &":
        return _simulation.JointInternalPowerProbe_upd_exponent(self, *args)

    def set_exponent(self, *args) -> "void":
        return _simulation.JointInternalPowerProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.JointInternalPowerProbe_swiginit(self, _simulation.new_JointInternalPowerProbe(*args))

    def getJointNames(self) -> "OpenSim::Property< std::string > const &":
        r""" Returns the names of the Joints being probed."""
        return _simulation.JointInternalPowerProbe_getJointNames(self)

    def getSumPowersTogether(self) -> "bool":
        r"""
        Returns whether to report sum of all joint powers together
               or report the joint powers individually.
        """
        return _simulation.JointInternalPowerProbe_getSumPowersTogether(self)

    def getExponent(self) -> "double":
        r""" Returns the exponent to apply to each joint power."""
        return _simulation.JointInternalPowerProbe_getExponent(self)

    def setJointNames(self, aJointNames: "ArrayStr") -> "void":
        r""" Sets the names of the Joints being probed."""
        return _simulation.JointInternalPowerProbe_setJointNames(self, aJointNames)

    def setSumPowersTogether(self, sum_powers_together: "bool") -> "void":
        r"""
        Sets whether to report sum of all joint powers together
               or report the joint powers individually.
        """
        return _simulation.JointInternalPowerProbe_setSumPowersTogether(self, sum_powers_together)

    def setExponent(self, exponent: "double const") -> "void":
        r""" Sets the exponent to apply to each joint power."""
        return _simulation.JointInternalPowerProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute the Joint power. *"""
        return _simulation.JointInternalPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.JointInternalPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.JointInternalPowerProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_JointInternalPowerProbe

# Register JointInternalPowerProbe in _simulation:
_simulation.JointInternalPowerProbe_swigregister(JointInternalPowerProbe)

def JointInternalPowerProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::JointInternalPowerProbe *":
    return _simulation.JointInternalPowerProbe_safeDownCast(obj)

def JointInternalPowerProbe_getClassName() -> "std::string const &":
    return _simulation.JointInternalPowerProbe_getClassName()

class ActuatorPowerProbe(Probe):
    r"""
    ActuatorPowerProbe is a ModelComponent Probe for computing an operation on a
    actuator power or sum of actuator powers in the model during a simulation.
    E.g. Actuator work is the integral of actuator power with respect to time, so by using the
    ActuatorPowerProbe with the 'integrate' operation, Actuator work may be computed.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActuatorPowerProbe *":
        return _simulation.ActuatorPowerProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ActuatorPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ActuatorPowerProbe_getClassName()

    def clone(self) -> "OpenSim::ActuatorPowerProbe *":
        return _simulation.ActuatorPowerProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ActuatorPowerProbe_getConcreteClassName(self)

    def copyProperty_actuator_names(self, source: "ActuatorPowerProbe") -> "void":
        r""" List of Actuators to probe.  *"""
        return _simulation.ActuatorPowerProbe_copyProperty_actuator_names(self, source)

    def get_actuator_names(self, i: "int") -> "std::string const &":
        return _simulation.ActuatorPowerProbe_get_actuator_names(self, i)

    def upd_actuator_names(self, i: "int") -> "std::string &":
        return _simulation.ActuatorPowerProbe_upd_actuator_names(self, i)

    def set_actuator_names(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.ActuatorPowerProbe_set_actuator_names(self, i, value)

    def append_actuator_names(self, value: "std::string const &") -> "int":
        return _simulation.ActuatorPowerProbe_append_actuator_names(self, value)

    def constructProperty_actuator_names(self) -> "void":
        return _simulation.ActuatorPowerProbe_constructProperty_actuator_names(self)

    def copyProperty_sum_powers_together(self, source: "ActuatorPowerProbe") -> "void":
        r"""
        Flag to specify whether to report the sum of all powers,
           or report each power value separately.  *
        """
        return _simulation.ActuatorPowerProbe_copyProperty_sum_powers_together(self, source)

    def append_sum_powers_together(self, value: "bool const &") -> "int":
        return _simulation.ActuatorPowerProbe_append_sum_powers_together(self, value)

    def constructProperty_sum_powers_together(self, initValue: "bool const &") -> "void":
        return _simulation.ActuatorPowerProbe_constructProperty_sum_powers_together(self, initValue)

    def get_sum_powers_together(self, *args) -> "bool const &":
        return _simulation.ActuatorPowerProbe_get_sum_powers_together(self, *args)

    def upd_sum_powers_together(self, *args) -> "bool &":
        return _simulation.ActuatorPowerProbe_upd_sum_powers_together(self, *args)

    def set_sum_powers_together(self, *args) -> "void":
        return _simulation.ActuatorPowerProbe_set_sum_powers_together(self, *args)

    def copyProperty_exponent(self, source: "ActuatorPowerProbe") -> "void":
        r"""
        Element-wise power exponent to apply to each actuator power prior to
           the Probe operation.  For example, if two actuators A1 and A2 are given in
           actuator_names, then the Probe value will be equal to Power_A1^exponent +
           Power_A2^exponent.
        """
        return _simulation.ActuatorPowerProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value: "double const &") -> "int":
        return _simulation.ActuatorPowerProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue: "double const &") -> "void":
        return _simulation.ActuatorPowerProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args) -> "double const &":
        return _simulation.ActuatorPowerProbe_get_exponent(self, *args)

    def upd_exponent(self, *args) -> "double &":
        return _simulation.ActuatorPowerProbe_upd_exponent(self, *args)

    def set_exponent(self, *args) -> "void":
        return _simulation.ActuatorPowerProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.ActuatorPowerProbe_swiginit(self, _simulation.new_ActuatorPowerProbe(*args))

    def getActuatorNames(self) -> "OpenSim::Property< std::string > const &":
        r""" Returns the names of the Actuators being probed."""
        return _simulation.ActuatorPowerProbe_getActuatorNames(self)

    def getSumPowersTogether(self) -> "bool":
        r"""
        Returns whether to report sum of all actuator powers together
           or report the actuator powers individually.
        """
        return _simulation.ActuatorPowerProbe_getSumPowersTogether(self)

    def getExponent(self) -> "double":
        r""" Returns the exponent to apply to each actuator power."""
        return _simulation.ActuatorPowerProbe_getExponent(self)

    def setActuatorNames(self, actuatorNames: "ArrayStr") -> "void":
        r""" Sets the names of the Actuators being probed."""
        return _simulation.ActuatorPowerProbe_setActuatorNames(self, actuatorNames)

    def setSumPowersTogether(self, sum_powers_together: "bool") -> "void":
        r"""
        Sets whether to report sum of all actuator powers together
           or report the actuator powers individually.
        """
        return _simulation.ActuatorPowerProbe_setSumPowersTogether(self, sum_powers_together)

    def setExponent(self, exponent: "double const") -> "void":
        r""" Sets the exponent to apply to each actuator power."""
        return _simulation.ActuatorPowerProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute the Actuator power."""
        return _simulation.ActuatorPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r"""
         Returns the number of probe inputs in the vector returned by
        computeProbeInputs().
        """
        return _simulation.ActuatorPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
           Currently uses the Probe name as the column label, so be sure
           to name your probe appropriately!
        """
        return _simulation.ActuatorPowerProbe_getProbeOutputLabels(self)

    def extendConnectToModel(self, aModel: "Model") -> "void":
        return _simulation.ActuatorPowerProbe_extendConnectToModel(self, aModel)
    __swig_destroy__ = _simulation.delete_ActuatorPowerProbe

# Register ActuatorPowerProbe in _simulation:
_simulation.ActuatorPowerProbe_swigregister(ActuatorPowerProbe)

def ActuatorPowerProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActuatorPowerProbe *":
    return _simulation.ActuatorPowerProbe_safeDownCast(obj)

def ActuatorPowerProbe_getClassName() -> "std::string const &":
    return _simulation.ActuatorPowerProbe_getClassName()

class ActuatorForceProbe(Probe):
    r"""
    ActuatorForceProbe is a ModelComponent Probe for computing an operation on a
    force or sum of forces in the model during a simulation.
    E.g. Impulse is the integral of force with respect to time.

    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActuatorForceProbe *":
        return _simulation.ActuatorForceProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ActuatorForceProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ActuatorForceProbe_getClassName()

    def clone(self) -> "OpenSim::ActuatorForceProbe *":
        return _simulation.ActuatorForceProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ActuatorForceProbe_getConcreteClassName(self)

    def copyProperty_actuator_names(self, source: "ActuatorForceProbe") -> "void":
        r""" List of Actuator forces to probe.  *"""
        return _simulation.ActuatorForceProbe_copyProperty_actuator_names(self, source)

    def get_actuator_names(self, i: "int") -> "std::string const &":
        return _simulation.ActuatorForceProbe_get_actuator_names(self, i)

    def upd_actuator_names(self, i: "int") -> "std::string &":
        return _simulation.ActuatorForceProbe_upd_actuator_names(self, i)

    def set_actuator_names(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.ActuatorForceProbe_set_actuator_names(self, i, value)

    def append_actuator_names(self, value: "std::string const &") -> "int":
        return _simulation.ActuatorForceProbe_append_actuator_names(self, value)

    def constructProperty_actuator_names(self) -> "void":
        return _simulation.ActuatorForceProbe_constructProperty_actuator_names(self)

    def copyProperty_sum_forces_together(self, source: "ActuatorForceProbe") -> "void":
        r"""
        Flag to specify whether to report the sum of all forces,
           or report each force value separately.  *
        """
        return _simulation.ActuatorForceProbe_copyProperty_sum_forces_together(self, source)

    def append_sum_forces_together(self, value: "bool const &") -> "int":
        return _simulation.ActuatorForceProbe_append_sum_forces_together(self, value)

    def constructProperty_sum_forces_together(self, initValue: "bool const &") -> "void":
        return _simulation.ActuatorForceProbe_constructProperty_sum_forces_together(self, initValue)

    def get_sum_forces_together(self, *args) -> "bool const &":
        return _simulation.ActuatorForceProbe_get_sum_forces_together(self, *args)

    def upd_sum_forces_together(self, *args) -> "bool &":
        return _simulation.ActuatorForceProbe_upd_sum_forces_together(self, *args)

    def set_sum_forces_together(self, *args) -> "void":
        return _simulation.ActuatorForceProbe_set_sum_forces_together(self, *args)

    def copyProperty_exponent(self, source: "ActuatorForceProbe") -> "void":
        r"""
        Element-wise power exponent to apply to each force prior to the Probe operation.
           For example, if two actuators A1 and A2 are given in actuator_names, then the
           Probe value will be equal to Force_A1^exponent + Force_A2^exponent.  *
        """
        return _simulation.ActuatorForceProbe_copyProperty_exponent(self, source)

    def append_exponent(self, value: "double const &") -> "int":
        return _simulation.ActuatorForceProbe_append_exponent(self, value)

    def constructProperty_exponent(self, initValue: "double const &") -> "void":
        return _simulation.ActuatorForceProbe_constructProperty_exponent(self, initValue)

    def get_exponent(self, *args) -> "double const &":
        return _simulation.ActuatorForceProbe_get_exponent(self, *args)

    def upd_exponent(self, *args) -> "double &":
        return _simulation.ActuatorForceProbe_upd_exponent(self, *args)

    def set_exponent(self, *args) -> "void":
        return _simulation.ActuatorForceProbe_set_exponent(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.ActuatorForceProbe_swiginit(self, _simulation.new_ActuatorForceProbe(*args))

    def getActuatorNames(self) -> "OpenSim::Property< std::string > const &":
        r""" Returns the name(s) of the Actuator forces being probed."""
        return _simulation.ActuatorForceProbe_getActuatorNames(self)

    def getSumForcesTogether(self) -> "bool":
        r"""
        Returns whether to report sum of all Actuator forces together
           or report the forces individually.
        """
        return _simulation.ActuatorForceProbe_getSumForcesTogether(self)

    def getExponent(self) -> "double":
        r""" Returns the exponent to apply to each Actuator force."""
        return _simulation.ActuatorForceProbe_getExponent(self)

    def setActuatorNames(self, actuatorNames: "ArrayStr") -> "void":
        r""" Sets the name(s) of the Actuator forces being probed."""
        return _simulation.ActuatorForceProbe_setActuatorNames(self, actuatorNames)

    def setSumForcesTogether(self, sum_forces_together: "bool") -> "void":
        r"""
        Sets whether to report sum of all Actuator force values together
           or report the force values individually.
        """
        return _simulation.ActuatorForceProbe_setSumForcesTogether(self, sum_forces_together)

    def setExponent(self, exponent: "double const") -> "void":
        r""" Sets the exponent to apply to each Actuator force."""
        return _simulation.ActuatorForceProbe_setExponent(self, exponent)

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute the Force"""
        return _simulation.ActuatorForceProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.ActuatorForceProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
           Currently uses the Probe name as the column label, so be sure
           to name your probe appropriately!
        """
        return _simulation.ActuatorForceProbe_getProbeOutputLabels(self)

    def extendConnectToModel(self, model: "Model") -> "void":
        return _simulation.ActuatorForceProbe_extendConnectToModel(self, model)
    __swig_destroy__ = _simulation.delete_ActuatorForceProbe

# Register ActuatorForceProbe in _simulation:
_simulation.ActuatorForceProbe_swigregister(ActuatorForceProbe)

def ActuatorForceProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActuatorForceProbe *":
    return _simulation.ActuatorForceProbe_safeDownCast(obj)

def ActuatorForceProbe_getClassName() -> "std::string const &":
    return _simulation.ActuatorForceProbe_getClassName()

class MuscleActiveFiberPowerProbe(Probe):
    r"""
    MuscleActiveFiberPowerProbe is a ModelComponent probe for computing an
    operation on the active fiber power of a muscle.

      Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleActiveFiberPowerProbe *":
        return _simulation.MuscleActiveFiberPowerProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MuscleActiveFiberPowerProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MuscleActiveFiberPowerProbe_getClassName()

    def clone(self) -> "OpenSim::MuscleActiveFiberPowerProbe *":
        return _simulation.MuscleActiveFiberPowerProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MuscleActiveFiberPowerProbe_getConcreteClassName(self)

    def copyProperty_muscle_names(self, source: "MuscleActiveFiberPowerProbe") -> "void":
        r""" List of Muscles to probe.  *"""
        return _simulation.MuscleActiveFiberPowerProbe_copyProperty_muscle_names(self, source)

    def get_muscle_names(self, i: "int") -> "std::string const &":
        return _simulation.MuscleActiveFiberPowerProbe_get_muscle_names(self, i)

    def upd_muscle_names(self, i: "int") -> "std::string &":
        return _simulation.MuscleActiveFiberPowerProbe_upd_muscle_names(self, i)

    def set_muscle_names(self, i: "int", value: "std::string const &") -> "void":
        return _simulation.MuscleActiveFiberPowerProbe_set_muscle_names(self, i, value)

    def append_muscle_names(self, value: "std::string const &") -> "int":
        return _simulation.MuscleActiveFiberPowerProbe_append_muscle_names(self, value)

    def constructProperty_muscle_names(self) -> "void":
        return _simulation.MuscleActiveFiberPowerProbe_constructProperty_muscle_names(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.MuscleActiveFiberPowerProbe_swiginit(self, _simulation.new_MuscleActiveFiberPowerProbe(*args))

    def getMuscleNames(self) -> "OpenSim::Property< std::string > const &":
        r""" Returns the names of the Actuators being probed."""
        return _simulation.MuscleActiveFiberPowerProbe_getMuscleNames(self)

    def setMuscleNames(self, muscleNames: "ArrayStr") -> "void":
        r""" Sets the names of the Actuators being probed."""
        return _simulation.MuscleActiveFiberPowerProbe_setMuscleNames(self, muscleNames)

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute the Actuator power upon which the Probe operation will be based."""
        return _simulation.MuscleActiveFiberPowerProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.MuscleActiveFiberPowerProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.MuscleActiveFiberPowerProbe_getProbeOutputLabels(self)
    __swig_destroy__ = _simulation.delete_MuscleActiveFiberPowerProbe

# Register MuscleActiveFiberPowerProbe in _simulation:
_simulation.MuscleActiveFiberPowerProbe_swigregister(MuscleActiveFiberPowerProbe)

def MuscleActiveFiberPowerProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleActiveFiberPowerProbe *":
    return _simulation.MuscleActiveFiberPowerProbe_safeDownCast(obj)

def MuscleActiveFiberPowerProbe_getClassName() -> "std::string const &":
    return _simulation.MuscleActiveFiberPowerProbe_getClassName()

class Bhargava2004MuscleMetabolicsProbe(Probe):
    r"""
    %Bhargava2004MuscleMetabolicsProbe is a Probe ModelComponent for computing
    the net metabolic energy rate of a set of Muscles in the model during a
    simulation.

    # %Bhargava2004MuscleMetabolicsProbe Theory

    The discussion here is based on the following paper:


    Bhargava, L. J., Pandy, M. G. and Anderson, F. C. (2004).
    A phenomenological model for estimating metabolic energy consumption
    in muscle contraction. J Biomech 37, 81-8. ("http://www.ncbi.nlm.nih.gov/pubmed/14672571")

    *Note that the equations below that describe the particular implementation of
    %Bhargava2004MuscleMetabolicsProbe may slightly differ from the equations
    described in the representative publication above. Note also that we define
    positive muscle velocity to indicate lengthening (eccentric contraction) and
    negative muscle velocity to indicate shortening (concentric contraction).*


    %Muscle metabolic power (or rate of metabolic energy consumption) is equal to the
    rate at which heat is liberated plus the rate at which work is done:

    **Edot = Bdot + sumOfAllMuscles(Adot + Mdot + Sdot + Wdot).**

          - Bdot is the basal heat rate (W).
          - Adot is the activation heat rate (W).
          - Mdot is the maintenance heat rate (W).
          - Sdot is the shortening heat rate (W).
          - Wdot is the mechanical work rate (W).


    This probe also uses muscle parameters stored in the MetabolicMuscle object for each muscle.
    The full set of all MetabolicMuscles (MetabolicMuscleSet) is a property of this probe:

    - m = The mass of the muscle (kg).
    - r = Ratio of slow twitch fibers in the muscle (between 0 and 1).
    - Adot_slow = Activation constant for slow twitch fibers (W/kg).
    - Adot_fast = Activation constant for fast twitch fibers (W/kg).
    - Mdot_slow = Maintenance constant for slow twitch fibers (W/kg).
    - Mdot_fast = Maintenance constant for slow twitch fibers (W/kg).


    ## ** BASAL HEAT RATE (W) **
    If *basal_rate_on* is set to true, then Bdot is calculated as follows:

    **Bdot = basal_coefficient * (m_body^basal_exponent)**
        - m_body = mass of the entire model
        - basal_coefficient and basal_exponent are defined by their respective properties.

    *Note that this quantity is muscle independent. Rather it is calculated on a whole body level.*


    ## ** ACTIVATION HEAT RATE (W) **
    If *activation_rate_on* is set to true, then Adot is calculated as follows:

    **Adot = phi * m * [ Adot_slow * r * sin((pi/2)*u) +
                          Adot_fast * (1-r) * (1-cos((pi/2)*u)) ]**
        - u = muscle excitation at the current time.
        - phi = decay function. Bhargava et al. (2004) use a function to model
                the observation that the rate of heat generation is greatest
                immediately after the muscle is excited and then decays. We
                follow the work of Anderson and Pandy, who set this value to 1.0.


    ## ** MAINTENANCE HEAT RATE (W) **
    If *maintenance_rate_on* is set to true, then Mdot is calculated as follows:

    **Mdot = m * f * [ Mdot_slow * r * sin((pi/2)*u)    +    Mdot_fast * (1-r) * (1-cos((pi/2)*u)) ]**
    - u = muscle excitation at the current time.
    - f is a piecewise linear function that describes the normalized fiber length dependence
    of the maintenance heat rate (default curve is shown below):
    Image: fig_NormalizedFiberLengthDependenceOfMaintenanceHeatRateBhargava2004.png


    ## ** SHORTENING HEAT RATE (W) **
    If *shortening_rate_on* is set to true, then Sdot is calculated as follows:

    **Sdot = -alpha * v_CE**

    If use_force_dependent_shortening_prop_constant = true,
        - **alpha = (0.16 * F_CE_iso) + (0.18 * F_CE)   **,   *v_CE >= 0 (concentric / isometric contraction)*
        - **alpha = 0.157 * F_CE                        **,   *v_CE <  0 (eccentric contraction)*

        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile (active) element of muscle at the current time.
        - F_CE_iso = force that would be developed by the contractile element of muscle under isometric conditions with the current activation and fiber length.

    If use_force_dependent_shortening_prop_constant = false,
        - **alpha = 0.25 * (F_CE + F_PASSIVE),   **,   *v_CE >= 0 (concentric / isometric contraction)*
        - **alpha = 0.00                         **,   *v_CE <  0 (eccentric contraction)*

         where F_PASSIVE = passive force developed by the muscle fiber velocity at the current time.


    ## ** MECHANICAL WORK RATE (W) **
    If *mechanical_work_rate_on* is set to true, then Wdot is calculated as follows:

    **Wdot = -F_CE * v_CE       **
        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile element of muscle at the current time.


    If we draw a control volume around the fiber, the first law of thermodynamics
    suggests that negative mechanical work should be included in Wdot. As such,
    we include negative mechanical work in Wdot by default. To exclude negative
    mechanical work from Wdot, set the 'include_negative_mechanical_work'
    property to false.

    During eccentric contraction, the magnitude of the (negative) mechanical work
    rate can exceed that of the total (positive) heat rate, resulting in a flow
    of energy into the fiber. Experiments indicate that the chemical processes
    involved in fiber contraction cannot be reversed, and most of the energy that
    is absorbed during eccentric contraction (in increased cross-bridge
    potentials, for example) is eventually converted into heat. Thus, we increase
    Sdot (if necessary) to ensure Edot > 0 for each muscle. See
    Constable, J.K.,
    Barclay, C.J., Gibbs, C.L. (1997) Energetics of lengthening in mouse and toad
    skeletal muscles. J Physiol 505:205-215 ("http://www.ncbi.nlm.nih.gov/pubmed/9409483"). To allow muscles to have
    negative total power, set the 'forbid_negative_total_power' property to false.


    Note that if enforce_minimum_heat_rate_per_muscle == true AND
    activation_rate_on == shortening_rate_on == maintenance_rate_on == true, then the total heat
    rate (AMdot + Mdot + Sdot) will be capped to a minimum value of 1.0 W/kg (Umberger(2003), page 104).




    # Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

    Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter is an Object class that
    holds the metabolic parameters required to calculate metabolic power for a single muscle.

    ## ** Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter Properties **

    REQUIRED PROPERTIES
    - **specific_tension** = The specific tension of the muscle (Pascals (N/m^2)).
    - **density** = The density of the muscle (kg/m^3).
    - **ratio_slow_twitch_fibers** = Ratio of slow twitch fibers in the muscle (must be between 0 and 1).
    - **activation_constant_slow_twitch**  = Activation constant for slow twitch fibers (W/kg).
    - **activation_constant_fast_twitch**  = Activation constant for fast twitch fibers (W/kg).
    - **maintenance_constant_slow_twitch** = Maintenance constant for slow twitch fibers (W/kg).
    - **maintenance_constant_fast_twitch** = Maintenance constant for slow twitch fibers (W/kg).

    OPTIONAL PROPERTIES
    - **use_provided_muscle_mass** = An optional flag that allows the user to
         explicitly specify a muscle mass. If set to true, the "provided_muscle_mass"
         property must be specified. The default setting is false, in which case, the
         muscle mass is calculated from the following formula:
             m = (Fmax/specific_tension)*density*Lm_opt, where
                 specific_tension and density are properties defined above
                     (note that their default values are set based on mammalian muscle,
                     0.25e6 N/m^2 and 1059.7 kg/m^3, respectively);
                 Fmax and Lm_opt are the maximum isometric force and optimal
                     fiber length, respectively, of the muscle.

    - **provided_muscle_mass** = The user specified muscle mass (kg).


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getClassName()

    def clone(self) -> "OpenSim::Bhargava2004MuscleMetabolicsProbe *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getConcreteClassName(self)

    def copyProperty_activation_rate_on(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_activation_rate_on(self, source)

    def append_activation_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_activation_rate_on(self, value)

    def constructProperty_activation_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_activation_rate_on(self, initValue)

    def get_activation_rate_on(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_activation_rate_on(self, *args)

    def upd_activation_rate_on(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_activation_rate_on(self, *args)

    def set_activation_rate_on(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_activation_rate_on(self, *args)

    def copyProperty_maintenance_rate_on(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_maintenance_rate_on(self, source)

    def append_maintenance_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_maintenance_rate_on(self, value)

    def constructProperty_maintenance_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_maintenance_rate_on(self, initValue)

    def get_maintenance_rate_on(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_maintenance_rate_on(self, *args)

    def upd_maintenance_rate_on(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_maintenance_rate_on(self, *args)

    def set_maintenance_rate_on(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_maintenance_rate_on(self, *args)

    def copyProperty_shortening_rate_on(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_shortening_rate_on(self, source)

    def append_shortening_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_shortening_rate_on(self, value)

    def constructProperty_shortening_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_shortening_rate_on(self, initValue)

    def get_shortening_rate_on(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_shortening_rate_on(self, *args)

    def upd_shortening_rate_on(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_shortening_rate_on(self, *args)

    def set_shortening_rate_on(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_shortening_rate_on(self, *args)

    def copyProperty_basal_rate_on(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_rate_on(self, source)

    def append_basal_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_rate_on(self, value)

    def constructProperty_basal_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_rate_on(self, initValue)

    def get_basal_rate_on(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_rate_on(self, *args)

    def upd_basal_rate_on(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_rate_on(self, *args)

    def set_basal_rate_on(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_rate_on(self, *args)

    def copyProperty_mechanical_work_rate_on(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_mechanical_work_rate_on(self, source)

    def append_mechanical_work_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_mechanical_work_rate_on(self, value)

    def constructProperty_mechanical_work_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_mechanical_work_rate_on(self, initValue)

    def get_mechanical_work_rate_on(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_mechanical_work_rate_on(self, *args)

    def upd_mechanical_work_rate_on(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_mechanical_work_rate_on(self, *args)

    def set_mechanical_work_rate_on(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_mechanical_work_rate_on(self, *args)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Default curve shown in doxygen. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, source)

    def append_normalized_fiber_length_dependence_on_maintenance_rate(self, value: "PiecewiseLinearFunction") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_normalized_fiber_length_dependence_on_maintenance_rate(self, value)

    def constructProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, initValue: "PiecewiseLinearFunction") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_normalized_fiber_length_dependence_on_maintenance_rate(self, initValue)

    def get_normalized_fiber_length_dependence_on_maintenance_rate(self, *args) -> "OpenSim::PiecewiseLinearFunction const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def upd_normalized_fiber_length_dependence_on_maintenance_rate(self, *args) -> "OpenSim::PiecewiseLinearFunction &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def set_normalized_fiber_length_dependence_on_maintenance_rate(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_normalized_fiber_length_dependence_on_maintenance_rate(self, *args)

    def copyProperty_use_force_dependent_shortening_prop_constant(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Disabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_use_force_dependent_shortening_prop_constant(self, source)

    def append_use_force_dependent_shortening_prop_constant(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_use_force_dependent_shortening_prop_constant(self, value)

    def constructProperty_use_force_dependent_shortening_prop_constant(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_use_force_dependent_shortening_prop_constant(self, initValue)

    def get_use_force_dependent_shortening_prop_constant(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_use_force_dependent_shortening_prop_constant(self, *args)

    def upd_use_force_dependent_shortening_prop_constant(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_use_force_dependent_shortening_prop_constant(self, *args)

    def set_use_force_dependent_shortening_prop_constant(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_use_force_dependent_shortening_prop_constant(self, *args)

    def copyProperty_basal_coefficient(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.2. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.0. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.0. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_forbid_negative_total_power(self, *args)

    def copyProperty_report_total_metabolics_only(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        r""" Default value = true *"""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_report_total_metabolics_only(self, source)

    def append_report_total_metabolics_only(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_report_total_metabolics_only(self, value)

    def constructProperty_report_total_metabolics_only(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_report_total_metabolics_only(self, initValue)

    def get_report_total_metabolics_only(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_report_total_metabolics_only(self, *args)

    def upd_report_total_metabolics_only(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_report_total_metabolics_only(self, *args)

    def set_report_total_metabolics_only(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_report_total_metabolics_only(self, *args)

    def copyProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source: "Bhargava2004MuscleMetabolicsProbe") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_copyProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source)

    def append_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_append_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value)

    def constructProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_constructProperty_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue)

    def get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_get_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_upd_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_set_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Bhargava2004MuscleMetabolicsProbe_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe(*args))

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute muscle metabolic power."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getProbeOutputLabels(self)

    def getNumMetabolicMuscles(self) -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getNumMetabolicMuscles(self)

    def addMuscle(self, *args) -> "void":
        r"""
        *Overload 1:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.

        |

        *Overload 2:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_addMuscle(self, *args)

    def removeMuscle(self, muscleName: "std::string const &") -> "void":
        r""" Remove a muscle from the metabolic analysis."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_removeMuscle(self, muscleName)

    def useProvidedMass(self, muscleName: "std::string const &", providedMass: "double") -> "void":
        r""" %Set an existing muscle to use a provided muscle mass."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_useProvidedMass(self, muscleName, providedMass)

    def useCalculatedMass(self, muscleName: "std::string const &") -> "void":
        r""" %Set an existing muscle to calculate its own mass."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_useCalculatedMass(self, muscleName)

    def isUsingProvidedMass(self, muscleName: "std::string const &") -> "bool":
        r"""
        Get whether the muscle mass is being explicitly provided.
              True means that it is using the property 'provided_muscle_mass'
              False means that the muscle mass is being calculated from muscle properties.
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_isUsingProvidedMass(self, muscleName)

    def getMuscleMass(self, muscleName: "std::string const &") -> "double":
        r"""
        Get the muscle mass used in the metabolic analysis. The value
               returned will depend on if the muscle mass is explicitly provided
               (i.e. isUsingProvidedMass = true), or if it is being automatically
               calculated from muscle data already present in the model
               (i.e. isUsingProvidedMass = true).
        """
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMuscleMass(self, muscleName)

    def getRatioSlowTwitchFibers(self, muscleName: "std::string const &") -> "double":
        r""" Get the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getRatioSlowTwitchFibers(self, muscleName)

    def setRatioSlowTwitchFibers(self, muscleName: "std::string const &", ratio: "double const &") -> "void":
        r""" %Set the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setRatioSlowTwitchFibers(self, muscleName, ratio)

    def getDensity(self, muscleName: "std::string const &") -> "double":
        r""" Get the density for an existing muscle (kg/m^3)."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getDensity(self, muscleName)

    def setDensity(self, muscleName: "std::string const &", density: "double const &") -> "void":
        r""" %Set the density for an existing muscle (kg/m^3)."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setDensity(self, muscleName, density)

    def getSpecificTension(self, muscleName: "std::string const &") -> "double":
        r""" Get the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getSpecificTension(self, muscleName)

    def setSpecificTension(self, muscleName: "std::string const &", specificTension: "double const &") -> "void":
        r""" %Set the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setSpecificTension(self, muscleName, specificTension)

    def getActivationConstantSlowTwitch(self, muscleName: "std::string const &") -> "double":
        r""" Get the activation constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getActivationConstantSlowTwitch(self, muscleName)

    def setActivationConstantSlowTwitch(self, muscleName: "std::string const &", c: "double const &") -> "void":
        r""" %Set the activation constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setActivationConstantSlowTwitch(self, muscleName, c)

    def getActivationConstantFastTwitch(self, muscleName: "std::string const &") -> "double":
        r""" Get the activation constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getActivationConstantFastTwitch(self, muscleName)

    def setActivationConstantFastTwitch(self, muscleName: "std::string const &", c: "double const &") -> "void":
        r""" %Set the activation constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setActivationConstantFastTwitch(self, muscleName, c)

    def getMaintenanceConstantSlowTwitch(self, muscleName: "std::string const &") -> "double":
        r""" Get the maintenance constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMaintenanceConstantSlowTwitch(self, muscleName)

    def setMaintenanceConstantSlowTwitch(self, muscleName: "std::string const &", c: "double const &") -> "void":
        r""" %Set the maintenance constant for slow twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setMaintenanceConstantSlowTwitch(self, muscleName, c)

    def getMaintenanceConstantFastTwitch(self, muscleName: "std::string const &") -> "double":
        r""" Get the maintenance constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_getMaintenanceConstantFastTwitch(self, muscleName)

    def setMaintenanceConstantFastTwitch(self, muscleName: "std::string const &", c: "double const &") -> "void":
        r""" %Set the maintenance constant for fast twitch fibers for an existing muscle."""
        return _simulation.Bhargava2004MuscleMetabolicsProbe_setMaintenanceConstantFastTwitch(self, muscleName, c)
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe

# Register Bhargava2004MuscleMetabolicsProbe in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_swigregister(Bhargava2004MuscleMetabolicsProbe)

def Bhargava2004MuscleMetabolicsProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe *":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_safeDownCast(obj)

def Bhargava2004MuscleMetabolicsProbe_getClassName() -> "std::string const &":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_getClassName()

class Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter(opensim.common.OpenSimObject):
    r"""
    Documentation for this class has been provided with the documentation for the
    Bhargava2004MuscleMetabolicsProbe class.

    See also: Bhargava2004MuscleMetabolicsProbe
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

    def clone(self) -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_specific_tension(self, *args)

    def copyProperty_density(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_density(self, source)

    def append_density(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_density(self, value)

    def constructProperty_density(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_density(self, initValue)

    def get_density(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_density(self, *args)

    def upd_density(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_density(self, *args)

    def set_density(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_use_provided_muscle_mass(self, *args)

    def get_use_provided_muscle_mass(self, *args) -> "bool const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args) -> "bool &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_provided_muscle_mass(self, *args)

    def get_provided_muscle_mass(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_provided_muscle_mass(self, *args)

    def copyProperty_activation_constant_slow_twitch(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_activation_constant_slow_twitch(self, source)

    def append_activation_constant_slow_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_activation_constant_slow_twitch(self, value)

    def constructProperty_activation_constant_slow_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_activation_constant_slow_twitch(self, initValue)

    def get_activation_constant_slow_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_activation_constant_slow_twitch(self, *args)

    def upd_activation_constant_slow_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_activation_constant_slow_twitch(self, *args)

    def set_activation_constant_slow_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_activation_constant_slow_twitch(self, *args)

    def copyProperty_activation_constant_fast_twitch(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_activation_constant_fast_twitch(self, source)

    def append_activation_constant_fast_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_activation_constant_fast_twitch(self, value)

    def constructProperty_activation_constant_fast_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_activation_constant_fast_twitch(self, initValue)

    def get_activation_constant_fast_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_activation_constant_fast_twitch(self, *args)

    def upd_activation_constant_fast_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_activation_constant_fast_twitch(self, *args)

    def set_activation_constant_fast_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_activation_constant_fast_twitch(self, *args)

    def copyProperty_maintenance_constant_slow_twitch(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_maintenance_constant_slow_twitch(self, source)

    def append_maintenance_constant_slow_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_maintenance_constant_slow_twitch(self, value)

    def constructProperty_maintenance_constant_slow_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_maintenance_constant_slow_twitch(self, initValue)

    def get_maintenance_constant_slow_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_maintenance_constant_slow_twitch(self, *args)

    def upd_maintenance_constant_slow_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_maintenance_constant_slow_twitch(self, *args)

    def set_maintenance_constant_slow_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_maintenance_constant_slow_twitch(self, *args)

    def copyProperty_maintenance_constant_fast_twitch(self, source: "Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_maintenance_constant_fast_twitch(self, source)

    def append_maintenance_constant_fast_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_append_maintenance_constant_fast_twitch(self, value)

    def constructProperty_maintenance_constant_fast_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_maintenance_constant_fast_twitch(self, initValue)

    def get_maintenance_constant_fast_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_get_maintenance_constant_fast_twitch(self, *args)

    def upd_maintenance_constant_fast_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_maintenance_constant_fast_twitch(self, *args)

    def set_maintenance_constant_fast_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_set_maintenance_constant_fast_twitch(self, *args)

    def __init__(self, *args):
        _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter(*args))

    def getMuscleMass(self) -> "double":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscleMass(self)

    def setMuscleMass(self) -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscleMass(self)

    def getMuscle(self) -> "OpenSim::Muscle const *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscle(self)

    def setMuscle(self, m: "Muscle") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscle(self, m)
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter

# Register Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_swigregister(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter)

def Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter *":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

def Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName() -> "std::string const &":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

class Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet(object):
    r"""
    MetabolicMuscleParameterSet is a class that holds the set of
    MetabolicMuscleParameters for each muscle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

    def clone(self) -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getConcreteClassName(self)

    def __init__(self):
        _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swiginit(self, _simulation.new_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet())
    __swig_destroy__ = _simulation.delete_Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet

# Register Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet in _simulation:
_simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swigregister(Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet)

def Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

def Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName() -> "std::string const &":
    return _simulation.Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

class Bhargava2004SmoothedMuscleMetabolics_MuscleParameters(opensim.common.Component):
    r"""
     Object class that holds the metabolic parameters required to calculate
    metabolic power for a single muscle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters *":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getClassName()

    def clone(self) -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters *":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_specific_tension(self, *args)

    def copyProperty_density(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_density(self, source)

    def append_density(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_density(self, value)

    def constructProperty_density(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_density(self, initValue)

    def get_density(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_density(self, *args)

    def upd_density(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_density(self, *args)

    def set_density(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_use_provided_muscle_mass(self, *args)

    def get_use_provided_muscle_mass(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_provided_muscle_mass(self, *args)

    def get_provided_muscle_mass(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_provided_muscle_mass(self, *args)

    def copyProperty_activation_constant_slow_twitch(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_activation_constant_slow_twitch(self, source)

    def append_activation_constant_slow_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_activation_constant_slow_twitch(self, value)

    def constructProperty_activation_constant_slow_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_activation_constant_slow_twitch(self, initValue)

    def get_activation_constant_slow_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_activation_constant_slow_twitch(self, *args)

    def upd_activation_constant_slow_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_activation_constant_slow_twitch(self, *args)

    def set_activation_constant_slow_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_activation_constant_slow_twitch(self, *args)

    def copyProperty_activation_constant_fast_twitch(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_activation_constant_fast_twitch(self, source)

    def append_activation_constant_fast_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_activation_constant_fast_twitch(self, value)

    def constructProperty_activation_constant_fast_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_activation_constant_fast_twitch(self, initValue)

    def get_activation_constant_fast_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_activation_constant_fast_twitch(self, *args)

    def upd_activation_constant_fast_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_activation_constant_fast_twitch(self, *args)

    def set_activation_constant_fast_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_activation_constant_fast_twitch(self, *args)

    def copyProperty_maintenance_constant_slow_twitch(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_maintenance_constant_slow_twitch(self, source)

    def append_maintenance_constant_slow_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_maintenance_constant_slow_twitch(self, value)

    def constructProperty_maintenance_constant_slow_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_maintenance_constant_slow_twitch(self, initValue)

    def get_maintenance_constant_slow_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_maintenance_constant_slow_twitch(self, *args)

    def upd_maintenance_constant_slow_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_maintenance_constant_slow_twitch(self, *args)

    def set_maintenance_constant_slow_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_maintenance_constant_slow_twitch(self, *args)

    def copyProperty_maintenance_constant_fast_twitch(self, source: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_copyProperty_maintenance_constant_fast_twitch(self, source)

    def append_maintenance_constant_fast_twitch(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_append_maintenance_constant_fast_twitch(self, value)

    def constructProperty_maintenance_constant_fast_twitch(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_constructProperty_maintenance_constant_fast_twitch(self, initValue)

    def get_maintenance_constant_fast_twitch(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_get_maintenance_constant_fast_twitch(self, *args)

    def upd_maintenance_constant_fast_twitch(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_upd_maintenance_constant_fast_twitch(self, *args)

    def set_maintenance_constant_fast_twitch(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_set_maintenance_constant_fast_twitch(self, *args)
    PropertyIndex_socket_muscle = property(_simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_PropertyIndex_socket_muscle_get, _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_PropertyIndex_socket_muscle_set)

    def connectSocket_muscle(self, object: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_connectSocket_muscle(self, object)

    def __init__(self):
        _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_swiginit(self, _simulation.new_Bhargava2004SmoothedMuscleMetabolics_MuscleParameters())

    def getMuscleMass(self) -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getMuscleMass(self)

    def setMuscleMass(self) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_setMuscleMass(self)

    def getMuscle(self) -> "OpenSim::Muscle const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getMuscle(self)
    __swig_destroy__ = _simulation.delete_Bhargava2004SmoothedMuscleMetabolics_MuscleParameters

# Register Bhargava2004SmoothedMuscleMetabolics_MuscleParameters in _simulation:
_simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_swigregister(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters)

def Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters *":
    return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_safeDownCast(obj)

def Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getClassName() -> "std::string const &":
    return _simulation.Bhargava2004SmoothedMuscleMetabolics_MuscleParameters_getClassName()

class Bhargava2004SmoothedMuscleMetabolics(ModelComponent):
    r"""
     This class implements the metabolic energy model of Bhargava et al (2004)
    and provides an option to use smooth (i.e., twice continuously
    differentiable) approximations. These approximations might be better suited
    for gradient-based optimization algorithms.

    We propose two smooth implementations.

    In the first implementation, conditional if statements were approximated by
    using hyperbolic tangent functions (tanh). For example, the following if
    statement:
         y = a, if x <= d
         y = b, if x > d
    can be approximated by:
         f = 0.5 + 0.5 tanh(b(x-d))
         y = a + (-a + b) f
    where b is a parameter that determines the smoothness of the transition.

    In the second implementation, conditional if statements were approximated
    by using Huber loss functions, which have the following form:
         L(f(x)) = 0.5 f(x)^2, if f(x) <= delta
         L(f(x)) = delta(f(x) - 0.5 delta), otherwise.
    The Huber loss function is quadratic for f(x) <= delta and linear
    otherwise, with equal value and slopes of the different sections at the
    points where f(x) = delta (https://en.wikipedia.org/wiki/Huber_loss). In
    our implementation, we scaled this function with a parameter b that
    determines the smootheness of the transition between the quadratic and
    linear parts. Note that this approximation is piecewise but still
    continuous.

    The metabolic energy model includes components for activation heat rate,
    maintenance heat rate, shortening heat rate, and mechanical work rate.

    The shortening heat rate model differs between concentric contractions and
    eccentric contractions. We smoothed the transition between both contraction
    types using our smoothing functions. Note that when using the force
    dependent shortening proportional constant, we only provide the tanh
    smoothing option for approximating the shortening heat rate. This is
    motivated by the fact that the shortening heat rate is defined by linear
    functions but with different non-zero constants of proportionality for
    concentric and eccentric contractions. It is therefore easier to smooth the
    transition between both contraction types with a tanh function than with a
    Huber loss function. The difference between the original (non-smooth) and the
    smooth implementations is illustrated in the following figure:

     <style>div.image img[src="SmoothShorteningHeatRate.png"]{width:750px;}</style>
    Image: SmoothShorteningHeatRate.png("Curves produced using isometricTotalActiveForce=350, fiberForceTotal=250, velocity_smoothing=10")

    The mechanical work rate model includes negative mechanical work rate
    (i.e., work rate resulting from eccentric contraction) by default. However,
    if specified by the user, the model only takes positive mechanical work
    rate (i.e., work rate resulting from concentric contraction) into account.
    In such case, we smoothed the transition between positive rate and zero
    using our smoothing functions. The difference between the original
    (non-smooth) and the smooth implementations is illustrated in the following
    figure:

     <style>div.image img[src="SmoothMechanicalWorkRate.png"]{width:750px;}</style>
    Image: SmoothMechanicalWorkRate.png("Curves produced using fiber_force_active=250, velocity_smoothing=10")

    The metabolic energy model implementation includes an optional clamping
    that prevents the total metabolic rate (i.e., total metabolic power) to be
    negative. This clamping is done by increasing the shortening heat rate. We
    smoothed the transition between positive and negative total metabolic rate
    using our smoothing functions. The difference between the original
    (non-smooth) and the smooth implementations is illustrated in the following
    figure:

     <style>div.image img[src="ClampingTotalMetabolicRate.png"]{width:750px;}</style>
    Image: ClampingTotalMetabolicRate.png("Curves produced using shorteningHeatRate=totalRate/4, power_smoothing=10")

    The metabolic energy model implementation includes an optional clamping
    (see Umberger et al (2003), page 104) that prevents the total heat rate
    (i.e., activation heat rate + maintenance heat rate + shortening heat rate)
    for a given muscle to fall below 1.0 W/kg. Note that, if active, this
    clamping will cause the sum of the reported individual heat rates and work
    rate to differ from the reported metabolic rate. We smoothed the transition
    between total heat rate higher and lower than 1.0 W/kg using our smoothing
    functions. The difference between the original (non-smooth) and the smooth
    implementations is illustrated in the following figure:

     <style>div.image img[src="ClampingTotalHeatRate.png"]{width:750px;}</style>
    Image: ClampingTotalHeatRate.png("Curves produced using muscle_mass=0.4, heat_rate_smoothing=10")

    Note that the maintenance heat rate implementation relies on a
    PiecewiseLinearFunction. The first and second order derivatives of this
    function can be evaluated but they are discontinuous. This might cause
    issues with gradient-based optimization algorithms. Problems using this
    discontinuous function have successfully converged; therefore, we have
    included it in this implementation of the model.

    You can enable smoothing via the `use_smoothing` property. The smoothing type
    ('tanh' or 'huber') can be chosen via the `smoothing_type` property, and the
    level of smoothing can be controlled by the `velocity_smoothing`,
    `power_smoothing`, and `heat_rate_smoothing` properties.

    Muscles to be included when computing the total metabolic rate should be
    specified using one of the three `addMuscle()` function overloads. See the
    properties of `Bhargava2004SmoothedMuscleMetabolics_MuscleParameters()` for the
    default parameter values used when not specified via the second or third
    `addMuscle()` overload.

    .. code-block:: c++

        Bhargava2004SmoothedMuscleMetabolics* metabolics =
            new Bhargava2004SmoothedMuscleMetabolics();
        metabolics->setName("metabolics");
        metabolics->set_use_smoothing(true);

        The simplest way to add the muscle to the metabolics model: just provide the
        name of the muscle and a reference to Muscle component.
        metabolics->addMuscle("soleus_r", model.getComponent<Muscle>("soleus_r"));

        Provide the ratio of slow to fast twitch fibers and the specific tension of
        muscle when adding it to the metabolics model. The values shown are also the
        default values.
        double ratio_slow_twitch_fibers = 0.5;
        double specific_tension = 0.25e6;
        metabolics->addMuscle("gastroc_r", model.getComponent<Muscle>("gastroc_r"),
                ratio_slow_twitch_fibers, specific_tension);

        Provide the slow and fast twitch fiber constants used to compute the
        activation and maintenance heat rates. The values shown are also the default
        values.
        double activation_constant_slow_twitch = 40.0;
        double activation_constant_fast_twitch = 133.0;
        double maintenance_constant_slow_twitch = 74.0;
        double maintenance_constant_fast_twitch = 111.0;
        metabolics->addMuscle("tibant_r", model.getComponent<Muscle>("tibant_r"),
                ratio_slow_twitch_fibers, specific_tension,
                activation_constant_slow_twitch, activation_constant_fast_twitch,
                maintenance_constant_slow_twitch, maintenance_constant_fast_twitch);

        model.addComponent(metabolics);
        model.finalizeConnections();

    The total metabolic rate output can be obtained using `getTotalMetabolicRate()`,
    which takes a SimTK::State as a argument. You can similarly obtain the
    individual heat rate and mechanical work rate components of the total metabolic
    cost via `getTotalActivationRate()`, `getTotalMaintenanceRate()`,
    `getTotalShorteningRate()`, and `getTotalMechanicalWorkRate()`. All outputs
    require realizing the passed SimTK::State to SimTK::Stage::Dynamics.

    .. code-block:: c++

        const auto& metabolics =
            model.getComponent<Bhargava2004SmoothedMuscleMetabolics>("metabolics");
        model.realizeDynamics(state);
        double totalMetabolicRate = metabolics.getTotalMetabolicRate(state);
        double activationHeatRate = metabolics.getTotalActivationRate(state);

    Bhargava et al. 2004: https://doi.org/10.1016/s0021-9290(03)00239-2
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics *":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getClassName()

    def clone(self) -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics *":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getConcreteClassName(self)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_use_force_dependent_shortening_prop_constant(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_force_dependent_shortening_prop_constant(self, source)

    def append_use_force_dependent_shortening_prop_constant(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_use_force_dependent_shortening_prop_constant(self, value)

    def constructProperty_use_force_dependent_shortening_prop_constant(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_force_dependent_shortening_prop_constant(self, initValue)

    def get_use_force_dependent_shortening_prop_constant(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_use_force_dependent_shortening_prop_constant(self, *args)

    def upd_use_force_dependent_shortening_prop_constant(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_use_force_dependent_shortening_prop_constant(self, *args)

    def set_use_force_dependent_shortening_prop_constant(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_use_force_dependent_shortening_prop_constant(self, *args)

    def copyProperty_basal_coefficient(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue: "double const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue: "bool const &") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_forbid_negative_total_power(self, *args)

    def copyProperty_use_smoothing(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_smoothing(self, source)

    def append_use_smoothing(self, value: "bool const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_use_smoothing(self, value)

    def constructProperty_use_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_smoothing(self, *args)

    def get_use_smoothing(self, *args) -> "bool const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_use_smoothing(self, *args)

    def upd_use_smoothing(self, *args) -> "bool &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_use_smoothing(self, *args)

    def set_use_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_use_smoothing(self, *args)

    def copyProperty_smoothing_type(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_smoothing_type(self, source)

    def append_smoothing_type(self, value: "std::string const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_smoothing_type(self, value)

    def constructProperty_smoothing_type(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_smoothing_type(self, *args)

    def get_smoothing_type(self, *args) -> "std::string const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_smoothing_type(self, *args)

    def upd_smoothing_type(self, *args) -> "std::string &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_smoothing_type(self, *args)

    def set_smoothing_type(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_smoothing_type(self, *args)

    def copyProperty_velocity_smoothing(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_velocity_smoothing(self, source)

    def append_velocity_smoothing(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_velocity_smoothing(self, value)

    def constructProperty_velocity_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_velocity_smoothing(self, *args)

    def get_velocity_smoothing(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_velocity_smoothing(self, *args)

    def upd_velocity_smoothing(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_velocity_smoothing(self, *args)

    def set_velocity_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_velocity_smoothing(self, *args)

    def copyProperty_power_smoothing(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_power_smoothing(self, source)

    def append_power_smoothing(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_power_smoothing(self, value)

    def constructProperty_power_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_power_smoothing(self, *args)

    def get_power_smoothing(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_power_smoothing(self, *args)

    def upd_power_smoothing(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_power_smoothing(self, *args)

    def set_power_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_power_smoothing(self, *args)

    def copyProperty_heat_rate_smoothing(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_heat_rate_smoothing(self, source)

    def append_heat_rate_smoothing(self, value: "double const &") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_heat_rate_smoothing(self, value)

    def constructProperty_heat_rate_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_heat_rate_smoothing(self, *args)

    def get_heat_rate_smoothing(self, *args) -> "double const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_heat_rate_smoothing(self, *args)

    def upd_heat_rate_smoothing(self, *args) -> "double &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_heat_rate_smoothing(self, *args)

    def set_heat_rate_smoothing(self, *args) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_heat_rate_smoothing(self, *args)

    def copyProperty_muscle_parameters(self, source: "Bhargava2004SmoothedMuscleMetabolics") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_parameters(self, source)

    def get_muscle_parameters(self, i: "int") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters const &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_get_muscle_parameters(self, i)

    def upd_muscle_parameters(self, i: "int") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics_MuscleParameters &":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_parameters(self, i)

    def set_muscle_parameters(self, i: "int", value: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_set_muscle_parameters(self, i, value)

    def append_muscle_parameters(self, value: "Bhargava2004SmoothedMuscleMetabolics_MuscleParameters") -> "int":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_append_muscle_parameters(self, value)

    def constructProperty_muscle_parameters(self) -> "void":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_parameters(self)
    _has_output_total_metabolic_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_set)
    _has_output_total_activation_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_set)
    _has_output_total_maintenance_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_set)
    _has_output_total_shortening_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_set)
    _has_output_total_mechanical_work_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_set)
    _has_output_muscle_metabolic_rate = property(_simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_get, _simulation.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_set)

    def __init__(self):
        _simulation.Bhargava2004SmoothedMuscleMetabolics_swiginit(self, _simulation.new_Bhargava2004SmoothedMuscleMetabolics())

    def getNumMetabolicMuscles(self) -> "int":
        r"""
        Get the number of muscles added to the metabolics model by one of the
           `addMuscle()` overloads.
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getNumMetabolicMuscles(self)

    def addMuscle(self, *args) -> "void":
        r"""
        *Overload 1:*
        Specify a muscle that should be included when computing the total
           metabolic rate. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 2:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 3:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. If the `muscle_mass` argument is not provided, it is
           estimated based on the max isometric force, specific tension,
           muscle density, and optimal fiber length.

        |

        *Overload 4:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. This overload also allows you to specify the slow and fast
           twitch fiber constants used to compute the activation and maintenance heat
           rates. If the `muscle_mass` argument is not provided, it is estimated based
           on the max isometric force, specific tension, muscle density, and optimal
           fiber length.

        |

        *Overload 5:*
        Specify a muscle that should be included when computing the total
           metabolic rate, as well as its ratio of slow to fast twitch fibers and
           specific tension. This overload also allows you to specify the slow and fast
           twitch fiber constants used to compute the activation and maintenance heat
           rates. If the `muscle_mass` argument is not provided, it is estimated based
           on the max isometric force, specific tension, muscle density, and optimal
           fiber length.
        """
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_addMuscle(self, *args)

    def getTotalMetabolicRate(self, s: "State") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMetabolicRate(self, s)

    def getTotalActivationRate(self, s: "State") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalActivationRate(self, s)

    def getTotalMaintenanceRate(self, s: "State") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMaintenanceRate(self, s)

    def getTotalShorteningRate(self, s: "State") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalShorteningRate(self, s)

    def getTotalMechanicalWorkRate(self, s: "State") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getTotalMechanicalWorkRate(self, s)

    def getMuscleMetabolicRate(self, s: "State", channel: "std::string const &") -> "double":
        return _simulation.Bhargava2004SmoothedMuscleMetabolics_getMuscleMetabolicRate(self, s, channel)
    __swig_destroy__ = _simulation.delete_Bhargava2004SmoothedMuscleMetabolics

# Register Bhargava2004SmoothedMuscleMetabolics in _simulation:
_simulation.Bhargava2004SmoothedMuscleMetabolics_swigregister(Bhargava2004SmoothedMuscleMetabolics)

def Bhargava2004SmoothedMuscleMetabolics_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Bhargava2004SmoothedMuscleMetabolics *":
    return _simulation.Bhargava2004SmoothedMuscleMetabolics_safeDownCast(obj)

def Bhargava2004SmoothedMuscleMetabolics_getClassName() -> "std::string const &":
    return _simulation.Bhargava2004SmoothedMuscleMetabolics_getClassName()

class Umberger2010MuscleMetabolicsProbe(Probe):
    r"""
    %Umberger2010MuscleMetabolicsProbe is a Probe ModelComponent for computing
    the net metabolic energy rate of a set of Muscles in the model during a
    simulation.

    # %Umberger2010MuscleMetabolicsProbe Theory

    The discussion here is based on the following papers:


    Uchida, T. K., Hicks, J. L., Dembia, C. L., Delp, S. L. (2016). Stretching
    your energetic budget: how tendon compliance affects the metabolic cost of
    running. PLOS ONE 11(3), e0150378. ("http://dx.doi.org/10.1371/journal.pone.0150378")


    Umberger, B. R. (2010). Stance and swing phase costs in human walking.
    J R Soc Interface 7, 1329-40. ("http://www.ncbi.nlm.nih.gov/pubmed/20356877")


    Umberger, B. R., Gerritsen, K. G. and Martin, P. E. (2003).
    A model of human muscle energy expenditure.
    Comput Methods Biomech Biomed Engin 6, 99-111. ("http://www.ncbi.nlm.nih.gov/pubmed/12745424")

    *Note that the equations below that describe the particular implementation
    of %Umberger2010MuscleMetabolicsProbe may slightly differ from the equations
    described in the representative publications above. Note also that we define
    positive muscle velocity to indicate lengthening (eccentric contraction) and
    negative muscle velocity to indicate shortening (concentric contraction).*


    %Muscle metabolic power (or rate of metabolic energy consumption) is equal to
    the rate at which heat is liberated plus the rate at which work is done:

    **Edot = Bdot + sumOfAllMuscles(Adot + Mdot + Sdot + Wdot).**

    - Bdot is the basal heat rate (W).
    - Adot is the activation heat rate (W).
    - Mdot is the maintenance heat rate (W).
    - Sdot is the shortening heat rate (W).
    - Wdot is the mechanical work rate (W).


    This probe also uses muscle parameters stored in the MetabolicMuscle object for each muscle.
    The full set of all MetabolicMuscles (MetabolicMuscleSet) is a property of this probe:

    - m = The mass of the muscle (kg).
    - r = Ratio of slow-twitch fibers in the muscle (between 0 and 1).

    The recruitment model described by Bhargava et al. (2004) is used to set the
    slow-twitch fiber ratio used in the calculations below. The ratio specified
    by the user indicates the composition of the muscle; this value is used only
    at full excitation (i.e., when all fibers are recruited). As excitation
    decreases from 1 to 0, the proportion of recruited fibers that are
    slow-twitch fibers increases from r to 1. See
    Bhargava, L.J., Pandy,
    M.G., Anderson, F.C. (2004) A phenomenological model for estimating metabolic
    energy consumption in muscle contraction. J Biomech 37:81-88 ("http://www.ncbi.nlm.nih.gov/pubmed/14672571") and Uchida
    et al. (2016). To assume a constant ratio of slow- and fast-twitch fiber
    recruitment, set the 'use_Bhargava_recruitment_model' property to false.



    ## ** BASAL HEAT RATE (W) **
    If *basal_rate_on* is set to true, then Bdot is calculated as follows:

    **Bdot = basal_coefficient * (m_body^basal_exponent) **
        - m_body = mass of the entire model
        - basal_coefficient and basal_exponent are defined by their respective properties.

    *Note that this quantity is muscle independent. Rather it is calculated on a whole body level.*


    ## ** ACTIVATION & MAINTENANCE HEAT RATE (W) **
    If *activation_maintenance_rate_on* is set to true, then Adot+Mdot is calculated as follows:

    **Adot+Mdot = [128*(1-r) + 25] * A^0.6 * S                                         **,  * l_CE <= l_CE_opt *

    **Adot+Mdot = (0.4*[128*(1-r) + 25] + 0.6*[128*(1-r) + 25]*F_CE_iso) * A^0.6 * S   **,  * l_CE >  l_CE_opt *
        - **A = u          **,    u >  a
        - **A = (u+a)/2    **,    u <= a

        - m = The mass of the muscle (kg).
        - l_CE = muscle fiber length at the current time.
        - l_CE_opt = optimal fiber length of the muscle.
        - F_CE_iso = normalized contractile element force-length curve.
        - u = muscle excitation at the current time.
        - a = muscle activation at the current time.
        - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).


    ## ** SHORTENING HEAT RATE (W) **
    If *shortening_rate_on* is set to true, then Sdot is calculated as follows:

    **Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S)           **,   *l_CE <= l_CE_opt   &   v_CE >= 0 (concentric / isometric contraction)*

    **Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S * F_iso)   **,   *l_CE >  l_CE_opt   &   v_CE >= 0 (concentric / isometric contraction)*

    **Sdot = m * (alphaL * v_CE_norm * A * S)              **,   *l_CE <= l_CE_opt   &   v_CE <  0 (eccentric contraction)*

    **Sdot = m * (alphaL * v_CE_norm * A * S * F_CE_iso)   **,   *l_CE >  l_CE_opt   &   v_CE <  0 (eccentric contraction)*
        - **A = u          **,    *u >  a *
        - **A = (u+a)/2    **,    *u <= a *

        - **alphaS_fast = 153 / v_CE_max          **
        - **alphaS_slow = 100 / (v_CE_max / 2.5)  **
        - **alphaL = 4.0 * alphaS_slow **

        - m = The mass of the muscle (kg).
        - l_CE = muscle fiber length at the current time.
        - l_CE_opt = optimal fiber length of the muscle.
        - F_CE_iso = force that would be developed by the contractile element of muscle under isometric conditions with the current activation and fiber length.
        - v_CE = muscle fiber velocity at the current time.
        - v_CE_max = maximum shortening velocity of the muscle.
        - v_CE_norm = normalized muscle fiber velocity (defined for this model as v_CE/l_CE_opt).
                  Note that this is a different metric to the typical normalized_muscle_fiber_velocity of v_CE/v_CE_max.
        - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).


    ## ** MECHANICAL WORK RATE (W) **
    If *mechanical_work_rate_on* is set to true, then Wdot is calculated as follows:

    **Wdot = -(F_CE * v_CE)           **
        - v_CE = muscle fiber velocity at the current time.
        - F_CE = force developed by the contractile element of muscle at the current time.


    If we draw a control volume around the fiber, the first law of thermodynamics
    suggests that negative mechanical work should be included in Wdot. As such,
    we revert back to the model described in Umberger et al. (2003) by default.
    To exclude negative mechanical work from Wdot and use a coefficient of 0.3
    (rather than 4.0) to calculate alpha_L, set the
    'include_negative_mechanical_work' property to false.

    During eccentric contraction, the magnitude of the (negative) mechanical work
    rate can exceed that of the total (positive) heat rate, resulting in a flow
    of energy into the fiber. Experiments indicate that the chemical processes
    involved in fiber contraction cannot be reversed, and most of the energy that
    is absorbed during eccentric contraction (in increased cross-bridge
    potentials, for example) is eventually converted into heat. Thus, we increase
    Sdot (if necessary) to ensure Edot > 0 for each muscle. See
    Constable, J.K.,
    Barclay, C.J., Gibbs, C.L. (1997) Energetics of lengthening in mouse and toad
    skeletal muscles. J Physiol 505:205-215 ("http://www.ncbi.nlm.nih.gov/pubmed/9409483") and Uchida et al. (2016). To
    allow muscles to have negative total power, set the
    'forbid_negative_total_power' property to false.


    Note that if enforce_minimum_heat_rate_per_muscle == true AND
    activation_maintenance_rate_on == shortening_rate_on == true, then the total heat
    rate (AMdot + Sdot) will be capped to a minimum value of 1.0 W/kg (Umberger(2003), page 104).




    # Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

    Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter is an Object class that
    holds the metabolic parameters required to calculate metabolic power for a single muscle.

    ## ** Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter Properties **

    REQUIRED PROPERTIES
    - **specific_tension** = The specific tension of the muscle (Pascals (N/m^2)).
    - **density** = The density of the muscle (kg/m^3).
    - **ratio_slow_twitch_fibers** = Ratio of slow twitch fibers in the muscle (must be between 0 and 1).

    OPTIONAL PROPERTIES
    - **use_provided_muscle_mass** = An optional flag that allows the user to
         explicitly specify a muscle mass. If set to true, the 'provided_muscle_mass'
         property must be specified. The default setting is false, in which case, the
         muscle mass is calculated from the following formula:
             m = (Fmax/specific_tension)*density*Lm_opt, where
                 specific_tension and density are properties defined above
                     (note that their default values are set based on mammalian muscle,
                     0.25e6 N/m^2 and 1059.7 kg/m^3, respectively);
                 Fmax and Lm_opt are the maximum isometric force and optimal
                     fiber length, respectively, of the muscle.

    - **provided_muscle_mass** = The user specified muscle mass (kg).


    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_getClassName()

    def clone(self) -> "OpenSim::Umberger2010MuscleMetabolicsProbe *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_getConcreteClassName(self)

    def copyProperty_activation_maintenance_rate_on(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_activation_maintenance_rate_on(self, source)

    def append_activation_maintenance_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_activation_maintenance_rate_on(self, value)

    def constructProperty_activation_maintenance_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_activation_maintenance_rate_on(self, initValue)

    def get_activation_maintenance_rate_on(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_activation_maintenance_rate_on(self, *args)

    def upd_activation_maintenance_rate_on(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_activation_maintenance_rate_on(self, *args)

    def set_activation_maintenance_rate_on(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_activation_maintenance_rate_on(self, *args)

    def copyProperty_shortening_rate_on(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_shortening_rate_on(self, source)

    def append_shortening_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_shortening_rate_on(self, value)

    def constructProperty_shortening_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_shortening_rate_on(self, initValue)

    def get_shortening_rate_on(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_shortening_rate_on(self, *args)

    def upd_shortening_rate_on(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_shortening_rate_on(self, *args)

    def set_shortening_rate_on(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_shortening_rate_on(self, *args)

    def copyProperty_basal_rate_on(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_rate_on(self, source)

    def append_basal_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_rate_on(self, value)

    def constructProperty_basal_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_rate_on(self, initValue)

    def get_basal_rate_on(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_rate_on(self, *args)

    def upd_basal_rate_on(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_rate_on(self, *args)

    def set_basal_rate_on(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_rate_on(self, *args)

    def copyProperty_mechanical_work_rate_on(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_mechanical_work_rate_on(self, source)

    def append_mechanical_work_rate_on(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_mechanical_work_rate_on(self, value)

    def constructProperty_mechanical_work_rate_on(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_mechanical_work_rate_on(self, initValue)

    def get_mechanical_work_rate_on(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_mechanical_work_rate_on(self, *args)

    def upd_mechanical_work_rate_on(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_mechanical_work_rate_on(self, *args)

    def set_mechanical_work_rate_on(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_mechanical_work_rate_on(self, *args)

    def copyProperty_enforce_minimum_heat_rate_per_muscle(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_enforce_minimum_heat_rate_per_muscle(self, source)

    def append_enforce_minimum_heat_rate_per_muscle(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_enforce_minimum_heat_rate_per_muscle(self, value)

    def constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_enforce_minimum_heat_rate_per_muscle(self, initValue)

    def get_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle(self, *args)

    def upd_enforce_minimum_heat_rate_per_muscle(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle(self, *args)

    def set_enforce_minimum_heat_rate_per_muscle(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle(self, *args)

    def copyProperty_aerobic_factor(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.5. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_aerobic_factor(self, source)

    def append_aerobic_factor(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_aerobic_factor(self, value)

    def constructProperty_aerobic_factor(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_aerobic_factor(self, initValue)

    def get_aerobic_factor(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_aerobic_factor(self, *args)

    def upd_aerobic_factor(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_aerobic_factor(self, *args)

    def set_aerobic_factor(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_aerobic_factor(self, *args)

    def copyProperty_basal_coefficient(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.2. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_coefficient(self, source)

    def append_basal_coefficient(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_coefficient(self, value)

    def constructProperty_basal_coefficient(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_coefficient(self, initValue)

    def get_basal_coefficient(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_coefficient(self, *args)

    def upd_basal_coefficient(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_coefficient(self, *args)

    def set_basal_coefficient(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_coefficient(self, *args)

    def copyProperty_basal_exponent(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.0. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_exponent(self, source)

    def append_basal_exponent(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_basal_exponent(self, value)

    def constructProperty_basal_exponent(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_exponent(self, initValue)

    def get_basal_exponent(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_basal_exponent(self, *args)

    def upd_basal_exponent(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_basal_exponent(self, *args)

    def set_basal_exponent(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_basal_exponent(self, *args)

    def copyProperty_muscle_effort_scaling_factor(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Default value = 1.0. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_muscle_effort_scaling_factor(self, source)

    def append_muscle_effort_scaling_factor(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_muscle_effort_scaling_factor(self, value)

    def constructProperty_muscle_effort_scaling_factor(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_muscle_effort_scaling_factor(self, initValue)

    def get_muscle_effort_scaling_factor(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_muscle_effort_scaling_factor(self, *args)

    def upd_muscle_effort_scaling_factor(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor(self, *args)

    def set_muscle_effort_scaling_factor(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_muscle_effort_scaling_factor(self, *args)

    def copyProperty_use_Bhargava_recruitment_model(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_use_Bhargava_recruitment_model(self, source)

    def append_use_Bhargava_recruitment_model(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_use_Bhargava_recruitment_model(self, value)

    def constructProperty_use_Bhargava_recruitment_model(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_use_Bhargava_recruitment_model(self, initValue)

    def get_use_Bhargava_recruitment_model(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_use_Bhargava_recruitment_model(self, *args)

    def upd_use_Bhargava_recruitment_model(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_use_Bhargava_recruitment_model(self, *args)

    def set_use_Bhargava_recruitment_model(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_use_Bhargava_recruitment_model(self, *args)

    def copyProperty_include_negative_mechanical_work(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_include_negative_mechanical_work(self, source)

    def append_include_negative_mechanical_work(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_include_negative_mechanical_work(self, value)

    def constructProperty_include_negative_mechanical_work(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_include_negative_mechanical_work(self, initValue)

    def get_include_negative_mechanical_work(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_include_negative_mechanical_work(self, *args)

    def upd_include_negative_mechanical_work(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_include_negative_mechanical_work(self, *args)

    def set_include_negative_mechanical_work(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_include_negative_mechanical_work(self, *args)

    def copyProperty_forbid_negative_total_power(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Enabled by default. *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_forbid_negative_total_power(self, source)

    def append_forbid_negative_total_power(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_forbid_negative_total_power(self, value)

    def constructProperty_forbid_negative_total_power(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_forbid_negative_total_power(self, initValue)

    def get_forbid_negative_total_power(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_forbid_negative_total_power(self, *args)

    def upd_forbid_negative_total_power(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_forbid_negative_total_power(self, *args)

    def set_forbid_negative_total_power(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_forbid_negative_total_power(self, *args)

    def copyProperty_report_total_metabolics_only(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        r""" Default value = true *"""
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_report_total_metabolics_only(self, source)

    def append_report_total_metabolics_only(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_report_total_metabolics_only(self, value)

    def constructProperty_report_total_metabolics_only(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_report_total_metabolics_only(self, initValue)

    def get_report_total_metabolics_only(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_report_total_metabolics_only(self, *args)

    def upd_report_total_metabolics_only(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_report_total_metabolics_only(self, *args)

    def set_report_total_metabolics_only(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_report_total_metabolics_only(self, *args)

    def copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source: "Umberger2010MuscleMetabolicsProbe") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, source)

    def append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, value)

    def constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, initValue)

    def get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor

        |

        *Overload 2:*
        Convenience constructor
        """
        _simulation.Umberger2010MuscleMetabolicsProbe_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe(*args))

    def computeProbeInputs(self, state: "State") -> "SimTK::Vector":
        r""" Compute muscle metabolic power."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_computeProbeInputs(self, state)

    def getNumProbeInputs(self) -> "int":
        r""" Returns the number of probe inputs in the vector returned by computeProbeInputs()."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getNumProbeInputs(self)

    def getProbeOutputLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Returns the column labels of the probe values for reporting.
               Currently uses the Probe name as the column label, so be sure
               to name your probe appropriately!
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_getProbeOutputLabels(self)

    def getNumMetabolicMuscles(self) -> "int":
        r""" Get the number of muscles being analyzed in the metabolic analysis."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getNumMetabolicMuscles(self)

    def addMuscle(self, *args) -> "void":
        r"""
        *Overload 1:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.

        |

        *Overload 2:*
        Add a muscle and its parameters so that it can be included in the metabolic analysis.
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_addMuscle(self, *args)

    def removeMuscle(self, muscleName: "std::string const &") -> "void":
        r""" Remove a muscle from the metabolic analysis."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_removeMuscle(self, muscleName)

    def useProvidedMass(self, muscleName: "std::string const &", providedMass: "double") -> "void":
        r""" %Set an existing muscle to use a provided muscle mass."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_useProvidedMass(self, muscleName, providedMass)

    def useCalculatedMass(self, muscleName: "std::string const &") -> "void":
        r""" %Set an existing muscle to calculate its own mass."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_useCalculatedMass(self, muscleName)

    def isUsingProvidedMass(self, muscleName: "std::string const &") -> "bool":
        r"""
        Get whether the muscle mass is being explicitly provided.
               True means that it is using the property 'provided_muscle_mass'
               False means that the muscle mass is being calculated from muscle properties.
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_isUsingProvidedMass(self, muscleName)

    def getMuscleMass(self, muscleName: "std::string const &") -> "double":
        r"""
        Get the muscle mass used in the metabolic analysis. The value
               returned will depend on if the muscle mass is explicitly provided
               (i.e. isUsingProvidedMass = true), or if it is being automatically
               calculated from muscle data already present in the model
               (i.e. isUsingProvidedMass = true).
        """
        return _simulation.Umberger2010MuscleMetabolicsProbe_getMuscleMass(self, muscleName)

    def getRatioSlowTwitchFibers(self, muscleName: "std::string const &") -> "double":
        r""" Get the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getRatioSlowTwitchFibers(self, muscleName)

    def setRatioSlowTwitchFibers(self, muscleName: "std::string const &", ratio: "double const &") -> "void":
        r""" %Set the ratio of slow twitch fibers for an existing muscle."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setRatioSlowTwitchFibers(self, muscleName, ratio)

    def getDensity(self, muscleName: "std::string const &") -> "double":
        r""" Get the density for an existing muscle (kg/m^3)."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getDensity(self, muscleName)

    def setDensity(self, muscleName: "std::string const &", density: "double const &") -> "void":
        r""" %Set the density for an existing muscle (kg/m^3)."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setDensity(self, muscleName, density)

    def getSpecificTension(self, muscleName: "std::string const &") -> "double":
        r""" Get the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_getSpecificTension(self, muscleName)

    def setSpecificTension(self, muscleName: "std::string const &", specificTension: "double const &") -> "void":
        r""" %Set the specific tension for an existing muscle (Pascals (N/m^2))."""
        return _simulation.Umberger2010MuscleMetabolicsProbe_setSpecificTension(self, muscleName, specificTension)
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe

# Register Umberger2010MuscleMetabolicsProbe in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_swigregister(Umberger2010MuscleMetabolicsProbe)

def Umberger2010MuscleMetabolicsProbe_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe *":
    return _simulation.Umberger2010MuscleMetabolicsProbe_safeDownCast(obj)

def Umberger2010MuscleMetabolicsProbe_getClassName() -> "std::string const &":
    return _simulation.Umberger2010MuscleMetabolicsProbe_getClassName()

class Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter(opensim.common.OpenSimObject):
    r"""
    Documentation for this class has been provided with the documentation for the
    Umberger2010MuscleMetabolicsProbe class.

    See also: Umberger2010MuscleMetabolicsProbe
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

    def clone(self) -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getConcreteClassName(self)

    def copyProperty_specific_tension(self, source: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_specific_tension(self, source)

    def append_specific_tension(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_specific_tension(self, value)

    def constructProperty_specific_tension(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_specific_tension(self, initValue)

    def get_specific_tension(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_specific_tension(self, *args)

    def upd_specific_tension(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_specific_tension(self, *args)

    def set_specific_tension(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_specific_tension(self, *args)

    def copyProperty_density(self, source: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_density(self, source)

    def append_density(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_density(self, value)

    def constructProperty_density(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_density(self, initValue)

    def get_density(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_density(self, *args)

    def upd_density(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_density(self, *args)

    def set_density(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_density(self, *args)

    def copyProperty_ratio_slow_twitch_fibers(self, source: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_ratio_slow_twitch_fibers(self, source)

    def append_ratio_slow_twitch_fibers(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_ratio_slow_twitch_fibers(self, value)

    def constructProperty_ratio_slow_twitch_fibers(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_ratio_slow_twitch_fibers(self, initValue)

    def get_ratio_slow_twitch_fibers(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_ratio_slow_twitch_fibers(self, *args)

    def upd_ratio_slow_twitch_fibers(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_ratio_slow_twitch_fibers(self, *args)

    def set_ratio_slow_twitch_fibers(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_ratio_slow_twitch_fibers(self, *args)

    def copyProperty_use_provided_muscle_mass(self, source: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_use_provided_muscle_mass(self, source)

    def append_use_provided_muscle_mass(self, value: "bool const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_use_provided_muscle_mass(self, value)

    def constructProperty_use_provided_muscle_mass(self, initValue: "bool const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_use_provided_muscle_mass(self, initValue)

    def get_use_provided_muscle_mass(self, *args) -> "bool const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_use_provided_muscle_mass(self, *args)

    def upd_use_provided_muscle_mass(self, *args) -> "bool &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_use_provided_muscle_mass(self, *args)

    def set_use_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_use_provided_muscle_mass(self, *args)

    def copyProperty_provided_muscle_mass(self, source: "Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_copyProperty_provided_muscle_mass(self, source)

    def append_provided_muscle_mass(self, value: "double const &") -> "int":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_append_provided_muscle_mass(self, value)

    def constructProperty_provided_muscle_mass(self, initValue: "double const &") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_constructProperty_provided_muscle_mass(self, initValue)

    def get_provided_muscle_mass(self, *args) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_get_provided_muscle_mass(self, *args)

    def upd_provided_muscle_mass(self, *args) -> "double &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_upd_provided_muscle_mass(self, *args)

    def set_provided_muscle_mass(self, *args) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_set_provided_muscle_mass(self, *args)

    def __init__(self, *args):
        _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter(*args))

    def getMuscleMass(self) -> "double const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscleMass(self)

    def setMuscleMass(self) -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscleMass(self)

    def getMuscle(self) -> "OpenSim::Muscle const *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getMuscle(self)

    def setMuscle(self, m: "Muscle") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_setMuscle(self, m)
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter

# Register Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_swigregister(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter)

def Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter *":
    return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_safeDownCast(obj)

def Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName() -> "std::string const &":
    return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter_getClassName()

class Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(object):
    r"""
    MetabolicMuscleParameterSet is an internal container class containing the set
    of MetabolicMuscleParameters for each muscle that is probed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

    def clone(self) -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getConcreteClassName(self)

    def __init__(self):
        _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swiginit(self, _simulation.new_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet())
    __swig_destroy__ = _simulation.delete_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet

# Register Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet in _simulation:
_simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_swigregister(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet)

def Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet *":
    return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_safeDownCast(obj)

def Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName() -> "std::string const &":
    return _simulation.Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet_getClassName()

class ModelVisualPreferences(opensim.common.OpenSimObject):
    r"""
     A class that holds the Visual Preferences of a full OpenSim Model
     displayed in Visualizer. Initially these are serializable ModelDisplayHints
     but in the future can be expanded to include search paths for Mesh files,
     Texture, Renderer preferences, lights, cameras etc. attached to Model.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelVisualPreferences *":
        return _simulation.ModelVisualPreferences_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ModelVisualPreferences_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ModelVisualPreferences_getClassName()

    def clone(self) -> "OpenSim::ModelVisualPreferences *":
        return _simulation.ModelVisualPreferences_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelVisualPreferences_getConcreteClassName(self)

    def copyProperty_ModelDisplayHints(self, source: "ModelVisualPreferences") -> "void":
        return _simulation.ModelVisualPreferences_copyProperty_ModelDisplayHints(self, source)

    def append_ModelDisplayHints(self, value: "ModelDisplayHints") -> "int":
        return _simulation.ModelVisualPreferences_append_ModelDisplayHints(self, value)

    def constructProperty_ModelDisplayHints(self, initValue: "ModelDisplayHints") -> "void":
        return _simulation.ModelVisualPreferences_constructProperty_ModelDisplayHints(self, initValue)

    def get_ModelDisplayHints(self, *args) -> "OpenSim::ModelDisplayHints const &":
        return _simulation.ModelVisualPreferences_get_ModelDisplayHints(self, *args)

    def upd_ModelDisplayHints(self, *args) -> "OpenSim::ModelDisplayHints &":
        return _simulation.ModelVisualPreferences_upd_ModelDisplayHints(self, *args)

    def set_ModelDisplayHints(self, *args) -> "void":
        return _simulation.ModelVisualPreferences_set_ModelDisplayHints(self, *args)

    def __init__(self):
        _simulation.ModelVisualPreferences_swiginit(self, _simulation.new_ModelVisualPreferences())
    __swig_destroy__ = _simulation.delete_ModelVisualPreferences

# Register ModelVisualPreferences in _simulation:
_simulation.ModelVisualPreferences_swigregister(ModelVisualPreferences)

def ModelVisualPreferences_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelVisualPreferences *":
    return _simulation.ModelVisualPreferences_safeDownCast(obj)

def ModelVisualPreferences_getClassName() -> "std::string const &":
    return _simulation.ModelVisualPreferences_getClassName()

class ModelVisualizer(object):
    r"""
     This class manages runtime visualization of a Model that is being
    manipulated through the OpenSim API. You should not allocate one of these
    yourself; instead, call the Model's setUseVisualizer() method and let the
    Model allocate one for itself. You may find the defaults to be adequate, but
    you can also get access to the %ModelVisualizer if you need it by calling
    the Model's getVisualizer() method.

    The %ModelVisualizer consults the Model's ModelDisplayHints object for
    instructions on what to display.

    The Simbody visualizer binary needs to be found at runtime to create a
    visualizer. The search proceeds in the following order:
    Directory of the currently running executable/binary.
    Directory referred to by the environment variable OPENSIM_HOME/bin
      if it exists.
    Directories referred to by the environment variable PATH.
    Possible locations for simbody installations:
      -- SIMBODY_HOME/bin if the environment variable SIMBODY_HOME exists.
      -- SimTK_INSTALL_DIR/bin if the environment variable SIMBODY_HOME exists.
      -- Platform specific default locations of binaries. For Linux/MacOS, this may
         be /usr/bin, /usr/local/bin etc. For Windows, this set is empty.

    Author: Michael Sherman

    See also: ModelDisplayHints, Model *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ModelVisualizer

    def show(self, state: "State") -> "void":
        r"""
        * Evaluate the geometry needed to visualize the given *state* and
            use it to generate a new image in the Visualizer window. *
        """
        return _simulation.ModelVisualizer_show(self, state)

    def getInputSilo(self) -> "SimTK::Visualizer::InputSilo const &":
        r"""
        ** If you want to poll for user input, you'll need access to the
            SimTK::Visualizer::InputSilo maintained here. Writable access is required
            to remove user input from the queues. *
        """
        return _simulation.ModelVisualizer_getInputSilo(self)

    def updInputSilo(self) -> "SimTK::Visualizer::InputSilo &":
        r"""
        Get writable access to the InputSilo so you can remove user input
           from the queues. *
        """
        return _simulation.ModelVisualizer_updInputSilo(self)

    def getSimbodyVisualizer(self) -> "SimTK::Visualizer const &":
        r"""
        If you want access to the underlying Simbody SimTK::Visualizer, you
           can get a const reference here. *
        """
        return _simulation.ModelVisualizer_getSimbodyVisualizer(self)

    def updSimbodyVisualizer(self) -> "SimTK::Visualizer &":
        r"""
        If you want writable access to the underlying Simbody SimTK::Visualizer,
           you can get a non-const reference here, provided that you have non-const
           access to the %ModelVisualizer. *
        """
        return _simulation.ModelVisualizer_updSimbodyVisualizer(self)

    def getGeometryDecorationGenerator(self) -> "SimTK::DefaultGeometry *":
        r"""
        ** Return a pointer to the DefaultGeometry decoration generator used by
            this %ModelVisualizer. *
        """
        return _simulation.ModelVisualizer_getGeometryDecorationGenerator(self)

    def getModel(self) -> "OpenSim::Model const &":
        r"""
        Return a const reference to the Model for which this %ModelVisualizer
           was constructed. *
        """
        return _simulation.ModelVisualizer_getModel(self)

    def updModel(self) -> "OpenSim::Model &":
        r"""
        Return a writable reference to the Model for which this %ModelVisualizer
           was constructed. *
        """
        return _simulation.ModelVisualizer_updModel(self)

    @staticmethod
    def findGeometryFile(model: "Model", geoFile: "std::string const &", isAbsolute: "bool &", attempts: "SimTKArrayString") -> "bool":
        r"""
        Given the name of a geometry file, this method will attempt to
           find it in a series of locations using the same algorithm as is done
           internally by the %ModelVisualizer.

           :type model: :py:class:`Model`, in
           :param model:
                   Used to obtain the name of the file from which the model was loaded.
           :type geoFile: string, in
           :param geoFile:
                   Name of file to look for; can be absolute or relative path name or just
                   a file name and the extension must be supplied.
           :type isAbsolute: boolean, out
           :param isAbsolute:
                   This output parameter is set to true on return if the supplied
                   *geoFile* was an absolute path name; in that case no searching was
                   done.
           :type attempts: SimTK::Array_< std::string,unsigned int >, out
           :param attempts:
                   On return, this is a list of the absolute path names that were tried.
                   If *geoFile* was found, attempts.back() (the last entry) is the
                   absolute path name of *geoFile*. The last entry of this array will be
                   the path that succeeded in finding the geometry file.
           :rtype: boolean
           :return: ``true`` if *geoFile* was located and is readable.

           The search rule is as follows:
             - If *geoFile* is an absolute pathname no search is done.
             - Otherwise, define modelDir as the directory from which the current
               Model file was read in, if any, otherwise the current directory.
             - Try modelDir/geoFile, then modelDir/Geometry/geoFile.
             - Otherwise, try the search paths added through
               addDirToGeometrySearchPaths(). The paths are searched in
               reverse-chronological order -- the latest path added is searched first.
             - Finally, try installDir/geoFile where installDir is taken from
               the OPENSIM_HOME environment variable if it exists, otherwise
               a default installation directory.

           No attempt is made to validate the contents of the file or whether it
           has a supported extension; we're just looking for a file of the given
           name that exists and is readable. *
        """
        return _simulation.ModelVisualizer_findGeometryFile(model, geoFile, isAbsolute, attempts)

    @staticmethod
    def addDirToGeometrySearchPaths(dir: "std::string const &") -> "void":
        r"""
        Add a directory to the search path to be used by the function
           findGeometryFile. The added paths are searched in the
           reverse-chronological order -- the latest path added is searched first.
        """
        return _simulation.ModelVisualizer_addDirToGeometrySearchPaths(dir)

# Register ModelVisualizer in _simulation:
_simulation.ModelVisualizer_swigregister(ModelVisualizer)

def ModelVisualizer_findGeometryFile(model: "Model", geoFile: "std::string const &", isAbsolute: "bool &", attempts: "SimTKArrayString") -> "bool":
    r"""
    Given the name of a geometry file, this method will attempt to
       find it in a series of locations using the same algorithm as is done
       internally by the %ModelVisualizer.

       :type model: :py:class:`Model`, in
       :param model:
               Used to obtain the name of the file from which the model was loaded.
       :type geoFile: string, in
       :param geoFile:
               Name of file to look for; can be absolute or relative path name or just
               a file name and the extension must be supplied.
       :type isAbsolute: boolean, out
       :param isAbsolute:
               This output parameter is set to true on return if the supplied
               *geoFile* was an absolute path name; in that case no searching was
               done.
       :type attempts: SimTK::Array_< std::string,unsigned int >, out
       :param attempts:
               On return, this is a list of the absolute path names that were tried.
               If *geoFile* was found, attempts.back() (the last entry) is the
               absolute path name of *geoFile*. The last entry of this array will be
               the path that succeeded in finding the geometry file.
       :rtype: boolean
       :return: ``true`` if *geoFile* was located and is readable.

       The search rule is as follows:
         - If *geoFile* is an absolute pathname no search is done.
         - Otherwise, define modelDir as the directory from which the current
           Model file was read in, if any, otherwise the current directory.
         - Try modelDir/geoFile, then modelDir/Geometry/geoFile.
         - Otherwise, try the search paths added through
           addDirToGeometrySearchPaths(). The paths are searched in
           reverse-chronological order -- the latest path added is searched first.
         - Finally, try installDir/geoFile where installDir is taken from
           the OPENSIM_HOME environment variable if it exists, otherwise
           a default installation directory.

       No attempt is made to validate the contents of the file or whether it
       has a supported extension; we're just looking for a file of the given
       name that exists and is readable. *
    """
    return _simulation.ModelVisualizer_findGeometryFile(model, geoFile, isAbsolute, attempts)

def ModelVisualizer_addDirToGeometrySearchPaths(dir: "std::string const &") -> "void":
    r"""
    Add a directory to the search path to be used by the function
       findGeometryFile. The added paths are searched in the
       reverse-chronological order -- the latest path added is searched first.
    """
    return _simulation.ModelVisualizer_addDirToGeometrySearchPaths(dir)

class ModelHasNoSystem(opensim.common.OpenSimException):
    r""" Model  Exceptions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", modelName: "std::string const &"):
        _simulation.ModelHasNoSystem_swiginit(self, _simulation.new_ModelHasNoSystem(file, line, func, modelName))
    __swig_destroy__ = _simulation.delete_ModelHasNoSystem

# Register ModelHasNoSystem in _simulation:
_simulation.ModelHasNoSystem_swigregister(ModelHasNoSystem)

class PhysicalOffsetFramesFormLoop(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", frameName: "std::string const &"):
        _simulation.PhysicalOffsetFramesFormLoop_swiginit(self, _simulation.new_PhysicalOffsetFramesFormLoop(file, line, func, obj, frameName))
    __swig_destroy__ = _simulation.delete_PhysicalOffsetFramesFormLoop

# Register PhysicalOffsetFramesFormLoop in _simulation:
_simulation.PhysicalOffsetFramesFormLoop_swigregister(PhysicalOffsetFramesFormLoop)

class JointFramesHaveSameBaseFrame(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", parentName: "std::string const &", childName: "std::string const &", baseName: "std::string const &"):
        _simulation.JointFramesHaveSameBaseFrame_swiginit(self, _simulation.new_JointFramesHaveSameBaseFrame(file, line, func, thisName, parentName, childName, baseName))
    __swig_destroy__ = _simulation.delete_JointFramesHaveSameBaseFrame

# Register JointFramesHaveSameBaseFrame in _simulation:
_simulation.JointFramesHaveSameBaseFrame_swigregister(JointFramesHaveSameBaseFrame)

class Model(ModelComponent):
    r"""
     A concrete class that specifies the interface to a musculoskeletal model.
    You can read this in from an XML file or create it programmatically, and
    modify it via the API.

    A Model contains ModelComponents, and is itself a ModelComponent so must
    satisfy the ModelComponent interface, as well as the Object interface from
    which ModelComponent derives. This allows a Model to allocate "global"
    resources using ModelComponent resource-allocation facilities.

    Computation using a Model is done by creating a computational representation
    of the Model, called a System (SimTK::System), using Simbody. Creation of the
    System is initiated by a call to the Model's initSystem() method. The System and
    related objects are maintained in a runtime section of the Model object. You
    can also ask a Model to provide visualization using the setUseVisualizer()
    method, in which case it will allocate and maintain a ModelVisualizer.

    Authors: Frank Anderson, Peter Loan, Ayman Habib, Ajay Seth, Michael Sherman
    See also: ModelComponent, ModelVisualizer, SimTK::System
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Model *":
        return _simulation.Model_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Model_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Model_getClassName()

    def copyProperty_credits(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_credits(self, source)

    def append_credits(self, value: "std::string const &") -> "int":
        return _simulation.Model_append_credits(self, value)

    def constructProperty_credits(self, initValue: "std::string const &") -> "void":
        return _simulation.Model_constructProperty_credits(self, initValue)

    def get_credits(self, *args) -> "std::string const &":
        return _simulation.Model_get_credits(self, *args)

    def upd_credits(self, *args) -> "std::string &":
        return _simulation.Model_upd_credits(self, *args)

    def set_credits(self, *args) -> "void":
        return _simulation.Model_set_credits(self, *args)

    def copyProperty_publications(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_publications(self, source)

    def append_publications(self, value: "std::string const &") -> "int":
        return _simulation.Model_append_publications(self, value)

    def constructProperty_publications(self, initValue: "std::string const &") -> "void":
        return _simulation.Model_constructProperty_publications(self, initValue)

    def get_publications(self, *args) -> "std::string const &":
        return _simulation.Model_get_publications(self, *args)

    def upd_publications(self, *args) -> "std::string &":
        return _simulation.Model_upd_publications(self, *args)

    def set_publications(self, *args) -> "void":
        return _simulation.Model_set_publications(self, *args)

    def copyProperty_length_units(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_length_units(self, source)

    def append_length_units(self, value: "std::string const &") -> "int":
        return _simulation.Model_append_length_units(self, value)

    def constructProperty_length_units(self, initValue: "std::string const &") -> "void":
        return _simulation.Model_constructProperty_length_units(self, initValue)

    def get_length_units(self, *args) -> "std::string const &":
        return _simulation.Model_get_length_units(self, *args)

    def upd_length_units(self, *args) -> "std::string &":
        return _simulation.Model_upd_length_units(self, *args)

    def set_length_units(self, *args) -> "void":
        return _simulation.Model_set_length_units(self, *args)

    def copyProperty_force_units(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_force_units(self, source)

    def append_force_units(self, value: "std::string const &") -> "int":
        return _simulation.Model_append_force_units(self, value)

    def constructProperty_force_units(self, initValue: "std::string const &") -> "void":
        return _simulation.Model_constructProperty_force_units(self, initValue)

    def get_force_units(self, *args) -> "std::string const &":
        return _simulation.Model_get_force_units(self, *args)

    def upd_force_units(self, *args) -> "std::string &":
        return _simulation.Model_upd_force_units(self, *args)

    def set_force_units(self, *args) -> "void":
        return _simulation.Model_set_force_units(self, *args)

    def copyProperty_assembly_accuracy(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_assembly_accuracy(self, source)

    def append_assembly_accuracy(self, value: "double const &") -> "int":
        return _simulation.Model_append_assembly_accuracy(self, value)

    def constructProperty_assembly_accuracy(self, initValue: "double const &") -> "void":
        return _simulation.Model_constructProperty_assembly_accuracy(self, initValue)

    def get_assembly_accuracy(self, *args) -> "double const &":
        return _simulation.Model_get_assembly_accuracy(self, *args)

    def upd_assembly_accuracy(self, *args) -> "double &":
        return _simulation.Model_upd_assembly_accuracy(self, *args)

    def set_assembly_accuracy(self, *args) -> "void":
        return _simulation.Model_set_assembly_accuracy(self, *args)

    def copyProperty_gravity(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_gravity(self, source)

    def append_gravity(self, value: "Vec3") -> "int":
        return _simulation.Model_append_gravity(self, value)

    def constructProperty_gravity(self, initValue: "Vec3") -> "void":
        return _simulation.Model_constructProperty_gravity(self, initValue)

    def get_gravity(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.Model_get_gravity(self, *args)

    def upd_gravity(self, *args) -> "SimTK::Vec3 &":
        return _simulation.Model_upd_gravity(self, *args)

    def set_gravity(self, *args) -> "void":
        return _simulation.Model_set_gravity(self, *args)

    def copyProperty_ground(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ground(self, source)

    def append_ground(self, value: "Ground") -> "int":
        return _simulation.Model_append_ground(self, value)

    def constructProperty_ground(self, initValue: "Ground") -> "void":
        return _simulation.Model_constructProperty_ground(self, initValue)

    def get_ground(self, *args) -> "OpenSim::Ground const &":
        return _simulation.Model_get_ground(self, *args)

    def upd_ground(self, *args) -> "OpenSim::Ground &":
        return _simulation.Model_upd_ground(self, *args)

    def set_ground(self, *args) -> "void":
        return _simulation.Model_set_ground(self, *args)

    def copyProperty_BodySet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_BodySet(self, source)

    def append_BodySet(self, value: "BodySet") -> "int":
        return _simulation.Model_append_BodySet(self, value)

    def constructProperty_BodySet(self, initValue: "BodySet") -> "void":
        return _simulation.Model_constructProperty_BodySet(self, initValue)

    def get_BodySet(self, *args) -> "OpenSim::BodySet const &":
        return _simulation.Model_get_BodySet(self, *args)

    def upd_BodySet(self, *args) -> "OpenSim::BodySet &":
        return _simulation.Model_upd_BodySet(self, *args)

    def set_BodySet(self, *args) -> "void":
        return _simulation.Model_set_BodySet(self, *args)

    def copyProperty_JointSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_JointSet(self, source)

    def append_JointSet(self, value: "JointSet") -> "int":
        return _simulation.Model_append_JointSet(self, value)

    def constructProperty_JointSet(self, initValue: "JointSet") -> "void":
        return _simulation.Model_constructProperty_JointSet(self, initValue)

    def get_JointSet(self, *args) -> "OpenSim::JointSet const &":
        return _simulation.Model_get_JointSet(self, *args)

    def upd_JointSet(self, *args) -> "OpenSim::JointSet &":
        return _simulation.Model_upd_JointSet(self, *args)

    def set_JointSet(self, *args) -> "void":
        return _simulation.Model_set_JointSet(self, *args)

    def copyProperty_ConstraintSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ConstraintSet(self, source)

    def append_ConstraintSet(self, value: "ConstraintSet") -> "int":
        return _simulation.Model_append_ConstraintSet(self, value)

    def constructProperty_ConstraintSet(self, initValue: "ConstraintSet") -> "void":
        return _simulation.Model_constructProperty_ConstraintSet(self, initValue)

    def get_ConstraintSet(self, *args) -> "OpenSim::ConstraintSet const &":
        return _simulation.Model_get_ConstraintSet(self, *args)

    def upd_ConstraintSet(self, *args) -> "OpenSim::ConstraintSet &":
        return _simulation.Model_upd_ConstraintSet(self, *args)

    def set_ConstraintSet(self, *args) -> "void":
        return _simulation.Model_set_ConstraintSet(self, *args)

    def copyProperty_MarkerSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_MarkerSet(self, source)

    def append_MarkerSet(self, value: "MarkerSet") -> "int":
        return _simulation.Model_append_MarkerSet(self, value)

    def constructProperty_MarkerSet(self, initValue: "MarkerSet") -> "void":
        return _simulation.Model_constructProperty_MarkerSet(self, initValue)

    def get_MarkerSet(self, *args) -> "OpenSim::MarkerSet const &":
        return _simulation.Model_get_MarkerSet(self, *args)

    def upd_MarkerSet(self, *args) -> "OpenSim::MarkerSet &":
        return _simulation.Model_upd_MarkerSet(self, *args)

    def set_MarkerSet(self, *args) -> "void":
        return _simulation.Model_set_MarkerSet(self, *args)

    def copyProperty_ForceSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ForceSet(self, source)

    def append_ForceSet(self, value: "ForceSet") -> "int":
        return _simulation.Model_append_ForceSet(self, value)

    def constructProperty_ForceSet(self, initValue: "ForceSet") -> "void":
        return _simulation.Model_constructProperty_ForceSet(self, initValue)

    def get_ForceSet(self, *args) -> "OpenSim::ForceSet const &":
        return _simulation.Model_get_ForceSet(self, *args)

    def upd_ForceSet(self, *args) -> "OpenSim::ForceSet &":
        return _simulation.Model_upd_ForceSet(self, *args)

    def set_ForceSet(self, *args) -> "void":
        return _simulation.Model_set_ForceSet(self, *args)

    def copyProperty_ControllerSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ControllerSet(self, source)

    def append_ControllerSet(self, value: "ControllerSet") -> "int":
        return _simulation.Model_append_ControllerSet(self, value)

    def constructProperty_ControllerSet(self, initValue: "ControllerSet") -> "void":
        return _simulation.Model_constructProperty_ControllerSet(self, initValue)

    def get_ControllerSet(self, *args) -> "OpenSim::ControllerSet const &":
        return _simulation.Model_get_ControllerSet(self, *args)

    def upd_ControllerSet(self, *args) -> "OpenSim::ControllerSet &":
        return _simulation.Model_upd_ControllerSet(self, *args)

    def set_ControllerSet(self, *args) -> "void":
        return _simulation.Model_set_ControllerSet(self, *args)

    def copyProperty_ContactGeometrySet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ContactGeometrySet(self, source)

    def append_ContactGeometrySet(self, value: "ContactGeometrySet") -> "int":
        return _simulation.Model_append_ContactGeometrySet(self, value)

    def constructProperty_ContactGeometrySet(self, initValue: "ContactGeometrySet") -> "void":
        return _simulation.Model_constructProperty_ContactGeometrySet(self, initValue)

    def get_ContactGeometrySet(self, *args) -> "OpenSim::ContactGeometrySet const &":
        return _simulation.Model_get_ContactGeometrySet(self, *args)

    def upd_ContactGeometrySet(self, *args) -> "OpenSim::ContactGeometrySet &":
        return _simulation.Model_upd_ContactGeometrySet(self, *args)

    def set_ContactGeometrySet(self, *args) -> "void":
        return _simulation.Model_set_ContactGeometrySet(self, *args)

    def copyProperty_ProbeSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ProbeSet(self, source)

    def append_ProbeSet(self, value: "ProbeSet") -> "int":
        return _simulation.Model_append_ProbeSet(self, value)

    def constructProperty_ProbeSet(self, initValue: "ProbeSet") -> "void":
        return _simulation.Model_constructProperty_ProbeSet(self, initValue)

    def get_ProbeSet(self, *args) -> "OpenSim::ProbeSet const &":
        return _simulation.Model_get_ProbeSet(self, *args)

    def upd_ProbeSet(self, *args) -> "OpenSim::ProbeSet &":
        return _simulation.Model_upd_ProbeSet(self, *args)

    def set_ProbeSet(self, *args) -> "void":
        return _simulation.Model_set_ProbeSet(self, *args)

    def copyProperty_ComponentSet(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ComponentSet(self, source)

    def append_ComponentSet(self, value: "ComponentSet") -> "int":
        return _simulation.Model_append_ComponentSet(self, value)

    def constructProperty_ComponentSet(self, initValue: "ComponentSet") -> "void":
        return _simulation.Model_constructProperty_ComponentSet(self, initValue)

    def get_ComponentSet(self, *args) -> "OpenSim::ComponentSet const &":
        return _simulation.Model_get_ComponentSet(self, *args)

    def upd_ComponentSet(self, *args) -> "OpenSim::ComponentSet &":
        return _simulation.Model_upd_ComponentSet(self, *args)

    def set_ComponentSet(self, *args) -> "void":
        return _simulation.Model_set_ComponentSet(self, *args)

    def copyProperty_ModelVisualPreferences(self, source: "Model") -> "void":
        return _simulation.Model_copyProperty_ModelVisualPreferences(self, source)

    def append_ModelVisualPreferences(self, value: "ModelVisualPreferences") -> "int":
        return _simulation.Model_append_ModelVisualPreferences(self, value)

    def constructProperty_ModelVisualPreferences(self, initValue: "ModelVisualPreferences") -> "void":
        return _simulation.Model_constructProperty_ModelVisualPreferences(self, initValue)

    def get_ModelVisualPreferences(self, *args) -> "OpenSim::ModelVisualPreferences const &":
        return _simulation.Model_get_ModelVisualPreferences(self, *args)

    def upd_ModelVisualPreferences(self, *args) -> "OpenSim::ModelVisualPreferences &":
        return _simulation.Model_upd_ModelVisualPreferences(self, *args)

    def set_ModelVisualPreferences(self, *args) -> "void":
        return _simulation.Model_set_ModelVisualPreferences(self, *args)
    _has_output_com_position = property(_simulation.Model__has_output_com_position_get, _simulation.Model__has_output_com_position_set)
    _has_output_com_velocity = property(_simulation.Model__has_output_com_velocity_get, _simulation.Model__has_output_com_velocity_set)
    _has_output_com_acceleration = property(_simulation.Model__has_output_com_acceleration_get, _simulation.Model__has_output_com_acceleration_set)
    _has_output_kinetic_energy = property(_simulation.Model__has_output_kinetic_energy_get, _simulation.Model__has_output_kinetic_energy_set)
    _has_output_potential_energy = property(_simulation.Model__has_output_potential_energy_get, _simulation.Model__has_output_potential_energy_set)

    def finalizeConnections(self, *args) -> "void":
        r"""
        *Overload 1:*
         Satisfy all connections (Sockets and Inputs) in the model, using this
        model as the root Component. This is a convenience form of
        Component::finalizeConnections() that uses this model as root.

        |

        *Overload 2:*
         Satisfy the Component's connections specified by its Sockets and Inputs.
                Locate Components and their Outputs to satisfy the connections in an
                aggregate Component (e.g. Model), which is the root of a tree of
                Components.
        """
        return _simulation.Model_finalizeConnections(self, *args)

    def setup(self) -> "void":
        r"""
        Perform some set up functions that happen after the
        object has been deserialized. TODO: this method is
        not yet designed to be called after a model has been
        copied.
        """
        return _simulation.Model_setup(self)

    def cleanup(self) -> "void":
        r"""
        Perform some clean up functions that are normally done
        from the destructor however this gives the GUI a way to
        proactively do the cleaning without waiting for garbage
        collection to do the actual cleanup.
        """
        return _simulation.Model_cleanup(self)

    def clone(self) -> "OpenSim::Model *":
        r"""
        Model clone() override that invokes finalizeFromProperties()
               on a default copy constructed Model, prior to returning the Model.
        """
        return _simulation.Model_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Model_getConcreteClassName(self)

    def getDisplayHints(self) -> "OpenSim::ModelDisplayHints const &":
        r"""
        * Get read only access to the ModelDisplayHints object stored with this
            %Model. These should be checked whenever display geometry is being
            generated. *
        """
        return _simulation.Model_getDisplayHints(self)

    def updDisplayHints(self) -> "OpenSim::ModelDisplayHints &":
        r"""
        Get writable access to the ModelDisplayHints object stored with this
           %Model. The GUI or ModelVisualizer can update these as a result of user
           requests, or an OpenSim API program can set them programmatically. *
        """
        return _simulation.Model_updDisplayHints(self)

    def setUseVisualizer(self, visualize: "bool") -> "void":
        r"""
        Request or suppress visualization of this %Model. This flag is checked
           during initSystem() and if set causes the %Model to allocate a
           ModelVisualizer that provides visualization and interaction with the %Model
           as it is executing. The default is no visualization.
           See also: getModelVisualizer() *
        """
        return _simulation.Model_setUseVisualizer(self, visualize)

    def getUseVisualizer(self) -> "bool":
        r"""
        Return the current setting of the "use visualizer" flag, which will
           take effect at the next call to initSystem() on this %Model. *
        """
        return _simulation.Model_getUseVisualizer(self)

    def hasVisualizer(self) -> "bool":
        r"""
        Test whether a ModelVisualizer has been created for this Model. Even
           if visualization has been requested there will be no visualizer present
           until initSystem() has been successfully invoked. Use this method prior
           to calling getVisualizer() or updVisualizer() to avoid an
           unpleasant exception. *
        """
        return _simulation.Model_hasVisualizer(self)

    def getVisualizer(self) -> "OpenSim::ModelVisualizer const &":
        r"""
        Obtain read-only access to the ModelVisualizer. This will throw an
           exception if visualization was not requested or initSystem() not yet
           called.
           :rtype: :py:class:`ModelVisualizer`
           :return: A const reference to the allocated ModelVisualizer. *
        """
        return _simulation.Model_getVisualizer(self)

    def updVisualizer(self) -> "OpenSim::ModelVisualizer &":
        r"""
        Obtain writable access to the ModelVisualizer. This will throw an
           exception if visualization was not requested or initSystem() not yet
           called. Writable access to the ModelVisualizer requires that you have
           writable access to this containing Model.
           :rtype: :py:class:`ModelVisualizer`
           :return: A non-const reference to the allocated ModelVisualizer. *
        """
        return _simulation.Model_updVisualizer(self)

    def buildSystem(self) -> "void":
        r"""
        * After the %Model and its components have been constructed, call this to
            interconnect the components and then create the Simbody
            MultibodySystem needed to represent the %Model computationally. The
            extendConnectToModel() method of each contained ModelComponent will be invoked,
            and then their addToSystem() methods are invoked.
            The resulting MultibodySystem is maintained internally by the %Model. After
            this call, you may obtain a writable reference to the System using
            updMultibodySystem() which you can use to make any additions you want. Then
            when the System is complete, call initializeState() to finalize it and
            obtain an initial State. *
        """
        return _simulation.Model_buildSystem(self)

    def initializeState(self) -> "SimTK::State &":
        r"""
        After buildSystem() has been called, and any additional modifications
           to the Simbody MultibodySystem have been made, call this method to finalize
           the MultibodySystem (by calling its realizeTopology() method), obtain an
           initial state, and assemble it so that position constraints are
           satisfied. The initStateFromProperties() method of each contained
           ModelComponent will be invoked. A reference to the writable internally-
           maintained model State is returned (note that this does not affect the
           system's default state (which is part of the model and hence read only).
           The model's state can be reset to the system's default state at any time
           by re-executing initializeState(). *
        """
        return _simulation.Model_initializeState(self)

    def initSystem(self) -> "SimTK::State &":
        r"""
        Convenience method that invokes buildSystem() and then
           initializeState(). This returns a reference to the writable internally-
           maintained model State. Note that this does not affect the
           system's default state (which is part of the model and hence read-only). *
        """
        return _simulation.Model_initSystem(self)

    def getWorkingState(self) -> "SimTK::State const &":
        r"""
        Convenience method that returns a reference to the model's 'working'
           state. This is just returning the reference that was returned by
           initSystem() and initializeState() -- note that either of these methods
           must be called prior to getWorkingState(), otherwise an empty state will
           be returned. *
        """
        return _simulation.Model_getWorkingState(self)

    def updWorkingState(self) -> "SimTK::State &":
        return _simulation.Model_updWorkingState(self)

    def initStateWithoutRecreatingSystem(self, state: "State") -> "void":
        r"""
        This is called after the Model is fully created but before starting a simulation.
        It ONLY initializes the computational system used to simulate the model and
        addToSystem() has been called already. This method should only be used if
        if additional SimTK::System components are being added using the SimTK API
        and the programmer is certain that the model's system has been created.
        """
        return _simulation.Model_initStateWithoutRecreatingSystem(self, state)

    def invalidateSystem(self) -> "void":
        r"""
        Mark the computational system as invalid.  This should be called whenever a property
        of the model is modified.  Once this has been called, no calculations can be done until
        initSystem() is called again.
        """
        return _simulation.Model_invalidateSystem(self)

    def isValidSystem(self) -> "bool":
        r"""
        Check that the underlying computational system representing the model is valid.
               That is, is the system ready for performing calculations.
        """
        return _simulation.Model_isValidSystem(self)

    def formStateStorage(self, originalStorage: "Storage", statesStorage: "Storage", warnUnspecifiedStates: "bool"=True) -> "void":
        r"""
        Create a storage (statesStorage) that has same label order as model's states
        with values populated from originalStorage. Use the default state value if
        a state is unspecified in the originalStorage. If warnUnspecifiedStates is
        true then a warning is printed that includes the default value used for
        the state value unspecified in originalStorage. The input originalStorage
        must be in meters or radians for Coordinate values and their speeds
        (m/s, rad/s) otherwise an Exception is thrown.
        """
        return _simulation.Model_formStateStorage(self, originalStorage, statesStorage, warnUnspecifiedStates)

    def formQStorage(self, originalStorage: "Storage", qStorage: "Storage") -> "void":
        return _simulation.Model_formQStorage(self, originalStorage, qStorage)

    def updateAssemblyConditions(self, s: "State") -> "void":
        r"""Update the AssemblySolver to the latest coordinate locking/constraints"""
        return _simulation.Model_updateAssemblyConditions(self, s)

    def assemble(self, state: "State", coord: "Coordinate"=None, weight: "double"=10) -> "void":
        r"""
        Find the kinematic state of the model that satisfies constraints and coordinate goals
        If assemble is being called due to a coordinate set value, provide the option
        to weight that coordinate value more heavily if specified.
        """
        return _simulation.Model_assemble(self, state, coord, weight)

    def equilibrateMuscles(self, state: "State") -> "void":
        r"""Update the state of all Muscles so they are in equilibrium."""
        return _simulation.Model_equilibrateMuscles(self, state)

    def getMultibodySystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        * Get read-only access to the internal Simbody MultibodySystem that was
            created by this %Model at the last initSystem() call. *
        """
        return _simulation.Model_getMultibodySystem(self)

    def updMultibodySystem(self) -> "SimTK::MultibodySystem &":
        r"""
        (Advanced) Get writable access to the internal Simbody MultibodySystem
           that was created by this %Model at the last initSystem() call. Be careful
           if you make modifications to the System because that will invalidate
           initialization already performed by the Model.
           See also: initStateWithoutRecreatingSystem() *
        """
        return _simulation.Model_updMultibodySystem(self)

    def getDefaultSubsystem(self) -> "SimTK::DefaultSystemSubsystem const &":
        r"""
        Get read-only access to the internal DefaultSystemSubsystem allocated
           by this %Model's Simbody MultibodySystem. *
        """
        return _simulation.Model_getDefaultSubsystem(self)

    def updDefaultSubsystem(self) -> "SimTK::DefaultSystemSubsystem &":
        r"""
        (Advanced) Get writable access to the internal DefaultSystemSubsystem
           allocated by this %Model's Simbody MultibodySystem. *
        """
        return _simulation.Model_updDefaultSubsystem(self)

    def getMatterSubsystem(self) -> "SimTK::SimbodyMatterSubsystem const &":
        r"""
        Get read-only access to the internal SimbodyMatterSubsystem allocated
           by this %Model. *
        """
        return _simulation.Model_getMatterSubsystem(self)

    def updMatterSubsystem(self) -> "SimTK::SimbodyMatterSubsystem &":
        r"""
        (Advanced) Get writable access to the internal SimbodyMatterSubsystem
           allocated by this %Model. *
        """
        return _simulation.Model_updMatterSubsystem(self)

    def getGravityForce(self) -> "SimTK::Force::Gravity const &":
        r"""
        Get read-only access to the Simbody Force::Gravity element that was
           allocated by this %Model. *
        """
        return _simulation.Model_getGravityForce(self)

    def updGravityForce(self) -> "SimTK::Force::Gravity &":
        r"""
        (Advanced) Get writable access to the Simbody Force::Gravity element
           that was allocated by this %Model. *
        """
        return _simulation.Model_updGravityForce(self)

    def getForceSubsystem(self) -> "SimTK::GeneralForceSubsystem const &":
        r"""
        Get read-only access to the internal Simbody GeneralForceSubsystem
           allocated by this %Model. *
        """
        return _simulation.Model_getForceSubsystem(self)

    def updForceSubsystem(self) -> "SimTK::GeneralForceSubsystem &":
        r"""
        (Advanced) Get writable access to the internal Simbody
           GeneralForceSubsystem allocated by this %Model. *
        """
        return _simulation.Model_updForceSubsystem(self)

    def realizeTime(self, state: "State") -> "void":
        r"""** Perform computations that depend only on time and earlier stages. *"""
        return _simulation.Model_realizeTime(self, state)

    def realizePosition(self, state: "State") -> "void":
        r"""
        Perform computations that depend only on position-level state
           variables and computations performed in earlier stages (including time). *
        """
        return _simulation.Model_realizePosition(self, state)

    def realizeVelocity(self, state: "State") -> "void":
        r"""
        Perform computations that depend only on velocity-level state
           variables and computations performed in earlier stages (including position,
           and time). *
        """
        return _simulation.Model_realizeVelocity(self, state)

    def realizeDynamics(self, state: "State") -> "void":
        r"""
        Perform computations (typically forces) that may depend on
           dynamics-stage state variables, and on computations performed in earlier
           stages (including velocity, position, and time), but not on other forces,
           accelerations, constraint multipliers, or reaction forces. *
        """
        return _simulation.Model_realizeDynamics(self, state)

    def realizeAcceleration(self, state: "State") -> "void":
        r""" Perform computations that may depend on applied forces. *"""
        return _simulation.Model_realizeAcceleration(self, state)

    def realizeReport(self, state: "State") -> "void":
        r"""
        Perform computations that may depend on anything but are only used
           for reporting and cannot affect subsequent simulation behavior. *
        """
        return _simulation.Model_realizeReport(self, state)

    def addModelComponent(self, adoptee: "ModelComponent") -> "void":
        r"""*"""
        val = _simulation.Model_addModelComponent(self, adoptee)

        adoptee._markAdopted()


        return val


    def addBody(self, adoptee: "Body") -> "void":
        val = _simulation.Model_addBody(self, adoptee)

        adoptee._markAdopted()


        return val


    def addJoint(self, adoptee: "Joint") -> "void":
        val = _simulation.Model_addJoint(self, adoptee)

        adoptee._markAdopted()


        return val


    def addConstraint(self, adoptee: "Constraint") -> "void":
        val = _simulation.Model_addConstraint(self, adoptee)

        adoptee._markAdopted()


        return val


    def addForce(self, adoptee: "Force") -> "void":
        val = _simulation.Model_addForce(self, adoptee)

        adoptee._markAdopted()


        return val


    def addProbe(self, adoptee: "Probe") -> "void":
        val = _simulation.Model_addProbe(self, adoptee)

        adoptee._markAdopted()


        return val


    def addContactGeometry(self, adoptee: "ContactGeometry") -> "void":
        val = _simulation.Model_addContactGeometry(self, adoptee)

        adoptee._markAdopted()


        return val


    def addMarker(self, adoptee: "Marker") -> "void":
        val = _simulation.Model_addMarker(self, adoptee)

        adoptee._markAdopted()


        return val


    def removeProbe(self, probe: "Probe") -> "void":
        r""" remove passed in Probe from model *"""
        return _simulation.Model_removeProbe(self, probe)

    def getInputFileName(self) -> "std::string const &":
        r"""
        Get the XML file name used to construct the model.

        :rtype: string
        :return: XML file name string.
        """
        return _simulation.Model_getInputFileName(self)

    def setInputFileName(self, fileName: "std::string const &") -> "void":
        r"""
        %Set the XML file name used to construct the model.

        :type fileName: string
        :param fileName: The XML file name.
        """
        return _simulation.Model_setInputFileName(self, fileName)

    def getCredits(self) -> "std::string const &":
        r"""
        Get the credits (e.g., model author names) associated with the model.

        :rtype: string
        :return: Credits string.
        """
        return _simulation.Model_getCredits(self)

    def setAuthors(self, aCredits: "std::string const &") -> "void":
        r"""
        %Set the credits (e.g., model author names) associated with the model.

        :type aCredits: string
        :param aCredits: The string of credits.
        """
        return _simulation.Model_setAuthors(self, aCredits)

    def getPublications(self) -> "std::string const &":
        r"""
        Get the publications associated with the model.

        :rtype: string
        :return: Publications string.
        """
        return _simulation.Model_getPublications(self)

    def setPublications(self, aPublications: "std::string const &") -> "void":
        r"""
        %Set the publications associated with the model.

        :type aPublications: string
        :param aPublications: The string of publications.
        """
        return _simulation.Model_setPublications(self, aPublications)

    def getLengthUnits(self) -> "OpenSim::Units const &":
        r"""
        Get the length units associated with the model.

        :rtype: :py:class:`Units`
        :return: Length units.
        """
        return _simulation.Model_getLengthUnits(self)

    def getForceUnits(self) -> "OpenSim::Units const &":
        r"""
        Get the force units associated with the model.

        :rtype: :py:class:`Units`
        :return: Force units
        """
        return _simulation.Model_getForceUnits(self)

    def getGravity(self) -> "SimTK::Vec3":
        r"""
        Get the gravity vector in the global frame.

        :rtype: :py:class:`Vec3`
        :return: The XYZ gravity vector in the global frame.
        """
        return _simulation.Model_getGravity(self)

    def setGravity(self, aGrav: "Vec3") -> "bool":
        r"""
        %Set the gravity vector in the global frame.

        :type aGrav: :py:class:`Vec3`
        :param aGrav: The XYZ gravity vector
        :rtype: boolean
        :return: Whether or not the gravity vector was successfully set.
        """
        return _simulation.Model_setGravity(self, aGrav)

    def getNumMarkers(self) -> "int":
        r"""
        Get the number of markers in the model.
        :rtype: int
        :return: Number of markers.
        """
        return _simulation.Model_getNumMarkers(self)

    def getNumContactGeometries(self) -> "int":
        r"""
        Get the number of ContactGeometries in the model.
        :rtype: int
        :return: Number of ContactGeometries.
        """
        return _simulation.Model_getNumContactGeometries(self)

    def getNumBodies(self) -> "int":
        r"""
        Get the total number of bodies in the model.
        :rtype: int
        :return: Number of bodies.
        """
        return _simulation.Model_getNumBodies(self)

    def getNumJoints(self) -> "int":
        r"""
        Get the total number of joints in the model.
        :rtype: int
        :return: Number of joints.
        """
        return _simulation.Model_getNumJoints(self)

    def getNumCoordinates(self) -> "int":
        r"""
        Get the total number of coordinates in the model.
        :rtype: int
        :return: Number of coordinates.
        """
        return _simulation.Model_getNumCoordinates(self)

    def getNumSpeeds(self) -> "int":
        r"""
        Get the total number of speeds in the model.
        :rtype: int
        :return: Number of speeds.
        """
        return _simulation.Model_getNumSpeeds(self)

    def getNumConstraints(self) -> "int":
        r"""
        Get the total number of constraints in the model.
        :rtype: int
        :return: Number of constraints.
        """
        return _simulation.Model_getNumConstraints(self)

    def getNumProbes(self) -> "int":
        r"""
        Get the total number of probes in the model.
        :rtype: int
        :return: Number of probes.
        """
        return _simulation.Model_getNumProbes(self)

    def getActuators(self) -> "OpenSim::Set< OpenSim::Actuator > const &":
        r"""
        Get the subset of Forces in the model which are actuators
        :rtype: OpenSim::Set< OpenSim::Actuator >
        :return: The set of Actuators
        """
        return _simulation.Model_getActuators(self)

    def updActuators(self) -> "OpenSim::Set< OpenSim::Actuator > &":
        return _simulation.Model_updActuators(self)

    def getMuscles(self) -> "OpenSim::Set< OpenSim::Muscle > const &":
        r"""
        Get the subset of Forces in the model which are muscles
        :rtype: OpenSim::Set< OpenSim::Muscle >
        :return: The set of Muscles
        """
        return _simulation.Model_getMuscles(self)

    def updMuscles(self) -> "OpenSim::Set< OpenSim::Muscle > &":
        return _simulation.Model_updMuscles(self)

    def getForceSet(self) -> "OpenSim::ForceSet const &":
        return _simulation.Model_getForceSet(self)

    def updForceSet(self) -> "OpenSim::ForceSet &":
        return _simulation.Model_updForceSet(self)

    def getProbeSet(self) -> "OpenSim::ProbeSet const &":
        r"""
        Get the subset of Probes in the model
        :rtype: :py:class:`ProbeSet`
        :return: The set of Probes
        """
        return _simulation.Model_getProbeSet(self)

    def updProbeSet(self) -> "OpenSim::ProbeSet &":
        return _simulation.Model_updProbeSet(self)

    def getMiscModelComponentSet(self) -> "OpenSim::ComponentSet const &":
        r"""
        Get the subst of misc ModelComponents in the model
        :rtype: :py:class:`ComponentSet`
        :return: The set of misc ModelComponents
        """
        return _simulation.Model_getMiscModelComponentSet(self)

    def updMiscModelComponentSet(self) -> "OpenSim::ComponentSet &":
        return _simulation.Model_updMiscModelComponentSet(self)

    def getNumAnalyses(self) -> "int":
        r"""
        Get the number of analyses in the model.
        :rtype: int
        :return: The number of analyses.
        """
        return _simulation.Model_getNumAnalyses(self)

    def getNumControls(self) -> "int":
        r"""
        Get the number of controls for this the model.
        Only valid once underlying system for the model has been created.
        Throws an exception if called before Model::initSystem()
        :rtype: int
        :return: number of controls corresponding to all the actuators in the model
        """
        return _simulation.Model_getNumControls(self)

    def updDefaultControls(self) -> "SimTK::Vector &":
        r"""
        Writable access to the default values for controls. These values are used for
               control value during a simulation unless updated, for example, by a Controller
        """
        return _simulation.Model_updDefaultControls(self)

    def setDefaultControls(self, controls: "Vector") -> "void":
        return _simulation.Model_setDefaultControls(self, controls)

    def getDefaultControls(self) -> "SimTK::Vector const &":
        return _simulation.Model_getDefaultControls(self)

    def updControls(self, s: "State") -> "SimTK::Vector &":
        r"""
        Update the controls for this the model at a given state.
        Only callable once underlying system for the model has been created.
        Throws an exception if called before Model::initSystem()
        This call invalidates the dynamics of the model and invalidates the
        value of the controls until they are marked as valid when the update
        is completed (See also: markControlsAsValid)
        :type s: :py:class:`State`, in
        :param s:         System state at which to apply the controls
        :rtype: :py:class:`Vector`
        :return: writable controls Vector
        """
        return _simulation.Model_updControls(self, s)

    def markControlsAsValid(self, s: "State") -> "void":
        r"""
        Mark controls as valid after an update at a given state.
        Indicates that controls are valid for use at the dynamics stage.
        If the stage is Velocity or lower the controls will remain invalid.
        :type s: :py:class:`State`, in
        :param s:         System state in which the controls are updated
        """
        return _simulation.Model_markControlsAsValid(self, s)

    def setControls(self, s: "State", controls: "Vector") -> "void":
        r"""
        Alternatively, set the controls on the model at a given state.
        Note, this method will invalidate the dynamics of the model,
        but will mark the controls as valid. (E.g. controllers will not be invoked)
        :type s: :py:class:`State`, in
        :param s:         System state at which to apply the controls
        :type controls: :py:class:`Vector`, in
        :param controls:  The complete Vector of controls to be applied
        """
        return _simulation.Model_setControls(self, s, controls)

    def getControls(self, s: "State") -> "SimTK::Vector const &":
        r""" Const access to controls does not invalidate dynamics"""
        return _simulation.Model_getControls(self, s)

    def computeControls(self, state: "State", controls: "Vector") -> "void":
        r"""
        Compute the controls for the model.
           Calls down to the Controllers to make their contributions to the controls.

           :type state: :py:class:`State`, in
           :param state:       System state from which Controllers should draw
                                        when computing their control outputs.
           :type controls: :py:class:`Vector`, out
           :param controls:    The complete vector of controls into which
                                        individual controller contributions should be
                                        added. *
        """
        return _simulation.Model_computeControls(self, state, controls)

    def isControlled(self) -> "bool":
        r"""Get a flag indicating if the model needs controls to operate its actuators"""
        return _simulation.Model_isControlled(self)

    def storeControls(self, s: "State", step: "int") -> "void":
        return _simulation.Model_storeControls(self, s, step)

    def printControlStorage(self, fileName: "std::string const &") -> "void":
        return _simulation.Model_printControlStorage(self, fileName)

    def getControlsTable(self) -> "OpenSim::TimeSeriesTable":
        return _simulation.Model_getControlsTable(self)

    def getControllerSet(self) -> "OpenSim::ControllerSet const &":
        return _simulation.Model_getControllerSet(self)

    def updControllerSet(self) -> "OpenSim::ControllerSet &":
        return _simulation.Model_updControllerSet(self)

    def getAllControllersEnabled(self) -> "bool":
        return _simulation.Model_getAllControllersEnabled(self)

    def setAllControllersEnabled(self, enabled: "bool") -> "void":
        return _simulation.Model_setAllControllersEnabled(self, enabled)

    def applyDefaultConfiguration(self, s: "State") -> "void":
        return _simulation.Model_applyDefaultConfiguration(self, s)

    def getSimbodyEngine(self) -> "OpenSim::SimbodyEngine const &":
        r"""
        Get the model's dynamics engine

        :rtype: :py:class:`SimbodyEngine`
        :return: Reference to the Simbody dynamics engine
        """
        return _simulation.Model_getSimbodyEngine(self)

    def updSimbodyEngine(self) -> "OpenSim::SimbodyEngine &":
        return _simulation.Model_updSimbodyEngine(self)

    def computeStateVariableDerivatives(self, s: "State") -> "void":
        return _simulation.Model_computeStateVariableDerivatives(self, s)

    def getTotalMass(self, s: "State") -> "double":
        return _simulation.Model_getTotalMass(self, s)

    def getInertiaAboutMassCenter(self, s: "State") -> "SimTK::Inertia":
        return _simulation.Model_getInertiaAboutMassCenter(self, s)

    def calcMassCenterPosition(self, s: "State") -> "SimTK::Vec3":
        return _simulation.Model_calcMassCenterPosition(self, s)

    def calcMassCenterVelocity(self, s: "State") -> "SimTK::Vec3":
        return _simulation.Model_calcMassCenterVelocity(self, s)

    def calcMassCenterAcceleration(self, s: "State") -> "SimTK::Vec3":
        return _simulation.Model_calcMassCenterAcceleration(self, s)

    def calcKineticEnergy(self, s: "State") -> "double":
        r""" return the total Kinetic Energy for the underlying system."""
        return _simulation.Model_calcKineticEnergy(self, s)

    def calcPotentialEnergy(self, s: "State") -> "double":
        r""" return the total Potential Energy for the underlying system."""
        return _simulation.Model_calcPotentialEnergy(self, s)

    def getNumMuscleStates(self) -> "int":
        return _simulation.Model_getNumMuscleStates(self)

    def getNumProbeStates(self) -> "int":
        return _simulation.Model_getNumProbeStates(self)

    def updCoordinateSet(self) -> "OpenSim::CoordinateSet &":
        return _simulation.Model_updCoordinateSet(self)

    def getCoordinateSet(self) -> "OpenSim::CoordinateSet const &":
        return _simulation.Model_getCoordinateSet(self)

    def getCoordinatesInMultibodyTreeOrder(self) -> "std::vector< SimTK::ReferencePtr< OpenSim::Coordinate const >,std::allocator< SimTK::ReferencePtr< OpenSim::Coordinate const > > >":
        r"""
        Obtain a list of Model's Coordinates in the order they appear in the
               MultibodySystem after Model::initSystem() has been called.
               Coordinates in the CoordinateSet do not have a predefined order. In
               some instances it is helpful to get the coordinates in order of
               generalized coordinates in the Multibody Tree as defined in the
               underlying MultibodySystem. For example, computing the generalized
               forces from the System, yields a vector of generalized forces
               in order of the Multibody Tree and now that can be attributed to
               corresponding generalized Coordinates of the Model.
               Throws if the MultibodySystem is not valid.
        """
        return _simulation.Model_getCoordinatesInMultibodyTreeOrder(self)

    def getWarningMesssageForMotionTypeInconsistency(self) -> "std::string":
        r"""
        Get a warning message if any Coordinates have a MotionType that is NOT
               consistent with its previous user-specified value that existed in
               Model files prior to OpenSim 4.0
        """
        return _simulation.Model_getWarningMesssageForMotionTypeInconsistency(self)

    def updBodySet(self) -> "OpenSim::BodySet &":
        return _simulation.Model_updBodySet(self)

    def getBodySet(self) -> "OpenSim::BodySet const &":
        return _simulation.Model_getBodySet(self)

    def updJointSet(self) -> "OpenSim::JointSet &":
        return _simulation.Model_updJointSet(self)

    def getJointSet(self) -> "OpenSim::JointSet const &":
        return _simulation.Model_getJointSet(self)

    def updAnalysisSet(self) -> "OpenSim::AnalysisSet &":
        return _simulation.Model_updAnalysisSet(self)

    def getAnalysisSet(self) -> "OpenSim::AnalysisSet const &":
        return _simulation.Model_getAnalysisSet(self)

    def updContactGeometrySet(self) -> "OpenSim::ContactGeometrySet &":
        return _simulation.Model_updContactGeometrySet(self)

    def getContactGeometrySet(self) -> "OpenSim::ContactGeometrySet const &":
        return _simulation.Model_getContactGeometrySet(self)

    def getGround(self) -> "OpenSim::Ground const &":
        r""" Get a const reference to the Ground reference frame"""
        return _simulation.Model_getGround(self)

    def updGround(self) -> "OpenSim::Ground &":
        r""" Get a writable reference to the Ground reference frame"""
        return _simulation.Model_updGround(self)

    def updConstraintSet(self) -> "OpenSim::ConstraintSet &":
        return _simulation.Model_updConstraintSet(self)

    def getConstraintSet(self) -> "OpenSim::ConstraintSet const &":
        return _simulation.Model_getConstraintSet(self)

    def updMarkerSet(self) -> "OpenSim::MarkerSet &":
        return _simulation.Model_updMarkerSet(self)

    def getMarkerSet(self) -> "OpenSim::MarkerSet const &":
        return _simulation.Model_getMarkerSet(self)

    def writeMarkerFile(self, aFileName: "std::string const &") -> "void":
        return _simulation.Model_writeMarkerFile(self, aFileName)

    def updateMarkerSet(self, newMarkerSet: "MarkerSet") -> "void":
        r"""
        Update the markers in the model by appending the ones in the
        passed-in marker set. If the marker of the same name exists
        in the model, then replace it.

        :type newMarkerSet: :py:class:`MarkerSet`
        :param newMarkerSet: the set of markers used to update the model's set.
        """
        return _simulation.Model_updateMarkerSet(self, newMarkerSet)

    def deleteUnusedMarkers(self, aMarkerNames: "ArrayStr") -> "int":
        return _simulation.Model_deleteUnusedMarkers(self, aMarkerNames)

    def addAnalysis(self, adoptee: "Analysis") -> "void":
        r"""
        Add an Analysis to the %Model.

        :type adoptee: :py:class:`Analysis`
        :param adoptee: pointer to the Analysis to add
        """
        val = _simulation.Model_addAnalysis(self, adoptee)

        adoptee._markAdopted()


        return val


    def addController(self, adoptee: "Controller") -> "void":
        r""" Add a Controller to the %Model. *"""
        val = _simulation.Model_addController(self, adoptee)

        adoptee._markAdopted()


        return val


    def removeAnalysis(self, analysis: "Analysis", deleteIt: "bool"=True) -> "void":
        r"""
        Remove an Analysis from the %Model.

        :type analysis: :py:class:`Analysis`
        :param analysis:  Pointer to the analysis to remove.
        :type deleteIt: boolean, optional
        :param deleteIt:  Whether the removed object should be deleted.
        """
        return _simulation.Model_removeAnalysis(self, analysis, deleteIt)

    def removeController(self, aController: "Controller") -> "void":
        r""" Remove a Controller from the %Model. *"""
        return _simulation.Model_removeController(self, aController)

    def scale(self, state: "State", scaleSet: "ScaleSet", preserveMassDist: "bool", finalMass: "double"=-1.0) -> "bool":
        r"""
        Scale the model.

        :type state: :py:class:`State`
        :param state:      State containing parameter values that might be
                              modified here.
        :type scaleSet: :py:class:`ScaleSet`
        :param scaleSet:   The set of XYZ scale factors for the bodies.
        :type preserveMassDist: boolean
        :param preserveMassDist:
                              Whether the masses of the bodies should be scaled by
                              the scale factors. If `false`, body masses will be
                              adjusted only if `finalMass` has been specified; if
                              `true`, body masses will be scaled by the product of
                              the body's scale factors (and then a second time if
                              `finalMass` has been specified). Inertias are always
                              updated to reflect changes in body dimensions.
        :type finalMass: float, optional
        :param finalMass:  The total mass that the scaled model should have.
        :rtype: boolean
        :return: Whether or not scaling was successful.
        """
        return _simulation.Model_scale(self, state, scaleSet, preserveMassDist, finalMass)

    def printBasicInfo(self, *args) -> "void":
        r"""
        Print some basic information about the model.

        :type aOStream: std::ostream, optional
        :param aOStream: Output stream. If this is std::cout, then the info is
            logged using OpenSim's Logger so that the info is printed to all log
            sinks.
        """
        return _simulation.Model_printBasicInfo(self, *args)

    def printDetailedInfo(self, *args) -> "void":
        r"""
        Print detailed information about the model.

        :type s: :py:class:`State`
        :param s:        the system State.
        :type aOStream: std::ostream, optional
        :param aOStream: Output stream. If this is std::cout, then the info is
            logged using OpenSim's Logger so that the info is printed to all log
            sinks.
        """
        return _simulation.Model_printDetailedInfo(self, *args)

    def disownAllComponents(self) -> "void":
        r"""
        Model relinquishes ownership of all components such as: Bodies, Constraints, Forces,
        ContactGeometry and so on. That means the freeing of the memory of these objects is up
        to the caller. This only affects components stored in the Model's Sets,
        and does not affect those added via Component::addComponent().
        """
        return _simulation.Model_disownAllComponents(self)

    def overrideAllActuators(self, s: "State", flag: "bool") -> "void":
        r"""Convenience function to turn on/off overriding the force for all actuators"""
        return _simulation.Model_overrideAllActuators(self, s, flag)

    def getValidationLog(self) -> "std::string const &":
        r"""Get a log of errors/warnings encountered when loading/constructing the model"""
        return _simulation.Model_getValidationLog(self)

    def appendToValidationLog(self, note: "std::string const &") -> "void":
        r""" Append to the Model's validation log without affecting is current contents"""
        return _simulation.Model_appendToValidationLog(self, note)

    def clearValidationLog(self) -> "void":
        return _simulation.Model_clearValidationLog(self)

    def getObjectByTypeAndName(self, typeString: "std::string const &", nameString: "std::string const &") -> "OpenSim::Object const &":
        r"""
        Utility to get a reference to an Object based on its name and type
        throws an exception if the object was not found.
        names are case sensitive
        :type typeString: string
        :param typeString: the type of object being looked up (Body, Force, Constraint, Coordinate, Joint, Marker, Controller, Frame)
        :type nameString: string
        :param nameString: the name of the object being looked up
        :rtype: :py:class:`Object`
        :return: reference to the object if found or throws an exception.
        """
        return _simulation.Model_getObjectByTypeAndName(self, typeString, nameString)
    __swig_destroy__ = _simulation.delete_Model

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        r""" Override of the default implementation to account for versioning."""
        return _simulation.Model_updateFromXMLNode(self, aNode, versionNumber)

    def extendFinalizeFromProperties(self) -> "void":
        r"""**"""
        return _simulation.Model_extendFinalizeFromProperties(self)

    def extendConnectToModel(self, model: "Model") -> "void":
        return _simulation.Model_extendConnectToModel(self, model)

    def extendAddToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        return _simulation.Model_extendAddToSystem(self, system)

    def extendInitStateFromProperties(self, state: "State") -> "void":
        return _simulation.Model_extendInitStateFromProperties(self, state)

    def extendSetPropertiesFromState(self, state: "State") -> "void":
        r"""
        *
        Given a State, set all default values for this Model to match those
        found in the State.
        """
        return _simulation.Model_extendSetPropertiesFromState(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""*"""
        return _simulation.Model_generateDecorations(self, fixed, hints, state, appendToThis)

    def getFrameList(self) -> "OpenSim::ComponentList< OpenSim::Frame const >":
        return _simulation.Model_getFrameList(self)

    def getBodyList(self) -> "OpenSim::ComponentList< OpenSim::Body const >":
        return _simulation.Model_getBodyList(self)

    def getMuscleList(self) -> "OpenSim::ComponentList< OpenSim::Muscle const >":
        return _simulation.Model_getMuscleList(self)

    def getJointList(self) -> "OpenSim::ComponentList< OpenSim::Joint const >":
        return _simulation.Model_getJointList(self)

    def getActuatorList(self) -> "OpenSim::ComponentList< OpenSim::Actuator const >":
        return _simulation.Model_getActuatorList(self)

    def getModelComponentList(self) -> "OpenSim::ComponentList< OpenSim::ModelComponent const >":
        return _simulation.Model_getModelComponentList(self)

    def getThelen2003MuscleList(self) -> "OpenSim::ComponentList< OpenSim::Thelen2003Muscle const >":
        return _simulation.Model_getThelen2003MuscleList(self)

    def getMillard2012EquilibriumMuscleList(self) -> "OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const >":
        return _simulation.Model_getMillard2012EquilibriumMuscleList(self)

    def __init__(self, *args):
        _simulation.Model_swiginit(self, _simulation.new_Model(*args))

# Register Model in _simulation:
_simulation.Model_swigregister(Model)

def Model_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Model *":
    return _simulation.Model_safeDownCast(obj)

def Model_getClassName() -> "std::string const &":
    return _simulation.Model_getClassName()

class AbstractPathPoint(Point):
    r"""An abstract class implementing a path point interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractPathPoint *":
        return _simulation.AbstractPathPoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.AbstractPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.AbstractPathPoint_getClassName()

    def clone(self) -> "OpenSim::AbstractPathPoint *":
        return _simulation.AbstractPathPoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.AbstractPathPoint_getConcreteClassName(self)
    PropertyIndex_socket_parent_frame = property(_simulation.AbstractPathPoint_PropertyIndex_socket_parent_frame_get, _simulation.AbstractPathPoint_PropertyIndex_socket_parent_frame_set)

    def connectSocket_parent_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.AbstractPathPoint_connectSocket_parent_frame(self, object)
    __swig_destroy__ = _simulation.delete_AbstractPathPoint

    def getLocation(self, s: "State") -> "SimTK::Vec3":
        r"""
        get the relative location of the path point with respect to the body
           it is connected to.
        """
        return _simulation.AbstractPathPoint_getLocation(self, s)

    def getParentFrame(self) -> "OpenSim::PhysicalFrame const &":
        r""" get the parent PhysicalFrame in which the PathPoint is defined"""
        return _simulation.AbstractPathPoint_getParentFrame(self)

    def setParentFrame(self, aFrame: "PhysicalFrame") -> "void":
        r""" set the parent PhysicalFrame in which the PathPoint is defined"""
        return _simulation.AbstractPathPoint_setParentFrame(self, aFrame)

    def getBody(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use getParentFrame() instead to get the PhysicalFrame in which
               this PathPoint is defined.
        """
        return _simulation.AbstractPathPoint_getBody(self)

    def setBody(self, body: "PhysicalFrame") -> "void":
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use setParentFrame() instead.
        """
        return _simulation.AbstractPathPoint_setBody(self, body)

    def getBodyName(self) -> "std::string const &":
        r"""
        **(Deprecated)** Old PathPoint interface.
               Use getParentFrame().getName() instead.
        """
        return _simulation.AbstractPathPoint_getBodyName(self)

    def getWrapObject(self) -> "OpenSim::WrapObject const *":
        return _simulation.AbstractPathPoint_getWrapObject(self)

    def isActive(self, s: "State") -> "bool":
        return _simulation.AbstractPathPoint_isActive(self, s)

    def getdPointdQ(self, s: "State") -> "SimTK::Vec3":
        r"""
        get the partial derivative of the point location in the parent frame
               w.r.t. to the coordinates(Q) and expressed in the parent frame.
        """
        return _simulation.AbstractPathPoint_getdPointdQ(self, s)

    @staticmethod
    def deletePathPoint(aPoint: "AbstractPathPoint") -> "void":
        return _simulation.AbstractPathPoint_deletePathPoint(aPoint)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        r"""
        Update the use of *body* property in previous revisions to the
               parent_frame (Socket) for the path point's dependency on a
               PhysicalFrame.
               Notes: If overriding updateFromXMLNode of derived classes, do not
               forget to invoke Super::updateFromXMLNode to include this update.
        """
        return _simulation.AbstractPathPoint_updateFromXMLNode(self, aNode, versionNumber)

# Register AbstractPathPoint in _simulation:
_simulation.AbstractPathPoint_swigregister(AbstractPathPoint)

def AbstractPathPoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractPathPoint *":
    return _simulation.AbstractPathPoint_safeDownCast(obj)

def AbstractPathPoint_getClassName() -> "std::string const &":
    return _simulation.AbstractPathPoint_getClassName()

def AbstractPathPoint_deletePathPoint(aPoint: "AbstractPathPoint") -> "void":
    return _simulation.AbstractPathPoint_deletePathPoint(aPoint)

class PathPoint(AbstractPathPoint):
    r"""A path point that is stationary with respect to parent's PhysicalFrame"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathPoint *":
        return _simulation.PathPoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathPoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathPoint_getClassName()

    def clone(self) -> "OpenSim::PathPoint *":
        return _simulation.PathPoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathPoint_getConcreteClassName(self)

    def copyProperty_location(self, source: "PathPoint") -> "void":
        return _simulation.PathPoint_copyProperty_location(self, source)

    def append_location(self, value: "Vec3") -> "int":
        return _simulation.PathPoint_append_location(self, value)

    def constructProperty_location(self, initValue: "Vec3") -> "void":
        return _simulation.PathPoint_constructProperty_location(self, initValue)

    def get_location(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PathPoint_get_location(self, *args)

    def upd_location(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PathPoint_upd_location(self, *args)

    def set_location(self, *args) -> "void":
        return _simulation.PathPoint_set_location(self, *args)

    def __init__(self):
        _simulation.PathPoint_swiginit(self, _simulation.new_PathPoint())

    def setLocationCoord(self, s: "State", aXYZ: "int", aValue: "double") -> "void":
        r""" **(Deprecated)** Old PathPoint interface"""
        return _simulation.PathPoint_setLocationCoord(self, s, aXYZ, aValue)

    def getLocation(self, s: "State") -> "SimTK::Vec3":
        return _simulation.PathPoint_getLocation(self, s)

    def setLocation(self, location: "Vec3") -> "void":
        return _simulation.PathPoint_setLocation(self, location)

    def changeBodyPreserveLocation(self, s: "State", body: "PhysicalFrame") -> "void":
        return _simulation.PathPoint_changeBodyPreserveLocation(self, s, body)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.PathPoint_extendScale(self, s, scaleSet)

    def getdPointdQ(self, s: "State") -> "SimTK::Vec3":
        return _simulation.PathPoint_getdPointdQ(self, s)
    __swig_destroy__ = _simulation.delete_PathPoint

# Register PathPoint in _simulation:
_simulation.PathPoint_swigregister(PathPoint)

def PathPoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathPoint *":
    return _simulation.PathPoint_safeDownCast(obj)

def PathPoint_getClassName() -> "std::string const &":
    return _simulation.PathPoint_getClassName()

class PathWrapPoint(AbstractPathPoint):
    r"""
    A class implementing a path wrapping point, which is a path point that
    is produced by a PathWrap.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrapPoint *":
        return _simulation.PathWrapPoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathWrapPoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathWrapPoint_getClassName()

    def clone(self) -> "OpenSim::PathWrapPoint *":
        return _simulation.PathWrapPoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathWrapPoint_getConcreteClassName(self)

    def extendAddToSystem(self, arg2: "SimTK::MultibodySystem &") -> "void":
        return _simulation.PathWrapPoint_extendAddToSystem(self, arg2)

    def getWrapObject(self) -> "OpenSim::WrapObject const *":
        return _simulation.PathWrapPoint_getWrapObject(self)

    def setWrapObject(self, arg2: "WrapObject") -> "void":
        return _simulation.PathWrapPoint_setWrapObject(self, arg2)

    def getWrapPath(self, arg2: "State") -> "OpenSim::Array< SimTK::Vec3 > const &":
        return _simulation.PathWrapPoint_getWrapPath(self, arg2)

    def setWrapPath(self, arg2: "State", arg3: "ArrayVec3") -> "void":
        return _simulation.PathWrapPoint_setWrapPath(self, arg2, arg3)

    def clearWrapPath(self, arg2: "State") -> "void":
        return _simulation.PathWrapPoint_clearWrapPath(self, arg2)

    def getWrapLength(self, arg2: "State") -> "double":
        return _simulation.PathWrapPoint_getWrapLength(self, arg2)

    def setWrapLength(self, arg2: "State", newLength: "double") -> "void":
        return _simulation.PathWrapPoint_setWrapLength(self, arg2, newLength)

    def getLocation(self, arg2: "State") -> "SimTK::Vec3":
        return _simulation.PathWrapPoint_getLocation(self, arg2)

    def setLocation(self, arg2: "State", arg3: "Vec3") -> "void":
        return _simulation.PathWrapPoint_setLocation(self, arg2, arg3)

    def getdPointdQ(self, arg2: "State") -> "SimTK::Vec3":
        return _simulation.PathWrapPoint_getdPointdQ(self, arg2)

    def __init__(self):
        _simulation.PathWrapPoint_swiginit(self, _simulation.new_PathWrapPoint())
    __swig_destroy__ = _simulation.delete_PathWrapPoint

# Register PathWrapPoint in _simulation:
_simulation.PathWrapPoint_swigregister(PathWrapPoint)

def PathWrapPoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathWrapPoint *":
    return _simulation.PathWrapPoint_safeDownCast(obj)

def PathWrapPoint_getClassName() -> "std::string const &":
    return _simulation.PathWrapPoint_getClassName()

class ConditionalPathPoint(PathPoint):
    r"""
    A class implementing a conditional path point, which is a point that
    is active only for a specified range of a coordinate.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConditionalPathPoint *":
        return _simulation.ConditionalPathPoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ConditionalPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ConditionalPathPoint_getClassName()

    def clone(self) -> "OpenSim::ConditionalPathPoint *":
        return _simulation.ConditionalPathPoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ConditionalPathPoint_getConcreteClassName(self)

    def copyProperty_range(self, source: "ConditionalPathPoint") -> "void":
        return _simulation.ConditionalPathPoint_copyProperty_range(self, source)

    def get_range(self, i: "int") -> "double const &":
        return _simulation.ConditionalPathPoint_get_range(self, i)

    def upd_range(self, i: "int") -> "double &":
        return _simulation.ConditionalPathPoint_upd_range(self, i)

    def set_range(self, i: "int", value: "double const &") -> "void":
        return _simulation.ConditionalPathPoint_set_range(self, i, value)

    def append_range(self, value: "double const &") -> "int":
        return _simulation.ConditionalPathPoint_append_range(self, value)
    PropertyIndex_socket_coordinate = property(_simulation.ConditionalPathPoint_PropertyIndex_socket_coordinate_get, _simulation.ConditionalPathPoint_PropertyIndex_socket_coordinate_set)

    def connectSocket_coordinate(self, object: "OpenSimObject") -> "void":
        return _simulation.ConditionalPathPoint_connectSocket_coordinate(self, object)

    def __init__(self):
        _simulation.ConditionalPathPoint_swiginit(self, _simulation.new_ConditionalPathPoint())
    __swig_destroy__ = _simulation.delete_ConditionalPathPoint

    def setRangeMin(self, minVal: "double") -> "void":
        return _simulation.ConditionalPathPoint_setRangeMin(self, minVal)

    def setRangeMax(self, maxVal: "double") -> "void":
        return _simulation.ConditionalPathPoint_setRangeMax(self, maxVal)

    def setCoordinate(self, coordinate: "Coordinate") -> "void":
        return _simulation.ConditionalPathPoint_setCoordinate(self, coordinate)

    def hasCoordinate(self) -> "bool":
        return _simulation.ConditionalPathPoint_hasCoordinate(self)

    def getCoordinate(self) -> "OpenSim::Coordinate const &":
        return _simulation.ConditionalPathPoint_getCoordinate(self)

    def isActive(self, s: "State") -> "bool":
        return _simulation.ConditionalPathPoint_isActive(self, s)

# Register ConditionalPathPoint in _simulation:
_simulation.ConditionalPathPoint_swigregister(ConditionalPathPoint)

def ConditionalPathPoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConditionalPathPoint *":
    return _simulation.ConditionalPathPoint_safeDownCast(obj)

def ConditionalPathPoint_getClassName() -> "std::string const &":
    return _simulation.ConditionalPathPoint_getClassName()

class MovingPathPoint(AbstractPathPoint):
    r"""
    A class implementing a moving muscle point, which is a muscle point that
    moves in a body's reference frame as a function of a coordinate.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MovingPathPoint *":
        return _simulation.MovingPathPoint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MovingPathPoint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MovingPathPoint_getClassName()

    def clone(self) -> "OpenSim::MovingPathPoint *":
        return _simulation.MovingPathPoint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MovingPathPoint_getConcreteClassName(self)

    def copyProperty_x_location(self, source: "MovingPathPoint") -> "void":
        return _simulation.MovingPathPoint_copyProperty_x_location(self, source)

    def append_x_location(self, value: "Function") -> "int":
        return _simulation.MovingPathPoint_append_x_location(self, value)

    def constructProperty_x_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_constructProperty_x_location(self, *args)

    def get_x_location(self, *args) -> "OpenSim::Function const &":
        return _simulation.MovingPathPoint_get_x_location(self, *args)

    def upd_x_location(self, *args) -> "OpenSim::Function &":
        return _simulation.MovingPathPoint_upd_x_location(self, *args)

    def set_x_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_set_x_location(self, *args)

    def copyProperty_y_location(self, source: "MovingPathPoint") -> "void":
        return _simulation.MovingPathPoint_copyProperty_y_location(self, source)

    def append_y_location(self, value: "Function") -> "int":
        return _simulation.MovingPathPoint_append_y_location(self, value)

    def constructProperty_y_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_constructProperty_y_location(self, *args)

    def get_y_location(self, *args) -> "OpenSim::Function const &":
        return _simulation.MovingPathPoint_get_y_location(self, *args)

    def upd_y_location(self, *args) -> "OpenSim::Function &":
        return _simulation.MovingPathPoint_upd_y_location(self, *args)

    def set_y_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_set_y_location(self, *args)

    def copyProperty_z_location(self, source: "MovingPathPoint") -> "void":
        return _simulation.MovingPathPoint_copyProperty_z_location(self, source)

    def append_z_location(self, value: "Function") -> "int":
        return _simulation.MovingPathPoint_append_z_location(self, value)

    def constructProperty_z_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_constructProperty_z_location(self, *args)

    def get_z_location(self, *args) -> "OpenSim::Function const &":
        return _simulation.MovingPathPoint_get_z_location(self, *args)

    def upd_z_location(self, *args) -> "OpenSim::Function &":
        return _simulation.MovingPathPoint_upd_z_location(self, *args)

    def set_z_location(self, *args) -> "void":
        return _simulation.MovingPathPoint_set_z_location(self, *args)
    PropertyIndex_socket_x_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_x_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_x_coordinate_set)

    def connectSocket_x_coordinate(self, object: "OpenSimObject") -> "void":
        return _simulation.MovingPathPoint_connectSocket_x_coordinate(self, object)
    PropertyIndex_socket_y_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_y_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_y_coordinate_set)

    def connectSocket_y_coordinate(self, object: "OpenSimObject") -> "void":
        return _simulation.MovingPathPoint_connectSocket_y_coordinate(self, object)
    PropertyIndex_socket_z_coordinate = property(_simulation.MovingPathPoint_PropertyIndex_socket_z_coordinate_get, _simulation.MovingPathPoint_PropertyIndex_socket_z_coordinate_set)

    def connectSocket_z_coordinate(self, object: "OpenSimObject") -> "void":
        return _simulation.MovingPathPoint_connectSocket_z_coordinate(self, object)

    def __init__(self):
        _simulation.MovingPathPoint_swiginit(self, _simulation.new_MovingPathPoint())
    __swig_destroy__ = _simulation.delete_MovingPathPoint

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        return _simulation.MovingPathPoint_updateFromXMLNode(self, aNode, versionNumber)

    def hasXCoordinate(self) -> "bool":
        return _simulation.MovingPathPoint_hasXCoordinate(self)

    def hasYCoordinate(self) -> "bool":
        return _simulation.MovingPathPoint_hasYCoordinate(self)

    def hasZCoordinate(self) -> "bool":
        return _simulation.MovingPathPoint_hasZCoordinate(self)

    def getXCoordinate(self) -> "OpenSim::Coordinate const &":
        return _simulation.MovingPathPoint_getXCoordinate(self)

    def getYCoordinate(self) -> "OpenSim::Coordinate const &":
        return _simulation.MovingPathPoint_getYCoordinate(self)

    def getZCoordinate(self) -> "OpenSim::Coordinate const &":
        return _simulation.MovingPathPoint_getZCoordinate(self)

    def setXCoordinate(self, coordinate: "Coordinate") -> "void":
        return _simulation.MovingPathPoint_setXCoordinate(self, coordinate)

    def setYCoordinate(self, coordinate: "Coordinate") -> "void":
        return _simulation.MovingPathPoint_setYCoordinate(self, coordinate)

    def setZCoordinate(self, coordinate: "Coordinate") -> "void":
        return _simulation.MovingPathPoint_setZCoordinate(self, coordinate)

    def isActive(self, s: "State") -> "bool":
        return _simulation.MovingPathPoint_isActive(self, s)

    def getLocation(self, s: "State") -> "SimTK::Vec3":
        r""" Get the local location of the MovingPathPoint in its Frame"""
        return _simulation.MovingPathPoint_getLocation(self, s)

    def getVelocity(self, s: "State") -> "SimTK::Vec3":
        r"""
        Get the local velocity of the MovingPathPoint w.r.t to and
               expressed in its Frame. To get the velocity of the point w.r.t.
               and expressed in Ground, call getVelocityInGround().
        """
        return _simulation.MovingPathPoint_getVelocity(self, s)

    def getdPointdQ(self, s: "State") -> "SimTK::Vec3":
        return _simulation.MovingPathPoint_getdPointdQ(self, s)

    def extendScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Scale the underlying MultiplierFunctions associated with the
               MovingPathPoint.
        """
        return _simulation.MovingPathPoint_extendScale(self, s, scaleSet)

# Register MovingPathPoint in _simulation:
_simulation.MovingPathPoint_swigregister(MovingPathPoint)

def MovingPathPoint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MovingPathPoint *":
    return _simulation.MovingPathPoint_safeDownCast(obj)

def MovingPathPoint_getClassName() -> "std::string const &":
    return _simulation.MovingPathPoint_getClassName()

class SetOfPathPoints(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::AbstractPathPoint > *":
        return _simulation.SetOfPathPoints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetOfPathPoints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetOfPathPoints_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::AbstractPathPoint > *":
        return _simulation.SetOfPathPoints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetOfPathPoints_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetOfPathPoints

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::AbstractPathPoint,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetOfPathPoints_swiginit(self, _simulation.new_SetOfPathPoints(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetOfPathPoints_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetOfPathPoints_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetOfPathPoints_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetOfPathPoints_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetOfPathPoints_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetOfPathPoints_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "AbstractPathPoint") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "AbstractPathPoint") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "AbstractPathPoint") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetOfPathPoints_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "AbstractPathPoint", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`AbstractPathPoint`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetOfPathPoints_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::AbstractPathPoint &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`AbstractPathPoint`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`AbstractPathPoint`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetOfPathPoints_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetOfPathPoints_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetOfPathPoints_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetOfPathPoints_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetOfPathPoints_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetOfPathPoints_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetOfPathPoints_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetOfPathPoints_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetOfPathPoints_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetOfPathPoints_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetOfPathPoints in _simulation:
_simulation.SetOfPathPoints_swigregister(SetOfPathPoints)

def SetOfPathPoints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::AbstractPathPoint > *":
    return _simulation.SetOfPathPoints_safeDownCast(obj)

def SetOfPathPoints_getClassName() -> "std::string const &":
    return _simulation.SetOfPathPoints_getClassName()

class ArrayPathPoint(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ArrayPathPoint

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`AbstractPathPoint`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::AbstractPathPoint * >
        :param aArray: Array to be copied.
        """
        _simulation.ArrayPathPoint_swiginit(self, _simulation.new_ArrayPathPoint(*args))

    def arrayEquals(self, aArray: "ArrayPathPoint") -> "bool":
        return _simulation.ArrayPathPoint_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _simulation.ArrayPathPoint_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _simulation.ArrayPathPoint_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.ArrayPathPoint_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _simulation.ArrayPathPoint_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::AbstractPathPoint * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _simulation.ArrayPathPoint_append(self, *args)

    def insert(self, aIndex: "int", aValue: "AbstractPathPoint") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _simulation.ArrayPathPoint_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _simulation.ArrayPathPoint_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "AbstractPathPoint") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value.
        """
        return _simulation.ArrayPathPoint_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::AbstractPathPoint *const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`AbstractPathPoint`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _simulation.ArrayPathPoint_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::AbstractPathPoint *":
        return _simulation.ArrayPathPoint_getitem(self, index)

    def setitem(self, index: "int", val: "AbstractPathPoint") -> "void":
        return _simulation.ArrayPathPoint_setitem(self, index, val)

    def getLast(self) -> "OpenSim::AbstractPathPoint *const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`AbstractPathPoint`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.ArrayPathPoint_getLast(self)

    def findIndex(self, aValue: "AbstractPathPoint") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPathPoint_findIndex(self, aValue)

    def rfindIndex(self, aValue: "AbstractPathPoint") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPathPoint_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "AbstractPathPoint", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`AbstractPathPoint`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _simulation.ArrayPathPoint_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayPathPoint in _simulation:
_simulation.ArrayPathPoint_swigregister(ArrayPathPoint)

class PathPointSet(SetOfPathPoints):
    r"""
    A class for holding a set of path points.
    Notes: the Set contains any path point that derives from AbstractPathPoint

    Authors: Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathPointSet *":
        return _simulation.PathPointSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathPointSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathPointSet_getClassName()

    def clone(self) -> "OpenSim::PathPointSet *":
        return _simulation.PathPointSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathPointSet_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.PathPointSet_swiginit(self, _simulation.new_PathPointSet(*args))

    def adoptAndAppend(self, aPathPoint):
        aPathPoint._markAdopted()
        return super(PathPointSet, self).adoptAndAppend(aPathPoint)

    __swig_destroy__ = _simulation.delete_PathPointSet

# Register PathPointSet in _simulation:
_simulation.PathPointSet_swigregister(PathPointSet)

def PathPointSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathPointSet *":
    return _simulation.PathPointSet_safeDownCast(obj)

def PathPointSet_getClassName() -> "std::string const &":
    return _simulation.PathPointSet_getClassName()

class PointForceDirection(object):
    r"""
     Convenience class for a generic representation of geometry of a complex
        Force (or any other object) with multiple points of contact through
        which forces are applied to bodies. This represents one such point and an
        array of these objects defines a complete Force distribution (ie. path).

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_PointForceDirection

    def __init__(self, point: "Vec3", frame: "PhysicalFrame", direction: "Vec3", scale: "double"=1):
        r"""
        Default constructor takes the point, body, direction and scale
               as arguments
        """
        _simulation.PointForceDirection_swiginit(self, _simulation.new_PointForceDirection(point, frame, direction, scale))

    def point(self) -> "SimTK::Vec3":
        r""" get point of "contact" with on a body defined in the body frame"""
        return _simulation.PointForceDirection_point(self)

    def frame(self) -> "OpenSim::PhysicalFrame const &":
        r""" get the body in which the point is defined"""
        return _simulation.PointForceDirection_frame(self)

    def direction(self) -> "SimTK::Vec3":
        r""" get direction of the force at the point defined in ground"""
        return _simulation.PointForceDirection_direction(self)

    def scale(self) -> "double":
        r""" get the scale factor on the force"""
        return _simulation.PointForceDirection_scale(self)

    def addToDirection(self, newDirection: "Vec3") -> "void":
        r""" replace the current direction with the resultant with a new direction"""
        return _simulation.PointForceDirection_addToDirection(self, newDirection)

# Register PointForceDirection in _simulation:
_simulation.PointForceDirection_swigregister(PointForceDirection)

class ArrayPointForceDirection(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_ArrayPointForceDirection

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`PointForceDirection`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::PointForceDirection * >
        :param aArray: Array to be copied.
        """
        _simulation.ArrayPointForceDirection_swiginit(self, _simulation.new_ArrayPointForceDirection(*args))

    def arrayEquals(self, aArray: "ArrayPointForceDirection") -> "bool":
        return _simulation.ArrayPointForceDirection_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _simulation.ArrayPointForceDirection_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _simulation.ArrayPointForceDirection_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.ArrayPointForceDirection_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _simulation.ArrayPointForceDirection_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::PointForceDirection * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _simulation.ArrayPointForceDirection_append(self, *args)

    def insert(self, aIndex: "int", aValue: "PointForceDirection") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _simulation.ArrayPointForceDirection_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _simulation.ArrayPointForceDirection_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "PointForceDirection") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value.
        """
        return _simulation.ArrayPointForceDirection_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::PointForceDirection *const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`PointForceDirection`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _simulation.ArrayPointForceDirection_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::PointForceDirection *":
        return _simulation.ArrayPointForceDirection_getitem(self, index)

    def setitem(self, index: "int", val: "PointForceDirection") -> "void":
        return _simulation.ArrayPointForceDirection_setitem(self, index, val)

    def getLast(self) -> "OpenSim::PointForceDirection *const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`PointForceDirection`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _simulation.ArrayPointForceDirection_getLast(self)

    def findIndex(self, aValue: "PointForceDirection") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_findIndex(self, aValue)

    def rfindIndex(self, aValue: "PointForceDirection") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "PointForceDirection", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`PointForceDirection`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _simulation.ArrayPointForceDirection_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayPointForceDirection in _simulation:
_simulation.ArrayPointForceDirection_swigregister(ArrayPointForceDirection)

class GeometryPath(ModelComponent):
    r"""
    A base class representing a path (muscle, ligament, etc.).

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::GeometryPath *":
        return _simulation.GeometryPath_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.GeometryPath_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.GeometryPath_getClassName()

    def clone(self) -> "OpenSim::GeometryPath *":
        return _simulation.GeometryPath_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.GeometryPath_getConcreteClassName(self)

    def copyProperty_Appearance(self, source: "GeometryPath") -> "void":
        return _simulation.GeometryPath_copyProperty_Appearance(self, source)

    def append_Appearance(self, value: "Appearance") -> "int":
        return _simulation.GeometryPath_append_Appearance(self, value)

    def constructProperty_Appearance(self, initValue: "Appearance") -> "void":
        return _simulation.GeometryPath_constructProperty_Appearance(self, initValue)

    def get_Appearance(self, *args) -> "OpenSim::Appearance const &":
        return _simulation.GeometryPath_get_Appearance(self, *args)

    def upd_Appearance(self, *args) -> "OpenSim::Appearance &":
        return _simulation.GeometryPath_upd_Appearance(self, *args)

    def set_Appearance(self, *args) -> "void":
        return _simulation.GeometryPath_set_Appearance(self, *args)

    def __init__(self):
        _simulation.GeometryPath_swiginit(self, _simulation.new_GeometryPath())
    __swig_destroy__ = _simulation.delete_GeometryPath

    def getPathPointSet(self) -> "OpenSim::PathPointSet const &":
        return _simulation.GeometryPath_getPathPointSet(self)

    def updPathPointSet(self) -> "OpenSim::PathPointSet &":
        return _simulation.GeometryPath_updPathPointSet(self)

    def getWrapSet(self) -> "OpenSim::PathWrapSet const &":
        return _simulation.GeometryPath_getWrapSet(self)

    def updWrapSet(self) -> "OpenSim::PathWrapSet &":
        return _simulation.GeometryPath_updWrapSet(self)

    def addPathWrap(self, aWrapObject: "WrapObject") -> "void":
        return _simulation.GeometryPath_addPathWrap(self, aWrapObject)

    def addPathPoint(self, s: "State", index: "int", frame: "PhysicalFrame") -> "OpenSim::AbstractPathPoint *":
        return _simulation.GeometryPath_addPathPoint(self, s, index, frame)

    def appendNewPathPoint(self, proposedName: "std::string const &", frame: "PhysicalFrame", locationOnFrame: "Vec3") -> "OpenSim::AbstractPathPoint *":
        return _simulation.GeometryPath_appendNewPathPoint(self, proposedName, frame, locationOnFrame)

    def canDeletePathPoint(self, index: "int") -> "bool":
        return _simulation.GeometryPath_canDeletePathPoint(self, index)

    def deletePathPoint(self, s: "State", index: "int") -> "bool":
        return _simulation.GeometryPath_deletePathPoint(self, s, index)

    def moveUpPathWrap(self, s: "State", index: "int") -> "void":
        return _simulation.GeometryPath_moveUpPathWrap(self, s, index)

    def moveDownPathWrap(self, s: "State", index: "int") -> "void":
        return _simulation.GeometryPath_moveDownPathWrap(self, s, index)

    def deletePathWrap(self, s: "State", index: "int") -> "void":
        return _simulation.GeometryPath_deletePathWrap(self, s, index)

    def replacePathPoint(self, s: "State", oldPathPoint: "AbstractPathPoint", newPathPoint: "AbstractPathPoint") -> "bool":
        return _simulation.GeometryPath_replacePathPoint(self, s, oldPathPoint, newPathPoint)

    def setDefaultColor(self, color: "Vec3") -> "void":
        r"""
        If you call this prior to extendAddToSystem() it will be used to initialize
           the color cache variable. Otherwise %GeometryPath will choose its own
           default which varies depending on owner. *
        """
        return _simulation.GeometryPath_setDefaultColor(self, color)

    def getDefaultColor(self) -> "SimTK::Vec3 const &":
        r"""
        Returns the color that will be used to initialize the color cache
           at the next extendAddToSystem() call. The actual color used to draw the path
           will be taken from the cache variable, so may have changed. *
        """
        return _simulation.GeometryPath_getDefaultColor(self)

    def setColor(self, s: "State", color: "Vec3") -> "void":
        r"""
        %Set the value of the color cache variable owned by this %GeometryPath
           object, in the cache of the given state. The value of this variable is used
           as the color when the path is drawn, which occurs with the state realized
           to Stage::Dynamics. So you must call this method during realizeDynamics() or
           earlier in order for it to have any effect. *
        """
        return _simulation.GeometryPath_setColor(self, s, color)

    def getColor(self, s: "State") -> "SimTK::Vec3":
        r"""
        Get the current value of the color cache entry owned by this
           %GeometryPath object in the given state. You can access this value any time
           after the state is initialized, at which point it will have been set to
           the default color value specified in a call to setDefaultColor() earlier,
           or it will have the default color value chosen by %GeometryPath.
           See also: setDefaultColor() *
        """
        return _simulation.GeometryPath_getColor(self, s)

    def getLength(self, s: "State") -> "double":
        return _simulation.GeometryPath_getLength(self, s)

    def setLength(self, s: "State", length: "double") -> "void":
        return _simulation.GeometryPath_setLength(self, s, length)

    def getPreScaleLength(self, s: "State") -> "double":
        return _simulation.GeometryPath_getPreScaleLength(self, s)

    def setPreScaleLength(self, s: "State", preScaleLength: "double") -> "void":
        return _simulation.GeometryPath_setPreScaleLength(self, s, preScaleLength)

    def getCurrentPath(self, s: "State") -> "OpenSim::Array< OpenSim::AbstractPathPoint * > const &":
        return _simulation.GeometryPath_getCurrentPath(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        return _simulation.GeometryPath_getLengtheningSpeed(self, s)

    def setLengtheningSpeed(self, s: "State", speed: "double") -> "void":
        return _simulation.GeometryPath_setLengtheningSpeed(self, s, speed)

    def getPointForceDirections(self, s: "State", rPFDs: "ArrayPointForceDirection") -> "void":
        r"""
        get the path as PointForceDirections directions, which can be used
               to apply tension to bodies the points are connected to.
        """
        return _simulation.GeometryPath_getPointForceDirections(self, s, rPFDs)

    def addInEquivalentForces(self, state: "State", tension: "double const &", bodyForces: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        r"""
        add in the equivalent body and generalized forces to be applied to the
               multibody system resulting from a tension along the GeometryPath
           :type state: :py:class:`State`
           :param state:    state used to evaluate forces
           :type tension: float, in
           :param tension:      scalar (double) of the applied (+ve) tensile force
           :type bodyForces: SimTK::Vector_< SimTK::SpatialVec >, in/out
           :param bodyForces:   Vector of SpatialVec's (torque, force) on bodies
           :type mobilityForces: :py:class:`Vector`, in/out
           :param mobilityForces:  Vector of generalized forces, one per mobility
        """
        return _simulation.GeometryPath_addInEquivalentForces(self, state, tension, bodyForces, mobilityForces)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.GeometryPath_computeMomentArm(self, s, aCoord)

    def extendPreScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Calculate the path length in the current body position and store it for
               use after the Model has been scaled.
        """
        return _simulation.GeometryPath_extendPreScale(self, s, scaleSet)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r""" Recalculate the path after the Model has been scaled."""
        return _simulation.GeometryPath_extendPostScale(self, s, scaleSet)

    def updateGeometry(self, s: "State") -> "void":
        return _simulation.GeometryPath_updateGeometry(self, s)

# Register GeometryPath in _simulation:
_simulation.GeometryPath_swigregister(GeometryPath)

def GeometryPath_safeDownCast(obj: "OpenSimObject") -> "OpenSim::GeometryPath *":
    return _simulation.GeometryPath_safeDownCast(obj)

def GeometryPath_getClassName() -> "std::string const &":
    return _simulation.GeometryPath_getClassName()

class Ligament(Force):
    r"""
    A class implementing a ligament. The path of the ligament is
    stored in a GeometryPath object.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ligament *":
        return _simulation.Ligament_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Ligament_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Ligament_getClassName()

    def clone(self) -> "OpenSim::Ligament *":
        return _simulation.Ligament_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Ligament_getConcreteClassName(self)

    def copyProperty_GeometryPath(self, source: "Ligament") -> "void":
        return _simulation.Ligament_copyProperty_GeometryPath(self, source)

    def append_GeometryPath(self, value: "GeometryPath") -> "int":
        return _simulation.Ligament_append_GeometryPath(self, value)

    def constructProperty_GeometryPath(self, initValue: "GeometryPath") -> "void":
        return _simulation.Ligament_constructProperty_GeometryPath(self, initValue)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.Ligament_get_GeometryPath(self, *args)

    def upd_GeometryPath(self, *args) -> "OpenSim::GeometryPath &":
        return _simulation.Ligament_upd_GeometryPath(self, *args)

    def set_GeometryPath(self, *args) -> "void":
        return _simulation.Ligament_set_GeometryPath(self, *args)

    def copyProperty_resting_length(self, source: "Ligament") -> "void":
        return _simulation.Ligament_copyProperty_resting_length(self, source)

    def append_resting_length(self, value: "double const &") -> "int":
        return _simulation.Ligament_append_resting_length(self, value)

    def constructProperty_resting_length(self, initValue: "double const &") -> "void":
        return _simulation.Ligament_constructProperty_resting_length(self, initValue)

    def get_resting_length(self, *args) -> "double const &":
        return _simulation.Ligament_get_resting_length(self, *args)

    def upd_resting_length(self, *args) -> "double &":
        return _simulation.Ligament_upd_resting_length(self, *args)

    def set_resting_length(self, *args) -> "void":
        return _simulation.Ligament_set_resting_length(self, *args)

    def copyProperty_pcsa_force(self, source: "Ligament") -> "void":
        return _simulation.Ligament_copyProperty_pcsa_force(self, source)

    def append_pcsa_force(self, value: "double const &") -> "int":
        return _simulation.Ligament_append_pcsa_force(self, value)

    def constructProperty_pcsa_force(self, initValue: "double const &") -> "void":
        return _simulation.Ligament_constructProperty_pcsa_force(self, initValue)

    def get_pcsa_force(self, *args) -> "double const &":
        return _simulation.Ligament_get_pcsa_force(self, *args)

    def upd_pcsa_force(self, *args) -> "double &":
        return _simulation.Ligament_upd_pcsa_force(self, *args)

    def set_pcsa_force(self, *args) -> "void":
        return _simulation.Ligament_set_pcsa_force(self, *args)

    def copyProperty_force_length_curve(self, source: "Ligament") -> "void":
        return _simulation.Ligament_copyProperty_force_length_curve(self, source)

    def append_force_length_curve(self, value: "Function") -> "int":
        return _simulation.Ligament_append_force_length_curve(self, value)

    def constructProperty_force_length_curve(self, initValue: "Function") -> "void":
        return _simulation.Ligament_constructProperty_force_length_curve(self, initValue)

    def get_force_length_curve(self, *args) -> "OpenSim::Function const &":
        return _simulation.Ligament_get_force_length_curve(self, *args)

    def upd_force_length_curve(self, *args) -> "OpenSim::Function &":
        return _simulation.Ligament_upd_force_length_curve(self, *args)

    def set_force_length_curve(self, *args) -> "void":
        return _simulation.Ligament_set_force_length_curve(self, *args)

    def __init__(self):
        _simulation.Ligament_swiginit(self, _simulation.new_Ligament())

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        return _simulation.Ligament_getGeometryPath(self)

    def updGeometryPath(self) -> "OpenSim::GeometryPath &":
        return _simulation.Ligament_updGeometryPath(self)

    def hasGeometryPath(self) -> "bool":
        return _simulation.Ligament_hasGeometryPath(self)

    def getLength(self, s: "State") -> "double":
        return _simulation.Ligament_getLength(self, s)

    def getRestingLength(self) -> "double":
        return _simulation.Ligament_getRestingLength(self)

    def setRestingLength(self, aRestingLength: "double") -> "bool":
        return _simulation.Ligament_setRestingLength(self, aRestingLength)

    def getMaxIsometricForce(self) -> "double":
        return _simulation.Ligament_getMaxIsometricForce(self)

    def setMaxIsometricForce(self, aMaxIsometricForce: "double") -> "bool":
        return _simulation.Ligament_setMaxIsometricForce(self, aMaxIsometricForce)

    def getForceLengthCurve(self) -> "OpenSim::Function const &":
        return _simulation.Ligament_getForceLengthCurve(self)

    def setForceLengthCurve(self, aForceLengthCurve: "Function") -> "bool":
        return _simulation.Ligament_setForceLengthCurve(self, aForceLengthCurve)

    def getTension(self, s: "State") -> "double const &":
        return _simulation.Ligament_getTension(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.Ligament_computeMomentArm(self, s, aCoord)

    def computeForce(self, s: "State", bodyForces: "VectorOfSpatialVec", generalizedForces: "Vector") -> "void":
        return _simulation.Ligament_computeForce(self, s, bodyForces, generalizedForces)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Adjust the resting length of the ligament after the model has been
               scaled. The `resting_length` property is multiplied by the quotient of
               the current path length and the path length before scaling.
        """
        return _simulation.Ligament_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_Ligament

# Register Ligament in _simulation:
_simulation.Ligament_swigregister(Ligament)

def Ligament_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Ligament *":
    return _simulation.Ligament_safeDownCast(obj)

def Ligament_getClassName() -> "std::string const &":
    return _simulation.Ligament_getClassName()

class Blankevoort1991Ligament(Force):
    r"""
    This class implements a nonlinear spring ligament model introduced by
    Blankevoort et al.\ (1991) [1] and further described in Smith et al.\ (2016)
    [2]. This model is partially based on the formulation orginally proposed by
    Wismans et al.\ (1980) [3]. The ligament is represented as a passive spring
    with the force-strain relationship described by a quadratic "toe" region at
    low strains and a linear region at high strains. The toe region represents the
    uncrimping and alignment of collagen fibers and the linear region represents
    the subsequent stretching of the aligned fibers. The ligament model also
    includes a damping force that is only applied if the ligament is stretched
    beyond the slack length and if the ligament is lengthening.
    The length of the ligament is :math:`l`.

    Image: fig_Blankevoort1991Ligament.png(width=400px)

    **Governing Equations**

    Spring %Force:

    .. math::

        F_{\mathrm{spring}} =
            \begin{Bmatrix}
            0 & \epsilon < 0 \\
            \frac{1}{2\epsilon_t }k\epsilon^2 & 0 \leq \epsilon \leq \epsilon_t \\
             k(\epsilon - \frac{\epsilon_t}{2})& \epsilon > \epsilon_t
            \end{Bmatrix}

    Damping %Force:

    .. math::

        F_{\mathrm{damping}} = 
            \begin{Bmatrix} 
            c\cdot \dot{\epsilon} & \epsilon > 0 \: and \: \dot{\epsilon} > 0 \\
            0 & otherwise
            \end{Bmatrix}

    Total %Force:

    .. math::

        F_{\mathrm{total}} = F_{\mathrm{spring}} + F_{\mathrm{damping}}

    This Force component has the following properties:

    - linear stiffness (k): The force/strain (e.g. N) stiffness of the linear
    region of the ligament model.

    - slack_length (_0:math:`): The resting length of the ligament (e.g. m).- damping coefficient (c): Damping coefficient used in the dampingforce calculation in units of force*time/strain (e.g. N*s/strain). The default value is 0.003.- transition_strain (`_t:math:`): The strain value where the ligamentmodel transitions from the quadratic toe region to the linear stiffness region.The default value is 0.06 (6%) according to Blankevoort (1991) [1].This value is widely used in the multibody knee modeling literature [2,4,5,6]and also agrees with some experimental studies [7]. However, other literaturesuggests the transition strain of ligaments occurs at around 0.03 (3%) strain[8,9]. In reality, the transition strain is likely dependent on the strainrate [10,11], however this effect is not included in this implementation.The Blankevoort1991Ligament implementation is intended to be compatible with common methods in the literature for parameterizing ligament properties. The zero-load length of the ligament is parameterized by theslack_length property, which can be set directly, in meters, usingset_slack_length(), or using setSlackLengthFromReferenceStrain() andsetSlackLengthFromReferenceForce(). Here, reference strain and referenceforce are the strain or force in the ligament at a reference pose (state). Ifyou want to compute the strain or force of the ligament in a given pose (state), you can use the getStrain() and getForce() methods. Thelinear_stiffness property has units of force/strain (newton) but can be set and obtained in units of force/length (newton/meter) usingsetLinearStiffnessForcePerLength() and getLinearStiffnessForcePerLength().When scaling a model (using the ScaleTool) that contains a Blankevoort1991Ligament, the slack_length property is scaled by the ratio of the entire GeometryPath length in the default model pose before and after scaling the bone geometries. This ensures that the strain in the ligament in the default pose is equivilent before and after scaling. Thus, it is important to consider the order of scaling the model and setting the slack_length property for your specific application. The linear_stiffness property is not affected by scaling the model. ### References[1] Blankevoort, L. and Huiskes, R., (1991).    Ligament-bone interaction in a three-dimensional model of the knee.    J Biomech Eng, 113(3), 263-269[2] Smith, C.R., Lenhart, R.L., Kaiser, J., Vignos, M.F. and Thelen, D.G.,    (2016). Influence of ligament properties on tibiofemoral mechanics    in walking. J Knee Surg, 29(02), 99-106.[3] Wismans, J.A.C., Veldpaus, F., Janssen, J., Huson, A. and Struben, P.,    (1980). A three-dimensional mathematical model of the knee-joint.    J Biomech, 13(8), 677-685.[4] Marra, M. A., Vanheule, V., Fluit, R., Koopman, B. H., Rasmussen, J.,    Verdonschot, N., & Andersen, M. S. (2015). A subject-specific    musculoskeletal modeling framework to predict in vivo mechanics of total    knee arthroplasty. Journal of biomechanical engineering, 137(2), 020904.[5] Guess, T. M., Razu, S., & Jahandar, H. (2016). Evaluation of knee ligament    mechanics using computational models. The journal of knee surgery, 29(02),    126-137.[6] Li, G., Gil, J., Kanamori, A., & Woo, S. Y. (1999). A validated    three-dimensional computational model of a human knee joint. Journal of    biomechanical engineering, 121(6), 657-662.[7] Ristaniemi, A., Stenroth, L., Mikkonen, S., & Korhonen, R. K. (2018).    Comparison of elastic, viscoelastic and failure tensile material properties    of knee ligaments and patellar tendon. Journal of biomechanics, 79, 31-38.[8] Weiss, J. A., & Gardiner, J. C. (2001). Computational modeling of ligament    mechanics. Critical Reviews in Biomedical Engineering, 29(3).[9] Martin, R. B., Burr, D. B., Sharkey, N. A., & Fyhrie, D. P. (2015).    Mechanical properties of ligament and tendon. In Skeletal Tissue Mechanics    (pp. 175-225). Springer, New York, NY.[10] Pioletti, D. P., Rakotomanana, L. R., Benvenuti, J. F., & Leyvraz, P. F.    (1998). Viscoelastic constitutive law in large deformations: application to     human knee ligaments and tendons. Journal of biomechanics, 31(8), 753-757.[11] Pioletti, D. P., Rakotomanana, L. R., & Leyvraz, P. F. (1999). Strain    rate effect on the mechanical behavior of the anterior cruciate    ligament-bone complex. Medical Engineering & Physics, 21(2), 95-100.[12] Galbusera, F., Freutel, M., Durselen, L., D'Aiuto, M., Croce, D.,    Villa, T., Sansone, V. & Innocenti, B. (2014). Material models and     properties in the finite element analysis of knee ligaments: a literature     review. Frontiers in bioengineering and biotechnology, 2, 54.@author Colin Smith`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Blankevoort1991Ligament *":
        return _simulation.Blankevoort1991Ligament_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Blankevoort1991Ligament_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Blankevoort1991Ligament_getClassName()

    def clone(self) -> "OpenSim::Blankevoort1991Ligament *":
        return _simulation.Blankevoort1991Ligament_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Blankevoort1991Ligament_getConcreteClassName(self)

    def copyProperty_GeometryPath(self, source: "Blankevoort1991Ligament") -> "void":
        return _simulation.Blankevoort1991Ligament_copyProperty_GeometryPath(self, source)

    def append_GeometryPath(self, value: "GeometryPath") -> "int":
        return _simulation.Blankevoort1991Ligament_append_GeometryPath(self, value)

    def constructProperty_GeometryPath(self, initValue: "GeometryPath") -> "void":
        return _simulation.Blankevoort1991Ligament_constructProperty_GeometryPath(self, initValue)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.Blankevoort1991Ligament_get_GeometryPath(self, *args)

    def upd_GeometryPath(self, *args) -> "OpenSim::GeometryPath &":
        return _simulation.Blankevoort1991Ligament_upd_GeometryPath(self, *args)

    def set_GeometryPath(self, *args) -> "void":
        return _simulation.Blankevoort1991Ligament_set_GeometryPath(self, *args)

    def copyProperty_linear_stiffness(self, source: "Blankevoort1991Ligament") -> "void":
        return _simulation.Blankevoort1991Ligament_copyProperty_linear_stiffness(self, source)

    def append_linear_stiffness(self, value: "double const &") -> "int":
        return _simulation.Blankevoort1991Ligament_append_linear_stiffness(self, value)

    def constructProperty_linear_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.Blankevoort1991Ligament_constructProperty_linear_stiffness(self, initValue)

    def get_linear_stiffness(self, *args) -> "double const &":
        return _simulation.Blankevoort1991Ligament_get_linear_stiffness(self, *args)

    def upd_linear_stiffness(self, *args) -> "double &":
        return _simulation.Blankevoort1991Ligament_upd_linear_stiffness(self, *args)

    def set_linear_stiffness(self, *args) -> "void":
        return _simulation.Blankevoort1991Ligament_set_linear_stiffness(self, *args)

    def copyProperty_transition_strain(self, source: "Blankevoort1991Ligament") -> "void":
        return _simulation.Blankevoort1991Ligament_copyProperty_transition_strain(self, source)

    def append_transition_strain(self, value: "double const &") -> "int":
        return _simulation.Blankevoort1991Ligament_append_transition_strain(self, value)

    def constructProperty_transition_strain(self, initValue: "double const &") -> "void":
        return _simulation.Blankevoort1991Ligament_constructProperty_transition_strain(self, initValue)

    def get_transition_strain(self, *args) -> "double const &":
        return _simulation.Blankevoort1991Ligament_get_transition_strain(self, *args)

    def upd_transition_strain(self, *args) -> "double &":
        return _simulation.Blankevoort1991Ligament_upd_transition_strain(self, *args)

    def set_transition_strain(self, *args) -> "void":
        return _simulation.Blankevoort1991Ligament_set_transition_strain(self, *args)

    def copyProperty_damping_coefficient(self, source: "Blankevoort1991Ligament") -> "void":
        return _simulation.Blankevoort1991Ligament_copyProperty_damping_coefficient(self, source)

    def append_damping_coefficient(self, value: "double const &") -> "int":
        return _simulation.Blankevoort1991Ligament_append_damping_coefficient(self, value)

    def constructProperty_damping_coefficient(self, initValue: "double const &") -> "void":
        return _simulation.Blankevoort1991Ligament_constructProperty_damping_coefficient(self, initValue)

    def get_damping_coefficient(self, *args) -> "double const &":
        return _simulation.Blankevoort1991Ligament_get_damping_coefficient(self, *args)

    def upd_damping_coefficient(self, *args) -> "double &":
        return _simulation.Blankevoort1991Ligament_upd_damping_coefficient(self, *args)

    def set_damping_coefficient(self, *args) -> "void":
        return _simulation.Blankevoort1991Ligament_set_damping_coefficient(self, *args)

    def copyProperty_slack_length(self, source: "Blankevoort1991Ligament") -> "void":
        return _simulation.Blankevoort1991Ligament_copyProperty_slack_length(self, source)

    def append_slack_length(self, value: "double const &") -> "int":
        return _simulation.Blankevoort1991Ligament_append_slack_length(self, value)

    def constructProperty_slack_length(self, initValue: "double const &") -> "void":
        return _simulation.Blankevoort1991Ligament_constructProperty_slack_length(self, initValue)

    def get_slack_length(self, *args) -> "double const &":
        return _simulation.Blankevoort1991Ligament_get_slack_length(self, *args)

    def upd_slack_length(self, *args) -> "double &":
        return _simulation.Blankevoort1991Ligament_upd_slack_length(self, *args)

    def set_slack_length(self, *args) -> "void":
        return _simulation.Blankevoort1991Ligament_set_slack_length(self, *args)
    _has_output_spring_force = property(_simulation.Blankevoort1991Ligament__has_output_spring_force_get, _simulation.Blankevoort1991Ligament__has_output_spring_force_set)
    _has_output_damping_force = property(_simulation.Blankevoort1991Ligament__has_output_damping_force_get, _simulation.Blankevoort1991Ligament__has_output_damping_force_set)
    _has_output_total_force = property(_simulation.Blankevoort1991Ligament__has_output_total_force_get, _simulation.Blankevoort1991Ligament__has_output_total_force_set)
    _has_output_strain = property(_simulation.Blankevoort1991Ligament__has_output_strain_get, _simulation.Blankevoort1991Ligament__has_output_strain_set)
    _has_output_strain_rate = property(_simulation.Blankevoort1991Ligament__has_output_strain_rate_get, _simulation.Blankevoort1991Ligament__has_output_strain_rate_set)
    _has_output_length = property(_simulation.Blankevoort1991Ligament__has_output_length_get, _simulation.Blankevoort1991Ligament__has_output_length_set)
    _has_output_lengthening_speed = property(_simulation.Blankevoort1991Ligament__has_output_lengthening_speed_get, _simulation.Blankevoort1991Ligament__has_output_lengthening_speed_set)

    def __init__(self, *args):
        _simulation.Blankevoort1991Ligament_swiginit(self, _simulation.new_Blankevoort1991Ligament(*args))

    def setSlackLengthFromReferenceStrain(self, strain: "double", reference_state: "State") -> "void":
        r"""
         %Set the slack_length property using the strain in the ligament at a
        known pose (reference state). Note that scaling the model will adjust
             the slack length property to hold the input reference strain constant
             if the input reference_state is equal to the default model pose
             (generated by initSystem()).
        """
        return _simulation.Blankevoort1991Ligament_setSlackLengthFromReferenceStrain(self, strain, reference_state)

    def setSlackLengthFromReferenceForce(self, force: "double", reference_state: "State") -> "void":
        r"""
        %Set the slack_length property using the absolute spring force (N) in
           the ligament at a known pose (reference force). Note that scaling the
           model will adjust the slack_length property, thus it is important to
           consider the order of scaling and using this function for your application.
        """
        return _simulation.Blankevoort1991Ligament_setSlackLengthFromReferenceForce(self, force, reference_state)

    def setLinearStiffnessForcePerLength(self, linear_stiffness: "double") -> "void":
        r"""
        %Set the linear_stiffness property using a value in units of
            force/length (N/m). Note that scaling the model keeps the
            linear_stiffness property (in units of force/strain) constant, thus the
            linear_stiffness in units of force/length input to this function will be
            altered by scaling.
        """
        return _simulation.Blankevoort1991Ligament_setLinearStiffnessForcePerLength(self, linear_stiffness)

    def setDampingCoefficientForceTimePerLength(self, damping_coefficient: "double") -> "void":
        r"""
        %Set the damping_coefficient property using a value in units of
           force*time/length (N*s/m). Note that scaling the model keeps the
           damping_coefficient property (in units force*time/strain) constant, thus
           the damping_coefficient in units of force*time/length input to this
           function will be altered by scaling.
        """
        return _simulation.Blankevoort1991Ligament_setDampingCoefficientForceTimePerLength(self, damping_coefficient)

    def getStrain(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getStrain(self, state)

    def getStrainRate(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getStrainRate(self, state)

    def getLength(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getLength(self, state)

    def getLengtheningSpeed(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getLengtheningSpeed(self, state)

    def getSpringForce(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getSpringForce(self, state)

    def getDampingForce(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getDampingForce(self, state)

    def getTotalForce(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_getTotalForce(self, state)

    def getLinearStiffnessForcePerLength(self) -> "double":
        r""" Get the linear_stiffness property in units of force/length (N/m)"""
        return _simulation.Blankevoort1991Ligament_getLinearStiffnessForcePerLength(self)

    def getTransitionLength(self) -> "double":
        r"""
        Get the length (m) of the ligament where the model transitions from
           the toe region to the linear region. This corresponds to the length of the
           ligament at the transistion_strain.
        """
        return _simulation.Blankevoort1991Ligament_getTransitionLength(self)

    def getDampingCoefficientForceTimePerLength(self) -> "double":
        r""" Get the damping_coefficient in units of force*time/length (N*s/m)"""
        return _simulation.Blankevoort1991Ligament_getDampingCoefficientForceTimePerLength(self)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.Blankevoort1991Ligament_computeMomentArm(self, s, aCoord)

    def computeForce(self, s: "State", bodyForces: "VectorOfSpatialVec", generalizedForces: "Vector") -> "void":
        return _simulation.Blankevoort1991Ligament_computeForce(self, s, bodyForces, generalizedForces)

    def computePotentialEnergy(self, state: "State") -> "double":
        return _simulation.Blankevoort1991Ligament_computePotentialEnergy(self, state)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        return _simulation.Blankevoort1991Ligament_extendPostScale(self, s, scaleSet)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        return _simulation.Blankevoort1991Ligament_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        return _simulation.Blankevoort1991Ligament_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_Blankevoort1991Ligament

# Register Blankevoort1991Ligament in _simulation:
_simulation.Blankevoort1991Ligament_swigregister(Blankevoort1991Ligament)

def Blankevoort1991Ligament_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Blankevoort1991Ligament *":
    return _simulation.Blankevoort1991Ligament_safeDownCast(obj)

def Blankevoort1991Ligament_getClassName() -> "std::string const &":
    return _simulation.Blankevoort1991Ligament_getClassName()

class PathActuator(ScalarActuator):
    r"""
    This is the base class for actuators that apply controllable tension along
    a geometry path. %PathActuator has no states; the control is simply the
    tension to be applied along a geometry path (i.e. tensionable rope).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathActuator *":
        return _simulation.PathActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathActuator_getClassName()

    def clone(self) -> "OpenSim::PathActuator *":
        return _simulation.PathActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathActuator_getConcreteClassName(self)

    def copyProperty_GeometryPath(self, source: "PathActuator") -> "void":
        return _simulation.PathActuator_copyProperty_GeometryPath(self, source)

    def append_GeometryPath(self, value: "GeometryPath") -> "int":
        return _simulation.PathActuator_append_GeometryPath(self, value)

    def constructProperty_GeometryPath(self, initValue: "GeometryPath") -> "void":
        return _simulation.PathActuator_constructProperty_GeometryPath(self, initValue)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.PathActuator_get_GeometryPath(self, *args)

    def upd_GeometryPath(self, *args) -> "OpenSim::GeometryPath &":
        return _simulation.PathActuator_upd_GeometryPath(self, *args)

    def set_GeometryPath(self, *args) -> "void":
        return _simulation.PathActuator_set_GeometryPath(self, *args)

    def copyProperty_optimal_force(self, source: "PathActuator") -> "void":
        return _simulation.PathActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value: "double const &") -> "int":
        return _simulation.PathActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue: "double const &") -> "void":
        return _simulation.PathActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args) -> "double const &":
        return _simulation.PathActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args) -> "double &":
        return _simulation.PathActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args) -> "void":
        return _simulation.PathActuator_set_optimal_force(self, *args)
    _has_output_tension = property(_simulation.PathActuator__has_output_tension_get, _simulation.PathActuator__has_output_tension_set)

    def __init__(self):
        _simulation.PathActuator_swiginit(self, _simulation.new_PathActuator())

    def updGeometryPath(self) -> "OpenSim::GeometryPath &":
        return _simulation.PathActuator_updGeometryPath(self)

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        return _simulation.PathActuator_getGeometryPath(self)

    def hasGeometryPath(self) -> "bool":
        return _simulation.PathActuator_hasGeometryPath(self)

    def setOptimalForce(self, aOptimalForce: "double") -> "void":
        return _simulation.PathActuator_setOptimalForce(self, aOptimalForce)

    def getOptimalForce(self) -> "double":
        return _simulation.PathActuator_getOptimalForce(self)

    def getLength(self, s: "State") -> "double":
        return _simulation.PathActuator_getLength(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        return _simulation.PathActuator_getLengtheningSpeed(self, s)

    def getPower(self, s: "State") -> "double":
        return _simulation.PathActuator_getPower(self, s)

    def getStress(self, s: "State") -> "double":
        return _simulation.PathActuator_getStress(self, s)

    def addNewPathPoint(self, proposedName: "std::string const &", aBody: "PhysicalFrame", aPositionOnBody: "Vec3") -> "void":
        r"""
        Note that this function does not maintain the State and so should be used only
               before a valid State is created
        """
        return _simulation.PathActuator_addNewPathPoint(self, proposedName, aBody, aPositionOnBody)

    def computeForce(self, state: "State", bodyForces: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        return _simulation.PathActuator_computeForce(self, state, bodyForces, mobilityForces)

    def computeActuation(self, s: "State") -> "double":
        return _simulation.PathActuator_computeActuation(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.PathActuator_computeMomentArm(self, s, aCoord)
    __swig_destroy__ = _simulation.delete_PathActuator

# Register PathActuator in _simulation:
_simulation.PathActuator_swigregister(PathActuator)

def PathActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathActuator *":
    return _simulation.PathActuator_safeDownCast(obj)

def PathActuator_getClassName() -> "std::string const &":
    return _simulation.PathActuator_getClassName()

class MuscleCannotEquilibrate(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", detail: "std::string const &"):
        _simulation.MuscleCannotEquilibrate_swiginit(self, _simulation.new_MuscleCannotEquilibrate(file, line, func, obj, detail))
    __swig_destroy__ = _simulation.delete_MuscleCannotEquilibrate

# Register MuscleCannotEquilibrate in _simulation:
_simulation.MuscleCannotEquilibrate_swigregister(MuscleCannotEquilibrate)

class Muscle(PathActuator):
    r"""
    A base class for modeling a muscle-tendon actuator. It defines muscle parameters
    and methods to PathActuator, but does not implement all of the necessary methods,
    and remains an abstract class. The path information for a muscle is contained
    in PathActuator, and the force-generating behavior should be defined in
    the derived classes.

    This class defines a subset of muscle models that include an active fiber
    (contractile element) in series with a tendon. This class defines common
    data members and handles the geometry of a unipennate fiber in connection
    with a tendon. No states are assumed, but concrete classes are free to
    add whatever states are necessary to describe the specific behavior of a
    muscle.

    Author: Ajay Seth, Matt Millard

    (Based on earlier work by Peter Loan and Frank C. Anderson.)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Muscle *":
        return _simulation.Muscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Muscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Muscle_getClassName()

    def clone(self) -> "OpenSim::Muscle *":
        return _simulation.Muscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Muscle_getConcreteClassName(self)

    def copyProperty_max_isometric_force(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_max_isometric_force(self, source)

    def append_max_isometric_force(self, value: "double const &") -> "int":
        return _simulation.Muscle_append_max_isometric_force(self, value)

    def constructProperty_max_isometric_force(self, initValue: "double const &") -> "void":
        return _simulation.Muscle_constructProperty_max_isometric_force(self, initValue)

    def get_max_isometric_force(self, *args) -> "double const &":
        return _simulation.Muscle_get_max_isometric_force(self, *args)

    def upd_max_isometric_force(self, *args) -> "double &":
        return _simulation.Muscle_upd_max_isometric_force(self, *args)

    def set_max_isometric_force(self, *args) -> "void":
        return _simulation.Muscle_set_max_isometric_force(self, *args)

    def copyProperty_optimal_fiber_length(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_optimal_fiber_length(self, source)

    def append_optimal_fiber_length(self, value: "double const &") -> "int":
        return _simulation.Muscle_append_optimal_fiber_length(self, value)

    def constructProperty_optimal_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.Muscle_constructProperty_optimal_fiber_length(self, initValue)

    def get_optimal_fiber_length(self, *args) -> "double const &":
        return _simulation.Muscle_get_optimal_fiber_length(self, *args)

    def upd_optimal_fiber_length(self, *args) -> "double &":
        return _simulation.Muscle_upd_optimal_fiber_length(self, *args)

    def set_optimal_fiber_length(self, *args) -> "void":
        return _simulation.Muscle_set_optimal_fiber_length(self, *args)

    def copyProperty_tendon_slack_length(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_tendon_slack_length(self, source)

    def append_tendon_slack_length(self, value: "double const &") -> "int":
        return _simulation.Muscle_append_tendon_slack_length(self, value)

    def constructProperty_tendon_slack_length(self, initValue: "double const &") -> "void":
        return _simulation.Muscle_constructProperty_tendon_slack_length(self, initValue)

    def get_tendon_slack_length(self, *args) -> "double const &":
        return _simulation.Muscle_get_tendon_slack_length(self, *args)

    def upd_tendon_slack_length(self, *args) -> "double &":
        return _simulation.Muscle_upd_tendon_slack_length(self, *args)

    def set_tendon_slack_length(self, *args) -> "void":
        return _simulation.Muscle_set_tendon_slack_length(self, *args)

    def copyProperty_pennation_angle_at_optimal(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_pennation_angle_at_optimal(self, source)

    def append_pennation_angle_at_optimal(self, value: "double const &") -> "int":
        return _simulation.Muscle_append_pennation_angle_at_optimal(self, value)

    def constructProperty_pennation_angle_at_optimal(self, initValue: "double const &") -> "void":
        return _simulation.Muscle_constructProperty_pennation_angle_at_optimal(self, initValue)

    def get_pennation_angle_at_optimal(self, *args) -> "double const &":
        return _simulation.Muscle_get_pennation_angle_at_optimal(self, *args)

    def upd_pennation_angle_at_optimal(self, *args) -> "double &":
        return _simulation.Muscle_upd_pennation_angle_at_optimal(self, *args)

    def set_pennation_angle_at_optimal(self, *args) -> "void":
        return _simulation.Muscle_set_pennation_angle_at_optimal(self, *args)

    def copyProperty_max_contraction_velocity(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_max_contraction_velocity(self, source)

    def append_max_contraction_velocity(self, value: "double const &") -> "int":
        return _simulation.Muscle_append_max_contraction_velocity(self, value)

    def constructProperty_max_contraction_velocity(self, initValue: "double const &") -> "void":
        return _simulation.Muscle_constructProperty_max_contraction_velocity(self, initValue)

    def get_max_contraction_velocity(self, *args) -> "double const &":
        return _simulation.Muscle_get_max_contraction_velocity(self, *args)

    def upd_max_contraction_velocity(self, *args) -> "double &":
        return _simulation.Muscle_upd_max_contraction_velocity(self, *args)

    def set_max_contraction_velocity(self, *args) -> "void":
        return _simulation.Muscle_set_max_contraction_velocity(self, *args)

    def copyProperty_ignore_tendon_compliance(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_ignore_tendon_compliance(self, source)

    def append_ignore_tendon_compliance(self, value: "bool const &") -> "int":
        return _simulation.Muscle_append_ignore_tendon_compliance(self, value)

    def constructProperty_ignore_tendon_compliance(self, initValue: "bool const &") -> "void":
        return _simulation.Muscle_constructProperty_ignore_tendon_compliance(self, initValue)

    def get_ignore_tendon_compliance(self, *args) -> "bool const &":
        return _simulation.Muscle_get_ignore_tendon_compliance(self, *args)

    def upd_ignore_tendon_compliance(self, *args) -> "bool &":
        return _simulation.Muscle_upd_ignore_tendon_compliance(self, *args)

    def set_ignore_tendon_compliance(self, *args) -> "void":
        return _simulation.Muscle_set_ignore_tendon_compliance(self, *args)

    def copyProperty_ignore_activation_dynamics(self, source: "Muscle") -> "void":
        return _simulation.Muscle_copyProperty_ignore_activation_dynamics(self, source)

    def append_ignore_activation_dynamics(self, value: "bool const &") -> "int":
        return _simulation.Muscle_append_ignore_activation_dynamics(self, value)

    def constructProperty_ignore_activation_dynamics(self, initValue: "bool const &") -> "void":
        return _simulation.Muscle_constructProperty_ignore_activation_dynamics(self, initValue)

    def get_ignore_activation_dynamics(self, *args) -> "bool const &":
        return _simulation.Muscle_get_ignore_activation_dynamics(self, *args)

    def upd_ignore_activation_dynamics(self, *args) -> "bool &":
        return _simulation.Muscle_upd_ignore_activation_dynamics(self, *args)

    def set_ignore_activation_dynamics(self, *args) -> "void":
        return _simulation.Muscle_set_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Muscle__has_output_excitation_get, _simulation.Muscle__has_output_excitation_set)
    _has_output_activation = property(_simulation.Muscle__has_output_activation_get, _simulation.Muscle__has_output_activation_set)
    _has_output_fiber_length = property(_simulation.Muscle__has_output_fiber_length_get, _simulation.Muscle__has_output_fiber_length_set)
    _has_output_pennation_angle = property(_simulation.Muscle__has_output_pennation_angle_get, _simulation.Muscle__has_output_pennation_angle_set)
    _has_output_cos_pennation_angle = property(_simulation.Muscle__has_output_cos_pennation_angle_get, _simulation.Muscle__has_output_cos_pennation_angle_set)
    _has_output_tendon_length = property(_simulation.Muscle__has_output_tendon_length_get, _simulation.Muscle__has_output_tendon_length_set)
    _has_output_normalized_fiber_length = property(_simulation.Muscle__has_output_normalized_fiber_length_get, _simulation.Muscle__has_output_normalized_fiber_length_set)
    _has_output_fiber_length_along_tendon = property(_simulation.Muscle__has_output_fiber_length_along_tendon_get, _simulation.Muscle__has_output_fiber_length_along_tendon_set)
    _has_output_tendon_strain = property(_simulation.Muscle__has_output_tendon_strain_get, _simulation.Muscle__has_output_tendon_strain_set)
    _has_output_passive_force_multiplier = property(_simulation.Muscle__has_output_passive_force_multiplier_get, _simulation.Muscle__has_output_passive_force_multiplier_set)
    _has_output_active_force_length_multiplier = property(_simulation.Muscle__has_output_active_force_length_multiplier_get, _simulation.Muscle__has_output_active_force_length_multiplier_set)
    _has_output_fiber_velocity = property(_simulation.Muscle__has_output_fiber_velocity_get, _simulation.Muscle__has_output_fiber_velocity_set)
    _has_output_normalized_fiber_velocity = property(_simulation.Muscle__has_output_normalized_fiber_velocity_get, _simulation.Muscle__has_output_normalized_fiber_velocity_set)
    _has_output_fiber_velocity_along_tendon = property(_simulation.Muscle__has_output_fiber_velocity_along_tendon_get, _simulation.Muscle__has_output_fiber_velocity_along_tendon_set)
    _has_output_tendon_velocity = property(_simulation.Muscle__has_output_tendon_velocity_get, _simulation.Muscle__has_output_tendon_velocity_set)
    _has_output_force_velocity_multiplier = property(_simulation.Muscle__has_output_force_velocity_multiplier_get, _simulation.Muscle__has_output_force_velocity_multiplier_set)
    _has_output_pennation_angular_velocity = property(_simulation.Muscle__has_output_pennation_angular_velocity_get, _simulation.Muscle__has_output_pennation_angular_velocity_set)
    _has_output_fiber_force = property(_simulation.Muscle__has_output_fiber_force_get, _simulation.Muscle__has_output_fiber_force_set)
    _has_output_fiber_force_along_tendon = property(_simulation.Muscle__has_output_fiber_force_along_tendon_get, _simulation.Muscle__has_output_fiber_force_along_tendon_set)
    _has_output_active_fiber_force = property(_simulation.Muscle__has_output_active_fiber_force_get, _simulation.Muscle__has_output_active_fiber_force_set)
    _has_output_passive_fiber_force = property(_simulation.Muscle__has_output_passive_fiber_force_get, _simulation.Muscle__has_output_passive_fiber_force_set)
    _has_output_active_fiber_force_along_tendon = property(_simulation.Muscle__has_output_active_fiber_force_along_tendon_get, _simulation.Muscle__has_output_active_fiber_force_along_tendon_set)
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Muscle__has_output_passive_fiber_force_along_tendon_get, _simulation.Muscle__has_output_passive_fiber_force_along_tendon_set)
    _has_output_tendon_force = property(_simulation.Muscle__has_output_tendon_force_get, _simulation.Muscle__has_output_tendon_force_set)
    _has_output_fiber_stiffness = property(_simulation.Muscle__has_output_fiber_stiffness_get, _simulation.Muscle__has_output_fiber_stiffness_set)
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Muscle__has_output_fiber_stiffness_along_tendon_get, _simulation.Muscle__has_output_fiber_stiffness_along_tendon_set)
    _has_output_tendon_stiffness = property(_simulation.Muscle__has_output_tendon_stiffness_get, _simulation.Muscle__has_output_tendon_stiffness_set)
    _has_output_muscle_stiffness = property(_simulation.Muscle__has_output_muscle_stiffness_get, _simulation.Muscle__has_output_muscle_stiffness_set)
    _has_output_fiber_active_power = property(_simulation.Muscle__has_output_fiber_active_power_get, _simulation.Muscle__has_output_fiber_active_power_set)
    _has_output_fiber_passive_power = property(_simulation.Muscle__has_output_fiber_passive_power_get, _simulation.Muscle__has_output_fiber_passive_power_set)
    _has_output_tendon_power = property(_simulation.Muscle__has_output_tendon_power_get, _simulation.Muscle__has_output_tendon_power_set)
    _has_output_muscle_power = property(_simulation.Muscle__has_output_muscle_power_get, _simulation.Muscle__has_output_muscle_power_set)

    def getMaxIsometricForce(self) -> "double":
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Muscle_getMaxIsometricForce(self)

    def setMaxIsometricForce(self, maxIsometricForce: "double") -> "void":
        return _simulation.Muscle_setMaxIsometricForce(self, maxIsometricForce)

    def getOptimalFiberLength(self) -> "double":
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Muscle_getOptimalFiberLength(self)

    def setOptimalFiberLength(self, optimalFiberLength: "double") -> "void":
        return _simulation.Muscle_setOptimalFiberLength(self, optimalFiberLength)

    def getTendonSlackLength(self) -> "double":
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Muscle_getTendonSlackLength(self)

    def setTendonSlackLength(self, tendonSlackLength: "double") -> "void":
        return _simulation.Muscle_setTendonSlackLength(self, tendonSlackLength)

    def getPennationAngleAtOptimalFiberLength(self) -> "double":
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Muscle_getPennationAngleAtOptimalFiberLength(self)

    def setPennationAngleAtOptimalFiberLength(self, pennationAngle: "double") -> "void":
        return _simulation.Muscle_setPennationAngleAtOptimalFiberLength(self, pennationAngle)

    def getMaxContractionVelocity(self) -> "double":
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Muscle_getMaxContractionVelocity(self)

    def setMaxContractionVelocity(self, maxContractionVelocity: "double") -> "void":
        return _simulation.Muscle_setMaxContractionVelocity(self, maxContractionVelocity)

    def getIgnoreTendonCompliance(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Muscle_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Muscle_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Muscle_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Muscle_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s: "State") -> "double":
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Muscle_getActivation(self, s)

    def getFiberLength(self, s: "State") -> "double":
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Muscle_getFiberLength(self, s)

    def getPennationAngle(self, s: "State") -> "double":
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Muscle_getPennationAngle(self, s)

    def getCosPennationAngle(self, s: "State") -> "double":
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Muscle_getCosPennationAngle(self, s)

    def getTendonLength(self, s: "State") -> "double":
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Muscle_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s: "State") -> "double":
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Muscle_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Muscle_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s: "State") -> "double":
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Muscle_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Muscle_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Muscle_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s: "State") -> "double":
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Muscle_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s: "State") -> "double":
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Muscle_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s: "State") -> "double":
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Muscle_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.Muscle_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s: "State") -> "double":
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Muscle_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Muscle_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s: "State") -> "double":
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Muscle_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s: "State") -> "double":
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Muscle_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s: "State") -> "double":
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Muscle_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s: "State") -> "double":
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Muscle_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s: "State") -> "double":
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Muscle_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s: "State") -> "double":
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Muscle_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s: "State") -> "double":
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Muscle_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s: "State") -> "double":
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Muscle_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Muscle_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s: "State") -> "double":
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Muscle_getTendonForce(self, s)

    def getFiberStiffness(self, s: "State") -> "double":
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Muscle_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.Muscle_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s: "State") -> "double":
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Muscle_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s: "State") -> "double":
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Muscle_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s: "State") -> "double":
        r""" get the current active fiber power (W)"""
        return _simulation.Muscle_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s: "State") -> "double":
        r""" get the current passive fiber power (W)"""
        return _simulation.Muscle_getFiberPassivePower(self, s)

    def getTendonPower(self, s: "State") -> "double":
        r""" get the current tendon power (W)"""
        return _simulation.Muscle_getTendonPower(self, s)

    def getMusclePower(self, s: "State") -> "double":
        r""" get the current muscle power (W)"""
        return _simulation.Muscle_getMusclePower(self, s)

    def getStress(self, s: "State") -> "double":
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Muscle_getStress(self, s)

    def setExcitation(self, s: "State", excitation: "double") -> "void":
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Muscle_setExcitation(self, s, excitation)

    def getExcitation(self, s: "State") -> "double":
        return _simulation.Muscle_getExcitation(self, s)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r""" DEPRECATED: only for backward compatibility"""
        return _simulation.Muscle_setActivation(self, s, activation)

    def computeActuation(self, s: "State") -> "double":
        r"""
        Actuator interface for a muscle computes the tension in the muscle
               and applied by the tendon to bones (i.e. not the fiber force)
        """
        return _simulation.Muscle_computeActuation(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Muscle_computeEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        r"""Conditional comment:"""
        return _simulation.Muscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)
    __swig_destroy__ = _simulation.delete_Muscle

# Register Muscle in _simulation:
_simulation.Muscle_swigregister(Muscle)

def Muscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Muscle *":
    return _simulation.Muscle_safeDownCast(obj)

def Muscle_getClassName() -> "std::string const &":
    return _simulation.Muscle_getClassName()

class ActivationFiberLengthMuscle(Muscle):
    r"""
    A base class representing a two-state muscle-tendon actuator.
    It adds activation and fiber-length states and dynamics to the
    Muscle class, but does not implement all of the necessary methods,
    so it is abstract as well. The path information for a muscle is contained
    in the Muscle class, and the force-generating behavior should be defined in
    the derived classes.

    Author: Ajay Seth

    (Based on earlier work by Peter Loan and Frank C. Anderson.)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActivationFiberLengthMuscle *":
        return _simulation.ActivationFiberLengthMuscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ActivationFiberLengthMuscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ActivationFiberLengthMuscle_getClassName()

    def clone(self) -> "OpenSim::ActivationFiberLengthMuscle *":
        return _simulation.ActivationFiberLengthMuscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ActivationFiberLengthMuscle_getConcreteClassName(self)

    def copyProperty_default_activation(self, source: "ActivationFiberLengthMuscle") -> "void":
        return _simulation.ActivationFiberLengthMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value: "double const &") -> "int":
        return _simulation.ActivationFiberLengthMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue: "double const &") -> "void":
        return _simulation.ActivationFiberLengthMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args) -> "double const &":
        return _simulation.ActivationFiberLengthMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args) -> "double &":
        return _simulation.ActivationFiberLengthMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args) -> "void":
        return _simulation.ActivationFiberLengthMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source: "ActivationFiberLengthMuscle") -> "void":
        return _simulation.ActivationFiberLengthMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value: "double const &") -> "int":
        return _simulation.ActivationFiberLengthMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.ActivationFiberLengthMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args) -> "double const &":
        return _simulation.ActivationFiberLengthMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args) -> "double &":
        return _simulation.ActivationFiberLengthMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args) -> "void":
        return _simulation.ActivationFiberLengthMuscle_set_default_fiber_length(self, *args)

    def getDefaultActivation(self) -> "double":
        return _simulation.ActivationFiberLengthMuscle_getDefaultActivation(self)

    def setDefaultActivation(self, activation: "double") -> "void":
        return _simulation.ActivationFiberLengthMuscle_setDefaultActivation(self, activation)

    def getDefaultFiberLength(self) -> "double":
        return _simulation.ActivationFiberLengthMuscle_getDefaultFiberLength(self)

    def setDefaultFiberLength(self, length: "double") -> "void":
        return _simulation.ActivationFiberLengthMuscle_setDefaultFiberLength(self, length)

    def setActivation(self, s: "State", activation: "double") -> "void":
        return _simulation.ActivationFiberLengthMuscle_setActivation(self, s, activation)

    def setFiberLength(self, s: "State", fiberLength: "double") -> "void":
        return _simulation.ActivationFiberLengthMuscle_setFiberLength(self, s, fiberLength)

    def getActivationRate(self, s: "State") -> "double":
        return _simulation.ActivationFiberLengthMuscle_getActivationRate(self, s)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Adjust the properties of the muscle after the model has been scaled. The
               optimal fiber length and tendon slack length are each multiplied by the
               ratio of the current path length and the path length before scaling.
        """
        return _simulation.ActivationFiberLengthMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_ActivationFiberLengthMuscle

# Register ActivationFiberLengthMuscle in _simulation:
_simulation.ActivationFiberLengthMuscle_swigregister(ActivationFiberLengthMuscle)

def ActivationFiberLengthMuscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActivationFiberLengthMuscle *":
    return _simulation.ActivationFiberLengthMuscle_safeDownCast(obj)

def ActivationFiberLengthMuscle_getClassName() -> "std::string const &":
    return _simulation.ActivationFiberLengthMuscle_getClassName()

class PointToPointSpring(Force):
    r"""
    A simple point to point spring with a resting length and stiffness.
    Points are connected to bodies and are defined in the body frame.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointToPointSpring *":
        return _simulation.PointToPointSpring_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PointToPointSpring_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PointToPointSpring_getClassName()

    def clone(self) -> "OpenSim::PointToPointSpring *":
        return _simulation.PointToPointSpring_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PointToPointSpring_getConcreteClassName(self)

    def copyProperty_point1(self, source: "PointToPointSpring") -> "void":
        return _simulation.PointToPointSpring_copyProperty_point1(self, source)

    def append_point1(self, value: "Vec3") -> "int":
        return _simulation.PointToPointSpring_append_point1(self, value)

    def constructProperty_point1(self, initValue: "Vec3") -> "void":
        return _simulation.PointToPointSpring_constructProperty_point1(self, initValue)

    def get_point1(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointToPointSpring_get_point1(self, *args)

    def upd_point1(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointToPointSpring_upd_point1(self, *args)

    def set_point1(self, *args) -> "void":
        return _simulation.PointToPointSpring_set_point1(self, *args)

    def copyProperty_point2(self, source: "PointToPointSpring") -> "void":
        return _simulation.PointToPointSpring_copyProperty_point2(self, source)

    def append_point2(self, value: "Vec3") -> "int":
        return _simulation.PointToPointSpring_append_point2(self, value)

    def constructProperty_point2(self, initValue: "Vec3") -> "void":
        return _simulation.PointToPointSpring_constructProperty_point2(self, initValue)

    def get_point2(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.PointToPointSpring_get_point2(self, *args)

    def upd_point2(self, *args) -> "SimTK::Vec3 &":
        return _simulation.PointToPointSpring_upd_point2(self, *args)

    def set_point2(self, *args) -> "void":
        return _simulation.PointToPointSpring_set_point2(self, *args)

    def copyProperty_stiffness(self, source: "PointToPointSpring") -> "void":
        return _simulation.PointToPointSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value: "double const &") -> "int":
        return _simulation.PointToPointSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.PointToPointSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args) -> "double const &":
        return _simulation.PointToPointSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args) -> "double &":
        return _simulation.PointToPointSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args) -> "void":
        return _simulation.PointToPointSpring_set_stiffness(self, *args)

    def copyProperty_rest_length(self, source: "PointToPointSpring") -> "void":
        return _simulation.PointToPointSpring_copyProperty_rest_length(self, source)

    def append_rest_length(self, value: "double const &") -> "int":
        return _simulation.PointToPointSpring_append_rest_length(self, value)

    def constructProperty_rest_length(self, initValue: "double const &") -> "void":
        return _simulation.PointToPointSpring_constructProperty_rest_length(self, initValue)

    def get_rest_length(self, *args) -> "double const &":
        return _simulation.PointToPointSpring_get_rest_length(self, *args)

    def upd_rest_length(self, *args) -> "double &":
        return _simulation.PointToPointSpring_upd_rest_length(self, *args)

    def set_rest_length(self, *args) -> "void":
        return _simulation.PointToPointSpring_set_rest_length(self, *args)
    PropertyIndex_socket_body1 = property(_simulation.PointToPointSpring_PropertyIndex_socket_body1_get, _simulation.PointToPointSpring_PropertyIndex_socket_body1_set)

    def connectSocket_body1(self, object: "OpenSimObject") -> "void":
        return _simulation.PointToPointSpring_connectSocket_body1(self, object)
    PropertyIndex_socket_body2 = property(_simulation.PointToPointSpring_PropertyIndex_socket_body2_get, _simulation.PointToPointSpring_PropertyIndex_socket_body2_set)

    def connectSocket_body2(self, object: "OpenSimObject") -> "void":
        return _simulation.PointToPointSpring_connectSocket_body2(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type body1: :py:class:`PhysicalFrame`
           :param body1:        the first body to which the spring is attached
           :type point1: :py:class:`Vec3`
           :param point1:       location where spring is attached on body1
           :type body2: :py:class:`PhysicalFrame`
           :param body2:        the second body to which the spring is attached
           :type point2: :py:class:`Vec3`
           :param point2:       location where spring is attached on body2
           :type stiffness: float
           :param stiffness:    spring stiffness
           :type restlength: float
           :param restlength:   the resting (zero force) length of the spring
        """
        _simulation.PointToPointSpring_swiginit(self, _simulation.new_PointToPointSpring(*args))

    def setBody1(self, body: "PhysicalFrame") -> "void":
        r"""Spring end point bodies"""
        return _simulation.PointToPointSpring_setBody1(self, body)

    def setBody2(self, body: "PhysicalFrame") -> "void":
        return _simulation.PointToPointSpring_setBody2(self, body)

    def getBody1(self) -> "OpenSim::PhysicalFrame const &":
        return _simulation.PointToPointSpring_getBody1(self)

    def getBody2(self) -> "OpenSim::PhysicalFrame const &":
        return _simulation.PointToPointSpring_getBody2(self)

    def setPoint1(self, aPosition: "Vec3") -> "void":
        r"""Spring end points"""
        return _simulation.PointToPointSpring_setPoint1(self, aPosition)

    def getPoint1(self) -> "SimTK::Vec3 const &":
        return _simulation.PointToPointSpring_getPoint1(self)

    def setPoint2(self, aPosition: "Vec3") -> "void":
        return _simulation.PointToPointSpring_setPoint2(self, aPosition)

    def getPoint2(self) -> "SimTK::Vec3 const &":
        return _simulation.PointToPointSpring_getPoint2(self)

    def setStiffness(self, stiffness: "double") -> "void":
        r"""
        Spring stiffness
        :type stiffness: float
        :param stiffness:
        """
        return _simulation.PointToPointSpring_setStiffness(self, stiffness)

    def getStiffness(self) -> "double":
        return _simulation.PointToPointSpring_getStiffness(self)

    def setRestlength(self, restLength: "double") -> "void":
        r"""
        Spring resting length
        :type restLength: float
        :param restLength:
        """
        return _simulation.PointToPointSpring_setRestlength(self, restLength)

    def getRestlength(self) -> "double":
        return _simulation.PointToPointSpring_getRestlength(self)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.PointToPointSpring_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.PointToPointSpring_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_PointToPointSpring

# Register PointToPointSpring in _simulation:
_simulation.PointToPointSpring_swigregister(PointToPointSpring)

def PointToPointSpring_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointToPointSpring *":
    return _simulation.PointToPointSpring_safeDownCast(obj)

def PointToPointSpring_getClassName() -> "std::string const &":
    return _simulation.PointToPointSpring_getClassName()

class ExpressionBasedPointToPointForce(Force):
    r"""
    A point-to-point Force who's force magnitude is determined by a user-defined
    expression, with the distance (d) and its time derivative (ddot) as variables.
    The direction of the force is directed along the line connecting the two
    points.

    "d" and "ddot" are the variables names expected by the expression parser.
    Common C math library functions such as: exp(), pow(), sqrt(), sin(), ...
    are permitted. See Lepton/Operation.h for a complete list.

    For example: string expression = "-1.5*exp(10*(d-0.25)^2)*(1 + 2.0*ddot)"
                 provides a model of a nonlinear point-to point spring, while
                 expression = "1.25/(rd^2)" is an electric field force between
                 charged particles at points separated by the distance, d.
                 i.e. K*q1*q2 = 1.25

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedPointToPointForce *":
        return _simulation.ExpressionBasedPointToPointForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_getClassName()

    def clone(self) -> "OpenSim::ExpressionBasedPointToPointForce *":
        return _simulation.ExpressionBasedPointToPointForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_getConcreteClassName(self)

    def copyProperty_body1(self, source: "ExpressionBasedPointToPointForce") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_body1(self, source)

    def append_body1(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedPointToPointForce_append_body1(self, value)

    def constructProperty_body1(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_body1(self, *args)

    def get_body1(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_get_body1(self, *args)

    def upd_body1(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedPointToPointForce_upd_body1(self, *args)

    def set_body1(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_set_body1(self, *args)

    def copyProperty_body2(self, source: "ExpressionBasedPointToPointForce") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_body2(self, source)

    def append_body2(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedPointToPointForce_append_body2(self, value)

    def constructProperty_body2(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_body2(self, *args)

    def get_body2(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_get_body2(self, *args)

    def upd_body2(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedPointToPointForce_upd_body2(self, *args)

    def set_body2(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_set_body2(self, *args)

    def copyProperty_point1(self, source: "ExpressionBasedPointToPointForce") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_point1(self, source)

    def append_point1(self, value: "Vec3") -> "int":
        return _simulation.ExpressionBasedPointToPointForce_append_point1(self, value)

    def constructProperty_point1(self, initValue: "Vec3") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_point1(self, initValue)

    def get_point1(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedPointToPointForce_get_point1(self, *args)

    def upd_point1(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ExpressionBasedPointToPointForce_upd_point1(self, *args)

    def set_point1(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_set_point1(self, *args)

    def copyProperty_point2(self, source: "ExpressionBasedPointToPointForce") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_point2(self, source)

    def append_point2(self, value: "Vec3") -> "int":
        return _simulation.ExpressionBasedPointToPointForce_append_point2(self, value)

    def constructProperty_point2(self, initValue: "Vec3") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_point2(self, initValue)

    def get_point2(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedPointToPointForce_get_point2(self, *args)

    def upd_point2(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ExpressionBasedPointToPointForce_upd_point2(self, *args)

    def set_point2(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_set_point2(self, *args)

    def copyProperty_expression(self, source: "ExpressionBasedPointToPointForce") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_copyProperty_expression(self, source)

    def append_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedPointToPointForce_append_expression(self, value)

    def constructProperty_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_constructProperty_expression(self, initValue)

    def get_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_get_expression(self, *args)

    def upd_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedPointToPointForce_upd_expression(self, *args)

    def set_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedPointToPointForce_set_expression(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type body1Name: string
           :param body1Name:    name of the first body to which the p2p force is attached
           :type point1: :py:class:`Vec3`
           :param point1:       first point location attached to body1
           :type body2Name: string
           :param body2Name:    name of the second body to which the p2p force is attached
           :type point2: :py:class:`Vec3`
           :param point2:       second  point location attached to body2
           :type expression: string
           :param expression:   the expression used to compute the force action at points
        """
        _simulation.ExpressionBasedPointToPointForce_swiginit(self, _simulation.new_ExpressionBasedPointToPointForce(*args))

    def setBody1Name(self, body1Name: "std::string const &") -> "void":
        r"""Force end point bodies"""
        return _simulation.ExpressionBasedPointToPointForce_setBody1Name(self, body1Name)

    def setBody2Name(self, body2Name: "std::string const &") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_setBody2Name(self, body2Name)

    def getBody1Name(self) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_getBody1Name(self)

    def getBody2Name(self) -> "std::string const &":
        return _simulation.ExpressionBasedPointToPointForce_getBody2Name(self)

    def setPoint1(self, aPosition: "Vec3") -> "void":
        r"""Force end points"""
        return _simulation.ExpressionBasedPointToPointForce_setPoint1(self, aPosition)

    def getPoint1(self) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedPointToPointForce_getPoint1(self)

    def setPoint2(self, aPosition: "Vec3") -> "void":
        return _simulation.ExpressionBasedPointToPointForce_setPoint2(self, aPosition)

    def getPoint2(self) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedPointToPointForce_getPoint2(self)

    def setExpression(self, expression: "std::string const &") -> "void":
        r"""
        %Set the mathematical expression that defines the force magnitude of this
        point-to-point force in terms of the point-to-point distance (d) and its
        time derivative (ddot). Expressions with C-mathematical operations
        such as +,-,*,/ and common functions: exp, pow, sqrt, sin, cos, tan,
        and so on are acceptable.
        NOTE: a limitation is that the expression may not contain whitespace
        :type expression: string
        :param expression:    string containing the mathematical expression that
                                 defines the point-to-point force
        """
        return _simulation.ExpressionBasedPointToPointForce_setExpression(self, expression)

    def getForceMagnitude(self, state: "State") -> "double const &":
        r"""
        Get the computed Force magnitude determined by evaluating the
        expression above. Note, computeForce must be evaluated first,
        and this is done automatically if the system is realized to Dynamics
        :type state: :py:class:`State`
        :param state:    const state (reference) for the model
        :rtype: float
        :return: const double ref to the force magnitude
        """
        return _simulation.ExpressionBasedPointToPointForce_getForceMagnitude(self, state)

    def computeForce(self, state: "State", bodyForces: "VectorOfSpatialVec", generalizedForces: "Vector") -> "void":
        r"""
        Compute the point-to-point force based on the user-defined expression
               and apply it to the model
        """
        return _simulation.ExpressionBasedPointToPointForce_computeForce(self, state, bodyForces, generalizedForces)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ExpressionBasedPointToPointForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedPointToPointForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedPointToPointForce

# Register ExpressionBasedPointToPointForce in _simulation:
_simulation.ExpressionBasedPointToPointForce_swigregister(ExpressionBasedPointToPointForce)

def ExpressionBasedPointToPointForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedPointToPointForce *":
    return _simulation.ExpressionBasedPointToPointForce_safeDownCast(obj)

def ExpressionBasedPointToPointForce_getClassName() -> "std::string const &":
    return _simulation.ExpressionBasedPointToPointForce_getClassName()

class ExpressionBasedCoordinateForce(Force):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedCoordinateForce *":
        return _simulation.ExpressionBasedCoordinateForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ExpressionBasedCoordinateForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ExpressionBasedCoordinateForce_getClassName()

    def clone(self) -> "OpenSim::ExpressionBasedCoordinateForce *":
        return _simulation.ExpressionBasedCoordinateForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ExpressionBasedCoordinateForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source: "ExpressionBasedCoordinateForce") -> "void":
        return _simulation.ExpressionBasedCoordinateForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedCoordinateForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedCoordinateForce_constructProperty_coordinate(self, initValue)

    def get_coordinate(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedCoordinateForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedCoordinateForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args) -> "void":
        return _simulation.ExpressionBasedCoordinateForce_set_coordinate(self, *args)

    def copyProperty_expression(self, source: "ExpressionBasedCoordinateForce") -> "void":
        return _simulation.ExpressionBasedCoordinateForce_copyProperty_expression(self, source)

    def append_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedCoordinateForce_append_expression(self, value)

    def constructProperty_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedCoordinateForce_constructProperty_expression(self, initValue)

    def get_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedCoordinateForce_get_expression(self, *args)

    def upd_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedCoordinateForce_upd_expression(self, *args)

    def set_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedCoordinateForce_set_expression(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. *

        |

        *Overload 2:*
        Convenience constructor for API users.
           :type coordinate: string
           :param coordinate:   name of the coordinate to apply the force to
           :type expression: string
           :param expression:   the expression used to compute the force magnitude
        """
        _simulation.ExpressionBasedCoordinateForce_swiginit(self, _simulation.new_ExpressionBasedCoordinateForce(*args))

    def setCoordinateName(self, coord: "std::string const &") -> "void":
        r"""Coordinate"""
        return _simulation.ExpressionBasedCoordinateForce_setCoordinateName(self, coord)

    def getCoordinateName(self) -> "std::string const &":
        return _simulation.ExpressionBasedCoordinateForce_getCoordinateName(self)

    def setExpression(self, expression: "std::string const &") -> "void":
        r"""
        %Set the mathematical expression that defines the force magnitude of this
        coordinate force in terms of the coordinate value (q) and its
        time derivative (qdot). Expressions with C-mathematical operations
        such as +,-,*,/ and common functions: exp, pow, sqrt, sin, cos, tan,
        and so on are acceptable.
        NOTE: a limitation is that the expression may not contain whitespace
        :type expression: string
        :param expression:    string containing the mathematical expression that
                                 defines the coordinate force
        """
        return _simulation.ExpressionBasedCoordinateForce_setExpression(self, expression)

    def getForceMagnitude(self, state: "State") -> "double const &":
        r"""
        Get the computed Force magnitude determined by evaluating the
        expression above. Note, computeForce must be evaluated first,
        and this is done automatically if the system is realized to Dynamics
        :type state: :py:class:`State`
        :param state:    const state (reference) for the model
        :rtype: float
        :return: const double ref to the force magnitude
        """
        return _simulation.ExpressionBasedCoordinateForce_getForceMagnitude(self, state)

    def computeForce(self, state: "State", bodyForces: "VectorOfSpatialVec", generalizedForces: "Vector") -> "void":
        r"""
        Compute the coordinate force based on the user-defined expression
               and apply it to the model
        """
        return _simulation.ExpressionBasedCoordinateForce_computeForce(self, state, bodyForces, generalizedForces)

    def calcExpressionForce(self, s: "State") -> "double":
        r""" Force calculation operator. *"""
        return _simulation.ExpressionBasedCoordinateForce_calcExpressionForce(self, s)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""Provide name(s) of the quantities (column labels) of the force value(s) to be reported"""
        return _simulation.ExpressionBasedCoordinateForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedCoordinateForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedCoordinateForce

# Register ExpressionBasedCoordinateForce in _simulation:
_simulation.ExpressionBasedCoordinateForce_swigregister(ExpressionBasedCoordinateForce)

def ExpressionBasedCoordinateForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedCoordinateForce *":
    return _simulation.ExpressionBasedCoordinateForce_safeDownCast(obj)

def ExpressionBasedCoordinateForce_getClassName() -> "std::string const &":
    return _simulation.ExpressionBasedCoordinateForce_getClassName()

class PathSpring(Force):
    r"""
    A class implementing a PathSpring. The path of the PathSpring is
    determined by a GeometryPath object. A PathSpring is a massless Force
    element which applies tension along a path connected to bodies and can wrap
    over surfaces.  The tension is proportional to its stretch beyond its
    resting length and the amount of dissipation scales with amount of stretch,
    such that tension = (K*s)*(1+D*ldot) where stretch, s = l-lo for l > lo, and
    0 otherwise. l is the path length of the spring and lo is its rest length.
    K is the linear stiffness and D is the dissipation factor.
    When l < lo the spring applies no tension to the bodies and considered
    to be slack.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathSpring *":
        return _simulation.PathSpring_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PathSpring_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PathSpring_getClassName()

    def clone(self) -> "OpenSim::PathSpring *":
        return _simulation.PathSpring_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PathSpring_getConcreteClassName(self)

    def copyProperty_resting_length(self, source: "PathSpring") -> "void":
        return _simulation.PathSpring_copyProperty_resting_length(self, source)

    def append_resting_length(self, value: "double const &") -> "int":
        return _simulation.PathSpring_append_resting_length(self, value)

    def constructProperty_resting_length(self, initValue: "double const &") -> "void":
        return _simulation.PathSpring_constructProperty_resting_length(self, initValue)

    def get_resting_length(self, *args) -> "double const &":
        return _simulation.PathSpring_get_resting_length(self, *args)

    def upd_resting_length(self, *args) -> "double &":
        return _simulation.PathSpring_upd_resting_length(self, *args)

    def set_resting_length(self, *args) -> "void":
        return _simulation.PathSpring_set_resting_length(self, *args)

    def copyProperty_stiffness(self, source: "PathSpring") -> "void":
        return _simulation.PathSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value: "double const &") -> "int":
        return _simulation.PathSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue: "double const &") -> "void":
        return _simulation.PathSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args) -> "double const &":
        return _simulation.PathSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args) -> "double &":
        return _simulation.PathSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args) -> "void":
        return _simulation.PathSpring_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source: "PathSpring") -> "void":
        return _simulation.PathSpring_copyProperty_dissipation(self, source)

    def append_dissipation(self, value: "double const &") -> "int":
        return _simulation.PathSpring_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue: "double const &") -> "void":
        return _simulation.PathSpring_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args) -> "double const &":
        return _simulation.PathSpring_get_dissipation(self, *args)

    def upd_dissipation(self, *args) -> "double &":
        return _simulation.PathSpring_upd_dissipation(self, *args)

    def set_dissipation(self, *args) -> "void":
        return _simulation.PathSpring_set_dissipation(self, *args)

    def copyProperty_GeometryPath(self, source: "PathSpring") -> "void":
        return _simulation.PathSpring_copyProperty_GeometryPath(self, source)

    def append_GeometryPath(self, value: "GeometryPath") -> "int":
        return _simulation.PathSpring_append_GeometryPath(self, value)

    def constructProperty_GeometryPath(self, initValue: "GeometryPath") -> "void":
        return _simulation.PathSpring_constructProperty_GeometryPath(self, initValue)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.PathSpring_get_GeometryPath(self, *args)

    def upd_GeometryPath(self, *args) -> "OpenSim::GeometryPath &":
        return _simulation.PathSpring_upd_GeometryPath(self, *args)

    def set_GeometryPath(self, *args) -> "void":
        return _simulation.PathSpring_set_GeometryPath(self, *args)
    _has_output_length = property(_simulation.PathSpring__has_output_length_get, _simulation.PathSpring__has_output_length_set)
    _has_output_stretch = property(_simulation.PathSpring__has_output_stretch_get, _simulation.PathSpring__has_output_stretch_set)
    _has_output_lengthening_speed = property(_simulation.PathSpring__has_output_lengthening_speed_get, _simulation.PathSpring__has_output_lengthening_speed_set)
    _has_output_tension = property(_simulation.PathSpring__has_output_tension_get, _simulation.PathSpring__has_output_tension_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a PathSpring with default parameters. Users should note
            that the default values for resting_length, stiffness, and dissipation
            are `NaN` so they must be set before simulating.

        |

        *Overload 2:*
         Convenience constructor with PathSpring parameters
        :type name: string
        :param name:          name of this %PathSpring Object
        :type restLength: float
        :param restLength:    the spring's resting length
        :type stiffness: float
        :param stiffness:     the spring stiffness
        :type dissipation: float
        :param dissipation:   the dissipation factor
        """
        _simulation.PathSpring_swiginit(self, _simulation.new_PathSpring(*args))

    def getRestingLength(self) -> "double":
        r""" get/set the resting length"""
        return _simulation.PathSpring_getRestingLength(self)

    def setRestingLength(self, restingLength: "double") -> "void":
        return _simulation.PathSpring_setRestingLength(self, restingLength)

    def getStiffness(self) -> "double":
        r""" get/set the stiffness"""
        return _simulation.PathSpring_getStiffness(self)

    def setStiffness(self, stiffness: "double") -> "void":
        return _simulation.PathSpring_setStiffness(self, stiffness)

    def getDissipation(self) -> "double":
        r""" get/set the dissipation factor"""
        return _simulation.PathSpring_getDissipation(self)

    def setDissipation(self, dissipation: "double") -> "void":
        return _simulation.PathSpring_setDissipation(self, dissipation)

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        r"""
        Access the GeometryPath to update connection points and
               specify wrap objects the path can interact with.
        """
        return _simulation.PathSpring_getGeometryPath(self)

    def updGeometryPath(self) -> "OpenSim::GeometryPath &":
        return _simulation.PathSpring_updGeometryPath(self)

    def getLength(self, s: "State") -> "double":
        r""" get the length of the PathSpring. Accessible at Stage::Position"""
        return _simulation.PathSpring_getLength(self, s)

    def getStretch(self, s: "State") -> "double":
        r"""
        get the stretch in the PathSpring. The value of the stretch
               can only be obtained after the system as be realized to Stage::Position
        """
        return _simulation.PathSpring_getStretch(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        r""" get the length of the PathSpring. Accessible at Stage::Velocity"""
        return _simulation.PathSpring_getLengtheningSpeed(self, s)

    def getTension(self, s: "State") -> "double":
        r"""
        get the tension generated by the PathSpring. The value of the tension
               can only be obtained after the system as be realized to Stage::Dynamics
        """
        return _simulation.PathSpring_getTension(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        r""" compute the moment-arm of the PathSpring about a coordinate of interest."""
        return _simulation.PathSpring_computeMomentArm(self, s, aCoord)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Adjust the resting length of the path spring after the model has been
               scaled. The `resting_length` property is multiplied by the quotient of
               the current path length and the path length before scaling.
        """
        return _simulation.PathSpring_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_PathSpring

# Register PathSpring in _simulation:
_simulation.PathSpring_swigregister(PathSpring)

def PathSpring_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PathSpring *":
    return _simulation.PathSpring_safeDownCast(obj)

def PathSpring_getClassName() -> "std::string const &":
    return _simulation.PathSpring_getClassName()

class BushingForce(TwoFrameLinkerForce):
    r"""
    A class implementing a Bushing Force.
    A Bushing Force is the force proportional to the deviation of two frames.
    One can think of the Bushing as being composed of 3 linear and 3 torsional
    spring-dampers, which act along or about the bushing frames. Orientations
    are measured as x-y-z body-fixed Euler rotations, which are treated as
    though they were uncoupled. Damping is proportional to the deflection rate of
    change (e.g. Euler angle derivatives) which is NOT the angular velocity between
    the two frames. That makes this bushing model suitable only for relatively
    small relative orientation deviations between the frames.
    The underlying Force in Simbody is a SimtK::Force::LinearBushing.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BushingForce *":
        return _simulation.BushingForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BushingForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BushingForce_getClassName()

    def clone(self) -> "OpenSim::BushingForce *":
        return _simulation.BushingForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BushingForce_getConcreteClassName(self)

    def copyProperty_rotational_stiffness(self, source: "BushingForce") -> "void":
        return _simulation.BushingForce_copyProperty_rotational_stiffness(self, source)

    def append_rotational_stiffness(self, value: "Vec3") -> "int":
        return _simulation.BushingForce_append_rotational_stiffness(self, value)

    def constructProperty_rotational_stiffness(self, initValue: "Vec3") -> "void":
        return _simulation.BushingForce_constructProperty_rotational_stiffness(self, initValue)

    def get_rotational_stiffness(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.BushingForce_get_rotational_stiffness(self, *args)

    def upd_rotational_stiffness(self, *args) -> "SimTK::Vec3 &":
        return _simulation.BushingForce_upd_rotational_stiffness(self, *args)

    def set_rotational_stiffness(self, *args) -> "void":
        return _simulation.BushingForce_set_rotational_stiffness(self, *args)

    def copyProperty_translational_stiffness(self, source: "BushingForce") -> "void":
        return _simulation.BushingForce_copyProperty_translational_stiffness(self, source)

    def append_translational_stiffness(self, value: "Vec3") -> "int":
        return _simulation.BushingForce_append_translational_stiffness(self, value)

    def constructProperty_translational_stiffness(self, initValue: "Vec3") -> "void":
        return _simulation.BushingForce_constructProperty_translational_stiffness(self, initValue)

    def get_translational_stiffness(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.BushingForce_get_translational_stiffness(self, *args)

    def upd_translational_stiffness(self, *args) -> "SimTK::Vec3 &":
        return _simulation.BushingForce_upd_translational_stiffness(self, *args)

    def set_translational_stiffness(self, *args) -> "void":
        return _simulation.BushingForce_set_translational_stiffness(self, *args)

    def copyProperty_rotational_damping(self, source: "BushingForce") -> "void":
        return _simulation.BushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value: "Vec3") -> "int":
        return _simulation.BushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.BushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.BushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.BushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args) -> "void":
        return _simulation.BushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source: "BushingForce") -> "void":
        return _simulation.BushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value: "Vec3") -> "int":
        return _simulation.BushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.BushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.BushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.BushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args) -> "void":
        return _simulation.BushingForce_set_translational_damping(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves frames unspecified and sets all bushing
                stiffness and damping properties to zero. *

        |

        *Overload 2:*
         Convenience Constructor.
            Create a BushingForce between two PhysicalFrames, frame1 and frame2.
            :type name: string, in
            :param name:         the name of this BushingForce
            :type frame1: :py:class:`PhysicalFrame`, in
            :param frame1:       the bushing's first PhysicalFrame
            :type frame2: :py:class:`PhysicalFrame`, in
            :param frame2:       the bushing's second PhysicalFrame

        |

        *Overload 3:*
         Convenience Constructor.
            Create a BushingForce between two PhysicalFrames, frame1 and frame2.
            :type name: string, in
            :param name:         the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:   the name of the bushing's first PhysicalFrame
            :type frame2Name: string, in
            :param frame2Name:   the name of the bushing's second PhysicalFrame

        |

        *Overload 4:*
         Construct a BushingForce given physical frames that it
        tries to keep aligned by generating a passive force according to the
        physical properties of the bushing. See property declarations for more
        information.

        |

        *Overload 5:*
         Construct a BushingForce given the names of physical frames that it
        tries to keep aligned by generating a passive force according to the
        physical properties of the bushing. See property declarations for more
        information.

        |

        *Overload 6:*
         Convenience Constructor
            Construct a BushingForce between two frames with offset transforms on the
            respective frames.

            :type name: string, in
            :param name:              the name of this BushingForce
            :type frame1: :py:class:`PhysicalFrame`, in
            :param frame1:            first PhysicalFrame that the bushing connects
            :type transformInFrame1: :py:class:`Transform`, in
            :param transformInFrame1: offset Transform on the first frame
            :type frame2: :py:class:`PhysicalFrame`, in
            :param frame2:            second PhysicalFrame that the bushing connects
            :type transformInFrame2: :py:class:`Transform`, in
            :param transformInFrame2: offset Transform on the second frame
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:    translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:      rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:      translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:        rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping

        |

        *Overload 7:*
         Convenience Constructor
            Construct a BushingForce where the two frames are specified by the name
            and offset transforms on the respective frames.

            :type name: string, in
            :param name:              the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:        first PhysicalFrame that the bushing connects
            :type transformInFrame1: :py:class:`Transform`, in
            :param transformInFrame1: offset Transform on the first frame
            :type frame2Name: string, in
            :param frame2Name:        second PhysicalFrame that the bushing connects
            :type transformInFrame2: :py:class:`Transform`, in
            :param transformInFrame2: offset Transform on the second frame
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:    translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:      rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:      translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:        rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping

        |

        *Overload 8:*
         Backwards compatible Convenience Constructor
            Construct a BushingForce where the bushing frames are specified in terms of their
            location and orientation in their respective PhysicalFrames and passive force
            defined by the physical properties of the bushing. See property declarations
            for more information.
            :type name: string, in
            :param name:                the name of this BushingForce
            :type frame1Name: string, in
            :param frame1Name:          name of the first PhysicalFrame of the bushing
            :type locationInFrame1: :py:class:`Vec3`, in
            :param locationInFrame1:    Vec3 location of the bushing in the first frame
            :type orientationInFrame1: :py:class:`Vec3`, in
            :param orientationInFrame1: Vec3 of the XYZ body-fixed Euler angles of the
                                               bushing frame orientation in frame 1.
            :type frame2Name: string, in
            :param frame2Name:          name of the second PhysicalFrame of the bushing
            :type locationInFrame2: :py:class:`Vec3`, in
            :param locationInFrame2:    Vec3 location of the weld in the second frame
            :type orientationInFrame2: :py:class:`Vec3`, in
            :param orientationInFrame2: Vec3 of the XYZ body-fixed Euler angles of the
                                               bushing frame orientation in frame2.
            :type transStiffness: :py:class:`Vec3`, in
            :param transStiffness:      translational (dx, dy, dz) stiffnesses
            :type rotStiffness: :py:class:`Vec3`, in
            :param rotStiffness:        rotational (dq_x, dq_y, dq_z) stiffnesses
            :type transDamping: :py:class:`Vec3`, in
            :param transDamping:        translational (dx/dt, dy/dt, dz/dt) damping
            :type rotDamping: :py:class:`Vec3`, in
            :param rotDamping:          rotational (dq_x/dt, dq_y/dt, dq_z/dt) damping
        """
        _simulation.BushingForce_swiginit(self, _simulation.new_BushingForce(*args))

    def computePotentialEnergy(self, s: "State") -> "double":
        r""" Potential energy is the elastic energy stored in the bushing."""
        return _simulation.BushingForce_computePotentialEnergy(self, s)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.BushingForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.BushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_BushingForce

# Register BushingForce in _simulation:
_simulation.BushingForce_swigregister(BushingForce)

def BushingForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BushingForce *":
    return _simulation.BushingForce_safeDownCast(obj)

def BushingForce_getClassName() -> "std::string const &":
    return _simulation.BushingForce_getClassName()

class FunctionBasedBushingForce(TwoFrameLinkerForce):
    r"""
    A class implementing a bushing force specified by functions of the frame
    deflections. These functions are user specified and can be used to capture
    the nonlinearities of biologic structures.  This FunctionBasedBushing
    does not capture coupling between the deflections (e.g. force in x due to
    rotation about z).

    A bushing force is the resistive force due to deviation between two frames.
    One can think of the Bushing as being composed of 3 translational and 3
    torsional spring-dampers, which act along or about the bushing frame axes.
    Orientations are measured as x-y-z body-fixed Euler rotations.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FunctionBasedBushingForce *":
        return _simulation.FunctionBasedBushingForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FunctionBasedBushingForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FunctionBasedBushingForce_getClassName()

    def clone(self) -> "OpenSim::FunctionBasedBushingForce *":
        return _simulation.FunctionBasedBushingForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FunctionBasedBushingForce_getConcreteClassName(self)

    def copyProperty_m_x_theta_x_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_m_x_theta_x_function(self, source)

    def append_m_x_theta_x_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_m_x_theta_x_function(self, value)

    def constructProperty_m_x_theta_x_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_m_x_theta_x_function(self, *args)

    def get_m_x_theta_x_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_m_x_theta_x_function(self, *args)

    def upd_m_x_theta_x_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_m_x_theta_x_function(self, *args)

    def set_m_x_theta_x_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_m_x_theta_x_function(self, *args)

    def copyProperty_m_y_theta_y_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_m_y_theta_y_function(self, source)

    def append_m_y_theta_y_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_m_y_theta_y_function(self, value)

    def constructProperty_m_y_theta_y_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_m_y_theta_y_function(self, *args)

    def get_m_y_theta_y_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_m_y_theta_y_function(self, *args)

    def upd_m_y_theta_y_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_m_y_theta_y_function(self, *args)

    def set_m_y_theta_y_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_m_y_theta_y_function(self, *args)

    def copyProperty_m_z_theta_z_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_m_z_theta_z_function(self, source)

    def append_m_z_theta_z_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_m_z_theta_z_function(self, value)

    def constructProperty_m_z_theta_z_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_m_z_theta_z_function(self, *args)

    def get_m_z_theta_z_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_m_z_theta_z_function(self, *args)

    def upd_m_z_theta_z_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_m_z_theta_z_function(self, *args)

    def set_m_z_theta_z_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_m_z_theta_z_function(self, *args)

    def copyProperty_f_x_delta_x_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_f_x_delta_x_function(self, source)

    def append_f_x_delta_x_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_f_x_delta_x_function(self, value)

    def constructProperty_f_x_delta_x_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_f_x_delta_x_function(self, *args)

    def get_f_x_delta_x_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_f_x_delta_x_function(self, *args)

    def upd_f_x_delta_x_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_f_x_delta_x_function(self, *args)

    def set_f_x_delta_x_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_f_x_delta_x_function(self, *args)

    def copyProperty_f_y_delta_y_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_f_y_delta_y_function(self, source)

    def append_f_y_delta_y_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_f_y_delta_y_function(self, value)

    def constructProperty_f_y_delta_y_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_f_y_delta_y_function(self, *args)

    def get_f_y_delta_y_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_f_y_delta_y_function(self, *args)

    def upd_f_y_delta_y_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_f_y_delta_y_function(self, *args)

    def set_f_y_delta_y_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_f_y_delta_y_function(self, *args)

    def copyProperty_f_z_delta_z_function(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_f_z_delta_z_function(self, source)

    def append_f_z_delta_z_function(self, value: "Function") -> "int":
        return _simulation.FunctionBasedBushingForce_append_f_z_delta_z_function(self, value)

    def constructProperty_f_z_delta_z_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_f_z_delta_z_function(self, *args)

    def get_f_z_delta_z_function(self, *args) -> "OpenSim::Function const &":
        return _simulation.FunctionBasedBushingForce_get_f_z_delta_z_function(self, *args)

    def upd_f_z_delta_z_function(self, *args) -> "OpenSim::Function &":
        return _simulation.FunctionBasedBushingForce_upd_f_z_delta_z_function(self, *args)

    def set_f_z_delta_z_function(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_f_z_delta_z_function(self, *args)

    def copyProperty_visual_aspect_ratio(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_visual_aspect_ratio(self, source)

    def append_visual_aspect_ratio(self, value: "double const &") -> "int":
        return _simulation.FunctionBasedBushingForce_append_visual_aspect_ratio(self, value)

    def constructProperty_visual_aspect_ratio(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_visual_aspect_ratio(self, *args)

    def get_visual_aspect_ratio(self, *args) -> "double const &":
        return _simulation.FunctionBasedBushingForce_get_visual_aspect_ratio(self, *args)

    def upd_visual_aspect_ratio(self, *args) -> "double &":
        return _simulation.FunctionBasedBushingForce_upd_visual_aspect_ratio(self, *args)

    def set_visual_aspect_ratio(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_visual_aspect_ratio(self, *args)

    def copyProperty_moment_visual_scale(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_moment_visual_scale(self, source)

    def append_moment_visual_scale(self, value: "double const &") -> "int":
        return _simulation.FunctionBasedBushingForce_append_moment_visual_scale(self, value)

    def constructProperty_moment_visual_scale(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_moment_visual_scale(self, *args)

    def get_moment_visual_scale(self, *args) -> "double const &":
        return _simulation.FunctionBasedBushingForce_get_moment_visual_scale(self, *args)

    def upd_moment_visual_scale(self, *args) -> "double &":
        return _simulation.FunctionBasedBushingForce_upd_moment_visual_scale(self, *args)

    def set_moment_visual_scale(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_moment_visual_scale(self, *args)

    def copyProperty_force_visual_scale(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_force_visual_scale(self, source)

    def append_force_visual_scale(self, value: "double const &") -> "int":
        return _simulation.FunctionBasedBushingForce_append_force_visual_scale(self, value)

    def constructProperty_force_visual_scale(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_force_visual_scale(self, *args)

    def get_force_visual_scale(self, *args) -> "double const &":
        return _simulation.FunctionBasedBushingForce_get_force_visual_scale(self, *args)

    def upd_force_visual_scale(self, *args) -> "double &":
        return _simulation.FunctionBasedBushingForce_upd_force_visual_scale(self, *args)

    def set_force_visual_scale(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_force_visual_scale(self, *args)

    def copyProperty_rotational_damping(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value: "Vec3") -> "int":
        return _simulation.FunctionBasedBushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.FunctionBasedBushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.FunctionBasedBushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source: "FunctionBasedBushingForce") -> "void":
        return _simulation.FunctionBasedBushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value: "Vec3") -> "int":
        return _simulation.FunctionBasedBushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.FunctionBasedBushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.FunctionBasedBushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.FunctionBasedBushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args) -> "void":
        return _simulation.FunctionBasedBushingForce_set_translational_damping(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves bodies unspecified, sets the bushing frames
        to be at their body origins, and sets all bushing parameters to zero. *

        |

        *Overload 2:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 3:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero. The frames are
        specified by name (path). *

        |

        *Overload 4:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*

        |

        *Overload 5:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles. The frames are specified by name (path). *
        """
        _simulation.FunctionBasedBushingForce_swiginit(self, _simulation.new_FunctionBasedBushingForce(*args))

    def setMomentVisualScale(self, scale: "double") -> "void":
        r"""
         Set the value used to scale the bushing moment on body2 when drawing it to screen.
        A moment of magnitude |M| will be drawn on screen with a length of (|M|*scale).  *
        """
        return _simulation.FunctionBasedBushingForce_setMomentVisualScale(self, scale)

    def setForceVisualScale(self, scale: "double") -> "void":
        r"""
         Set the value used to scale the bushing force on body2 when drawing it to screen.
        A force of magnitude |F| will be drawn on screen with a length of (|F|*scale).  *
        """
        return _simulation.FunctionBasedBushingForce_setForceVisualScale(self, scale)

    def setVisualAspectRatio(self, ratio: "double") -> "void":
        r"""
        Set the aspect ratio used to control the thickness of the bushing force and moment
               in drawn in the visualizer.  ratio = length/diameter.
        """
        return _simulation.FunctionBasedBushingForce_setVisualAspectRatio(self, ratio)

    def extendFinalizeFromProperties(self) -> "void":
        r""" Component interface."""
        return _simulation.FunctionBasedBushingForce_extendFinalizeFromProperties(self)

    def calcStiffnessForce(self, state: "State") -> "SimTK::Vec6":
        r"""
        Calculate the bushing force contribution due to its stiffness. This is
           a function of the deflection between the bushing frames. It is the force
           on frame2 from frame1 in the basis of the deflection (dq).
        """
        return _simulation.FunctionBasedBushingForce_calcStiffnessForce(self, state)

    def calcDampingForce(self, state: "State") -> "SimTK::Vec6":
        r"""
        Calculate the bushing force contribution due to its damping. This is a
           function of the deflection rate between the bushing frames. It is the
           force on frame2 from frame1 in the basis of the deflection rate (dqdot).
        """
        return _simulation.FunctionBasedBushingForce_calcDampingForce(self, state)

    def computeForce(self, s: "State", bodyForces: "VectorOfSpatialVec", generalizedForces: "Vector") -> "void":
        r"""
         Compute the bushing force contribution to the system and add in to appropriate
        bodyForce and/or system generalizedForce.
        """
        return _simulation.FunctionBasedBushingForce_computeForce(self, s, bodyForces, generalizedForces)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.FunctionBasedBushingForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.FunctionBasedBushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_FunctionBasedBushingForce

# Register FunctionBasedBushingForce in _simulation:
_simulation.FunctionBasedBushingForce_swigregister(FunctionBasedBushingForce)

def FunctionBasedBushingForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FunctionBasedBushingForce *":
    return _simulation.FunctionBasedBushingForce_safeDownCast(obj)

def FunctionBasedBushingForce_getClassName() -> "std::string const &":
    return _simulation.FunctionBasedBushingForce_getClassName()

class ExpressionBasedBushingForce(TwoFrameLinkerForce):
    r"""
    A class implementing a bushing force specified by expressions of the
    deflection between two bushing frames. These expressions are user specified
    as strings that are interpreted during a simulation.
    Each expression is a function of the bushing's rotational deflections
    (theta_x, theta_y, theta_z) and translational deflections, (delta_x, delta_y,
    delta_z). These user defined expressions can capture nonlinearities and
    coupling common in biologic structures.

    A bushing force is the resistive force due to defection between two frames.
    One can think of the Bushing as being composed of 3 translational and 3
    torsional spring-dampers, which act along or about the bushing frame axes.
    Orientations are measured as x-y-z body-fixed Euler rotations.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedBushingForce *":
        return _simulation.ExpressionBasedBushingForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ExpressionBasedBushingForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_getClassName()

    def clone(self) -> "OpenSim::ExpressionBasedBushingForce *":
        return _simulation.ExpressionBasedBushingForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_getConcreteClassName(self)

    def copyProperty_Mx_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_Mx_expression(self, source)

    def append_Mx_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_Mx_expression(self, value)

    def constructProperty_Mx_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_Mx_expression(self, initValue)

    def get_Mx_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_Mx_expression(self, *args)

    def upd_Mx_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_Mx_expression(self, *args)

    def set_Mx_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_Mx_expression(self, *args)

    def copyProperty_My_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_My_expression(self, source)

    def append_My_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_My_expression(self, value)

    def constructProperty_My_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_My_expression(self, initValue)

    def get_My_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_My_expression(self, *args)

    def upd_My_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_My_expression(self, *args)

    def set_My_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_My_expression(self, *args)

    def copyProperty_Mz_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_Mz_expression(self, source)

    def append_Mz_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_Mz_expression(self, value)

    def constructProperty_Mz_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_Mz_expression(self, initValue)

    def get_Mz_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_Mz_expression(self, *args)

    def upd_Mz_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_Mz_expression(self, *args)

    def set_Mz_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_Mz_expression(self, *args)

    def copyProperty_Fx_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fx_expression(self, source)

    def append_Fx_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_Fx_expression(self, value)

    def constructProperty_Fx_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fx_expression(self, initValue)

    def get_Fx_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_Fx_expression(self, *args)

    def upd_Fx_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_Fx_expression(self, *args)

    def set_Fx_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_Fx_expression(self, *args)

    def copyProperty_Fy_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fy_expression(self, source)

    def append_Fy_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_Fy_expression(self, value)

    def constructProperty_Fy_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fy_expression(self, initValue)

    def get_Fy_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_Fy_expression(self, *args)

    def upd_Fy_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_Fy_expression(self, *args)

    def set_Fy_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_Fy_expression(self, *args)

    def copyProperty_Fz_expression(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_Fz_expression(self, source)

    def append_Fz_expression(self, value: "std::string const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_Fz_expression(self, value)

    def constructProperty_Fz_expression(self, initValue: "std::string const &") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_Fz_expression(self, initValue)

    def get_Fz_expression(self, *args) -> "std::string const &":
        return _simulation.ExpressionBasedBushingForce_get_Fz_expression(self, *args)

    def upd_Fz_expression(self, *args) -> "std::string &":
        return _simulation.ExpressionBasedBushingForce_upd_Fz_expression(self, *args)

    def set_Fz_expression(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_Fz_expression(self, *args)

    def copyProperty_visual_aspect_ratio(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_visual_aspect_ratio(self, source)

    def append_visual_aspect_ratio(self, value: "double const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_visual_aspect_ratio(self, value)

    def constructProperty_visual_aspect_ratio(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_visual_aspect_ratio(self, *args)

    def get_visual_aspect_ratio(self, *args) -> "double const &":
        return _simulation.ExpressionBasedBushingForce_get_visual_aspect_ratio(self, *args)

    def upd_visual_aspect_ratio(self, *args) -> "double &":
        return _simulation.ExpressionBasedBushingForce_upd_visual_aspect_ratio(self, *args)

    def set_visual_aspect_ratio(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_visual_aspect_ratio(self, *args)

    def copyProperty_moment_visual_scale(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_moment_visual_scale(self, source)

    def append_moment_visual_scale(self, value: "double const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_moment_visual_scale(self, value)

    def constructProperty_moment_visual_scale(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_moment_visual_scale(self, *args)

    def get_moment_visual_scale(self, *args) -> "double const &":
        return _simulation.ExpressionBasedBushingForce_get_moment_visual_scale(self, *args)

    def upd_moment_visual_scale(self, *args) -> "double &":
        return _simulation.ExpressionBasedBushingForce_upd_moment_visual_scale(self, *args)

    def set_moment_visual_scale(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_moment_visual_scale(self, *args)

    def copyProperty_force_visual_scale(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_force_visual_scale(self, source)

    def append_force_visual_scale(self, value: "double const &") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_force_visual_scale(self, value)

    def constructProperty_force_visual_scale(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_force_visual_scale(self, *args)

    def get_force_visual_scale(self, *args) -> "double const &":
        return _simulation.ExpressionBasedBushingForce_get_force_visual_scale(self, *args)

    def upd_force_visual_scale(self, *args) -> "double &":
        return _simulation.ExpressionBasedBushingForce_upd_force_visual_scale(self, *args)

    def set_force_visual_scale(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_force_visual_scale(self, *args)

    def copyProperty_rotational_damping(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_rotational_damping(self, source)

    def append_rotational_damping(self, value: "Vec3") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_rotational_damping(self, value)

    def constructProperty_rotational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_rotational_damping(self, initValue)

    def get_rotational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedBushingForce_get_rotational_damping(self, *args)

    def upd_rotational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ExpressionBasedBushingForce_upd_rotational_damping(self, *args)

    def set_rotational_damping(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_rotational_damping(self, *args)

    def copyProperty_translational_damping(self, source: "ExpressionBasedBushingForce") -> "void":
        return _simulation.ExpressionBasedBushingForce_copyProperty_translational_damping(self, source)

    def append_translational_damping(self, value: "Vec3") -> "int":
        return _simulation.ExpressionBasedBushingForce_append_translational_damping(self, value)

    def constructProperty_translational_damping(self, initValue: "Vec3") -> "void":
        return _simulation.ExpressionBasedBushingForce_constructProperty_translational_damping(self, initValue)

    def get_translational_damping(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.ExpressionBasedBushingForce_get_translational_damping(self, *args)

    def upd_translational_damping(self, *args) -> "SimTK::Vec3 &":
        return _simulation.ExpressionBasedBushingForce_upd_translational_damping(self, *args)

    def set_translational_damping(self, *args) -> "void":
        return _simulation.ExpressionBasedBushingForce_set_translational_damping(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor leaves bodies unspecified, sets the bushing frames
        to be at their body origins, and sets all bushing parameters to zero. *

        |

        *Overload 2:*
         This convenience constructor sets the bushing frames and sets all
        bushing functions to zero.  *

        |

        *Overload 3:*
         This convenience constructor defines and sets the bushing frames by name
        and sets all bushing functions to zero.  *

        |

        *Overload 4:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 5:*
         This convenience constructor defines and sets the bushing frames on
        each body, and sets all bushing functions to zero.  *

        |

        *Overload 6:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*

        |

        *Overload 7:*
         This convenience constructor defines a bushing that behaves like a
        primitive bushing.  Stiffnesses are used to define linear functions for
        force deflection profiles.*
        """
        _simulation.ExpressionBasedBushingForce_swiginit(self, _simulation.new_ExpressionBasedBushingForce(*args))

    def setMomentVisualScale(self, scale: "double") -> "void":
        r"""
        Set the value used to scale the bushing moment on body2 when drawing it to
               screen. A moment of magnitude |M| will be drawn on screen with a length of
               (|M|*scale).  *
        """
        return _simulation.ExpressionBasedBushingForce_setMomentVisualScale(self, scale)

    def setForceVisualScale(self, scale: "double") -> "void":
        r"""
        Set the value used to scale the bushing force on body2 when drawing it to
               screen. A force of magnitude |F| will be drawn on screen with a length of
               (|F|*scale).  *
        """
        return _simulation.ExpressionBasedBushingForce_setForceVisualScale(self, scale)

    def setVisualAspectRatio(self, ratio: "double") -> "void":
        r"""
        Set the aspect ratio used to control the thickness of the bushing force
               and moment in drawn in the visualizer.  ratio = length/diameter.*
        """
        return _simulation.ExpressionBasedBushingForce_setVisualAspectRatio(self, ratio)

    def setMxExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining Mx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMxExpression(self, expression)

    def setMyExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining My as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMyExpression(self, expression)

    def setMzExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining Mz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setMzExpression(self, expression)

    def setFxExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining Fx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFxExpression(self, expression)

    def setFyExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining Fy as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFyExpression(self, expression)

    def setFzExpression(self, expression: "std::string") -> "void":
        r"""
        Set the expression defining Fz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_setFzExpression(self, expression)

    def getMxExpression(self) -> "std::string":
        r"""
        Get the expression defining Mx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMxExpression(self)

    def getMyExpression(self) -> "std::string":
        r"""
        Get the expression defining My as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMyExpression(self)

    def getMzExpression(self) -> "std::string":
        r"""
        Get the expression defining Mz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getMzExpression(self)

    def getFxExpression(self) -> "std::string":
        r"""
        Get the expression defining Fx as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFxExpression(self)

    def getFyExpression(self) -> "std::string":
        r"""
        Get the expression defining Fy as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFyExpression(self)

    def getFzExpression(self) -> "std::string":
        r"""
        Get the expression defining Fz as a function of the bushing deflections
               theta_x, theta_y, theta_z, delta_x, delta_y, delta_z *
        """
        return _simulation.ExpressionBasedBushingForce_getFzExpression(self)

    def calcStiffnessForce(self, state: "State") -> "SimTK::Vec6":
        r"""
        Calculate the bushing force contribution due to its stiffness. This is
               a function of the deflection between the bushing frames. It is the force
               on frame2 from frame1 in the basis of the deflection (dq).
        """
        return _simulation.ExpressionBasedBushingForce_calcStiffnessForce(self, state)

    def calcDampingForce(self, state: "State") -> "SimTK::Vec6":
        r"""
        Calculate the bushing force contribution due to its damping. This is a
               function of the deflection rate between the bushing frames. It is the
               force on frame2 from frame1 in the basis of the deflection rate (dqdot).
        """
        return _simulation.ExpressionBasedBushingForce_calcDampingForce(self, state)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Provide name(s) of the quantities (column labels) of the force value(s)
        to be reported.
        """
        return _simulation.ExpressionBasedBushingForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r""" Provide the value(s) to be reported that correspond to the labels"""
        return _simulation.ExpressionBasedBushingForce_getRecordValues(self, state)
    __swig_destroy__ = _simulation.delete_ExpressionBasedBushingForce

# Register ExpressionBasedBushingForce in _simulation:
_simulation.ExpressionBasedBushingForce_swigregister(ExpressionBasedBushingForce)

def ExpressionBasedBushingForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExpressionBasedBushingForce *":
    return _simulation.ExpressionBasedBushingForce_safeDownCast(obj)

def ExpressionBasedBushingForce_getClassName() -> "std::string const &":
    return _simulation.ExpressionBasedBushingForce_getClassName()

class ReferenceVec3(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< SimTK::Vec3 > *":
        return _simulation.ReferenceVec3_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ReferenceVec3_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ReferenceVec3_getClassName()

    def clone(self) -> "OpenSim::Reference_< SimTK::Vec3 > *":
        return _simulation.ReferenceVec3_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ReferenceVec3_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceVec3

    def getNumRefs(self) -> "int":
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceVec3_getNumRefs(self)

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceVec3_getValidTimeRange(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceVec3_getNames(self)

    def hasNext(self) -> "bool":
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceVec3_hasNext(self)

    def getWeights(self, *args) -> "SimTK::Array_< double,unsigned int >":
        return _simulation.ReferenceVec3_getWeights(self, *args)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayVec3") -> "void":
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceVec3_getValuesAtTime(self, time, values)

    def getValues(self, time: "double") -> "SimTK::Array_< SimTK::Vec< 3,double,1 >,unsigned int >":
        return _simulation.ReferenceVec3_getValues(self, time)

# Register ReferenceVec3 in _simulation:
_simulation.ReferenceVec3_swigregister(ReferenceVec3)

def ReferenceVec3_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< SimTK::Vec3 > *":
    return _simulation.ReferenceVec3_safeDownCast(obj)

def ReferenceVec3_getClassName() -> "std::string const &":
    return _simulation.ReferenceVec3_getClassName()

class ReferenceDouble(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< double > *":
        return _simulation.ReferenceDouble_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ReferenceDouble_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ReferenceDouble_getClassName()

    def clone(self) -> "OpenSim::Reference_< double > *":
        return _simulation.ReferenceDouble_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ReferenceDouble_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceDouble

    def getNumRefs(self) -> "int":
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceDouble_getNumRefs(self)

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceDouble_getValidTimeRange(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceDouble_getNames(self)

    def hasNext(self) -> "bool":
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceDouble_hasNext(self)

    def getWeights(self, *args) -> "SimTK::Array_< double,unsigned int >":
        return _simulation.ReferenceDouble_getWeights(self, *args)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayDouble") -> "void":
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceDouble_getValuesAtTime(self, time, values)

    def getValues(self, time: "double") -> "SimTK::Array_< double,unsigned int >":
        return _simulation.ReferenceDouble_getValues(self, time)

# Register ReferenceDouble in _simulation:
_simulation.ReferenceDouble_swigregister(ReferenceDouble)

def ReferenceDouble_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< double > *":
    return _simulation.ReferenceDouble_safeDownCast(obj)

def ReferenceDouble_getClassName() -> "std::string const &":
    return _simulation.ReferenceDouble_getClassName()

class ReferenceRotation(opensim.common.OpenSimObject):
    r"""
    This base (abstract) class defines the interface for a Reference signals to
    be achieved/tracked via optimization and/or tracking controller. Combines
    weightings that identifies the relative importance of achieving one
    Reference value relative to the others. The specific value type is defined
    by the concrete References. For example, a MarkerRefrence is of type Vec3,
    for the 3D location coordinates of a marker. Correspondence with model
    values are established via the Reference names.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< SimTK::Rotation_< double > > *":
        return _simulation.ReferenceRotation_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ReferenceRotation_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ReferenceRotation_getClassName()

    def clone(self) -> "OpenSim::Reference_< SimTK::Rotation_< double > > *":
        return _simulation.ReferenceRotation_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ReferenceRotation_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_ReferenceRotation

    def getNumRefs(self) -> "int":
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.ReferenceRotation_getNumRefs(self)

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which the Reference is valid, which can and will
               be finite if the reference encapsulates experimental data. By default
               they are infinite
        """
        return _simulation.ReferenceRotation_getValidTimeRange(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.ReferenceRotation_getNames(self)

    def hasNext(self) -> "bool":
        r""" Indicate whether this Reference can provide discretized data or not"""
        return _simulation.ReferenceRotation_hasNext(self)

    def getWeights(self, *args) -> "SimTK::Array_< double,unsigned int >":
        return _simulation.ReferenceRotation_getWeights(self, *args)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayRotation") -> "void":
        r"""
        get the values of the Reference signals as a function
           of the passed in time
        """
        return _simulation.ReferenceRotation_getValuesAtTime(self, time, values)

    def getValues(self, time: "double") -> "SimTK::Array_< SimTK::Rotation_< double >,unsigned int >":
        return _simulation.ReferenceRotation_getValues(self, time)

# Register ReferenceRotation in _simulation:
_simulation.ReferenceRotation_swigregister(ReferenceRotation)

def ReferenceRotation_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reference_< SimTK::Rotation_< double > > *":
    return _simulation.ReferenceRotation_safeDownCast(obj)

def ReferenceRotation_getClassName() -> "std::string const &":
    return _simulation.ReferenceRotation_getClassName()

class StreamableReferenceRotation(ReferenceRotation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::StreamableReference_< SimTK::Rotation_< double > > *":
        return _simulation.StreamableReferenceRotation_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.StreamableReferenceRotation_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.StreamableReferenceRotation_getClassName()

    def clone(self) -> "OpenSim::StreamableReference_< SimTK::Rotation_< double > > *":
        return _simulation.StreamableReferenceRotation_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.StreamableReferenceRotation_getConcreteClassName(self)

    def getNextValuesAndTime(self, values: "SimTKArrayRotation") -> "double":
        return _simulation.StreamableReferenceRotation_getNextValuesAndTime(self, values)

    def hasNext(self) -> "bool":
        return _simulation.StreamableReferenceRotation_hasNext(self)
    __swig_destroy__ = _simulation.delete_StreamableReferenceRotation

# Register StreamableReferenceRotation in _simulation:
_simulation.StreamableReferenceRotation_swigregister(StreamableReferenceRotation)

def StreamableReferenceRotation_safeDownCast(obj: "OpenSimObject") -> "OpenSim::StreamableReference_< SimTK::Rotation_< double > > *":
    return _simulation.StreamableReferenceRotation_safeDownCast(obj)

def StreamableReferenceRotation_getClassName() -> "std::string const &":
    return _simulation.StreamableReferenceRotation_getClassName()

class SimTKArrayCoordinateReference(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simulation.SimTKArrayCoordinateReference_swiginit(self, _simulation.new_SimTKArrayCoordinateReference(*args))
    __swig_destroy__ = _simulation.delete_SimTKArrayCoordinateReference

    def deallocate(self) -> "SimTK::Array_< OpenSim::CoordinateReference > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< OpenSim::CoordinateReference >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simulation.SimTKArrayCoordinateReference_deallocate(self)

    def assign(self, n: "SimTK::Array_< OpenSim::CoordinateReference >::size_type", fillValue: "CoordinateReference") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: :py:class:`CoordinateReference`, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simulation.SimTKArrayCoordinateReference_assign(self, n, fillValue)

    def fill(self, fillValue: "CoordinateReference") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: :py:class:`CoordinateReference`, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simulation.SimTKArrayCoordinateReference_fill(self, fillValue)

    def swap(self, other: "SimTKArrayCoordinateReference") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simulation.SimTKArrayCoordinateReference_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< OpenSim::CoordinateReference > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simulation.SimTKArrayCoordinateReference_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< OpenSim::CoordinateReference > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simulation.SimTKArrayCoordinateReference_shareData(self, *args)

    def size(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simulation.SimTKArrayCoordinateReference_size(self)

    def max_size(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simulation.SimTKArrayCoordinateReference_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simulation.SimTKArrayCoordinateReference_empty(self)

    def capacity(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simulation.SimTKArrayCoordinateReference_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simulation.SimTKArrayCoordinateReference_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< OpenSim::CoordinateReference >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simulation.SimTKArrayCoordinateReference_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simulation.SimTKArrayCoordinateReference_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_isOwner(self)

    def cbegin(self) -> "OpenSim::CoordinateReference const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simulation.SimTKArrayCoordinateReference_cbegin(self)

    def begin(self, *args) -> "OpenSim::CoordinateReference *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simulation.SimTKArrayCoordinateReference_begin(self, *args)

    def cend(self) -> "OpenSim::CoordinateReference const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simulation.SimTKArrayCoordinateReference_cend(self)

    def end(self, *args) -> "OpenSim::CoordinateReference *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simulation.SimTKArrayCoordinateReference_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simulation.SimTKArrayCoordinateReference_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< OpenSim::CoordinateReference >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simulation.SimTKArrayCoordinateReference_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< OpenSim::CoordinateReference >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simulation.SimTKArrayCoordinateReference_crend(self)

    def rend(self, *args) -> "SimTK::Array_< OpenSim::CoordinateReference >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simulation.SimTKArrayCoordinateReference_rend(self, *args)

    def cdata(self) -> "OpenSim::CoordinateReference const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simulation.SimTKArrayCoordinateReference_cdata(self)

    def data(self, *args) -> "OpenSim::CoordinateReference *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simulation.SimTKArrayCoordinateReference_data(self, *args)

    def at(self, *args) -> "OpenSim::CoordinateReference &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_at(self, *args)

    def getElt(self, i: "SimTK::Array_< OpenSim::CoordinateReference >::index_type") -> "OpenSim::CoordinateReference const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simulation.SimTKArrayCoordinateReference_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< OpenSim::CoordinateReference >::index_type") -> "OpenSim::CoordinateReference &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simulation.SimTKArrayCoordinateReference_updElt(self, i)

    def front(self, *args) -> "OpenSim::CoordinateReference &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_front(self, *args)

    def back(self, *args) -> "OpenSim::CoordinateReference &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simulation.SimTKArrayCoordinateReference_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: :py:class:`CoordinateReference`, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simulation.SimTKArrayCoordinateReference_push_back(self, *args)

    def raw_push_back(self) -> "OpenSim::CoordinateReference *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simulation.SimTKArrayCoordinateReference_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simulation.SimTKArrayCoordinateReference_pop_back(self)

    def erase(self, *args) -> "OpenSim::CoordinateReference *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: :py:class:`CoordinateReference`
        :param first:
                Points to the first element that will be erased.
        :type last1: :py:class:`CoordinateReference`
        :param last1:
                Points one element past the last element to be erased.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: :py:class:`CoordinateReference`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simulation.SimTKArrayCoordinateReference_erase(self, *args)

    def eraseFast(self, p: "CoordinateReference") -> "OpenSim::CoordinateReference *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: :py:class:`CoordinateReference`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simulation.SimTKArrayCoordinateReference_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simulation.SimTKArrayCoordinateReference_clear(self)

    def insert(self, *args) -> "OpenSim::CoordinateReference *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: :py:class:`CoordinateReference`, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: :py:class:`CoordinateReference`, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: :py:class:`CoordinateReference`
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simulation.SimTKArrayCoordinateReference_insert(self, *args)

# Register SimTKArrayCoordinateReference in _simulation:
_simulation.SimTKArrayCoordinateReference_swigregister(SimTKArrayCoordinateReference)

class UnsupportedFileType(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", msg: "std::string const &"):
        _simulation.UnsupportedFileType_swiginit(self, _simulation.new_UnsupportedFileType(file, line, func, filename, msg))
    __swig_destroy__ = _simulation.delete_UnsupportedFileType

# Register UnsupportedFileType in _simulation:
_simulation.UnsupportedFileType_swigregister(UnsupportedFileType)

class MarkerWeight(opensim.common.OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerWeight *":
        return _simulation.MarkerWeight_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MarkerWeight_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MarkerWeight_getClassName()

    def clone(self) -> "OpenSim::MarkerWeight *":
        return _simulation.MarkerWeight_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MarkerWeight_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.MarkerWeight_swiginit(self, _simulation.new_MarkerWeight(*args))

    def setWeight(self, weight: "double") -> "void":
        return _simulation.MarkerWeight_setWeight(self, weight)

    def getWeight(self) -> "double":
        return _simulation.MarkerWeight_getWeight(self)
    __swig_destroy__ = _simulation.delete_MarkerWeight

# Register MarkerWeight in _simulation:
_simulation.MarkerWeight_swigregister(MarkerWeight)

def MarkerWeight_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerWeight *":
    return _simulation.MarkerWeight_safeDownCast(obj)

def MarkerWeight_getClassName() -> "std::string const &":
    return _simulation.MarkerWeight_getClassName()

class MarkersReference(ReferenceVec3):
    r"""
    Reference values to be achieved for specified Markers that will be used
    via optimization and/or tracking. Also contains a weighting that identifies
    the relative importance of achieving one marker's reference relative to
    another.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkersReference *":
        return _simulation.MarkersReference_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MarkersReference_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MarkersReference_getClassName()

    def clone(self) -> "OpenSim::MarkersReference *":
        return _simulation.MarkersReference_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MarkersReference_getConcreteClassName(self)

    def copyProperty_marker_file(self, source: "MarkersReference") -> "void":
        return _simulation.MarkersReference_copyProperty_marker_file(self, source)

    def append_marker_file(self, value: "std::string const &") -> "int":
        return _simulation.MarkersReference_append_marker_file(self, value)

    def constructProperty_marker_file(self, initValue: "std::string const &") -> "void":
        return _simulation.MarkersReference_constructProperty_marker_file(self, initValue)

    def get_marker_file(self, *args) -> "std::string const &":
        return _simulation.MarkersReference_get_marker_file(self, *args)

    def upd_marker_file(self, *args) -> "std::string &":
        return _simulation.MarkersReference_upd_marker_file(self, *args)

    def set_marker_file(self, *args) -> "void":
        return _simulation.MarkersReference_set_marker_file(self, *args)

    def copyProperty_marker_weights(self, source: "MarkersReference") -> "void":
        return _simulation.MarkersReference_copyProperty_marker_weights(self, source)

    def append_marker_weights(self, value: "SetMarkerWeights") -> "int":
        return _simulation.MarkersReference_append_marker_weights(self, value)

    def constructProperty_marker_weights(self, initValue: "SetMarkerWeights") -> "void":
        return _simulation.MarkersReference_constructProperty_marker_weights(self, initValue)

    def get_marker_weights(self, *args) -> "OpenSim::Set< OpenSim::MarkerWeight > const &":
        return _simulation.MarkersReference_get_marker_weights(self, *args)

    def upd_marker_weights(self, *args) -> "OpenSim::Set< OpenSim::MarkerWeight > &":
        return _simulation.MarkersReference_upd_marker_weights(self, *args)

    def set_marker_weights(self, *args) -> "void":
        return _simulation.MarkersReference_set_marker_weights(self, *args)

    def copyProperty_default_weight(self, source: "MarkersReference") -> "void":
        return _simulation.MarkersReference_copyProperty_default_weight(self, source)

    def append_default_weight(self, value: "double const &") -> "int":
        return _simulation.MarkersReference_append_default_weight(self, value)

    def constructProperty_default_weight(self, initValue: "double const &") -> "void":
        return _simulation.MarkersReference_constructProperty_default_weight(self, initValue)

    def get_default_weight(self, *args) -> "double const &":
        return _simulation.MarkersReference_get_default_weight(self, *args)

    def upd_default_weight(self, *args) -> "double &":
        return _simulation.MarkersReference_upd_default_weight(self, *args)

    def set_default_weight(self, *args) -> "void":
        return _simulation.MarkersReference_set_default_weight(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience load markers from a file. See below.

        |

        *Overload 2:*
        Convenience load markers from a file. See below.

        |

        *Overload 3:*
        Form a Reference from TimeSeriesTable and corresponding marker weights.
           The marker weights are used to initialize the weightings of the markers
           provided by the Reference. Marker weights are associated to markers by
           name. If a markerWeightSet is provided, then only those markers listed in
           the set are tracked, otherwise all the markerData table that correspond
           with model markers are tracked with the default weighting.
           The TimeSeriesTable should contain the key 'Units', representing
           units of the columns, as table metadata. In absence of 'Units' metadata,
           columns are assumed to be of units 'meters'.

        |

        *Overload 4:*
        Form a Reference from TimeSeriesTable and corresponding marker weights.
           The marker weights are used to initialize the weightings of the markers
           provided by the Reference. Marker weights are associated to markers by
           name. If a markerWeightSet is provided, then only those markers listed in
           the set are tracked, otherwise all the markerData table that correspond
           with model markers are tracked with the default weighting.
           The TimeSeriesTable should contain the key 'Units', representing
           units of the columns, as table metadata. In absence of 'Units' metadata,
           columns are assumed to be of units 'meters'.
        """
        _simulation.MarkersReference_swiginit(self, _simulation.new_MarkersReference(*args))
    __swig_destroy__ = _simulation.delete_MarkersReference

    def initializeFromMarkersFile(self, *args) -> "void":
        r"""
        Initialize this MarkersReference from data in a markerFile such that it
               corresponds to the markers that have weights. If weights is empty Set,
               all corresponding markers are tracked at default reference weight.
               See setDefaultWeight()
        """
        return _simulation.MarkersReference_initializeFromMarkersFile(self, *args)

    def getNumRefs(self) -> "int":
        return _simulation.MarkersReference_getNumRefs(self)

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which the MarkersReference values are valid,
               based on the loaded marker data.
        """
        return _simulation.MarkersReference_getValidTimeRange(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the names of the markers serving as references"""
        return _simulation.MarkersReference_getNames(self)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayVec3") -> "void":
        r""" get the value of the MarkersReference"""
        return _simulation.MarkersReference_getValuesAtTime(self, time, values)

    def getWeights(self, s: "State", weights: "SimTKArrayDouble") -> "void":
        r"""
        get the weighting (importance) of meeting this MarkersReference in the
               same order as names
        """
        return _simulation.MarkersReference_getWeights(self, s, weights)

    def getMarkerTable(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 > const &":
        r""" get the marker trajectories in a table"""
        return _simulation.MarkersReference_getMarkerTable(self)

    def getSamplingFrequency(self) -> "double":
        return _simulation.MarkersReference_getSamplingFrequency(self)

    def getMarkerWeightSet(self) -> "OpenSim::Set< OpenSim::MarkerWeight > const &":
        return _simulation.MarkersReference_getMarkerWeightSet(self)

    def updMarkerWeightSet(self) -> "OpenSim::Set< OpenSim::MarkerWeight > &":
        return _simulation.MarkersReference_updMarkerWeightSet(self)

    def setMarkerWeightSet(self, markerWeights: "SetMarkerWeights") -> "void":
        r"""
        %Set the marker weights from a set of MarkerWeights. As of OpenSim 4.0
               the input set is const and a copy of the Set is used internally.
               Therefore, subsequent changes to the Set of MarkerWeights will have
               no effect on the marker weights associated with this Reference.
        """
        return _simulation.MarkersReference_setMarkerWeightSet(self, markerWeights)

    def setDefaultWeight(self, weight: "double") -> "void":
        return _simulation.MarkersReference_setDefaultWeight(self, weight)

    def getNumFrames(self) -> "size_t":
        return _simulation.MarkersReference_getNumFrames(self)

# Register MarkersReference in _simulation:
_simulation.MarkersReference_swigregister(MarkersReference)

def MarkersReference_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkersReference *":
    return _simulation.MarkersReference_safeDownCast(obj)

def MarkersReference_getClassName() -> "std::string const &":
    return _simulation.MarkersReference_getClassName()

class SharedMarkersReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simulation.SharedMarkersReference_swiginit(self, _simulation.new_SharedMarkersReference())
    __swig_destroy__ = _simulation.delete_SharedMarkersReference

# Register SharedMarkersReference in _simulation:
_simulation.SharedMarkersReference_swigregister(SharedMarkersReference)

class SetMarkerWeights(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MarkerWeight,OpenSim::Object > *":
        return _simulation.SetMarkerWeights_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetMarkerWeights_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetMarkerWeights_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::MarkerWeight,OpenSim::Object > *":
        return _simulation.SetMarkerWeights_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetMarkerWeights_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetMarkerWeights

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::MarkerWeight,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetMarkerWeights_swiginit(self, _simulation.new_SetMarkerWeights(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetMarkerWeights_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetMarkerWeights_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetMarkerWeights_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetMarkerWeights_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetMarkerWeights_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetMarkerWeights_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "MarkerWeight") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "MarkerWeight") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "MarkerWeight") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetMarkerWeights_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "MarkerWeight", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`MarkerWeight`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetMarkerWeights_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::MarkerWeight &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`MarkerWeight`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`MarkerWeight`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetMarkerWeights_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetMarkerWeights_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetMarkerWeights_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetMarkerWeights_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetMarkerWeights_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetMarkerWeights_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetMarkerWeights_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetMarkerWeights_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetMarkerWeights_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetMarkerWeights_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMarkerWeights in _simulation:
_simulation.SetMarkerWeights_swigregister(SetMarkerWeights)

def SetMarkerWeights_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MarkerWeight,OpenSim::Object > *":
    return _simulation.SetMarkerWeights_safeDownCast(obj)

def SetMarkerWeights_getClassName() -> "std::string const &":
    return _simulation.SetMarkerWeights_getClassName()

class CoordinateReference(ReferenceDouble):
    r"""
    Reference value to be achieved for a specified coordinate that will be used
    via optimization and/or tracking. Also contains a weighting that identifies
    the relative importance of achieving one CoordinateReference relative to
    other coordinates.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateReference *":
        return _simulation.CoordinateReference_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.CoordinateReference_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.CoordinateReference_getClassName()

    def clone(self) -> "OpenSim::CoordinateReference *":
        return _simulation.CoordinateReference_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.CoordinateReference_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.CoordinateReference_swiginit(self, _simulation.new_CoordinateReference(*args))
    __swig_destroy__ = _simulation.delete_CoordinateReference

    def getNumRefs(self) -> "int":
        r"""
        get the number of referettes (individual signals) in this Reference. All
               return arrays are guaranteed to be this length
        """
        return _simulation.CoordinateReference_getNumRefs(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the name(s) of the reference or its referettes"""
        return _simulation.CoordinateReference_getNames(self)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayDouble") -> "void":
        r""" get the value of the Reference as a function of the state"""
        return _simulation.CoordinateReference_getValuesAtTime(self, time, values)

    def getWeights(self, s: "State", weights: "SimTKArrayDouble") -> "void":
        r""" get the weighting (importance) of meeting this Reference"""
        return _simulation.CoordinateReference_getWeights(self, s, weights)

    def getValue(self, s: "State") -> "double":
        r""" get the value of the CoordinateReference"""
        return _simulation.CoordinateReference_getValue(self, s)

    def getSpeedValue(self, s: "State") -> "double":
        r""" get the speed value of the CoordinateReference"""
        return _simulation.CoordinateReference_getSpeedValue(self, s)

    def getAccelerationValue(self, s: "State") -> "double":
        r""" get the speed value of the CoordinateReference"""
        return _simulation.CoordinateReference_getAccelerationValue(self, s)

    def getWeight(self, s: "State") -> "double":
        r""" get the weighting (importance) of meeting this CoordinateReference"""
        return _simulation.CoordinateReference_getWeight(self, s)

    def setWeight(self, weight: "double") -> "void":
        r""" set the weighting (importance) of meeting this CoordinateReference"""
        return _simulation.CoordinateReference_setWeight(self, weight)

    def setValueFunction(self, function: "Function") -> "void":
        r""" %Set the coordinate value as a function of time."""
        return _simulation.CoordinateReference_setValueFunction(self, function)

# Register CoordinateReference in _simulation:
_simulation.CoordinateReference_swigregister(CoordinateReference)

def CoordinateReference_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateReference *":
    return _simulation.CoordinateReference_safeDownCast(obj)

def CoordinateReference_getClassName() -> "std::string const &":
    return _simulation.CoordinateReference_getClassName()

class OrientationWeight(opensim.common.OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationWeight *":
        return _simulation.OrientationWeight_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.OrientationWeight_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.OrientationWeight_getClassName()

    def clone(self) -> "OpenSim::OrientationWeight *":
        return _simulation.OrientationWeight_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.OrientationWeight_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.OrientationWeight_swiginit(self, _simulation.new_OrientationWeight(*args))

    def setWeight(self, weight: "double") -> "void":
        return _simulation.OrientationWeight_setWeight(self, weight)

    def getWeight(self) -> "double":
        return _simulation.OrientationWeight_getWeight(self)
    __swig_destroy__ = _simulation.delete_OrientationWeight

# Register OrientationWeight in _simulation:
_simulation.OrientationWeight_swigregister(OrientationWeight)

def OrientationWeight_safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationWeight *":
    return _simulation.OrientationWeight_safeDownCast(obj)

def OrientationWeight_getClassName() -> "std::string const &":
    return _simulation.OrientationWeight_getClassName()

class OrientationsReference(StreamableReferenceRotation):
    r"""
    Reference values for the Orientations of model frames that will be used to
    to compute tracking errors. An Orientation is specified by a Rotation
    matrix describing the frame orientation with respect to Ground. The
    reference also contains weightings that identifies the relative importance
    of achieving one orientation's reference value over another.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationsReference *":
        return _simulation.OrientationsReference_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.OrientationsReference_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.OrientationsReference_getClassName()

    def clone(self) -> "OpenSim::OrientationsReference *":
        return _simulation.OrientationsReference_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.OrientationsReference_getConcreteClassName(self)

    def copyProperty_orientation_file(self, source: "OrientationsReference") -> "void":
        return _simulation.OrientationsReference_copyProperty_orientation_file(self, source)

    def append_orientation_file(self, value: "std::string const &") -> "int":
        return _simulation.OrientationsReference_append_orientation_file(self, value)

    def constructProperty_orientation_file(self, initValue: "std::string const &") -> "void":
        return _simulation.OrientationsReference_constructProperty_orientation_file(self, initValue)

    def get_orientation_file(self, *args) -> "std::string const &":
        return _simulation.OrientationsReference_get_orientation_file(self, *args)

    def upd_orientation_file(self, *args) -> "std::string &":
        return _simulation.OrientationsReference_upd_orientation_file(self, *args)

    def set_orientation_file(self, *args) -> "void":
        return _simulation.OrientationsReference_set_orientation_file(self, *args)

    def copyProperty_orientation_weights(self, source: "OrientationsReference") -> "void":
        return _simulation.OrientationsReference_copyProperty_orientation_weights(self, source)

    def append_orientation_weights(self, value: "SetOientationWeights") -> "int":
        return _simulation.OrientationsReference_append_orientation_weights(self, value)

    def constructProperty_orientation_weights(self, initValue: "SetOientationWeights") -> "void":
        return _simulation.OrientationsReference_constructProperty_orientation_weights(self, initValue)

    def get_orientation_weights(self, *args) -> "OpenSim::Set< OpenSim::OrientationWeight > const &":
        return _simulation.OrientationsReference_get_orientation_weights(self, *args)

    def upd_orientation_weights(self, *args) -> "OpenSim::Set< OpenSim::OrientationWeight > &":
        return _simulation.OrientationsReference_upd_orientation_weights(self, *args)

    def set_orientation_weights(self, *args) -> "void":
        return _simulation.OrientationsReference_set_orientation_weights(self, *args)

    def copyProperty_default_weight(self, source: "OrientationsReference") -> "void":
        return _simulation.OrientationsReference_copyProperty_default_weight(self, source)

    def append_default_weight(self, value: "double const &") -> "int":
        return _simulation.OrientationsReference_append_default_weight(self, value)

    def constructProperty_default_weight(self, initValue: "double const &") -> "void":
        return _simulation.OrientationsReference_constructProperty_default_weight(self, initValue)

    def get_default_weight(self, *args) -> "double const &":
        return _simulation.OrientationsReference_get_default_weight(self, *args)

    def upd_default_weight(self, *args) -> "double &":
        return _simulation.OrientationsReference_upd_default_weight(self, *args)

    def set_default_weight(self, *args) -> "void":
        return _simulation.OrientationsReference_set_default_weight(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience load Orientations data from a file in the form of XYZ
               body-fixed Euler angles. Units default to Radians.

        |

        *Overload 2:*
        Convenience load Orientations data from a file in the form of XYZ
               body-fixed Euler angles. Units default to Radians.

        |

        *Overload 3:*
        Form a Reference from TimeSeriesTable of Rotations and corresponding
           orientation weights. The input orientatonWeightSet is used to initialize
           Reference weightings for individual Orientations. Weights are associated
           to Orientations by name.

        |

        *Overload 4:*
        Form a Reference from TimeSeriesTable of Rotations and corresponding
           orientation weights. The input orientatonWeightSet is used to initialize
           Reference weightings for individual Orientations. Weights are associated
           to Orientations by name.
        """
        _simulation.OrientationsReference_swiginit(self, _simulation.new_OrientationsReference(*args))
    __swig_destroy__ = _simulation.delete_OrientationsReference

    def loadOrientationsEulerAnglesFile(self, *args) -> "void":
        r"""
        load the orientation data for this OrientationsReference from a file
           containing Euler-angles in body-fixed XYZ order.
        """
        return _simulation.OrientationsReference_loadOrientationsEulerAnglesFile(self, *args)

    def getNumRefs(self) -> "int":
        return _simulation.OrientationsReference_getNumRefs(self)

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which the OrientationsReference values are valid,
               based on the loaded orientation data.
        """
        return _simulation.OrientationsReference_getValidTimeRange(self)

    def getTimes(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        get the times at which the OrientationsReference values are specified,
               based on the loaded orientation data.
        """
        return _simulation.OrientationsReference_getTimes(self)

    def getNames(self) -> "SimTK::Array_< std::string,unsigned int > const &":
        r""" get the names of the Orientations serving as references"""
        return _simulation.OrientationsReference_getNames(self)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayRotation") -> "void":
        r""" get the value of the OrientationsReference"""
        return _simulation.OrientationsReference_getValuesAtTime(self, time, values)

    def getNextValuesAndTime(self, values: "SimTKArrayRotation") -> "double":
        r""" Default implementation does not support streaming"""
        return _simulation.OrientationsReference_getNextValuesAndTime(self, values)

    def hasNext(self) -> "bool":
        return _simulation.OrientationsReference_hasNext(self)

    def getWeights(self, s: "State", weights: "SimTKArrayDouble") -> "void":
        r"""
        get the weighting (importance) of meeting this OrientationsReference in the
               same order as names
        """
        return _simulation.OrientationsReference_getWeights(self, s, weights)

    def getSamplingFrequency(self) -> "double":
        return _simulation.OrientationsReference_getSamplingFrequency(self)

    def updOrientationWeightSet(self) -> "OpenSim::Set< OpenSim::OrientationWeight > &":
        return _simulation.OrientationsReference_updOrientationWeightSet(self)

    def setOrientationWeightSet(self, orientationWeights: "SetOientationWeights") -> "void":
        r"""
        %Set the orientation weights from a set of OrientationWeights, which is
           const and a copy of the Set is used internally. Therefore, subsequent changes
           to the Set of OrientationWeights will have no effect on the orientation weights
           associated with this Reference. You can, however, change the weightings on the
           InverseKinematicsSolver prior to solving at any instant in time.
        """
        return _simulation.OrientationsReference_setOrientationWeightSet(self, orientationWeights)

    def setDefaultWeight(self, weight: "double") -> "void":
        return _simulation.OrientationsReference_setDefaultWeight(self, weight)

# Register OrientationsReference in _simulation:
_simulation.OrientationsReference_swigregister(OrientationsReference)

def OrientationsReference_safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationsReference *":
    return _simulation.OrientationsReference_safeDownCast(obj)

def OrientationsReference_getClassName() -> "std::string const &":
    return _simulation.OrientationsReference_getClassName()

class SetOientationWeights(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::OrientationWeight,OpenSim::Object > *":
        return _simulation.SetOientationWeights_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.SetOientationWeights_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.SetOientationWeights_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::OrientationWeight,OpenSim::Object > *":
        return _simulation.SetOientationWeights_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.SetOientationWeights_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_SetOientationWeights

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::OrientationWeight,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _simulation.SetOientationWeights_swiginit(self, _simulation.new_SetOientationWeights(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _simulation.SetOientationWeights_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _simulation.SetOientationWeights_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _simulation.SetOientationWeights_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _simulation.SetOientationWeights_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _simulation.SetOientationWeights_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _simulation.SetOientationWeights_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "OrientationWeight") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "OrientationWeight") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "OrientationWeight") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _simulation.SetOientationWeights_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "OrientationWeight", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`OrientationWeight`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _simulation.SetOientationWeights_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::OrientationWeight &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`OrientationWeight`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`OrientationWeight`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _simulation.SetOientationWeights_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _simulation.SetOientationWeights_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _simulation.SetOientationWeights_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _simulation.SetOientationWeights_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _simulation.SetOientationWeights_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _simulation.SetOientationWeights_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _simulation.SetOientationWeights_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _simulation.SetOientationWeights_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _simulation.SetOientationWeights_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _simulation.SetOientationWeights_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetOientationWeights in _simulation:
_simulation.SetOientationWeights_swigregister(SetOientationWeights)

def SetOientationWeights_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::OrientationWeight,OpenSim::Object > *":
    return _simulation.SetOientationWeights_safeDownCast(obj)

def SetOientationWeights_getClassName() -> "std::string const &":
    return _simulation.SetOientationWeights_getClassName()

class SharedOrientationsReference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simulation.SharedOrientationsReference_swiginit(self, _simulation.new_SharedOrientationsReference())
    __swig_destroy__ = _simulation.delete_SharedOrientationsReference

# Register SharedOrientationsReference in _simulation:
_simulation.SharedOrientationsReference_swigregister(SharedOrientationsReference)

class BufferedOrientationsReference(OrientationsReference):
    r"""
    Subclass of OrientationsReference that handles live data by providing a DataQueue
    that allows clients to push data into and allows the InverseKinematicsSolver to
    draw data from for solving.
    Ideally this would be templatized, allowing for all Reference classes to leverage it.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BufferedOrientationsReference *":
        return _simulation.BufferedOrientationsReference_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.BufferedOrientationsReference_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.BufferedOrientationsReference_getClassName()

    def clone(self) -> "OpenSim::BufferedOrientationsReference *":
        return _simulation.BufferedOrientationsReference_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BufferedOrientationsReference_getConcreteClassName(self)

    def __init__(self, *args):
        _simulation.BufferedOrientationsReference_swiginit(self, _simulation.new_BufferedOrientationsReference(*args))
    __swig_destroy__ = _simulation.delete_BufferedOrientationsReference

    def getValidTimeRange(self) -> "SimTK::Vec2":
        r"""
        get the time range for which this Reference values are valid,
               based on the loaded orientation data.
        """
        return _simulation.BufferedOrientationsReference_getValidTimeRange(self)

    def getValuesAtTime(self, time: "double", values: "SimTKArrayRotation") -> "void":
        r"""
         get the values from the base OrientationsReference, or from
        the client provided data that was queued earlier using putValues call.
        """
        return _simulation.BufferedOrientationsReference_getValuesAtTime(self, time, values)

    def putValues(self, time: "double", dataRow: "SimTK::RowVector_< SimTK::Rotation > const &") -> "void":
        r""" add passed in values to data procesing Queue"""
        return _simulation.BufferedOrientationsReference_putValues(self, time, dataRow)

    def getNextValuesAndTime(self, values: "SimTKArrayRotation") -> "double":
        return _simulation.BufferedOrientationsReference_getNextValuesAndTime(self, values)

    def hasNext(self) -> "bool":
        return _simulation.BufferedOrientationsReference_hasNext(self)

    def setFinished(self, finished: "bool") -> "void":
        return _simulation.BufferedOrientationsReference_setFinished(self, finished)

# Register BufferedOrientationsReference in _simulation:
_simulation.BufferedOrientationsReference_swigregister(BufferedOrientationsReference)

def BufferedOrientationsReference_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BufferedOrientationsReference *":
    return _simulation.BufferedOrientationsReference_safeDownCast(obj)

def BufferedOrientationsReference_getClassName() -> "std::string const &":
    return _simulation.BufferedOrientationsReference_getClassName()

class AssemblySolver(Solver):
    r"""
    Solve for the coordinates (degrees-of-freedom) of the model that satisfy the
    set of constraints imposed on the model as well as set of desired coordinate
    values.  The AssembleSolver provides the option to convert the problem to an
    approximate one where the constraint violations are treated as penalties to
    to be minimized rather than strictly enforced. This can speed up the time
    solution and can be used to seed the constrained problem near to a solution.

    The assembly objective: min A = sum(Wq_i*(q_i-qd_i)^2)) + [Wc*sum(c_err)^2]
    iff Wc == Infinity, second term is not included, but
     A is subject to the constraint equations:  G(q)-Go = 0

    When the model (and the number of goals) is guaranteed not to change and the
    the initial state is close to the assembly solution (from initial assembly(),
    then track() is a efficient method for updating the configuration to track
    the small change to the desired coordinate value.

    See SimTK::Assembler for more algorithmic details of the underlying solver.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AssemblySolver *":
        return _simulation.AssemblySolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.AssemblySolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.AssemblySolver_getClassName()

    def clone(self) -> "OpenSim::AssemblySolver *":
        return _simulation.AssemblySolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.AssemblySolver_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        Construct an Assembly solver with the coordinate references as the goal
               of the assembly and (optional)constraint weight. Default is infinity
               constraint weighting (i.e. rigidly enforced) during assembly.
        """
        _simulation.AssemblySolver_swiginit(self, _simulation.new_AssemblySolver(*args))
    __swig_destroy__ = _simulation.delete_AssemblySolver

    def setAccuracy(self, accuracy: "double") -> "void":
        r"""
        %Set the unitless accuracy of the assembly solution, which dictates
               the number of significant digits the solution should be resolved to.
               Note, setting the accuracy will invalidate the AssemblySolver and one
               must call assemble() before being able to track().
        """
        return _simulation.AssemblySolver_setAccuracy(self, accuracy)

    def setConstraintWeight(self, weight: "double") -> "void":
        r"""
        %Set the relative weighting for constraints. Use Infinity to identify the
               strict enforcement of constraints, otherwise any positive weighting will
               append the constraint errors to the assembly cost which the solver will
               minimize.
        """
        return _simulation.AssemblySolver_setConstraintWeight(self, weight)

    def getCoordinateReferences(self) -> "SimTK::Array_< OpenSim::CoordinateReference,unsigned int > const &":
        r"""
        Specify which coordinates to match, each with a desired value and a
               relative weighting.
        """
        return _simulation.AssemblySolver_getCoordinateReferences(self)

    def updateCoordinateReference(self, coordName: "std::string const &", value: "double", weight: "double"=1.0) -> "void":
        r"""
        Once a set of coordinates has been specified its reference value and
               weight can be updated directly
        """
        return _simulation.AssemblySolver_updateCoordinateReference(self, coordName, value, weight)

    def assemble(self, s: "State") -> "void":
        r"""
        Assemble a model configuration that meets the assembly conditions
               (desired values and constraints) and accuracy, starting from an initial
               state that does not have to satisfy the constraints.
        """
        return _simulation.AssemblySolver_assemble(self, s)

    def track(self, s: "State") -> "void":
        r"""
        Obtain a model configuration that meets the assembly conditions
               (desired values and constraints) given a state that satisfies or
               is close to satisfying the constraints. Note there can be no change
               in the number of constraints or desired coordinates. Desired
               coordinate values can and should be updated between repeated calls
               to track a desired trajectory of coordinate values. Use assemble()
               first to obtain the first solution and use track() to efficiently
               find a nearby solution due to a small change in the desired value.
        """
        return _simulation.AssemblySolver_track(self, s)

    def getAssembler(self) -> "SimTK::Assembler const &":
        r""" Read access to the underlying SimTK::Assembler."""
        return _simulation.AssemblySolver_getAssembler(self)

# Register AssemblySolver in _simulation:
_simulation.AssemblySolver_swigregister(AssemblySolver)

def AssemblySolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AssemblySolver *":
    return _simulation.AssemblySolver_safeDownCast(obj)

def AssemblySolver_getClassName() -> "std::string const &":
    return _simulation.AssemblySolver_getClassName()

class InverseKinematicsSolver(AssemblySolver):
    r"""
    Solve for the coordinates (degrees of freedom) of the model that satisfy the
    set of constraints imposed on the model and the set of desired coordinate
    values. The InverseKinematicsSolver provides the option to convert the
    problem to an approximate one where the constraint violations are treated as
    penalties to be minimized rather than strictly enforced. This can speed up
    the solution and can be used to seed the constrained problem closer to the
    solution.

    The InverseKinematicsSolver objective:

    .. math::

        min: J = sum(Wm_i*(m_i-md_i)^T*(m_i-md_i)) + sum(Wq_j*(q_j-qd_j)^2) +
                   [Wc*sum(c_{err})^2]
    where m_i and md_i are the model and desired marker locations (Vec3); q_j
    and qd_j are model and desired joint coordinates. Wm_i and Wq_j are the
    marker and coordinate weightings, respectively, and Wc is the weighting on
    constraint errors. When Wc == Infinity, the second term is not included,
    but instead q is subject to the constraint equations:

         .. math::

             c_{err} = G(q)-Go = 0

    When the model (and the number of goals) is guaranteed not to change and
    the initial state is close to the InverseKinematics solution (e.g., from the
    initial assemble()), then track() is an efficient method for updating the
    configuration to determine the small change in coordinate values, q.

    See SimTK::Assembler for more algorithmic details of the underlying solver.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simulation.delete_InverseKinematicsSolver

    def __init__(self, *args):
        _simulation.InverseKinematicsSolver_swiginit(self, _simulation.new_InverseKinematicsSolver(*args))

    def getNumMarkersInUse(self) -> "int":
        r"""
        Return the number of markers used to solve for model coordinates.
               It is a count of the number of markers in the intersection of
               the reference markers and model markers.
               This number is guaranteed not to change after assemble() is called
               (i.e. during subsequent calls to track()).
        """
        return _simulation.InverseKinematicsSolver_getNumMarkersInUse(self)

    def getNumOrientationSensorsInUse(self) -> "int":
        r"""
        Return the number of orientation sensors used to solve for model
           coordinates. It is a count of the number of orientation sensors that
           intersect the reference orientations and model reference frames with
           the same name. This number is guaranteed not to change after assemble()
           is called (i.e. during subsequent calls to track()).
        """
        return _simulation.InverseKinematicsSolver_getNumOrientationSensorsInUse(self)

    def updateMarkerWeight(self, *args) -> "void":
        r"""
        *Overload 1:*
        Change the weighting of a marker, given the marker's name. Takes effect
               when assemble() or track() is called next.

        |

        *Overload 2:*
        Change the weighting of a marker, given the marker's index. Takes effect
               when assemble() or track() is called next.
        """
        return _simulation.InverseKinematicsSolver_updateMarkerWeight(self, *args)

    def updateMarkerWeights(self, weights: "SimTKArrayDouble") -> "void":
        r"""
        Change the weighting of all markers. Takes effect when assemble() or
               track() is called next. Marker weights are specified in the same order
               as they appear in the MarkersReference that was passed in when the
               solver was constructed.
        """
        return _simulation.InverseKinematicsSolver_updateMarkerWeights(self, weights)

    def updateOrientationWeight(self, *args) -> "void":
        r"""
        *Overload 1:*
        Change the weighting of an orientation sensor, given its name. Takes
           effect when assemble() or track() is called next.

        |

        *Overload 2:*
        Change the weighting of an orientation sensor, given its index. Takes
           effect when assemble() or track() is called next.
        """
        return _simulation.InverseKinematicsSolver_updateOrientationWeight(self, *args)

    def updateOrientationWeights(self, weights: "SimTKArrayDouble") -> "void":
        r"""
        Change the weighting of all orientation sensors. Takes effect when
           assemble() or track() is called next. Orientation weights are specified
           in the same order as they appear in the OrientationsReference that was
           passed in when the solver was constructed.
        """
        return _simulation.InverseKinematicsSolver_updateOrientationWeights(self, weights)

    def computeCurrentMarkerLocation(self, *args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
        Compute and return a marker's spatial location in the ground frame,
               given the marker's name.

        |

        *Overload 2:*
        Compute and return a marker's spatial location in the ground frame,
               given the marker's index.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerLocation(self, *args)

    def computeCurrentMarkerLocations(self, markerLocations: "SimTKArrayVec3") -> "void":
        r"""
        Compute and return the spatial locations of all markers, expressed in
               the ground frame.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerLocations(self, markerLocations)

    def computeCurrentMarkerError(self, *args) -> "double":
        r"""
        *Overload 1:*
        Compute and return the distance error between a model marker and its
               observation, given the marker's name.

        |

        *Overload 2:*
        Compute and return the distance error between a model marker and its
               observation, given the marker's index.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerError(self, *args)

    def computeCurrentMarkerErrors(self, markerErrors: "SimTKArrayDouble") -> "void":
        r"""
        Compute and return the distance errors between all model markers and
               their observations.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentMarkerErrors(self, markerErrors)

    def computeCurrentSquaredMarkerError(self, *args) -> "double":
        r"""
        *Overload 1:*
        Compute and return the squared-distance error between a model marker and
               its observation, given the marker's name. This method is cheaper than
               squaring the value returned by computeCurrentMarkerError().

        |

        *Overload 2:*
        Compute and return the squared-distance error between a model marker and
               its observation, given the marker's index. This method is cheaper than
               squaring the value returned by computeCurrentMarkerError().
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSquaredMarkerError(self, *args)

    def computeCurrentSquaredMarkerErrors(self, markerErrors: "SimTKArrayDouble") -> "void":
        r"""
        Compute and return the squared-distance errors between all model markers
               and their observations. This method is cheaper than squaring the values
               returned by computeCurrentMarkerErrors().
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSquaredMarkerErrors(self, markerErrors)

    def getMarkerNameForIndex(self, markerIndex: "int") -> "std::string":
        r"""
        Marker locations and errors may be computed in an order that is different
               from tasks file or listed in the model. Return the corresponding marker
               name for an index in the list of marker locations/errors returned by the
               solver.
        """
        return _simulation.InverseKinematicsSolver_getMarkerNameForIndex(self, markerIndex)

    def computeCurrentSensorOrientation(self, *args) -> "SimTK::Rotation":
        r"""
        *Overload 1:*
        Compute and return an orientation sensor's spatial orientation in the
           ground frame, given the o-sensor's name.

        |

        *Overload 2:*
        Compute and return an orientation sensor's spatial orientation in the
           ground frame, given the o-sensor's index.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSensorOrientation(self, *args)

    def computeCurrentSensorOrientations(self, osensorOrientations: "SimTK::Array_< SimTK::Rotation,unsigned int > &") -> "void":
        r"""
        Compute and return the spatial orientations of all o-sensors, expressed in
           the ground frame.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentSensorOrientations(self, osensorOrientations)

    def computeCurrentOrientationError(self, *args) -> "double":
        r"""
        *Overload 1:*
        Compute and return the orientation error between the model orientation
           sensor and its observation, given the o-sensor's name.

        |

        *Overload 2:*
        Compute and return the orientation error between the model orientation
           sensor and its observation, given the o-sensor's index.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentOrientationError(self, *args)

    def computeCurrentOrientationErrors(self, osensorErrors: "SimTKArrayDouble") -> "void":
        r"""
        Compute all the orientation errors between the model orientation
           sensors and their observations.
        """
        return _simulation.InverseKinematicsSolver_computeCurrentOrientationErrors(self, osensorErrors)

    def getOrientationSensorNameForIndex(self, osensorIndex: "int") -> "std::string":
        r"""
        Orientation sensor locations and errors may be computed in an order that
           may be different from tasks file or listed in the model. Return the
           corresponding orientation sensor name for an index in the list of
           orientations returned by the solver.
        """
        return _simulation.InverseKinematicsSolver_getOrientationSensorNameForIndex(self, osensorIndex)

    def setAdvanceTimeFromReference(self, newValue: "bool") -> "void":
        r""" indicate whether time is provided by Reference objects or driver program"""
        return _simulation.InverseKinematicsSolver_setAdvanceTimeFromReference(self, newValue)

# Register InverseKinematicsSolver in _simulation:
_simulation.InverseKinematicsSolver_swigregister(InverseKinematicsSolver)

class IMUPlacer(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how to place IMUs
    on a model to match placement of experimental sensors (IMUs)

    Calibrates a model by registering IMU frames whose orientations in the
    sensor world frame are specified, assuming the model's default pose is the
    calibration pose. The resultant model with IMU frames registered is optionally
    written to file. Optional properties are available to identify heading correction
    to line up the base IMU by its label in the orientation_file_for_calibration
    e.g. 'pelvis imu' and its heading axis as +/- 'x', 'y', or 'z', are used to
    align all the IMU data so that base imu's heading (forward) is in the X direction
    of OpenSim's ground frame.

    Author: Ayman Habib, Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMUPlacer *":
        return _simulation.IMUPlacer_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.IMUPlacer_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.IMUPlacer_getClassName()

    def clone(self) -> "OpenSim::IMUPlacer *":
        return _simulation.IMUPlacer_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.IMUPlacer_getConcreteClassName(self)

    def copyProperty_model_file(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_model_file(self, source)

    def append_model_file(self, value: "std::string const &") -> "int":
        return _simulation.IMUPlacer_append_model_file(self, value)

    def constructProperty_model_file(self, initValue: "std::string const &") -> "void":
        return _simulation.IMUPlacer_constructProperty_model_file(self, initValue)

    def get_model_file(self, *args) -> "std::string const &":
        return _simulation.IMUPlacer_get_model_file(self, *args)

    def upd_model_file(self, *args) -> "std::string &":
        return _simulation.IMUPlacer_upd_model_file(self, *args)

    def set_model_file(self, *args) -> "void":
        return _simulation.IMUPlacer_set_model_file(self, *args)

    def copyProperty_base_imu_label(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_base_imu_label(self, source)

    def append_base_imu_label(self, value: "std::string const &") -> "int":
        return _simulation.IMUPlacer_append_base_imu_label(self, value)

    def constructProperty_base_imu_label(self, initValue: "std::string const &") -> "void":
        return _simulation.IMUPlacer_constructProperty_base_imu_label(self, initValue)

    def get_base_imu_label(self, *args) -> "std::string const &":
        return _simulation.IMUPlacer_get_base_imu_label(self, *args)

    def upd_base_imu_label(self, *args) -> "std::string &":
        return _simulation.IMUPlacer_upd_base_imu_label(self, *args)

    def set_base_imu_label(self, *args) -> "void":
        return _simulation.IMUPlacer_set_base_imu_label(self, *args)

    def copyProperty_base_heading_axis(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_base_heading_axis(self, source)

    def append_base_heading_axis(self, value: "std::string const &") -> "int":
        return _simulation.IMUPlacer_append_base_heading_axis(self, value)

    def constructProperty_base_heading_axis(self, initValue: "std::string const &") -> "void":
        return _simulation.IMUPlacer_constructProperty_base_heading_axis(self, initValue)

    def get_base_heading_axis(self, *args) -> "std::string const &":
        return _simulation.IMUPlacer_get_base_heading_axis(self, *args)

    def upd_base_heading_axis(self, *args) -> "std::string &":
        return _simulation.IMUPlacer_upd_base_heading_axis(self, *args)

    def set_base_heading_axis(self, *args) -> "void":
        return _simulation.IMUPlacer_set_base_heading_axis(self, *args)

    def copyProperty_sensor_to_opensim_rotations(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_sensor_to_opensim_rotations(self, source)

    def append_sensor_to_opensim_rotations(self, value: "Vec3") -> "int":
        return _simulation.IMUPlacer_append_sensor_to_opensim_rotations(self, value)

    def constructProperty_sensor_to_opensim_rotations(self, initValue: "Vec3") -> "void":
        return _simulation.IMUPlacer_constructProperty_sensor_to_opensim_rotations(self, initValue)

    def get_sensor_to_opensim_rotations(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.IMUPlacer_get_sensor_to_opensim_rotations(self, *args)

    def upd_sensor_to_opensim_rotations(self, *args) -> "SimTK::Vec3 &":
        return _simulation.IMUPlacer_upd_sensor_to_opensim_rotations(self, *args)

    def set_sensor_to_opensim_rotations(self, *args) -> "void":
        return _simulation.IMUPlacer_set_sensor_to_opensim_rotations(self, *args)

    def copyProperty_orientation_file_for_calibration(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_orientation_file_for_calibration(self, source)

    def append_orientation_file_for_calibration(self, value: "std::string const &") -> "int":
        return _simulation.IMUPlacer_append_orientation_file_for_calibration(self, value)

    def constructProperty_orientation_file_for_calibration(self, initValue: "std::string const &") -> "void":
        return _simulation.IMUPlacer_constructProperty_orientation_file_for_calibration(self, initValue)

    def get_orientation_file_for_calibration(self, *args) -> "std::string const &":
        return _simulation.IMUPlacer_get_orientation_file_for_calibration(self, *args)

    def upd_orientation_file_for_calibration(self, *args) -> "std::string &":
        return _simulation.IMUPlacer_upd_orientation_file_for_calibration(self, *args)

    def set_orientation_file_for_calibration(self, *args) -> "void":
        return _simulation.IMUPlacer_set_orientation_file_for_calibration(self, *args)

    def copyProperty_output_model_file(self, source: "IMUPlacer") -> "void":
        return _simulation.IMUPlacer_copyProperty_output_model_file(self, source)

    def append_output_model_file(self, value: "std::string const &") -> "int":
        return _simulation.IMUPlacer_append_output_model_file(self, value)

    def constructProperty_output_model_file(self, initValue: "std::string const &") -> "void":
        return _simulation.IMUPlacer_constructProperty_output_model_file(self, initValue)

    def get_output_model_file(self, *args) -> "std::string const &":
        return _simulation.IMUPlacer_get_output_model_file(self, *args)

    def upd_output_model_file(self, *args) -> "std::string &":
        return _simulation.IMUPlacer_upd_output_model_file(self, *args)

    def set_output_model_file(self, *args) -> "void":
        return _simulation.IMUPlacer_set_output_model_file(self, *args)
    __swig_destroy__ = _simulation.delete_IMUPlacer

    def __init__(self, *args):
        r""" Create an IMUPlacer based on a setup file"""
        _simulation.IMUPlacer_swiginit(self, _simulation.new_IMUPlacer(*args))

    def run(self, visualizeResults: "bool"=False) -> "bool":
        r"""
        Run the calibration method to place IMUs on the model,
            Optionally visualize the model post calibration.
        """
        return _simulation.IMUPlacer_run(self, visualizeResults)

    def setModel(self, aModel: "Model") -> "void":
        return _simulation.IMUPlacer_setModel(self, aModel)

    def getCalibratedModel(self) -> "OpenSim::Model &":
        r"""
        Retrieve the calibrated model. This method will throw if called before
           the run method is invoked.
        """
        return _simulation.IMUPlacer_getCalibratedModel(self)

# Register IMUPlacer in _simulation:
_simulation.IMUPlacer_swigregister(IMUPlacer)

def IMUPlacer_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMUPlacer *":
    return _simulation.IMUPlacer_safeDownCast(obj)

def IMUPlacer_getClassName() -> "std::string const &":
    return _simulation.IMUPlacer_getClassName()

class IMU(ModelComponent):
    r"""
    IMU is a Model Component that represents an IMU along with its Geometry
    for visualization.
    TODO: add noise model, limits/saturation, as needed.


    Authors: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMU *":
        return _simulation.IMU_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.IMU_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.IMU_getClassName()

    def clone(self) -> "OpenSim::IMU *":
        return _simulation.IMU_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.IMU_getConcreteClassName(self)
    __swig_destroy__ = _simulation.delete_IMU

    def __init__(self, *args):
        _simulation.IMU_swiginit(self, _simulation.new_IMU(*args))
    PropertyIndex_socket_frame = property(_simulation.IMU_PropertyIndex_socket_frame_get, _simulation.IMU_PropertyIndex_socket_frame_set)

    def connectSocket_frame(self, object: "OpenSimObject") -> "void":
        return _simulation.IMU_connectSocket_frame(self, object)
    _has_output_orientation_as_quaternion = property(_simulation.IMU__has_output_orientation_as_quaternion_get, _simulation.IMU__has_output_orientation_as_quaternion_set)
    _has_output_gyroscope_signal = property(_simulation.IMU__has_output_gyroscope_signal_get, _simulation.IMU__has_output_gyroscope_signal_set)
    _has_output_accelerometer_signal = property(_simulation.IMU__has_output_accelerometer_signal_get, _simulation.IMU__has_output_accelerometer_signal_set)

    def calcTransformInGround(self, s: "State") -> "SimTK::Transform":
        r""" Report the Transform of this IMU in Ground frame"""
        return _simulation.IMU_calcTransformInGround(self, s)

    def calcOrientationAsQuaternion(self, s: "State") -> "SimTK::Quaternion":
        r""" Report the orientation of this IMU in ground frame expressed as Quaternion"""
        return _simulation.IMU_calcOrientationAsQuaternion(self, s)

    def calcGyroscopeSignal(self, s: "State") -> "SimTK::Vec3":
        r"""
        Report the angular velocity of the frame to which this IMU is attached
        in ground frame
        """
        return _simulation.IMU_calcGyroscopeSignal(self, s)

    def calcAccelerometerSignal(self, s: "State") -> "SimTK::Vec3":
        r"""
        Report the linear acceleration of the frame to which this IMU is attached in Ground.
        Gravity is subtracted and result expressed in the frame to which the IMU is attached.
        """
        return _simulation.IMU_calcAccelerometerSignal(self, s)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        return _simulation.IMU_generateDecorations(self, fixed, hints, state, appendToThis)

# Register IMU in _simulation:
_simulation.IMU_swigregister(IMU)

def IMU_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMU *":
    return _simulation.IMU_safeDownCast(obj)

def IMU_getClassName() -> "std::string const &":
    return _simulation.IMU_getClassName()

class OpenSenseUtilities(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def rotateOrientationTable(quaternionsTable: "TimeSeriesTableQuaternion", rotationMatrix: "Rotation") -> "void":
        r"""
        Apply the passed in Rotation matrix to a TimeSeriesTable of Quaternions.
               The rotation is done in place so the table passed in is modified
        """
        return _simulation.OpenSenseUtilities_rotateOrientationTable(quaternionsTable, rotationMatrix)

    @staticmethod
    def convertQuaternionsToRotations(qauternionsTable: "TimeSeriesTableQuaternion") -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > >":
        r"""
        Convert a TimeSeriesTable with quaternions as data elements into a TimeSeriesTable
               of Rotation matrices.
        """
        return _simulation.OpenSenseUtilities_convertQuaternionsToRotations(qauternionsTable)

    @staticmethod
    def computeHeadingCorrection(model: "Model", state: "State", quatTimeSeries: "TimeSeriesTableQuaternion", baseIMU: "std::string const &", arg5: "CoordinateDirection") -> "SimTK::Vec3":
        r"""
        Compute a SimTK::Vec3 of Space-fixed XYZ Euler angles that aligns the
              specified baseIMU and CoordinateDirection combination with the positive
              X-axis (= typically forward) direction of the base segment in OpenSim
              model. Base segment is typically the segment attached directly to Ground.
              baseIMU is assumed to be placed on Base segment. Passed in state places
              the model in the same configuration as the first frame of the
              passed in table of quaternions quatTimeSeries.
        """
        return _simulation.OpenSenseUtilities_computeHeadingCorrection(model, state, quatTimeSeries, baseIMU, arg5)

    @staticmethod
    def createOrientationsFileFromMarkers(markersFile: "std::string const &") -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >":
        r"""Create Orientations as a TimeSeriesTable based on passed in markerFile"""
        return _simulation.OpenSenseUtilities_createOrientationsFileFromMarkers(markersFile)

    @staticmethod
    def formTransformFromPoints(op: "Vec3", xp: "Vec3", yp: "Vec3") -> "SimTK::Transform":
        r""" form a Transform from 3 points origin (op), along x (xp - op), along y(yp - op)"""
        return _simulation.OpenSenseUtilities_formTransformFromPoints(op, xp, yp)

    @staticmethod
    def addModelIMUs(model: "Model", paths: "StdVectorString") -> "std::vector< OpenSim::IMU *,std::allocator< OpenSim::IMU * > >":
        r"""
        Add IMUs to passed in model and return references to them
        based on paths specification.
        - If "paths" refer to user specified list of frames, then one new
            "{Frame}_imu" is added to the model and returned in result.
        """
        return _simulation.OpenSenseUtilities_addModelIMUs(model, paths)

    def __init__(self):
        _simulation.OpenSenseUtilities_swiginit(self, _simulation.new_OpenSenseUtilities())
    __swig_destroy__ = _simulation.delete_OpenSenseUtilities

# Register OpenSenseUtilities in _simulation:
_simulation.OpenSenseUtilities_swigregister(OpenSenseUtilities)

def OpenSenseUtilities_rotateOrientationTable(quaternionsTable: "TimeSeriesTableQuaternion", rotationMatrix: "Rotation") -> "void":
    r"""
    Apply the passed in Rotation matrix to a TimeSeriesTable of Quaternions.
           The rotation is done in place so the table passed in is modified
    """
    return _simulation.OpenSenseUtilities_rotateOrientationTable(quaternionsTable, rotationMatrix)

def OpenSenseUtilities_convertQuaternionsToRotations(qauternionsTable: "TimeSeriesTableQuaternion") -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > >":
    r"""
    Convert a TimeSeriesTable with quaternions as data elements into a TimeSeriesTable
           of Rotation matrices.
    """
    return _simulation.OpenSenseUtilities_convertQuaternionsToRotations(qauternionsTable)

def OpenSenseUtilities_computeHeadingCorrection(model: "Model", state: "State", quatTimeSeries: "TimeSeriesTableQuaternion", baseIMU: "std::string const &", arg5: "CoordinateDirection") -> "SimTK::Vec3":
    r"""
    Compute a SimTK::Vec3 of Space-fixed XYZ Euler angles that aligns the
          specified baseIMU and CoordinateDirection combination with the positive
          X-axis (= typically forward) direction of the base segment in OpenSim
          model. Base segment is typically the segment attached directly to Ground.
          baseIMU is assumed to be placed on Base segment. Passed in state places
          the model in the same configuration as the first frame of the
          passed in table of quaternions quatTimeSeries.
    """
    return _simulation.OpenSenseUtilities_computeHeadingCorrection(model, state, quatTimeSeries, baseIMU, arg5)

def OpenSenseUtilities_createOrientationsFileFromMarkers(markersFile: "std::string const &") -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >":
    r"""Create Orientations as a TimeSeriesTable based on passed in markerFile"""
    return _simulation.OpenSenseUtilities_createOrientationsFileFromMarkers(markersFile)

def OpenSenseUtilities_formTransformFromPoints(op: "Vec3", xp: "Vec3", yp: "Vec3") -> "SimTK::Transform":
    r""" form a Transform from 3 points origin (op), along x (xp - op), along y(yp - op)"""
    return _simulation.OpenSenseUtilities_formTransformFromPoints(op, xp, yp)

def OpenSenseUtilities_addModelIMUs(model: "Model", paths: "StdVectorString") -> "std::vector< OpenSim::IMU *,std::allocator< OpenSim::IMU * > >":
    r"""
    Add IMUs to passed in model and return references to them
    based on paths specification.
    - If "paths" refer to user specified list of frames, then one new
        "{Frame}_imu" is added to the model and returned in result.
    """
    return _simulation.OpenSenseUtilities_addModelIMUs(model, paths)

class StdVectorIMUs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simulation.StdVectorIMUs_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simulation.StdVectorIMUs___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simulation.StdVectorIMUs___bool__(self)

    def __len__(self) -> "std::vector< OpenSim::IMU * >::size_type":
        return _simulation.StdVectorIMUs___len__(self)

    def __getslice__(self, i: "std::vector< OpenSim::IMU * >::difference_type", j: "std::vector< OpenSim::IMU * >::difference_type") -> "std::vector< OpenSim::IMU *,std::allocator< OpenSim::IMU * > > *":
        return _simulation.StdVectorIMUs___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simulation.StdVectorIMUs___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< OpenSim::IMU * >::difference_type", j: "std::vector< OpenSim::IMU * >::difference_type") -> "void":
        return _simulation.StdVectorIMUs___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simulation.StdVectorIMUs___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< OpenSim::IMU * >::value_type":
        return _simulation.StdVectorIMUs___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simulation.StdVectorIMUs___setitem__(self, *args)

    def pop(self) -> "std::vector< OpenSim::IMU * >::value_type":
        return _simulation.StdVectorIMUs_pop(self)

    def append(self, x: "IMU") -> "void":
        return _simulation.StdVectorIMUs_append(self, x)

    def empty(self) -> "bool":
        return _simulation.StdVectorIMUs_empty(self)

    def size(self) -> "std::vector< OpenSim::IMU * >::size_type":
        return _simulation.StdVectorIMUs_size(self)

    def swap(self, v: "StdVectorIMUs") -> "void":
        return _simulation.StdVectorIMUs_swap(self, v)

    def begin(self) -> "std::vector< OpenSim::IMU * >::iterator":
        return _simulation.StdVectorIMUs_begin(self)

    def end(self) -> "std::vector< OpenSim::IMU * >::iterator":
        return _simulation.StdVectorIMUs_end(self)

    def rbegin(self) -> "std::vector< OpenSim::IMU * >::reverse_iterator":
        return _simulation.StdVectorIMUs_rbegin(self)

    def rend(self) -> "std::vector< OpenSim::IMU * >::reverse_iterator":
        return _simulation.StdVectorIMUs_rend(self)

    def clear(self) -> "void":
        return _simulation.StdVectorIMUs_clear(self)

    def get_allocator(self) -> "std::vector< OpenSim::IMU * >::allocator_type":
        return _simulation.StdVectorIMUs_get_allocator(self)

    def pop_back(self) -> "void":
        return _simulation.StdVectorIMUs_pop_back(self)

    def erase(self, *args) -> "std::vector< OpenSim::IMU * >::iterator":
        return _simulation.StdVectorIMUs_erase(self, *args)

    def __init__(self, *args):
        _simulation.StdVectorIMUs_swiginit(self, _simulation.new_StdVectorIMUs(*args))

    def push_back(self, x: "IMU") -> "void":
        return _simulation.StdVectorIMUs_push_back(self, x)

    def front(self) -> "std::vector< OpenSim::IMU * >::value_type":
        return _simulation.StdVectorIMUs_front(self)

    def back(self) -> "std::vector< OpenSim::IMU * >::value_type":
        return _simulation.StdVectorIMUs_back(self)

    def assign(self, n: "std::vector< OpenSim::IMU * >::size_type", x: "IMU") -> "void":
        return _simulation.StdVectorIMUs_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simulation.StdVectorIMUs_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simulation.StdVectorIMUs_insert(self, *args)

    def reserve(self, n: "std::vector< OpenSim::IMU * >::size_type") -> "void":
        return _simulation.StdVectorIMUs_reserve(self, n)

    def capacity(self) -> "std::vector< OpenSim::IMU * >::size_type":
        return _simulation.StdVectorIMUs_capacity(self)
    __swig_destroy__ = _simulation.delete_StdVectorIMUs

# Register StdVectorIMUs in _simulation:
_simulation.StdVectorIMUs_swigregister(StdVectorIMUs)

class StatesTrajectory(object):
    r"""
    This class holds a sequence of SimTK::State%s. You can obtain a
    StatesTrajectory during a simulation via the StatesTrajectoryReporter. You
    can also create a StatesTrajectory from a states storage (.sto) file (see
    createFromStatesStorage()). Users can modify a trajectory by appending
    states to it, but users cannot modify the individual states that are already
    in a trajectory.

    This class was introduced in OpenSim version 4.0, and enables scripting
    (Python/MATLAB) and C++ users to postprocess their results with greater ease
    and flexibility than with an Analysis.

    Notes: In a future release, we plan to support an OSTATES file format that
    allows one to write the trajectory to a file with full numerical precision.


    This class is designed to ensure the following:
    - The states are ordered nondecreasing in time (adjacent states *can* have
      the same time).
    - All states in the trajectory are consistent with each other (see
      isConsistent()).

    These guarantees apply when using this class through C++, Java,
    or the %OpenSim GUI, but **not** through Python or MATLAB. This is because
    Python and MATLAB do not enforce constness and thus allow modifying the
    trajectory.


    A StatesTrajectory is not very useful on its own, since neither the
    trajectory nor the contained states know how the Component%s name the state
    variables they create. You probably want to use the trajectory with an
    OpenSim::Model, through which the state variables have a meaning (e.g.,
    `model.getStateVariableValue(states[0], "soleus_r/activation")`).

    SimTK::State%s have a tight association with a specific OpenSim::Model
    (actually, with the SimTK::System within an OpenSim::Model). However,
    the StatesTrajectory does not know anything about the model to which
    it corresponds. So, for example, you could use a single StatesTrajectory
    with a generic gait2392 model as well as with a scaled (subject-specific)
    gait2392 model. This flexibility may be beneficial in some scenarios, but
    also allows one to accidentally use the wrong model with a given states
    trajectory, potentially leading to silent errors that could compromise a
    scientific study.

    To increase your confidence that a StatesTrajectory matches a given Model,
    you can perform some weak checks with isCompatibleWith().


    Here are a few basic things you can do with a StatesTrajectory, assuming you
    already have one:

    .. code-block:: c++

        StatesTrajectory states = getStatesTrajectorySomehow();
        const double numStates = states.getSize();
        const double initialTime = states[0].getTime();
        const double finalTime = states.back().getTime();

    Without a model, you can access the state variable values, but you won't
    know the identity of such state variables.

    .. code-block:: c++

        int numGeneralizedCoordinates = states[0].getNQ();
        const SimTK::Vector& generalizedCoordinateValues = states[0].getQ();

    To do most things with the StatesTrajectory, you'll need a model as well as
    its underlying SimTK::System. **It is therefore required that you call
    `Model::initSystem()` before you try to use any states with the model**:

    .. code-block:: c++

        Model model("subject01.osim");
        model.initSystem();
        double knee_angle = model.getStateVariableValue(states[0], "knee/flexion/value");
        Vec3 com = model.calcMassCenterPosition(states[0]);

    Depending on the quantity you want to obtain, you may also need to realize
    the state to a certain stage:

    .. code-block:: c++

        model.getMultibodySystem().realize(states[0], SimTK::Stage::Velocity);
        model.getMuscles().get("soleus_r").getActivation(states[0]);

    You can iterate through a trajectory to access the value of a state variable
    at each time in the trajectory.

    .. code-block:: c++

        for (const auto& state : states) {
            std::cout << state.getTime() << " "
                      << model.getStateVariableValue(state, "knee/flexion/value")
                      << std::endl;
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Create an empty trajectory of states."""
        _simulation.StatesTrajectory_swiginit(self, _simulation.new_StatesTrajectory())

    def getSize(self) -> "size_t":
        r""" The number of SimTK::State%s in the trajectory."""
        return _simulation.StatesTrajectory_getSize(self)

    def get(self, index: "size_t") -> "SimTK::State const &":
        r"""
         Get a const reference to the state at a given index in the trajectory.

        :raises: IndexOutOfRange If the index is greater than the size of the
                                    trajectory.
        """
        return _simulation.StatesTrajectory_get(self, index)

    def front(self) -> "SimTK::State const &":
        r""" Get a const reference to the first state in the trajectory."""
        return _simulation.StatesTrajectory_front(self)

    def back(self) -> "SimTK::State const &":
        r""" Get a const reference to the last state in the trajectory."""
        return _simulation.StatesTrajectory_back(self)

    def begin(self) -> "OpenSim::StatesTrajectory::const_iterator":
        r"""
         Iterator pointing to first SimTK::State; does not allow modifying the
        states. Allows using this class in a range for loop.
        """
        return _simulation.StatesTrajectory_begin(self)

    def end(self) -> "OpenSim::StatesTrajectory::const_iterator":
        r"""
         Iterator pointing past the end of the trajectory. Allows using this
        class in a range for loop.
        """
        return _simulation.StatesTrajectory_end(self)

    def clear(self) -> "void":
        r""" Clear all the states in the trajectory."""
        return _simulation.StatesTrajectory_clear(self)

    def append(self, state: "State") -> "void":
        r"""
         Append a SimTK::State to this trajectory.
        This function ensures that the time in the new SimTK::State is greater
        than or equal to the time in the last SimTK::State in the trajectory.

        The state that ends up in the trajectory is a deep copy of the one
        passed in.
        """
        return _simulation.StatesTrajectory_append(self, state)

    def hasIntegrity(self) -> "bool":
        r"""
         Checks isNondecreasingInTime() and isConsistent().
        The design of this class is such that this method should always return
        true. This check may be more useful in Python or MATLAB, in which it's
        possible to edit the trajectory such that this method could return
        false.
        """
        return _simulation.StatesTrajectory_hasIntegrity(self)

    def isNondecreasingInTime(self) -> "bool":
        r""" Returns true if times are non-decreasing; false otherwise."""
        return _simulation.StatesTrajectory_isNondecreasingInTime(self)

    def isConsistent(self) -> "bool":
        r"""
         Checks if the states have the same number of state variables,
        constraints, etc. Returns true if the following quantities are the same
        for all states in the trajectory:
        - number of generalized coordinates (Q's)
        - number of generalized speeds (U's)
        - number of auxiliary state variables (Z's)
        - number of position constraints (QErr's)
        - number of velocity constraints (UErr's)
        - number of acceleration constraints (UDotErr's)
        - number of constraint Lagrange multipliers
        - number of event triggers

        Returns false otherwise.
        """
        return _simulation.StatesTrajectory_isConsistent(self)

    def isCompatibleWith(self, model: "Model") -> "bool":
        r"""
         Weak check for if the trajectory can be used with the given model.
        Returns true if the trajectory isConsistent() and if the number of speeds
        in the model matches the number of U's in state.

        Returns false otherwise. This method **cannot** guarantee that the
        trajectory will work with the given model, and makes no attempt to
        determine if the trajectory was generated with the given model.
        """
        return _simulation.StatesTrajectory_isCompatibleWith(self, model)

    def exportToTable(self, *args) -> "OpenSim::TimeSeriesTable":
        r"""
         Export the continuous state variables to a data table, perhaps to write
        to a file and postprocess in MATLAB/Python/Excel. The names of the
        columns in the table will be the absolute names of the continuous state
        variables (e.g., `knee/flexion/angle`).

        You must provide a model that is compatible with this trajectory,
        since only the model knows the names of the state variables.

        By default, all continuous state variables are written to the table
        (one per column). If you only want some of them to be written to the
        table, use the `stateVars` argument to specify their absolute names
        (e.g., `knee/flexion/angle`).

        .. code-block:: c++

            auto allStateVars = states.exportToTable(model);
            auto kneeStates = states.exportToTable(model, {"knee/flexion/value",
                                                           "knee/flexion/speed"});

        :raises: IncompatibleModel Thrown if the Model fails the check
                 isCompatibleWith().

        See DataAdapter for details on writing to files.
        """
        return _simulation.StatesTrajectory_exportToTable(self, *args)

    @staticmethod
    def createFromStatesTable(model: "Model", table: "TimeSeriesTable", allowMissingColumns: "bool"=False, allowExtraColumns: "bool"=False, assemble: "bool"=False) -> "OpenSim::StatesTrajectory":
        r"""
         Create a partial trajectory of States from a states table.
        The resulting StatesTrajectory will restore continuous state
        variable values, but not discrete state variable values, modeling
        option values, etc. Also, keep in mind that states files usually
        do not contain the state values to full precision, and thus cannot
        exactly reproduce results from the initial state trajectory. Lastly,
        this function optionally modifies each state to obey any constraints in
        the model (by calling Model::assemble()).

        The states in the resulting trajectory will be realized to
        SimTK::Stage::Instance. You should not use the resulting trajectory with
        an instance of the model other than the one you passed to this function
        (the state contains Instance-stage cache variables that are pointers to
        objects in the model; e.g., force elements).

        Notes: The naming convention for state variables changed in OpenSim v4.0;
        `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,
        `soleus_r/activation` used to be `soleus_r.activation`, etc. This
        function can handle column labels that use the pre-v4.0 naming
        convention.

        :type model: :py:class:`Model`
        :param model: The Model to which the states belong. A Model is necessary
                 because the data file lists the state variables by name.
        :type table: :py:class:`TimeSeriesTable`
        :param table: The table containing state values.
        :type allowMissingColumns: boolean, optional
        :param allowMissingColumns: If false, throws exception if there are
                 continuous state variables in the Model for which there is no
                 column in the table. If true, no exception is thrown but such
                 state variables are set to NaN.
        :type allowExtraColumns: boolean, optional
        :param allowExtraColumns: If false, throws exception if there are
                 columns in the table that do not correspond to continuous state
                 variables in the Model. If true, such columns of the table are
                 ignored.
        :type assemble: boolean, optional
        :param assemble: Modify state variable values to satisfy
                 kinematic constraints (by calling Model::assemble()).
                 Use this option if the provided states are incomplete (for example,
                 the values for dependent coordinates are unspecified).
                 Caution: enforcing constraints can drastically alter the
                 provided states if they do not already obey the constraints.
                 Do not use this option with results from a forward simulation: the
                 states trajectory from a forward simulation may not meet the
                 model's assembly accuracy, and therefore assembling could
                 alter the trajectory and cause inconsistency between coordinate
                 values and speeds.

        Here is how you might use this function in python:

        .. code-block:: python

            import opensim
            model = opensim.Model("subject01.osim")
            table = opensim.TimeSeriesTable("subject01_states.sto")
            states = opensim.StatesTrajectory.createFromStatesTable(model, table)
            print(states[0].getTime())
            print(model.getStateVariableValue(states[0], "knee/flexion/value"))

        :raises: MissingColumns See the description of the
                 `allowMissingColumns` argument.

        :raises: ExtraColumns See the description of the
                 `allowExtraColumns` argument.

        :raises: NonUniqueLabels Thrown if multiple columns in
                 the table have the same name.

        :raises: DataIsInDegrees Thrown if the table is in degrees
                 (inDegrees=yes); angular quantities must use radians to properly
                 create the trajectory.
        """
        return _simulation.StatesTrajectory_createFromStatesTable(model, table, allowMissingColumns, allowExtraColumns, assemble)

    @staticmethod
    def createFromStatesStorage(*args) -> "OpenSim::StatesTrajectory":
        r"""
        *Overload 1:*

        This function is identical to createFromStatesTable() except that this
        function accepts a Storage instead of a TimeSeriesTable.

        |

        *Overload 2:*
         Convenience form of createFromStatesStorage() that takes the path to a
        Storage file instead of a Storage object. This convenience form uses the
        default values for `allowMissingColumns` and `allowExtraColumns`.
        """
        return _simulation.StatesTrajectory_createFromStatesStorage(*args)


    def __iter__(self):
        """Get an iterator for this Set, to be used as such (where `states` is
        the StatesTrajectory object)::

            for state in states:
                model.calcMassCenterPosition(state)
        """
        it = self.begin()
        while it != self.end():
            yield it.next()

    def getBetween(self, *args, **kwargs):
        iter_range = self._getBetween(*args, **kwargs)
        it = iter_range.begin()
        while it != iter_range.end():
            yield it.next()


    def __getitem__(self, i: "int") -> "SimTK::State const &":
        return _simulation.StatesTrajectory___getitem__(self, i)
    __swig_destroy__ = _simulation.delete_StatesTrajectory

# Register StatesTrajectory in _simulation:
_simulation.StatesTrajectory_swigregister(StatesTrajectory)

def StatesTrajectory_createFromStatesTable(model: "Model", table: "TimeSeriesTable", allowMissingColumns: "bool"=False, allowExtraColumns: "bool"=False, assemble: "bool"=False) -> "OpenSim::StatesTrajectory":
    r"""
     Create a partial trajectory of States from a states table.
    The resulting StatesTrajectory will restore continuous state
    variable values, but not discrete state variable values, modeling
    option values, etc. Also, keep in mind that states files usually
    do not contain the state values to full precision, and thus cannot
    exactly reproduce results from the initial state trajectory. Lastly,
    this function optionally modifies each state to obey any constraints in
    the model (by calling Model::assemble()).

    The states in the resulting trajectory will be realized to
    SimTK::Stage::Instance. You should not use the resulting trajectory with
    an instance of the model other than the one you passed to this function
    (the state contains Instance-stage cache variables that are pointers to
    objects in the model; e.g., force elements).

    Notes: The naming convention for state variables changed in OpenSim v4.0;
    `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,
    `soleus_r/activation` used to be `soleus_r.activation`, etc. This
    function can handle column labels that use the pre-v4.0 naming
    convention.

    :type model: :py:class:`Model`
    :param model: The Model to which the states belong. A Model is necessary
             because the data file lists the state variables by name.
    :type table: :py:class:`TimeSeriesTable`
    :param table: The table containing state values.
    :type allowMissingColumns: boolean, optional
    :param allowMissingColumns: If false, throws exception if there are
             continuous state variables in the Model for which there is no
             column in the table. If true, no exception is thrown but such
             state variables are set to NaN.
    :type allowExtraColumns: boolean, optional
    :param allowExtraColumns: If false, throws exception if there are
             columns in the table that do not correspond to continuous state
             variables in the Model. If true, such columns of the table are
             ignored.
    :type assemble: boolean, optional
    :param assemble: Modify state variable values to satisfy
             kinematic constraints (by calling Model::assemble()).
             Use this option if the provided states are incomplete (for example,
             the values for dependent coordinates are unspecified).
             Caution: enforcing constraints can drastically alter the
             provided states if they do not already obey the constraints.
             Do not use this option with results from a forward simulation: the
             states trajectory from a forward simulation may not meet the
             model's assembly accuracy, and therefore assembling could
             alter the trajectory and cause inconsistency between coordinate
             values and speeds.

    Here is how you might use this function in python:

    .. code-block:: python

        import opensim
        model = opensim.Model("subject01.osim")
        table = opensim.TimeSeriesTable("subject01_states.sto")
        states = opensim.StatesTrajectory.createFromStatesTable(model, table)
        print(states[0].getTime())
        print(model.getStateVariableValue(states[0], "knee/flexion/value"))

    :raises: MissingColumns See the description of the
             `allowMissingColumns` argument.

    :raises: ExtraColumns See the description of the
             `allowExtraColumns` argument.

    :raises: NonUniqueLabels Thrown if multiple columns in
             the table have the same name.

    :raises: DataIsInDegrees Thrown if the table is in degrees
             (inDegrees=yes); angular quantities must use radians to properly
             create the trajectory.
    """
    return _simulation.StatesTrajectory_createFromStatesTable(model, table, allowMissingColumns, allowExtraColumns, assemble)

def StatesTrajectory_createFromStatesStorage(*args) -> "OpenSim::StatesTrajectory":
    r"""
    *Overload 1:*

    This function is identical to createFromStatesTable() except that this
    function accepts a Storage instead of a TimeSeriesTable.

    |

    *Overload 2:*
     Convenience form of createFromStatesStorage() that takes the path to a
    Storage file instead of a Storage object. This convenience form uses the
    default values for `allowMissingColumns` and `allowExtraColumns`.
    """
    return _simulation.StatesTrajectory_createFromStatesStorage(*args)

class IteratorRangeStatesTrajectoryIterator(object):
    r"""
     Helper class to use range-based for loops with a pair of iterators. This
    class should only be used when you're sure the iterators are valid. Don't
    use this class directly; instead, use makeIteratorRange().

    Here's an example of using iterators `first` and `last` to iterate over the
    range `[first, last)` (that is, `last` won't be reached):

    .. code-block:: c++

        std::vector<int> v {5, 10, 15, 20, 22};
        auto first = std::lower_bound(v.begin(), v.end(), 10);
        auto last = std::lower_bound(v.begin(), v.end(), 15); // actually points to 20.
        for (auto& x : makeIteratorRange(first, last)) {
            ...
        }

    You can also use this class with an std::pair of iterators, such as that
    returned by std::multimap::equal_range(). We assume the first iterator in the
    pair is the first iterator in the range, and the second iterator in the pair is
    the last iterator in the range.

    .. code-block:: c++

        std::multimap<std::string, int> map;
        ...
        for (auto& x : makeIteratorRange(map.equal_range("some_key"))) {
            ...
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simulation.IteratorRangeStatesTrajectoryIterator_swiginit(self, _simulation.new_IteratorRangeStatesTrajectoryIterator(*args))

    def begin(self) -> "std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator":
        return _simulation.IteratorRangeStatesTrajectoryIterator_begin(self)

    def end(self) -> "std::vector< SimTK::State,std::allocator< SimTK::State > >::const_iterator":
        return _simulation.IteratorRangeStatesTrajectoryIterator_end(self)
    __swig_destroy__ = _simulation.delete_IteratorRangeStatesTrajectoryIterator

# Register IteratorRangeStatesTrajectoryIterator in _simulation:
_simulation.IteratorRangeStatesTrajectoryIterator_swigregister(IteratorRangeStatesTrajectoryIterator)

class StatesTrajectoryReporter(opensim.common.AbstractReporter):
    r"""
     Stores the states during a simulation in a StatesTrajectory.

    This class was introduced in v4.0 and is intended to replace the
    StatesReporter analysis.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::StatesTrajectoryReporter *":
        return _simulation.StatesTrajectoryReporter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.StatesTrajectoryReporter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.StatesTrajectoryReporter_getClassName()

    def clone(self) -> "OpenSim::StatesTrajectoryReporter *":
        return _simulation.StatesTrajectoryReporter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.StatesTrajectoryReporter_getConcreteClassName(self)

    def getStates(self) -> "OpenSim::StatesTrajectory const &":
        r""" Access the accumulated states."""
        return _simulation.StatesTrajectoryReporter_getStates(self)

    def clear(self) -> "void":
        r""" Clear the accumulated states."""
        return _simulation.StatesTrajectoryReporter_clear(self)

    def __init__(self):
        _simulation.StatesTrajectoryReporter_swiginit(self, _simulation.new_StatesTrajectoryReporter())
    __swig_destroy__ = _simulation.delete_StatesTrajectoryReporter

# Register StatesTrajectoryReporter in _simulation:
_simulation.StatesTrajectoryReporter_swigregister(StatesTrajectoryReporter)

def StatesTrajectoryReporter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::StatesTrajectoryReporter *":
    return _simulation.StatesTrajectoryReporter_safeDownCast(obj)

def StatesTrajectoryReporter_getClassName() -> "std::string const &":
    return _simulation.StatesTrajectoryReporter_getClassName()

class PositionMotion(ModelComponent):
    r"""
     This class prescribes the value, speed, and acceleration of all coordinates
    in the model using SimTK::Motion. SimTK::Motion%s remove degrees of freedom
    from the system rather than add constraints. This is an alternative to
    prescribing kinematics using Coordinate's prescribed_function, which uses a
    kinematic constraint. When prescribing motion, the system must compute
    constraint forces to apply to enforce the prescribed motion;
    such forces are available via SimbodyMatterSubsystem::findMotionForces().
    Notes: This class requires that *all* coordinates are prescribed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PositionMotion *":
        return _simulation.PositionMotion_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.PositionMotion_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.PositionMotion_getClassName()

    def clone(self) -> "OpenSim::PositionMotion *":
        return _simulation.PositionMotion_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.PositionMotion_getConcreteClassName(self)

    def copyProperty_default_enabled(self, source: "PositionMotion") -> "void":
        return _simulation.PositionMotion_copyProperty_default_enabled(self, source)

    def append_default_enabled(self, value: "bool const &") -> "int":
        return _simulation.PositionMotion_append_default_enabled(self, value)

    def constructProperty_default_enabled(self, initValue: "bool const &") -> "void":
        return _simulation.PositionMotion_constructProperty_default_enabled(self, initValue)

    def get_default_enabled(self, *args) -> "bool const &":
        return _simulation.PositionMotion_get_default_enabled(self, *args)

    def upd_default_enabled(self, *args) -> "bool &":
        return _simulation.PositionMotion_upd_default_enabled(self, *args)

    def set_default_enabled(self, *args) -> "void":
        return _simulation.PositionMotion_set_default_enabled(self, *args)

    def copyProperty_functions(self, source: "PositionMotion") -> "void":
        return _simulation.PositionMotion_copyProperty_functions(self, source)

    def append_functions(self, value: "FunctionSet") -> "int":
        return _simulation.PositionMotion_append_functions(self, value)

    def constructProperty_functions(self, initValue: "FunctionSet") -> "void":
        return _simulation.PositionMotion_constructProperty_functions(self, initValue)

    def get_functions(self, *args) -> "OpenSim::FunctionSet const &":
        return _simulation.PositionMotion_get_functions(self, *args)

    def upd_functions(self, *args) -> "OpenSim::FunctionSet &":
        return _simulation.PositionMotion_upd_functions(self, *args)

    def set_functions(self, *args) -> "void":
        return _simulation.PositionMotion_set_functions(self, *args)

    def __init__(self, *args):
        _simulation.PositionMotion_swiginit(self, _simulation.new_PositionMotion(*args))
    __swig_destroy__ = _simulation.delete_PositionMotion

    def setPositionForCoordinate(self, coord: "Coordinate", position: "Function") -> "void":
        r"""
        Set a function to calculate the position for a given coordinate.
        The speed and acceleration of the coordinate are obtained as derivatives
        of the provided function.
        """
        return _simulation.PositionMotion_setPositionForCoordinate(self, coord, position)

    def setDefaultEnabled(self, enabled: "bool") -> "void":
        r"""
        This determines if, after Model::initSystem(), these prescribed
        motions are enabled or disabled.
        """
        return _simulation.PositionMotion_setDefaultEnabled(self, enabled)

    def getDefaultEnabled(self) -> "bool":
        return _simulation.PositionMotion_getDefaultEnabled(self)

    def setEnabled(self, state: "State", enabled: "bool") -> "void":
        r"""
        Use this after Model::initSystem() to set if the prescribed motions
        are enforced.
        """
        return _simulation.PositionMotion_setEnabled(self, state, enabled)

    def getEnabled(self, state: "State") -> "bool":
        return _simulation.PositionMotion_getEnabled(self, state)

    @staticmethod
    def createFromTable(model: "Model", coords: "TimeSeriesTable", allowExtraColumns: "bool"=False) -> "std::unique_ptr< OpenSim::PositionMotion >":
        r"""
        Create a PositionMotion that prescribes kinematics for all coordinates
        in a model, given a data table containing coordinate values for all
        coordinates using GCVSpline. If the table contains any columns that are
        not the names of coordinate value state variables, an exception is
        thrown (unless allowExtraColumns is true).

        Notes: If the data in the table violates kinematic constraints in the
        model, the resulting PositionMotion will also violate the kinematic
        constraints.

        This fuction ignores the inDegrees header metadata.
        """
        return _simulation.PositionMotion_createFromTable(model, coords, allowExtraColumns)

    @staticmethod
    def createFromStatesTrajectory(model: "Model", statesTraj: "StatesTrajectory") -> "std::unique_ptr< OpenSim::PositionMotion >":
        r"""
        Create a PositionMotion that prescribes kinematics for all coordinates
        in a model, given a StatesTrajectory.

        Notes: If the states trajectory violates kinematic constraints in the
        model, the resulting PositionMotion will also violate the kinematic
        constraints.
        """
        return _simulation.PositionMotion_createFromStatesTrajectory(model, statesTraj)

    def exportToTable(self, time: "StdVectorDouble") -> "OpenSim::TimeSeriesTable":
        return _simulation.PositionMotion_exportToTable(self, time)

# Register PositionMotion in _simulation:
_simulation.PositionMotion_swigregister(PositionMotion)

def PositionMotion_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PositionMotion *":
    return _simulation.PositionMotion_safeDownCast(obj)

def PositionMotion_getClassName() -> "std::string const &":
    return _simulation.PositionMotion_getClassName()

def PositionMotion_createFromTable(model: "Model", coords: "TimeSeriesTable", allowExtraColumns: "bool"=False) -> "std::unique_ptr< OpenSim::PositionMotion >":
    r"""
    Create a PositionMotion that prescribes kinematics for all coordinates
    in a model, given a data table containing coordinate values for all
    coordinates using GCVSpline. If the table contains any columns that are
    not the names of coordinate value state variables, an exception is
    thrown (unless allowExtraColumns is true).

    Notes: If the data in the table violates kinematic constraints in the
    model, the resulting PositionMotion will also violate the kinematic
    constraints.

    This fuction ignores the inDegrees header metadata.
    """
    return _simulation.PositionMotion_createFromTable(model, coords, allowExtraColumns)

def PositionMotion_createFromStatesTrajectory(model: "Model", statesTraj: "StatesTrajectory") -> "std::unique_ptr< OpenSim::PositionMotion >":
    r"""
    Create a PositionMotion that prescribes kinematics for all coordinates
    in a model, given a StatesTrajectory.

    Notes: If the states trajectory violates kinematic constraints in the
    model, the resulting PositionMotion will also violate the kinematic
    constraints.
    """
    return _simulation.PositionMotion_createFromStatesTrajectory(model, statesTraj)


def simulate(model: "Model", initialState: "State", finalTime: "double", saveStatesFile: "bool"=False) -> "SimTK::State":
    r"""
    Simulate a model from an initial state and return the final state.
       If the model's useVisualizer flag is true, the user is repeatedly prompted
       to either begin simulating or quit. The provided state is not updated but
       the final state is returned at the end of the simulation, when finalTime is
       reached. %Set saveStatesFile=true to save the states to a storage file as:
       "<model_name>_states.sto".
    """
    return _simulation.simulate(model, initialState, finalTime, saveStatesFile)

def updateStateLabels40(model: "Model", labels: "StdVectorString") -> "void":
    r"""
    Update a vector of state labels (in place) to use post-4.0 state paths
    instead of pre-4.0 state names. For example, this converts labels as
    follows:
      - `pelvis_tilt` -> `/jointset/ground_pelvis/pelvis_tilt/value`
      - `pelvis_tilt_u` -> `/jointset/ground_pelvis/pelvis_tilt/speed`
      - `soleus.activation` -> `/forceset/soleus/activation`
      - `soleus.fiber_length` -> `/forceset/soleus/fiber_length`
    This can also be used to update the column labels of an Inverse
    Kinematics Tool solution MOT file so that the data can be used as
    states. If a label does not identify a state in the model, the column
    label is not changed.
    :raises: Exception if labels are not unique.
    """
    return _simulation.updateStateLabels40(model, labels)

def updatePre40KinematicsFilesFor40MotionType(*args) -> "void":
    r"""
    This function can be used to upgrade MOT files generated with versions
       before 4.0 in which some data columns are associated with coordinates
       that were incorrectly marked as Rotational (rather than Coupled). Specific
       instances of the issue are the patella coordinate in the Rajagopal 2015 and
       leg6dof9musc models. In these cases, the patella will visualize incorrectly
       in the GUI when replaying the kinematics from the MOT file, and Static
       Optimization will yield incorrect results.

       The new files are written to the same directories as the original files,
       but with the provided suffix (before the file extension). To overwrite your
       original files, set the suffix to an emtpty string.

       If the file does not need to be updated, no new file is written.

       Conversion of the data only occurs for files in degrees ("inDegrees=yes"
       in the header).

       Do not use this function with MOT files generated by 4.0 or later; doing
       so will cause your data to be altered incorrectly. We do not detect whether
       or not your MOT file is pre-4.0.

       In OpenSim 4.0, MotionTypes for
       Coordinates are now determined strictly by the coordinates' owning Joint.
       In older models, the MotionType, particularly for CustomJoints, were user-
       specified. That entailed in some cases, incorrectly labeling a Coordinate
       as being Rotational, for example, when it is in fact Coupled. For the above
       models, for example, the patella Coordinate had been user-specified to be
       Rotational, but the angle of the patella about the Z-axis of the patella
       body, is a spline function (e.g. coupled function) of the patella
       Coordinate. Thus, the patella Coordinate is not an angle measurement
       and is not classified as Rotational. Use this utility to remove any unit
       conversions from Coordinates that were incorrectly labeled
       as Rotational in the past. For these Coordinates only, the utility will undo
       the incorrect radians to degrees conversion.
    """
    return _simulation.updatePre40KinematicsFilesFor40MotionType(*args)

def updateSocketConnecteesBySearch(model: "Model") -> "void":
    r"""
     This function attempts to update the connectee path for any Socket anywhere
    in the model whose connectee path does not point to an existing component.
    The paths are updated by searching the model for a component with the
    correct name. For example, a connectee path like
    `../../some/invalid/path/to/foo` will be updated to `/bodyset/foo` if a Body
    named `foo` exists in the Model's BodySet. If a socket specifies a Body `foo` and
    more than one Body `foo` exists in the model, we emit a warning and the
    socket that specified `foo` is not altered.

    This method is intended for use with models loaded from version-30516 XML
    files to bring them up to date with the 4.0 interface.

    """
    return _simulation.updateSocketConnecteesBySearch(model)

def createStateVariableNamesInSystemOrder(model: "Model") -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    The map provides the index of each state variable in
    SimTK::State::getY() from its each state variable path string.
    Empty slots in Y (e.g., for quaternions) are ignored.
    """
    return _simulation.createStateVariableNamesInSystemOrder(model)

def createControlNamesFromModel(*args) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    *Overload 1:*
    Create a vector of control names based on the actuators in the model for
    which appliesForce == True. For actuators with one control (e.g.
    ScalarActuator) the control name is simply the actuator name. For actuators
    with multiple controls, each control name is the actuator name appended by
    the control index (e.g. "/actuator_0"); modelControlIndices has length equal
    to the number of controls associated with actuators that apply a force
    (appliesForce == True). Its elements are the indices of the controls in the
    Model::updControls() that are associated with actuators that apply a force.


    |

    *Overload 2:*
    Same as above, but when there is no mapping to the modelControlIndices.
    """
    return _simulation.createControlNamesFromModel(*args)

def createSystemControlIndexMap(model: "Model") -> "std::unordered_map< std::string,int >":
    r"""
    The map provides the index of each control variable in the SimTK::Vector
    returned by Model::getControls(), using the control name as the
    key.
    :raises: Exception if the order of actuators in the model does not match
            the order of controls in Model::getControls(). This is an internal
            error, but you may be able to avoid the error by ensuring all Actuator%s
            are in the Model's ForceSet.
    """
    return _simulation.createSystemControlIndexMap(model)

def checkOrderSystemControls(model: "Model") -> "void":
    r"""
    Throws an exception if the order of the controls in the model is not the
    same as the order of the actuators in the model.
    """
    return _simulation.checkOrderSystemControls(model)

def checkLabelsMatchModelStates(model: "Model", labels: "StdVectorString") -> "void":
    r"""
    Throws an exception if any label in the provided list does not match any
    state variable names in the model.
    """
    return _simulation.checkLabelsMatchModelStates(model, labels)

def createSyntheticIMUAccelerationSignals(model: "Model", statesTable: "TimeSeriesTable", controlsTable: "TimeSeriesTable", framePaths: "StdVectorString") -> "OpenSim::TimeSeriesTableVec3":
    r"""
    Calculate "synthetic" acceleration signals equivalent to signals recorded
    from inertial measurement units (IMUs). First, this utility computes the
    linear acceleration for each frame included in 'framePaths' using Frame's
    'linear_acceleration' Output. Then, to mimic acceleration signals measured
    from IMUs, the model's gravitational acceleration vector is subtracted from
    the linear accelerations and the resulting accelerations are re-expressed in
    the bases of the associated Frame%s.

    Notes: The linear acceleration Output%s are computed using the analyze()
    simulation utility, and therefore the 'statesTable' and 'controlsTable'
    arguments must contain the same time points and we assume that the states
    obey any kinematic constraints in the Model.

    The passed in model must have the correct mass and inertia properties
    included, since computing accelerations requires realizing to
    SimTK::Stage::Acceleration which depends on SimTK::Stage::Dynamics.

    """
    return _simulation.createSyntheticIMUAccelerationSignals(model, statesTable, controlsTable, framePaths)

def analyze(*args) -> "OpenSim::TimeSeriesTable_< double >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyze(*args)

def analyzeVec3(*args) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyzeVec3(*args)

def analyzeSpatialVec(*args) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec3,1 > >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided states and controls tables.
    The controls table is used to set the model's controls vector.
    We assume the states and controls tables contain the same time points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Controls missing from the controls table are given a value of 0.

    If you analysis depends on the values of discrete variables in the state,
    you may provide those values via the optional argument
    "discreteVariablesTable". This table should contain column labels with the
    following format: <path_to_component>/<discrete_var_name>. For example,
    "/forceset/muscle/implicitderiv_normalized_tendon_force".

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.
    """
    return _simulation.analyzeSpatialVec(*args)
class VisualizerUtilities(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def showMotion(arg1: "Model", arg2: "TimeSeriesTable") -> "void":
        r"""
        Play back an existing motion (from the table) in the
        simbody-visualizer. The Storage should contain all generalized
        coordinates. The visualizer window allows the user to control playback
        speed. This function blocks until the user exits the simbody-visualizer
        window.
        """
        return _simulation.VisualizerUtilities_showMotion(arg1, arg2)

    @staticmethod
    def showModel(arg1: "Model") -> "void":
        r"""
        Visualize the passed in model in a simbody-visualizer window.
        This function blocks until the user exits the simbody-visualizer
        window.
        """
        return _simulation.VisualizerUtilities_showModel(arg1)

    @staticmethod
    def showMarkerData(arg1: "TimeSeriesTableVec3") -> "void":
        r"""
        Show markers with time histories specified by the passed in
               TimeSeriesTableVec3. Visualization is shown in the simbody visualizer.
               Function blocks waiting for user to hit a key to start.
        """
        return _simulation.VisualizerUtilities_showMarkerData(arg1)

    @staticmethod
    def showOrientationData(*args) -> "void":
        r"""
        Show frames with time histories specified by the passed in
               TimeSeriesTableQuaternion. Visualization is shown in the simbody
              visualizer.
              - layout options:
                   -'line' default layout frames in a row along Z axis
                   -'circle' frames laid out around a half-circle in the Y-Z plane
                   -'model' Load passed in model and overlay frames at origins of
                       corresponding bodies at default pose. Must have invoked
                       initSystem() on the model.

              Function blocks waiting for user to hit a key to start.
        """
        return _simulation.VisualizerUtilities_showOrientationData(*args)

    def __init__(self):
        _simulation.VisualizerUtilities_swiginit(self, _simulation.new_VisualizerUtilities())
    __swig_destroy__ = _simulation.delete_VisualizerUtilities

# Register VisualizerUtilities in _simulation:
_simulation.VisualizerUtilities_swigregister(VisualizerUtilities)

def VisualizerUtilities_showMotion(arg1: "Model", arg2: "TimeSeriesTable") -> "void":
    r"""
    Play back an existing motion (from the table) in the
    simbody-visualizer. The Storage should contain all generalized
    coordinates. The visualizer window allows the user to control playback
    speed. This function blocks until the user exits the simbody-visualizer
    window.
    """
    return _simulation.VisualizerUtilities_showMotion(arg1, arg2)

def VisualizerUtilities_showModel(arg1: "Model") -> "void":
    r"""
    Visualize the passed in model in a simbody-visualizer window.
    This function blocks until the user exits the simbody-visualizer
    window.
    """
    return _simulation.VisualizerUtilities_showModel(arg1)

def VisualizerUtilities_showMarkerData(arg1: "TimeSeriesTableVec3") -> "void":
    r"""
    Show markers with time histories specified by the passed in
           TimeSeriesTableVec3. Visualization is shown in the simbody visualizer.
           Function blocks waiting for user to hit a key to start.
    """
    return _simulation.VisualizerUtilities_showMarkerData(arg1)

def VisualizerUtilities_showOrientationData(*args) -> "void":
    r"""
    Show frames with time histories specified by the passed in
           TimeSeriesTableQuaternion. Visualization is shown in the simbody
          visualizer.
          - layout options:
               -'line' default layout frames in a row along Z axis
               -'circle' frames laid out around a half-circle in the Y-Z plane
               -'model' Load passed in model and overlay frames at origins of
                   corresponding bodies at default pose. Must have invoked
                   initSystem() on the model.

          Function blocks waiting for user to hit a key to start.
    """
    return _simulation.VisualizerUtilities_showOrientationData(*args)

class TableOperator(opensim.common.OpenSimObject):
    r"""
     This abstract class describes *any* operation that consumes and modifies a
    TimeSeriesTable as part of a TableProcessor.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableOperator *":
        return _simulation.TableOperator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TableOperator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TableOperator_getClassName()

    def clone(self) -> "OpenSim::TableOperator *":
        return _simulation.TableOperator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TableOperator_getConcreteClassName(self)

    def operate(self, table: "TimeSeriesTable", model: "Model") -> "void":
        r"""
        This function may or may not be provided with a model. If the operation
           requires a model and model == nullptr, an exception is thrown.
        """
        return _simulation.TableOperator_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TableOperator

# Register TableOperator in _simulation:
_simulation.TableOperator_swigregister(TableOperator)

def TableOperator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableOperator *":
    return _simulation.TableOperator_safeDownCast(obj)

def TableOperator_getClassName() -> "std::string const &":
    return _simulation.TableOperator_getClassName()

class TableProcessor(opensim.common.OpenSimObject):
    r"""
     This class describes a workflow for processing a table using
    TableOperator%s. The user must provide a source table either as a filepath
    to a table or an in-memory TimeSeriesTable. In C++, one can easily chain
    together the operators in a processor using the C++ pipe operator:

    .. code-block:: c++

        TableProcessor proc = TableProcessor("file.sto") | TabOpLowPassFilter(6);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableProcessor *":
        return _simulation.TableProcessor_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TableProcessor_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TableProcessor_getClassName()

    def clone(self) -> "OpenSim::TableProcessor *":
        return _simulation.TableProcessor_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TableProcessor_getConcreteClassName(self)

    def copyProperty_filepath(self, source: "TableProcessor") -> "void":
        return _simulation.TableProcessor_copyProperty_filepath(self, source)

    def append_filepath(self, value: "std::string const &") -> "int":
        return _simulation.TableProcessor_append_filepath(self, value)

    def constructProperty_filepath(self, initValue: "std::string const &") -> "void":
        return _simulation.TableProcessor_constructProperty_filepath(self, initValue)

    def get_filepath(self, *args) -> "std::string const &":
        return _simulation.TableProcessor_get_filepath(self, *args)

    def upd_filepath(self, *args) -> "std::string &":
        return _simulation.TableProcessor_upd_filepath(self, *args)

    def set_filepath(self, *args) -> "void":
        return _simulation.TableProcessor_set_filepath(self, *args)

    def copyProperty_operators(self, source: "TableProcessor") -> "void":
        return _simulation.TableProcessor_copyProperty_operators(self, source)

    def get_operators(self, i: "int") -> "OpenSim::TableOperator const &":
        return _simulation.TableProcessor_get_operators(self, i)

    def upd_operators(self, i: "int") -> "OpenSim::TableOperator &":
        return _simulation.TableProcessor_upd_operators(self, i)

    def set_operators(self, i: "int", value: "TableOperator") -> "void":
        return _simulation.TableProcessor_set_operators(self, i, value)

    def append_operators(self, value: "TableOperator") -> "int":
        return _simulation.TableProcessor_append_operators(self, value)

    def constructProperty_operators(self) -> "void":
        return _simulation.TableProcessor_constructProperty_operators(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        This constructor is only for use when reading (deserializing) from an
           XML file.

        |

        *Overload 2:*
        Use an in-memory TimeSeriesTable as the source table.
           Since this constructor is not explicit, you can provide a
           TimeSeriesTable to any function that takes a TableProcessor (in C++).

        |

        *Overload 3:*
        Use a filepath as the source table.
           Since this constructor is not explicit, you can provide a string
           filepath to any function that takes a TableProcessor.
        """
        _simulation.TableProcessor_swiginit(self, _simulation.new_TableProcessor(*args))

    def process(self, *args) -> "OpenSim::TimeSeriesTable":
        r"""
        *Overload 1:*
        Process and obtain the table. If a filepath is provided, it will be
           evaluated relative to `relativeToDirectory`.
           Certain TableOperator%s require a Model (e.g.,
           TabOpConvertDegreesToRadians, TabOpUseAbsoluteStateNames). If this processor
           contains such an operator, then the operator will throw an exception
           if you do not provide a model when invoking this function.

        |

        *Overload 2:*
        Same as above, but paths are evaluated with respect to the current
           working directory.

        |

        *Overload 3:*
        Same as above, but paths are evaluated with respect to the current
           working directory.
        """
        return _simulation.TableProcessor_process(self, *args)

    def processAndConvertToRadians(self, *args) -> "OpenSim::TimeSeriesTable":
        r"""
        *Overload 1:*
        Same as process(), but the columns of processed table are converted from
           degrees to radians, if applicable. This conversion requires a model.

        |

        *Overload 2:*
        Same as above, but paths are evaluated with respect to the current
           working directory.
        """
        return _simulation.TableProcessor_processAndConvertToRadians(self, *args)

    def empty(self) -> "bool":
        r"""
        Returns true if neither a filepath nor an in-memory table have been
           provided.
        """
        return _simulation.TableProcessor_empty(self)

    def append(self, *args) -> "OpenSim::TableProcessor &":
        r"""
        *Overload 1:*
        Append an operation to the end of the operations in this processor.

        |

        *Overload 2:*
        Append all operations in another processor to this processor.
           The source table of the provided trajectory is ignored.
        """
        return _simulation.TableProcessor_append(self, *args)

    def __or__(self, right: "TableOperator") -> "OpenSim::TableProcessor &":
        r"""
        This operator allows one to write the following code in C++:

           .. code-block:: c++

               TableProcessor proc = TableProcessor("file.sto") |
                       TabOpLowPassFilter(6);
        """
        return _simulation.TableProcessor___or__(self, right)
    __swig_destroy__ = _simulation.delete_TableProcessor

# Register TableProcessor in _simulation:
_simulation.TableProcessor_swigregister(TableProcessor)

def TableProcessor_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableProcessor *":
    return _simulation.TableProcessor_safeDownCast(obj)

def TableProcessor_getClassName() -> "std::string const &":
    return _simulation.TableProcessor_getClassName()

class TabOpConvertDegreesToRadians(TableOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpConvertDegreesToRadians *":
        return _simulation.TabOpConvertDegreesToRadians_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TabOpConvertDegreesToRadians_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TabOpConvertDegreesToRadians_getClassName()

    def clone(self) -> "OpenSim::TabOpConvertDegreesToRadians *":
        return _simulation.TabOpConvertDegreesToRadians_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TabOpConvertDegreesToRadians_getConcreteClassName(self)

    def __init__(self):
        _simulation.TabOpConvertDegreesToRadians_swiginit(self, _simulation.new_TabOpConvertDegreesToRadians())
    __swig_destroy__ = _simulation.delete_TabOpConvertDegreesToRadians

# Register TabOpConvertDegreesToRadians in _simulation:
_simulation.TabOpConvertDegreesToRadians_swigregister(TabOpConvertDegreesToRadians)

def TabOpConvertDegreesToRadians_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpConvertDegreesToRadians *":
    return _simulation.TabOpConvertDegreesToRadians_safeDownCast(obj)

def TabOpConvertDegreesToRadians_getClassName() -> "std::string const &":
    return _simulation.TabOpConvertDegreesToRadians_getClassName()

class TabOpLowPassFilter(TableOperator):
    r""" Apply a low-pass filter to the trajectory."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpLowPassFilter *":
        return _simulation.TabOpLowPassFilter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TabOpLowPassFilter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TabOpLowPassFilter_getClassName()

    def clone(self) -> "OpenSim::TabOpLowPassFilter *":
        return _simulation.TabOpLowPassFilter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TabOpLowPassFilter_getConcreteClassName(self)

    def copyProperty_cutoff_frequency(self, source: "TabOpLowPassFilter") -> "void":
        return _simulation.TabOpLowPassFilter_copyProperty_cutoff_frequency(self, source)

    def append_cutoff_frequency(self, value: "double const &") -> "int":
        return _simulation.TabOpLowPassFilter_append_cutoff_frequency(self, value)

    def constructProperty_cutoff_frequency(self, initValue: "double const &") -> "void":
        return _simulation.TabOpLowPassFilter_constructProperty_cutoff_frequency(self, initValue)

    def get_cutoff_frequency(self, *args) -> "double const &":
        return _simulation.TabOpLowPassFilter_get_cutoff_frequency(self, *args)

    def upd_cutoff_frequency(self, *args) -> "double &":
        return _simulation.TabOpLowPassFilter_upd_cutoff_frequency(self, *args)

    def set_cutoff_frequency(self, *args) -> "void":
        return _simulation.TabOpLowPassFilter_set_cutoff_frequency(self, *args)

    def __init__(self, *args):
        _simulation.TabOpLowPassFilter_swiginit(self, _simulation.new_TabOpLowPassFilter(*args))

    def operate(self, table: "TimeSeriesTable", model: "Model"=None) -> "void":
        return _simulation.TabOpLowPassFilter_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpLowPassFilter

# Register TabOpLowPassFilter in _simulation:
_simulation.TabOpLowPassFilter_swigregister(TabOpLowPassFilter)

def TabOpLowPassFilter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpLowPassFilter *":
    return _simulation.TabOpLowPassFilter_safeDownCast(obj)

def TabOpLowPassFilter_getClassName() -> "std::string const &":
    return _simulation.TabOpLowPassFilter_getClassName()

class TabOpUseAbsoluteStateNames(TableOperator):
    r"""
     Update table column labels to use post-4.0 state paths instead of pre-4.0
    state names. For example, this converts column labels as follows:
      - `pelvis_tilt` -> `/jointset/ground_pelvis/pelvis_tilt/value`
      - `pelvis_tilt_u` -> `/jointset/ground_pelvis/pelvis_tilt/speed`
      - `soleus.activation` -> `/forceset/soleus/activation`
      - `soleus.fiber_length` -> `/forceset/soleus/fiber_length`
    This can also be used to convert an Inverse Kinematics Tool solution MOT
    file to be used as a states file (with only coordinate values).
    If a column label does not identify a state in the model,
    the column label is not changed. Column labels must be unique.
    This operator is implemented using updateStateLabels40().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpUseAbsoluteStateNames *":
        return _simulation.TabOpUseAbsoluteStateNames_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TabOpUseAbsoluteStateNames_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TabOpUseAbsoluteStateNames_getClassName()

    def clone(self) -> "OpenSim::TabOpUseAbsoluteStateNames *":
        return _simulation.TabOpUseAbsoluteStateNames_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TabOpUseAbsoluteStateNames_getConcreteClassName(self)

    def __init__(self):
        _simulation.TabOpUseAbsoluteStateNames_swiginit(self, _simulation.new_TabOpUseAbsoluteStateNames())

    def operate(self, table: "TimeSeriesTable", model: "Model") -> "void":
        return _simulation.TabOpUseAbsoluteStateNames_operate(self, table, model)
    __swig_destroy__ = _simulation.delete_TabOpUseAbsoluteStateNames

# Register TabOpUseAbsoluteStateNames in _simulation:
_simulation.TabOpUseAbsoluteStateNames_swigregister(TabOpUseAbsoluteStateNames)

def TabOpUseAbsoluteStateNames_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TabOpUseAbsoluteStateNames *":
    return _simulation.TabOpUseAbsoluteStateNames_safeDownCast(obj)

def TabOpUseAbsoluteStateNames_getClassName() -> "std::string const &":
    return _simulation.TabOpUseAbsoluteStateNames_getClassName()

class FrameList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.FrameList_swiginit(self, _simulation.new_FrameList(*args))
    __swig_destroy__ = _simulation.delete_FrameList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Frame const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.FrameList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Frame const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.FrameList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Frame const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.FrameList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Frame const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.FrameList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.FrameList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register FrameList in _simulation:
_simulation.FrameList_swigregister(FrameList)

class FrameIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "FrameIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.FrameIterator_equals(self, other)

    def __eq__(self, other: "FrameIterator") -> "bool":
        return _simulation.FrameIterator___eq__(self, other)

    def __ne__(self, other: "FrameIterator") -> "bool":
        return _simulation.FrameIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Frame const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.FrameIterator___ref__(self)

    def deref(self) -> "OpenSim::Frame const &":
        return _simulation.FrameIterator_deref(self)

    def __deref__(self) -> "OpenSim::Frame const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.FrameIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Frame const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.FrameIterator_next(self)
    __swig_destroy__ = _simulation.delete_FrameIterator

    def clone(self) -> "OpenSim::Frame *":
        return _simulation.FrameIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FrameIterator_getConcreteClassName(self)

    def get_frame_geometry(self, *args) -> "OpenSim::FrameGeometry const &":
        return _simulation.FrameIterator_get_frame_geometry(self, *args)

    def get_attached_geometry(self, i: "int") -> "OpenSim::Geometry const &":
        return _simulation.FrameIterator_get_attached_geometry(self, i)
    _has_output_position = property(_simulation.FrameIterator__has_output_position_get)
    _has_output_rotation = property(_simulation.FrameIterator__has_output_rotation_get)
    _has_output_transform = property(_simulation.FrameIterator__has_output_transform_get)
    _has_output_velocity = property(_simulation.FrameIterator__has_output_velocity_get)
    _has_output_angular_velocity = property(_simulation.FrameIterator__has_output_angular_velocity_get)
    _has_output_linear_velocity = property(_simulation.FrameIterator__has_output_linear_velocity_get)
    _has_output_acceleration = property(_simulation.FrameIterator__has_output_acceleration_get)
    _has_output_angular_acceleration = property(_simulation.FrameIterator__has_output_angular_acceleration_get)
    _has_output_linear_acceleration = property(_simulation.FrameIterator__has_output_linear_acceleration_get)

    def getTransformInGround(self, state: "State") -> "SimTK::Transform const &":
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.FrameIterator_getTransformInGround(self, state)

    def getVelocityInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.FrameIterator_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.FrameIterator_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.FrameIterator_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.FrameIterator_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.FrameIterator_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.FrameIterator_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state: "State", otherFrame: "Frame") -> "SimTK::Transform":
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.FrameIterator_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state: "State", vec_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.FrameIterator_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state: "State", vec_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.FrameIterator_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state: "State", station_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.FrameIterator_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.FrameIterator_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.FrameIterator_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.FrameIterator_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self) -> "OpenSim::Frame const &":
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.FrameIterator_findBaseFrame(self)

    def findTransformInBaseFrame(self) -> "SimTK::Transform":
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.FrameIterator_findTransformInBaseFrame(self)

    def getPositionInGround(self, state: "State") -> "SimTK::Vec3":
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.FrameIterator_getPositionInGround(self, state)

    def getRotationInGround(self, state: "State") -> "SimTK::Rotation_< double >":
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.FrameIterator_getRotationInGround(self, state)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.FrameIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.FrameIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.FrameIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.FrameIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.FrameIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.FrameIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.FrameIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.FrameIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.FrameIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.FrameIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.FrameIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.FrameIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.FrameIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.FrameIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.FrameIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.FrameIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.FrameIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.FrameIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.FrameIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.FrameIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.FrameIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.FrameIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.FrameIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.FrameIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.FrameIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.FrameIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.FrameIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.FrameIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.FrameIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.FrameIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.FrameIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.FrameIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.FrameIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.FrameIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.FrameIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.FrameIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.FrameIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.FrameIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.FrameIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.FrameIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.FrameIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.FrameIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.FrameIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.FrameIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.FrameIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.FrameIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.FrameIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.FrameIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.FrameIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.FrameIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.FrameIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.FrameIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.FrameIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.FrameIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.FrameIterator_toString(self)

# Register FrameIterator in _simulation:
_simulation.FrameIterator_swigregister(FrameIterator)

class BodyList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.BodyList_swiginit(self, _simulation.new_BodyList(*args))
    __swig_destroy__ = _simulation.delete_BodyList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Body const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.BodyList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Body const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.BodyList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Body const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.BodyList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Body const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.BodyList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.BodyList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register BodyList in _simulation:
_simulation.BodyList_swigregister(BodyList)

class BodyIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "BodyIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.BodyIterator_equals(self, other)

    def __eq__(self, other: "BodyIterator") -> "bool":
        return _simulation.BodyIterator___eq__(self, other)

    def __ne__(self, other: "BodyIterator") -> "bool":
        return _simulation.BodyIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Body const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.BodyIterator___ref__(self)

    def deref(self) -> "OpenSim::Body const &":
        return _simulation.BodyIterator_deref(self)

    def __deref__(self) -> "OpenSim::Body const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.BodyIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Body const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.BodyIterator_next(self)
    __swig_destroy__ = _simulation.delete_BodyIterator

    def clone(self) -> "OpenSim::Body *":
        return _simulation.BodyIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.BodyIterator_getConcreteClassName(self)

    def get_mass(self, *args) -> "double const &":
        return _simulation.BodyIterator_get_mass(self, *args)

    def get_mass_center(self, *args) -> "SimTK::Vec3 const &":
        return _simulation.BodyIterator_get_mass_center(self, *args)

    def get_inertia(self, *args) -> "SimTK::Vec6 const &":
        return _simulation.BodyIterator_get_inertia(self, *args)

    def getMass(self) -> "double const &":
        r""" Access Properties of the Body  The mass of the body in kg"""
        return _simulation.BodyIterator_getMass(self)

    def getMassCenter(self) -> "SimTK::Vec3 const &":
        r""" The body center of mass location (Vec3) in the Body frame."""
        return _simulation.BodyIterator_getMassCenter(self)

    def getInertia(self) -> "SimTK::Inertia const &":
        r""" The body's inertia about the center of mass location."""
        return _simulation.BodyIterator_getInertia(self)

    def getMassProperties(self) -> "SimTK::MassProperties":
        r"""
        Assemble body inertial properties: mass, center of mass location, moment
               of inertia about the origin of the body and return as
               SimTK::MassProperties.
        """
        return _simulation.BodyIterator_getMassProperties(self)

    def get_WrapObjectSet(self, *args) -> "OpenSim::WrapObjectSet const &":
        return _simulation.BodyIterator_get_WrapObjectSet(self, *args)

    def getMobilizedBodyIndex(self) -> "SimTK::MobilizedBodyIndex const &":
        r"""
        This method returns the MobilizedBodyIndex of the MobilizedBody for this
        PhysicalFrame. This index is only available after Model::initSystem() has
        been invoked.

        The MobilizedBodyIndex is necessary to access the underlying MobilizedBody
        in the System. It allows access to physical quantities (e.g. forces)
        associated with individual PhysicalFrames. For examples, the underlying
        MultibodySystem's net body forces are represented as a Vector of spatial
        forces (torque and force on each body) and it is indexed by the
        MobilizedBodyIndex.

        :rtype: int
        :return: index The MobilizedBodyIndex corresponding to this PhysicalFrame's
                       underlying MobilizedBody

        See also: getMobilizedBody, updMobilizedBody
        """
        return _simulation.BodyIterator_getMobilizedBodyIndex(self)

    def getMobilizedBody(self) -> "SimTK::MobilizedBody const &":
        r"""
        Access a readable SimTK::MobilizedBody that backs this PhysicalFrame.
        The MobilizedBody is only available after Model::initSystem() has been
        invoked.
        See also: getMobilizedBodyIndex
        """
        return _simulation.BodyIterator_getMobilizedBody(self)

    def getWrapObject(self, aName: "std::string const &") -> "OpenSim::WrapObject const *":
        r"""
        Deprecated methods for intermediate integration of Frames  Get the named wrap object, if it exists.

        :type aName: string
        :param aName: Name of the wrap object.
        :rtype: :py:class:`WrapObject`
        :return: const Pointer to the wrap object.
        """
        return _simulation.BodyIterator_getWrapObject(self, aName)

    def getWrapObjectSet(self) -> "OpenSim::WrapObjectSet const &":
        return _simulation.BodyIterator_getWrapObjectSet(self)

    def get_frame_geometry(self, *args) -> "OpenSim::FrameGeometry const &":
        return _simulation.BodyIterator_get_frame_geometry(self, *args)

    def get_attached_geometry(self, i: "int") -> "OpenSim::Geometry const &":
        return _simulation.BodyIterator_get_attached_geometry(self, i)
    _has_output_position = property(_simulation.BodyIterator__has_output_position_get)
    _has_output_rotation = property(_simulation.BodyIterator__has_output_rotation_get)
    _has_output_transform = property(_simulation.BodyIterator__has_output_transform_get)
    _has_output_velocity = property(_simulation.BodyIterator__has_output_velocity_get)
    _has_output_angular_velocity = property(_simulation.BodyIterator__has_output_angular_velocity_get)
    _has_output_linear_velocity = property(_simulation.BodyIterator__has_output_linear_velocity_get)
    _has_output_acceleration = property(_simulation.BodyIterator__has_output_acceleration_get)
    _has_output_angular_acceleration = property(_simulation.BodyIterator__has_output_angular_acceleration_get)
    _has_output_linear_acceleration = property(_simulation.BodyIterator__has_output_linear_acceleration_get)

    def getTransformInGround(self, state: "State") -> "SimTK::Transform const &":
        r"""
        *
            Get the transform of this frame (F) relative to the ground frame (G).
            It transforms quantities expressed in F into quantities expressed
            in G. This is mathematically stated as:
                vec_G = X_GF*vec_F ,
            where X_GF is the transform returned by getTransformInGround.

            :type state: :py:class:`State`
            :param state:       The state applied to the model when determining the
                                   transform.
            :rtype: :py:class:`Transform`
            :return: transform  The transform between this frame and the ground frame
        """
        return _simulation.BodyIterator_getTransformInGround(self, state)

    def getVelocityInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial velocity V_GF {omega; v} of this Frame, measured with
               respect to and expressed in the ground frame. It can be used to compute
               the velocity of any stationary point on F, located at r_F (Vec3), in
               ground, G, as:
                   v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);
               Is only valid at Stage::Velocity or higher.
        """
        return _simulation.BodyIterator_getVelocityInGround(self, state)

    def getAngularVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.BodyIterator_getAngularVelocityInGround(self, state)

    def getLinearVelocityInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear velocity of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getVelocityInGround()).
        """
        return _simulation.BodyIterator_getLinearVelocityInGround(self, state)

    def getAccelerationInGround(self, state: "State") -> "SimTK::SpatialVec const &":
        r"""
        The spatial acceleration A_GF {alpha; a} of this Frame, measured with
               respect to and expressed in the ground frame. It can also be used to
               compute the acceleration of any stationary point on F, located at r_F
               (Vec3), in ground, G, as:
                   a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) +
                         SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));
               Is only valid at Stage::Acceleration or higher.
        """
        return _simulation.BodyIterator_getAccelerationInGround(self, state)

    def getAngularAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The angular acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the first half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.BodyIterator_getAngularAccelerationInGround(self, state)

    def getLinearAccelerationInGround(self, state: "State") -> "SimTK::Vec3 const &":
        r"""
        The linear acceleration of this Frame, measured with respect to and
               expressed in the ground frame (i.e., the second half of the SpatialVec
               returned by getAccelerationInGround()).
        """
        return _simulation.BodyIterator_getLinearAccelerationInGround(self, state)

    def findTransformBetween(self, state: "State", otherFrame: "Frame") -> "SimTK::Transform":
        r"""
        Find the transform that describes this frame (F) relative to another
        frame (A). It transforms quantities expressed in F to quantities expressed
        in A. This is mathematically stated as:
            vec_A = X_AF*vec_F ,
        where X_AF is the transform returned by this method.

        :type state: :py:class:`State`
        :param state:       The state applied to the model when determining the
                               transform.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  a second frame
        :rtype: :py:class:`Transform`
        :return: transform  The transform between this frame and otherFrame
        """
        return _simulation.BodyIterator_findTransformBetween(self, state, otherFrame)

    def expressVectorInAnotherFrame(self, state: "State", vec_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a vector expressed in this frame (F) and re-express the same vector
        in another frame (A). This re-expression accounts for the difference
        in orientation between the frames. This is mathematically stated as:
            vec_A = R_AF*vec_F
        which does not translate the vector. This is intended to re-express
        physical vector quantities such as a frame's angular velocity or an
        applied force, from one frame to another without changing the physical
        quantity. If you have a position vector and want to change the point from
        which the position is measured, you want findStationLocationInAnotherFrame().

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame in which the vector will be re-expressed
        :rtype: :py:class:`Vec3`
        :return: vec_A      The expression of the vector in otherFrame.
        """
        return _simulation.BodyIterator_expressVectorInAnotherFrame(self, state, vec_F, otherFrame)

    def expressVectorInGround(self, state: "State", vec_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a vector in this frame (F) and re-express the same vector
        in Ground (G). This method is equivalent to expressVectorInAnotherFrame()
        where the "other Frame" is always Ground.
        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type vec_F: :py:class:`Vec3`
        :param vec_F:       The vector to be re-expressed.
        :rtype: :py:class:`Vec3`
        :return: vec_G      The expression of the vector in Ground.
        """
        return _simulation.BodyIterator_expressVectorInGround(self, state, vec_F)

    def findStationLocationInAnotherFrame(self, state: "State", station_F: "Vec3", otherFrame: "Frame") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in another frame (A). The transform
        accounts for the difference in orientation and translation between the
        frames.
        This is mathematically stated as:
            loc_A = X_AF*station_F

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :type otherFrame: :py:class:`Frame`
        :param otherFrame:  The frame (A) in which the station's location
                               will be relative to and expressed.
        :rtype: :py:class:`Vec3`
        :return: loc_A      The location of the station in another frame (A).
        """
        return _simulation.BodyIterator_findStationLocationInAnotherFrame(self, state, station_F, otherFrame)

    def findStationLocationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its location relative to and expressed in Ground (G). This method is
        equivalent to findStationLocationInAnotherFrame() where the "other Frame" is
        always Ground.

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getLocationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: loc_G      The location of the station in Ground.
        """
        return _simulation.BodyIterator_findStationLocationInGround(self, state, station_F)

    def findStationVelocityInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its velocity relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getVelocityInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: vel_G      The velocity of the station in Ground.
        """
        return _simulation.BodyIterator_findStationVelocityInGround(self, state, station_F)

    def findStationAccelerationInGround(self, state: "State", station_F: "Vec3") -> "SimTK::Vec3":
        r"""
        Take a station located and expressed in this frame (F) and determine
        its acceleration relative to and expressed in Ground (G).

        Note that if you have added an OpenSim::Station, you should use the
        Station's %getAccelerationInGround() method instead.

        :type state: :py:class:`State`
        :param state:       The state of the model.
        :type station_F: :py:class:`Vec3`
        :param station_F:   The position Vec3 from frame F's origin to the station.
        :rtype: :py:class:`Vec3`
        :return: acc_G      The acceleration of the station in Ground.
        """
        return _simulation.BodyIterator_findStationAccelerationInGround(self, state, station_F)

    def findBaseFrame(self) -> "OpenSim::Frame const &":
        r"""
        *

            Find this Frame's base Frame. See the "Advanced" note, above.

            :rtype: :py:class:`Frame`
            :return: baseFrame     The Frame that is the base for this Frame.
        """
        return _simulation.BodyIterator_findBaseFrame(self)

    def findTransformInBaseFrame(self) -> "SimTK::Transform":
        r"""
        Find the equivalent Transform of this Frame (F) in its base (B) Frame.
        That is find X_BF, such that vecB = X_BF*vecF
        For a Frame that is itself a base, this returns the identity Transform.
        :rtype: :py:class:`Transform`
        :return: X_BF     The Transform of F in B
        """
        return _simulation.BodyIterator_findTransformInBaseFrame(self)

    def getPositionInGround(self, state: "State") -> "SimTK::Vec3":
        r""" Accessor for position of the origin of the Frame in Ground."""
        return _simulation.BodyIterator_getPositionInGround(self, state)

    def getRotationInGround(self, state: "State") -> "SimTK::Rotation_< double >":
        r""" Accessor for Rotation matrix of the Frame in Ground."""
        return _simulation.BodyIterator_getRotationInGround(self, state)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.BodyIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.BodyIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.BodyIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.BodyIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.BodyIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.BodyIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.BodyIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.BodyIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.BodyIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.BodyIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.BodyIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.BodyIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.BodyIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.BodyIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.BodyIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.BodyIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.BodyIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.BodyIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.BodyIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.BodyIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.BodyIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.BodyIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.BodyIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.BodyIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.BodyIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.BodyIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.BodyIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.BodyIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.BodyIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.BodyIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.BodyIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.BodyIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.BodyIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.BodyIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.BodyIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.BodyIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.BodyIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.BodyIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.BodyIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.BodyIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.BodyIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.BodyIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.BodyIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.BodyIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.BodyIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.BodyIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.BodyIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.BodyIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.BodyIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.BodyIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.BodyIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.BodyIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.BodyIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.BodyIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.BodyIterator_toString(self)

# Register BodyIterator in _simulation:
_simulation.BodyIterator_swigregister(BodyIterator)

class MuscleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.MuscleList_swiginit(self, _simulation.new_MuscleList(*args))
    __swig_destroy__ = _simulation.delete_MuscleList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Muscle const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.MuscleList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Muscle const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.MuscleList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Muscle const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.MuscleList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Muscle const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.MuscleList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.MuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register MuscleList in _simulation:
_simulation.MuscleList_swigregister(MuscleList)

class MuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "MuscleIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.MuscleIterator_equals(self, other)

    def __eq__(self, other: "MuscleIterator") -> "bool":
        return _simulation.MuscleIterator___eq__(self, other)

    def __ne__(self, other: "MuscleIterator") -> "bool":
        return _simulation.MuscleIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Muscle const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.MuscleIterator___ref__(self)

    def deref(self) -> "OpenSim::Muscle const &":
        return _simulation.MuscleIterator_deref(self)

    def __deref__(self) -> "OpenSim::Muscle const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.MuscleIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Muscle const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.MuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_MuscleIterator

    def clone(self) -> "OpenSim::Muscle *":
        return _simulation.MuscleIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MuscleIterator_getConcreteClassName(self)

    def get_max_isometric_force(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args) -> "bool const &":
        return _simulation.MuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args) -> "bool const &":
        return _simulation.MuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.MuscleIterator__has_output_excitation_get)
    _has_output_activation = property(_simulation.MuscleIterator__has_output_activation_get)
    _has_output_fiber_length = property(_simulation.MuscleIterator__has_output_fiber_length_get)
    _has_output_pennation_angle = property(_simulation.MuscleIterator__has_output_pennation_angle_get)
    _has_output_cos_pennation_angle = property(_simulation.MuscleIterator__has_output_cos_pennation_angle_get)
    _has_output_tendon_length = property(_simulation.MuscleIterator__has_output_tendon_length_get)
    _has_output_normalized_fiber_length = property(_simulation.MuscleIterator__has_output_normalized_fiber_length_get)
    _has_output_fiber_length_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_length_along_tendon_get)
    _has_output_tendon_strain = property(_simulation.MuscleIterator__has_output_tendon_strain_get)
    _has_output_passive_force_multiplier = property(_simulation.MuscleIterator__has_output_passive_force_multiplier_get)
    _has_output_active_force_length_multiplier = property(_simulation.MuscleIterator__has_output_active_force_length_multiplier_get)
    _has_output_fiber_velocity = property(_simulation.MuscleIterator__has_output_fiber_velocity_get)
    _has_output_normalized_fiber_velocity = property(_simulation.MuscleIterator__has_output_normalized_fiber_velocity_get)
    _has_output_fiber_velocity_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_velocity_along_tendon_get)
    _has_output_tendon_velocity = property(_simulation.MuscleIterator__has_output_tendon_velocity_get)
    _has_output_force_velocity_multiplier = property(_simulation.MuscleIterator__has_output_force_velocity_multiplier_get)
    _has_output_pennation_angular_velocity = property(_simulation.MuscleIterator__has_output_pennation_angular_velocity_get)
    _has_output_fiber_force = property(_simulation.MuscleIterator__has_output_fiber_force_get)
    _has_output_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_force_along_tendon_get)
    _has_output_active_fiber_force = property(_simulation.MuscleIterator__has_output_active_fiber_force_get)
    _has_output_passive_fiber_force = property(_simulation.MuscleIterator__has_output_passive_fiber_force_get)
    _has_output_active_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_active_fiber_force_along_tendon_get)
    _has_output_passive_fiber_force_along_tendon = property(_simulation.MuscleIterator__has_output_passive_fiber_force_along_tendon_get)
    _has_output_tendon_force = property(_simulation.MuscleIterator__has_output_tendon_force_get)
    _has_output_fiber_stiffness = property(_simulation.MuscleIterator__has_output_fiber_stiffness_get)
    _has_output_fiber_stiffness_along_tendon = property(_simulation.MuscleIterator__has_output_fiber_stiffness_along_tendon_get)
    _has_output_tendon_stiffness = property(_simulation.MuscleIterator__has_output_tendon_stiffness_get)
    _has_output_muscle_stiffness = property(_simulation.MuscleIterator__has_output_muscle_stiffness_get)
    _has_output_fiber_active_power = property(_simulation.MuscleIterator__has_output_fiber_active_power_get)
    _has_output_fiber_passive_power = property(_simulation.MuscleIterator__has_output_fiber_passive_power_get)
    _has_output_tendon_power = property(_simulation.MuscleIterator__has_output_tendon_power_get)
    _has_output_muscle_power = property(_simulation.MuscleIterator__has_output_muscle_power_get)

    def getMaxIsometricForce(self) -> "double":
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.MuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self) -> "double":
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.MuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self) -> "double":
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.MuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self) -> "double":
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.MuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self) -> "double":
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.MuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.MuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s: "State", ignore: "bool") -> "void":
        return _simulation.MuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.MuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s: "State", ignore: "bool") -> "void":
        return _simulation.MuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s: "State") -> "double":
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.MuscleIterator_getActivation(self, s)

    def getFiberLength(self, s: "State") -> "double":
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.MuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s: "State") -> "double":
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.MuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s: "State") -> "double":
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.MuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s: "State") -> "double":
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.MuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s: "State") -> "double":
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.MuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.MuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s: "State") -> "double":
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.MuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.MuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.MuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s: "State") -> "double":
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.MuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s: "State") -> "double":
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.MuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s: "State") -> "double":
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.MuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.MuscleIterator_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s: "State") -> "double":
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.MuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.MuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s: "State") -> "double":
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.MuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s: "State") -> "double":
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.MuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s: "State") -> "double":
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.MuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s: "State") -> "double":
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.MuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s: "State") -> "double":
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.MuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s: "State") -> "double":
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.MuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s: "State") -> "double":
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.MuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s: "State") -> "double":
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.MuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.MuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s: "State") -> "double":
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.MuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s: "State") -> "double":
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.MuscleIterator_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.MuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s: "State") -> "double":
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.MuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s: "State") -> "double":
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.MuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s: "State") -> "double":
        r""" get the current active fiber power (W)"""
        return _simulation.MuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s: "State") -> "double":
        r""" get the current passive fiber power (W)"""
        return _simulation.MuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s: "State") -> "double":
        r""" get the current tendon power (W)"""
        return _simulation.MuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s: "State") -> "double":
        r""" get the current muscle power (W)"""
        return _simulation.MuscleIterator_getMusclePower(self, s)

    def getStress(self, s: "State") -> "double":
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.MuscleIterator_getStress(self, s)

    def setExcitation(self, s: "State", excitation: "double") -> "void":
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.MuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getExcitation(self, s)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r""" DEPRECATED: only for backward compatibility"""
        return _simulation.MuscleIterator_setActivation(self, s, activation)

    def computeActuation(self, s: "State") -> "double":
        r"""
        Actuator interface for a muscle computes the tension in the muscle
               and applied by the tendon to bones (i.e. not the fiber force)
        """
        return _simulation.MuscleIterator_computeActuation(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.MuscleIterator_computeEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        r"""Conditional comment:"""
        return _simulation.MuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.MuscleIterator_get_GeometryPath(self, *args)

    def get_optimal_force(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.MuscleIterator__has_output_tension_get)

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        return _simulation.MuscleIterator_getGeometryPath(self)

    def hasGeometryPath(self) -> "bool":
        return _simulation.MuscleIterator_hasGeometryPath(self)

    def getOptimalForce(self) -> "double":
        return _simulation.MuscleIterator_getOptimalForce(self)

    def getLength(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getLengtheningSpeed(self, s)

    def getPower(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getPower(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.MuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args) -> "double const &":
        return _simulation.MuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.MuscleIterator__has_output_actuation_get)
    _has_output_speed = property(_simulation.MuscleIterator__has_output_speed_get)

    def getControl(self, s: "State") -> "double":
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.MuscleIterator_getControl(self, s)

    def numControls(self) -> "int":
        return _simulation.MuscleIterator_numControls(self)

    def setActuation(self, s: "State", aActuation: "double") -> "void":
        return _simulation.MuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getActuation(self, s)

    def setSpeed(self, s: "State", aspeed: "double") -> "void":
        return _simulation.MuscleIterator_setSpeed(self, s, aspeed)

    def getSpeed(self, s: "State") -> "double":
        return _simulation.MuscleIterator_getSpeed(self, s)

    def getMinControl(self) -> "double":
        return _simulation.MuscleIterator_getMinControl(self)

    def getMaxControl(self) -> "double":
        return _simulation.MuscleIterator_getMaxControl(self)

    def overrideActuation(self, s: "State", flag: "bool") -> "void":
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.MuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s: "State") -> "bool":
        r""" return ScalarActuator's override status"""
        return _simulation.MuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s: "State", value: "double") -> "void":
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.MuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s: "State") -> "double":
        r"""return override actuation"""
        return _simulation.MuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls: "Vector", actuatorControls: "Vector") -> "void":
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.MuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.MuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.MuscleIterator_addInControls(self, actuatorControls, modelControls)

    def get_appliesForce(self, *args) -> "bool const &":
        return _simulation.MuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.MuscleIterator__has_output_potential_energy_get)

    def shouldBeParallelized(self) -> "bool":
        r"""
        Tell SimBody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.MuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s: "State") -> "bool":
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.MuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s: "State", applyForce: "bool") -> "void":
        r""" %Set whether or not the Force is applied."""
        return _simulation.MuscleIterator_setAppliesForce(self, s, applyForce)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.MuscleIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.MuscleIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.MuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.MuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.MuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.MuscleIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.MuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.MuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.MuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.MuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.MuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.MuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.MuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.MuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.MuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.MuscleIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.MuscleIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.MuscleIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.MuscleIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.MuscleIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.MuscleIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.MuscleIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.MuscleIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.MuscleIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.MuscleIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.MuscleIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.MuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.MuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.MuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.MuscleIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.MuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.MuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.MuscleIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.MuscleIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.MuscleIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.MuscleIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.MuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.MuscleIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.MuscleIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.MuscleIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.MuscleIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.MuscleIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.MuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.MuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.MuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.MuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.MuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.MuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.MuscleIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.MuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.MuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.MuscleIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.MuscleIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.MuscleIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.MuscleIterator_toString(self)

# Register MuscleIterator in _simulation:
_simulation.MuscleIterator_swigregister(MuscleIterator)

class ModelComponentList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.ModelComponentList_swiginit(self, _simulation.new_ModelComponentList(*args))
    __swig_destroy__ = _simulation.delete_ModelComponentList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::ModelComponent const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.ModelComponentList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::ModelComponent const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.ModelComponentList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::ModelComponent const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.ModelComponentList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::ModelComponent const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.ModelComponentList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.ModelComponentList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register ModelComponentList in _simulation:
_simulation.ModelComponentList_swigregister(ModelComponentList)

class ModelComponentIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "ModelComponentIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.ModelComponentIterator_equals(self, other)

    def __eq__(self, other: "ModelComponentIterator") -> "bool":
        return _simulation.ModelComponentIterator___eq__(self, other)

    def __ne__(self, other: "ModelComponentIterator") -> "bool":
        return _simulation.ModelComponentIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::ModelComponent const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.ModelComponentIterator___ref__(self)

    def deref(self) -> "OpenSim::ModelComponent const &":
        return _simulation.ModelComponentIterator_deref(self)

    def __deref__(self) -> "OpenSim::ModelComponent const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.ModelComponentIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::ModelComponent const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.ModelComponentIterator_next(self)
    __swig_destroy__ = _simulation.delete_ModelComponentIterator

    def clone(self) -> "OpenSim::ModelComponent *":
        return _simulation.ModelComponentIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ModelComponentIterator_getConcreteClassName(self)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ModelComponentIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ModelComponentIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.ModelComponentIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.ModelComponentIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.ModelComponentIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.ModelComponentIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.ModelComponentIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.ModelComponentIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.ModelComponentIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.ModelComponentIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.ModelComponentIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.ModelComponentIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.ModelComponentIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.ModelComponentIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.ModelComponentIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.ModelComponentIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.ModelComponentIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.ModelComponentIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.ModelComponentIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.ModelComponentIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.ModelComponentIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.ModelComponentIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.ModelComponentIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.ModelComponentIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.ModelComponentIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.ModelComponentIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.ModelComponentIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ModelComponentIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.ModelComponentIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.ModelComponentIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.ModelComponentIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.ModelComponentIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.ModelComponentIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.ModelComponentIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.ModelComponentIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.ModelComponentIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.ModelComponentIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.ModelComponentIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.ModelComponentIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.ModelComponentIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.ModelComponentIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.ModelComponentIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.ModelComponentIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.ModelComponentIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.ModelComponentIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.ModelComponentIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.ModelComponentIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.ModelComponentIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.ModelComponentIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.ModelComponentIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.ModelComponentIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.ModelComponentIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.ModelComponentIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.ModelComponentIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.ModelComponentIterator_toString(self)

# Register ModelComponentIterator in _simulation:
_simulation.ModelComponentIterator_swigregister(ModelComponentIterator)

class JointList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.JointList_swiginit(self, _simulation.new_JointList(*args))
    __swig_destroy__ = _simulation.delete_JointList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Joint const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.JointList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Joint const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.JointList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Joint const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.JointList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Joint const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.JointList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.JointList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register JointList in _simulation:
_simulation.JointList_swigregister(JointList)

class JointIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "JointIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.JointIterator_equals(self, other)

    def __eq__(self, other: "JointIterator") -> "bool":
        return _simulation.JointIterator___eq__(self, other)

    def __ne__(self, other: "JointIterator") -> "bool":
        return _simulation.JointIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Joint const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.JointIterator___ref__(self)

    def deref(self) -> "OpenSim::Joint const &":
        return _simulation.JointIterator_deref(self)

    def __deref__(self) -> "OpenSim::Joint const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.JointIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Joint const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.JointIterator_next(self)
    __swig_destroy__ = _simulation.delete_JointIterator

    def clone(self) -> "OpenSim::Joint *":
        return _simulation.JointIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.JointIterator_getConcreteClassName(self)

    def get_coordinates(self, i: "int") -> "OpenSim::Coordinate const &":
        return _simulation.JointIterator_get_coordinates(self, i)

    def get_frames(self, i: "int") -> "OpenSim::PhysicalOffsetFrame const &":
        return _simulation.JointIterator_get_frames(self, i)
    PropertyIndex_socket_parent_frame = property(_simulation.JointIterator_PropertyIndex_socket_parent_frame_get)
    PropertyIndex_socket_child_frame = property(_simulation.JointIterator_PropertyIndex_socket_child_frame_get)
    _has_output_power = property(_simulation.JointIterator__has_output_power_get)
    _has_output_reaction_on_parent = property(_simulation.JointIterator__has_output_reaction_on_parent_get)
    _has_output_reaction_on_child = property(_simulation.JointIterator__has_output_reaction_on_child_get)

    def getChildFrame(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Get the child joint frame.

        :rtype: :py:class:`PhysicalFrame`
        :return: const PhysicalFrame reference.
        """
        return _simulation.JointIterator_getChildFrame(self)

    def getParentFrame(self) -> "OpenSim::PhysicalFrame const &":
        r"""
        Get the parent frame to which this joint attaches.

        :rtype: :py:class:`PhysicalFrame`
        :return: const ref to parent PhysicalFrame.
        """
        return _simulation.JointIterator_getParentFrame(self)

    def getCoordinate(self) -> "OpenSim::Coordinate const &":
        r"""
        Convenience method to get a const reference to the Coordinate associated
               with a single-degree-of-freedom Joint. If the Joint has more than one
               Coordinate, you must use get_coordinates() or provide the appropriate
               argument to the getCoordinate() method defined in the derived class.
        """
        return _simulation.JointIterator_getCoordinate(self)

    def numCoordinates(self) -> "int":
        return _simulation.JointIterator_numCoordinates(self)

    def isCoordinateUsed(self, aCoordinate: "Coordinate") -> "bool":
        return _simulation.JointIterator_isCoordinateUsed(self, aCoordinate)

    def calcEquivalentSpatialForce(self, state: "State", mobilityForces: "Vector") -> "SimTK::SpatialVec":
        r"""
        Given some system mobility (generalized) forces, calculate the
           equivalent spatial body force for this Joint. Keep in mind that there are
           typically nm < 6 mobilities per joint with an infinite set of solutions that
           can map nm gen forces to 6 spatial force components (3 for torque + 3 for
           force). The solution returned provides the "most" effective force and torque
           in the joint frame. This means the smallest magnitude force and/or torque
           that will result in the same generalized force. If a generalized force is
           defined along/about a joint axis, then this should be evident in the
           reported results as a force or torque on the same axis.  NOTE: Joints
           comprised of multiple mobilizers and/or constraints, should override this
           method and account for multiple internal components.

           :type state: :py:class:`State`
           :param state: containing the generalized coordinate and speed values
           :type mobilityForces: :py:class:`Vector`
           :param mobilityForces: for the system as computed by inverse dynamics,
                                     for example
           :rtype: :py:class:`SpatialVec`
           :return: spatial force, FB_G, acting on the body connected by this joint at
               its location B, expressed in ground.
        """
        return _simulation.JointIterator_calcEquivalentSpatialForce(self, state, mobilityForces)

    def calcReactionOnParentExpressedInGround(self, state: "State") -> "SimTK::SpatialVec":
        r"""
        Joint Reaction forces  Calculate the joint reaction force and moment acting on the parent frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on parent frame, P,
                           and expressed in ground, G.
        """
        return _simulation.JointIterator_calcReactionOnParentExpressedInGround(self, state)

    def calcReactionOnChildExpressedInGround(self, state: "State") -> "SimTK::SpatialVec":
        r"""
        Calculate the joint reaction force and moment acting on the child frame
               and expressed in Ground.
           :type state: :py:class:`State`, in
           :param state: containing the generalized coordinate and speed values
           :rtype: :py:class:`SpatialVec`
           :return: SpatialVec of reaction force, RP_G, acting on child frame, C,
                           and expressed in ground, G.
        """
        return _simulation.JointIterator_calcReactionOnChildExpressedInGround(self, state)

    def calcPower(self, s: "State") -> "double":
        r"""
        Joints in general do not contribute power since the reaction space
               forces are orthogonal to the mobility space. However, when joint motion
               is prescribed, the internal forces that move the joint will do work. In
               that case, the power is non-zero and the supplied SimTK::State
               must already have been realized to %Acceleration stage so that
               constraint forces are available.
        """
        return _simulation.JointIterator_calcPower(self, s)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.JointIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.JointIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.JointIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.JointIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.JointIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.JointIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.JointIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.JointIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.JointIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.JointIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.JointIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.JointIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.JointIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.JointIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.JointIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.JointIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.JointIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.JointIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.JointIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.JointIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.JointIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.JointIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.JointIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.JointIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.JointIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.JointIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.JointIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.JointIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.JointIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.JointIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.JointIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.JointIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.JointIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.JointIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.JointIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.JointIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.JointIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.JointIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.JointIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.JointIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.JointIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.JointIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.JointIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.JointIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.JointIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.JointIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.JointIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.JointIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.JointIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.JointIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.JointIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.JointIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.JointIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.JointIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.JointIterator_toString(self)

# Register JointIterator in _simulation:
_simulation.JointIterator_swigregister(JointIterator)

class ActuatorList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.ActuatorList_swiginit(self, _simulation.new_ActuatorList(*args))
    __swig_destroy__ = _simulation.delete_ActuatorList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Actuator const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.ActuatorList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Actuator const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.ActuatorList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Actuator const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.ActuatorList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Actuator const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.ActuatorList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.ActuatorList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register ActuatorList in _simulation:
_simulation.ActuatorList_swigregister(ActuatorList)

class ActuatorIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "ActuatorIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.ActuatorIterator_equals(self, other)

    def __eq__(self, other: "ActuatorIterator") -> "bool":
        return _simulation.ActuatorIterator___eq__(self, other)

    def __ne__(self, other: "ActuatorIterator") -> "bool":
        return _simulation.ActuatorIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Actuator const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.ActuatorIterator___ref__(self)

    def deref(self) -> "OpenSim::Actuator const &":
        return _simulation.ActuatorIterator_deref(self)

    def __deref__(self) -> "OpenSim::Actuator const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.ActuatorIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Actuator const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.ActuatorIterator_next(self)
    __swig_destroy__ = _simulation.delete_ActuatorIterator

    def clone(self) -> "OpenSim::Actuator *":
        return _simulation.ActuatorIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ActuatorIterator_getConcreteClassName(self)

    def numControls(self) -> "int":
        return _simulation.ActuatorIterator_numControls(self)

    def getControls(self, modelControls: "Vector", actuatorControls: "Vector") -> "void":
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.ActuatorIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.ActuatorIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.ActuatorIterator_addInControls(self, actuatorControls, modelControls)

    def getPower(self, s: "State") -> "double":
        return _simulation.ActuatorIterator_getPower(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        return _simulation.ActuatorIterator_computeEquilibrium(self, s)

    def get_appliesForce(self, *args) -> "bool const &":
        return _simulation.ActuatorIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.ActuatorIterator__has_output_potential_energy_get)

    def shouldBeParallelized(self) -> "bool":
        r"""
        Tell SimBody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.ActuatorIterator_shouldBeParallelized(self)

    def appliesForce(self, s: "State") -> "bool":
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.ActuatorIterator_appliesForce(self, s)

    def setAppliesForce(self, s: "State", applyForce: "bool") -> "void":
        r""" %Set whether or not the Force is applied."""
        return _simulation.ActuatorIterator_setAppliesForce(self, s, applyForce)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods to query a Force for the value actually applied during
        simulation. The names of the quantities (column labels) is returned by
        this first function getRecordLabels().
        """
        return _simulation.ActuatorIterator_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report
        forces, application location frame, etc. used in conjunction with
        getRecordLabels and should return same size Array.
        """
        return _simulation.ActuatorIterator_getRecordValues(self, state)

    def hasGeometryPath(self) -> "bool":
        r"""
        Return a flag indicating whether the Force is applied along a Path. If
           you override this method to return true for a specific subclass, it must
           also implement the getGeometryPath() method. *
        """
        return _simulation.ActuatorIterator_hasGeometryPath(self)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.ActuatorIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.ActuatorIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.ActuatorIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.ActuatorIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.ActuatorIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.ActuatorIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.ActuatorIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.ActuatorIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.ActuatorIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.ActuatorIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.ActuatorIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.ActuatorIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.ActuatorIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.ActuatorIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.ActuatorIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.ActuatorIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.ActuatorIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.ActuatorIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.ActuatorIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.ActuatorIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.ActuatorIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.ActuatorIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.ActuatorIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.ActuatorIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.ActuatorIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.ActuatorIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.ActuatorIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.ActuatorIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.ActuatorIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.ActuatorIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.ActuatorIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.ActuatorIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.ActuatorIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.ActuatorIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.ActuatorIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.ActuatorIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.ActuatorIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.ActuatorIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.ActuatorIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.ActuatorIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.ActuatorIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.ActuatorIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.ActuatorIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.ActuatorIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.ActuatorIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.ActuatorIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.ActuatorIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.ActuatorIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.ActuatorIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.ActuatorIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.ActuatorIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.ActuatorIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.ActuatorIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.ActuatorIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.ActuatorIterator_toString(self)

# Register ActuatorIterator in _simulation:
_simulation.ActuatorIterator_swigregister(ActuatorIterator)

class Thelen2003MuscleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.Thelen2003MuscleList_swiginit(self, _simulation.new_Thelen2003MuscleList(*args))
    __swig_destroy__ = _simulation.delete_Thelen2003MuscleList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Thelen2003Muscle const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.Thelen2003MuscleList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Thelen2003Muscle const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.Thelen2003MuscleList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Thelen2003Muscle const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.Thelen2003MuscleList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Thelen2003Muscle const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.Thelen2003MuscleList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.Thelen2003MuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register Thelen2003MuscleList in _simulation:
_simulation.Thelen2003MuscleList_swigregister(Thelen2003MuscleList)

class Thelen2003MuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "Thelen2003MuscleIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.Thelen2003MuscleIterator_equals(self, other)

    def __eq__(self, other: "Thelen2003MuscleIterator") -> "bool":
        return _simulation.Thelen2003MuscleIterator___eq__(self, other)

    def __ne__(self, other: "Thelen2003MuscleIterator") -> "bool":
        return _simulation.Thelen2003MuscleIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Thelen2003Muscle const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.Thelen2003MuscleIterator___ref__(self)

    def deref(self) -> "OpenSim::Thelen2003Muscle const &":
        return _simulation.Thelen2003MuscleIterator_deref(self)

    def __deref__(self) -> "OpenSim::Thelen2003Muscle const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.Thelen2003MuscleIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Thelen2003Muscle const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.Thelen2003MuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_Thelen2003MuscleIterator

    def clone(self) -> "OpenSim::Thelen2003Muscle *":
        return _simulation.Thelen2003MuscleIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Thelen2003MuscleIterator_getConcreteClassName(self)

    def get_FmaxTendonStrain(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_FmaxTendonStrain(self, *args)

    def get_FmaxMuscleStrain(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_FmaxMuscleStrain(self, *args)

    def get_KshapeActive(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_KshapeActive(self, *args)

    def get_KshapePassive(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_KshapePassive(self, *args)

    def get_Af(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_Af(self, *args)

    def get_Flen(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_Flen(self, *args)

    def get_fv_linear_extrap_threshold(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_fv_linear_extrap_threshold(self, *args)

    def get_maximum_pennation_angle(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_maximum_pennation_angle(self, *args)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_activation_time_constant(self, *args)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_deactivation_time_constant(self, *args)

    def get_minimum_activation(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_minimum_activation(self, *args)

    def getActivationTimeConstant(self) -> "double":
        r"""*"""
        return _simulation.Thelen2003MuscleIterator_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getDeactivationTimeConstant(self)

    def getMinimumActivation(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getMinimumActivation(self)

    def getMaximumPennationAngle(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getMaximumPennationAngle(self)

    def getMinimumFiberLength(self) -> "double":
        r"""
        *
             :rtype: float
             :return: the minimum fiber length, which is the maximum of two values:
                    the smallest fiber length allowed by the pennation model, and the
                    minimum fiber length in the active force length curve. When the fiber
                    length reaches this value, it is constrained to this value until the
                    fiber velocity goes positive.
        """
        return _simulation.Thelen2003MuscleIterator_getMinimumFiberLength(self)

    def getActivationModel(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003MuscleIterator_getActivationModel(self)

    def getPennationModel(self) -> "OpenSim::MuscleFixedWidthPennationModel const &":
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003MuscleIterator_getPennationModel(self)

    def printCurveToCSVFile(self, ctype: "OpenSim::Thelen2003Muscle::CurveType const", path: "std::string const &") -> "void":
        return _simulation.Thelen2003MuscleIterator_printCurveToCSVFile(self, ctype, path)

    def computeActuation(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        Compute initial fiber length (velocity) such that muscle fiber and
               tendon are in static equilibrium and update the state

               Part of the Muscle.h interface

               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Thelen2003MuscleIterator_computeInitialFiberEquilibrium(self, s)

    def calcActiveFiberForceAlongTendon(self, activation: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Thelen2003MuscleIterator_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        return _simulation.Thelen2003MuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_default_activation(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_default_activation(self, *args)

    def get_default_fiber_length(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_default_fiber_length(self, *args)

    def getDefaultActivation(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getDefaultActivation(self)

    def getDefaultFiberLength(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getDefaultFiberLength(self)

    def setActivation(self, s: "State", activation: "double") -> "void":
        return _simulation.Thelen2003MuscleIterator_setActivation(self, s, activation)

    def setFiberLength(self, s: "State", fiberLength: "double") -> "void":
        return _simulation.Thelen2003MuscleIterator_setFiberLength(self, s, fiberLength)

    def getActivationRate(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getActivationRate(self, s)

    def get_max_isometric_force(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args) -> "bool const &":
        return _simulation.Thelen2003MuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args) -> "bool const &":
        return _simulation.Thelen2003MuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Thelen2003MuscleIterator__has_output_excitation_get)
    _has_output_activation = property(_simulation.Thelen2003MuscleIterator__has_output_activation_get)
    _has_output_fiber_length = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_length_get)
    _has_output_pennation_angle = property(_simulation.Thelen2003MuscleIterator__has_output_pennation_angle_get)
    _has_output_cos_pennation_angle = property(_simulation.Thelen2003MuscleIterator__has_output_cos_pennation_angle_get)
    _has_output_tendon_length = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_length_get)
    _has_output_normalized_fiber_length = property(_simulation.Thelen2003MuscleIterator__has_output_normalized_fiber_length_get)
    _has_output_fiber_length_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_length_along_tendon_get)
    _has_output_tendon_strain = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_strain_get)
    _has_output_passive_force_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_passive_force_multiplier_get)
    _has_output_active_force_length_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_active_force_length_multiplier_get)
    _has_output_fiber_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_velocity_get)
    _has_output_normalized_fiber_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_normalized_fiber_velocity_get)
    _has_output_fiber_velocity_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_velocity_along_tendon_get)
    _has_output_tendon_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_velocity_get)
    _has_output_force_velocity_multiplier = property(_simulation.Thelen2003MuscleIterator__has_output_force_velocity_multiplier_get)
    _has_output_pennation_angular_velocity = property(_simulation.Thelen2003MuscleIterator__has_output_pennation_angular_velocity_get)
    _has_output_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_force_get)
    _has_output_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_force_along_tendon_get)
    _has_output_active_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_active_fiber_force_get)
    _has_output_passive_fiber_force = property(_simulation.Thelen2003MuscleIterator__has_output_passive_fiber_force_get)
    _has_output_active_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_active_fiber_force_along_tendon_get)
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_passive_fiber_force_along_tendon_get)
    _has_output_tendon_force = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_force_get)
    _has_output_fiber_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_stiffness_get)
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_stiffness_along_tendon_get)
    _has_output_tendon_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_stiffness_get)
    _has_output_muscle_stiffness = property(_simulation.Thelen2003MuscleIterator__has_output_muscle_stiffness_get)
    _has_output_fiber_active_power = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_active_power_get)
    _has_output_fiber_passive_power = property(_simulation.Thelen2003MuscleIterator__has_output_fiber_passive_power_get)
    _has_output_tendon_power = property(_simulation.Thelen2003MuscleIterator__has_output_tendon_power_get)
    _has_output_muscle_power = property(_simulation.Thelen2003MuscleIterator__has_output_muscle_power_get)

    def getMaxIsometricForce(self) -> "double":
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Thelen2003MuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self) -> "double":
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Thelen2003MuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self) -> "double":
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Thelen2003MuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self) -> "double":
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self) -> "double":
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Thelen2003MuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Thelen2003MuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Thelen2003MuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Thelen2003MuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Thelen2003MuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s: "State") -> "double":
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Thelen2003MuscleIterator_getActivation(self, s)

    def getFiberLength(self, s: "State") -> "double":
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Thelen2003MuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s: "State") -> "double":
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s: "State") -> "double":
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s: "State") -> "double":
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Thelen2003MuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s: "State") -> "double":
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Thelen2003MuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s: "State") -> "double":
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Thelen2003MuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Thelen2003MuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Thelen2003MuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s: "State") -> "double":
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Thelen2003MuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s: "State") -> "double":
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Thelen2003MuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s: "State") -> "double":
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Thelen2003MuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r""" get current fiber velocity (m/s) positive is lengthening"""
        return _simulation.Thelen2003MuscleIterator_getFiberVelocity(self, s)

    def getNormalizedFiberVelocity(self, s: "State") -> "double":
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Thelen2003MuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s: "State") -> "double":
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Thelen2003MuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s: "State") -> "double":
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Thelen2003MuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s: "State") -> "double":
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Thelen2003MuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s: "State") -> "double":
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Thelen2003MuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s: "State") -> "double":
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Thelen2003MuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s: "State") -> "double":
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Thelen2003MuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s: "State") -> "double":
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Thelen2003MuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s: "State") -> "double":
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Thelen2003MuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Thelen2003MuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s: "State") -> "double":
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Thelen2003MuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s: "State") -> "double":
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Thelen2003MuscleIterator_getFiberStiffness(self, s)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        get the stiffness of the fiber (N/m) along the direction of the tendon,
            that is the partial derivative of the fiber force along the tendon with
            respect to small changes in fiber length along the tendon
        """
        return _simulation.Thelen2003MuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getTendonStiffness(self, s: "State") -> "double":
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Thelen2003MuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s: "State") -> "double":
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Thelen2003MuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s: "State") -> "double":
        r""" get the current active fiber power (W)"""
        return _simulation.Thelen2003MuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s: "State") -> "double":
        r""" get the current passive fiber power (W)"""
        return _simulation.Thelen2003MuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s: "State") -> "double":
        r""" get the current tendon power (W)"""
        return _simulation.Thelen2003MuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s: "State") -> "double":
        r""" get the current muscle power (W)"""
        return _simulation.Thelen2003MuscleIterator_getMusclePower(self, s)

    def getStress(self, s: "State") -> "double":
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Thelen2003MuscleIterator_getStress(self, s)

    def setExcitation(self, s: "State", excitation: "double") -> "void":
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Thelen2003MuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getExcitation(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Thelen2003MuscleIterator_computeEquilibrium(self, s)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.Thelen2003MuscleIterator_get_GeometryPath(self, *args)

    def get_optimal_force(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.Thelen2003MuscleIterator__has_output_tension_get)

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        return _simulation.Thelen2003MuscleIterator_getGeometryPath(self)

    def hasGeometryPath(self) -> "bool":
        return _simulation.Thelen2003MuscleIterator_hasGeometryPath(self)

    def getOptimalForce(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getOptimalForce(self)

    def getLength(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getLengtheningSpeed(self, s)

    def getPower(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getPower(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.Thelen2003MuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args) -> "double const &":
        return _simulation.Thelen2003MuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.Thelen2003MuscleIterator__has_output_actuation_get)
    _has_output_speed = property(_simulation.Thelen2003MuscleIterator__has_output_speed_get)

    def getControl(self, s: "State") -> "double":
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.Thelen2003MuscleIterator_getControl(self, s)

    def numControls(self) -> "int":
        return _simulation.Thelen2003MuscleIterator_numControls(self)

    def setActuation(self, s: "State", aActuation: "double") -> "void":
        return _simulation.Thelen2003MuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getActuation(self, s)

    def setSpeed(self, s: "State", aspeed: "double") -> "void":
        return _simulation.Thelen2003MuscleIterator_setSpeed(self, s, aspeed)

    def getSpeed(self, s: "State") -> "double":
        return _simulation.Thelen2003MuscleIterator_getSpeed(self, s)

    def getMinControl(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getMinControl(self)

    def getMaxControl(self) -> "double":
        return _simulation.Thelen2003MuscleIterator_getMaxControl(self)

    def overrideActuation(self, s: "State", flag: "bool") -> "void":
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.Thelen2003MuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s: "State") -> "bool":
        r""" return ScalarActuator's override status"""
        return _simulation.Thelen2003MuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s: "State", value: "double") -> "void":
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.Thelen2003MuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s: "State") -> "double":
        r"""return override actuation"""
        return _simulation.Thelen2003MuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls: "Vector", actuatorControls: "Vector") -> "void":
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Thelen2003MuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Thelen2003MuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Thelen2003MuscleIterator_addInControls(self, actuatorControls, modelControls)

    def get_appliesForce(self, *args) -> "bool const &":
        return _simulation.Thelen2003MuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Thelen2003MuscleIterator__has_output_potential_energy_get)

    def shouldBeParallelized(self) -> "bool":
        r"""
        Tell SimBody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Thelen2003MuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s: "State") -> "bool":
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Thelen2003MuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s: "State", applyForce: "bool") -> "void":
        r""" %Set whether or not the Force is applied."""
        return _simulation.Thelen2003MuscleIterator_setAppliesForce(self, s, applyForce)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.Thelen2003MuscleIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.Thelen2003MuscleIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.Thelen2003MuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.Thelen2003MuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.Thelen2003MuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.Thelen2003MuscleIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.Thelen2003MuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.Thelen2003MuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.Thelen2003MuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.Thelen2003MuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.Thelen2003MuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.Thelen2003MuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.Thelen2003MuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.Thelen2003MuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.Thelen2003MuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.Thelen2003MuscleIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.Thelen2003MuscleIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.Thelen2003MuscleIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.Thelen2003MuscleIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.Thelen2003MuscleIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.Thelen2003MuscleIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.Thelen2003MuscleIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.Thelen2003MuscleIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.Thelen2003MuscleIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.Thelen2003MuscleIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.Thelen2003MuscleIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.Thelen2003MuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Thelen2003MuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.Thelen2003MuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.Thelen2003MuscleIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.Thelen2003MuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.Thelen2003MuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.Thelen2003MuscleIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.Thelen2003MuscleIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.Thelen2003MuscleIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.Thelen2003MuscleIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.Thelen2003MuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.Thelen2003MuscleIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.Thelen2003MuscleIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.Thelen2003MuscleIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.Thelen2003MuscleIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.Thelen2003MuscleIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.Thelen2003MuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.Thelen2003MuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.Thelen2003MuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.Thelen2003MuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.Thelen2003MuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.Thelen2003MuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.Thelen2003MuscleIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.Thelen2003MuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.Thelen2003MuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.Thelen2003MuscleIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.Thelen2003MuscleIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.Thelen2003MuscleIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.Thelen2003MuscleIterator_toString(self)

# Register Thelen2003MuscleIterator in _simulation:
_simulation.Thelen2003MuscleIterator_swigregister(Thelen2003MuscleIterator)

class Millard2012EquilibriumMuscleList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _simulation.Millard2012EquilibriumMuscleList_swiginit(self, _simulation.new_Millard2012EquilibriumMuscleList(*args))
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscleList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _simulation.Millard2012EquilibriumMuscleList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _simulation.Millard2012EquilibriumMuscleList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _simulation.Millard2012EquilibriumMuscleList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Millard2012EquilibriumMuscle const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _simulation.Millard2012EquilibriumMuscleList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _simulation.Millard2012EquilibriumMuscleList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register Millard2012EquilibriumMuscleList in _simulation:
_simulation.Millard2012EquilibriumMuscleList_swigregister(Millard2012EquilibriumMuscleList)

class Millard2012EquilibriumMuscleIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "Millard2012EquilibriumMuscleIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_equals(self, other)

    def __eq__(self, other: "Millard2012EquilibriumMuscleIterator") -> "bool":
        return _simulation.Millard2012EquilibriumMuscleIterator___eq__(self, other)

    def __ne__(self, other: "Millard2012EquilibriumMuscleIterator") -> "bool":
        return _simulation.Millard2012EquilibriumMuscleIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Millard2012EquilibriumMuscle const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator___ref__(self)

    def deref(self) -> "OpenSim::Millard2012EquilibriumMuscle const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_deref(self)

    def __deref__(self) -> "OpenSim::Millard2012EquilibriumMuscle const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _simulation.Millard2012EquilibriumMuscleIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Millard2012EquilibriumMuscle const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_next(self)
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscleIterator

    def clone(self) -> "OpenSim::Millard2012EquilibriumMuscle *":
        return _simulation.Millard2012EquilibriumMuscleIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_getConcreteClassName(self)

    def get_fiber_damping(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_fiber_damping(self, *args)

    def get_default_activation(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_default_activation(self, *args)

    def get_default_fiber_length(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_default_fiber_length(self, *args)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_activation_time_constant(self, *args)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_deactivation_time_constant(self, *args)

    def get_minimum_activation(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_minimum_activation(self, *args)

    def get_maximum_pennation_angle(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_maximum_pennation_angle(self, *args)

    def get_ActiveForceLengthCurve(self, *args) -> "OpenSim::ActiveForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ActiveForceLengthCurve(self, *args)

    def get_ForceVelocityCurve(self, *args) -> "OpenSim::ForceVelocityCurve const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ForceVelocityCurve(self, *args)

    def get_FiberForceLengthCurve(self, *args) -> "OpenSim::FiberForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_FiberForceLengthCurve(self, *args)

    def get_TendonForceLengthCurve(self, *args) -> "OpenSim::TendonForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_TendonForceLengthCurve(self, *args)
    _has_output_passive_fiber_elastic_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_get)
    _has_output_passive_fiber_elastic_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_along_tendon_get)
    _has_output_passive_fiber_damping_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_get)
    _has_output_passive_fiber_damping_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_along_tendon_get)

    def getUseFiberDamping(self) -> "bool":
        r"""
        :rtype: boolean
        :return: A boolean indicating whether fiber damping is being used.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getUseFiberDamping(self)

    def getFiberDamping(self) -> "double":
        r"""
        :rtype: float
        :return: The fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberDamping(self)

    def getDefaultActivation(self) -> "double":
        r"""
        :rtype: float
        :return: The default activation level that is used as an initial
               condition if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDefaultActivation(self)

    def getDefaultFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The default fiber length that is used as an initial condition
               if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDefaultFiberLength(self)

    def getActivationTimeConstant(self) -> "double":
        r"""
        :rtype: float
        :return: The activation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self) -> "double":
        r"""
        :rtype: float
        :return: The deactivation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDeactivationTimeConstant(self)

    def getMinimumActivation(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum activation level permitted by the muscle model.
               Note that this equilibrium model, like all equilibrium models, has a
               singularity when activation approaches 0, which means that a non-zero lower
               bound is required.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumActivation(self)

    def getActiveForceLengthCurve(self) -> "OpenSim::ActiveForceLengthCurve const &":
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: The ActiveForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self) -> "OpenSim::ForceVelocityCurve const &":
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: The ForceVelocityCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self) -> "OpenSim::FiberForceLengthCurve const &":
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: The FiberForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self) -> "OpenSim::TendonForceLengthCurve const &":
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: The TendonForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForceLengthCurve(self)

    def getPennationModel(self) -> "OpenSim::MuscleFixedWidthPennationModel const &":
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: The MuscleFixedWidthPennationModel owned by this model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationModel(self)

    def getActivationModel(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: The MuscleFirstOrderActivationDynamicModel owned by this
               model.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationModel(self)

    def getMinimumFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum fiber length, which is the maximum of two values:
               the smallest fiber length allowed by the pennation model, and the minimum
               fiber length on the active-force-length curve. When the fiber reaches this
               length, it is constrained to this value until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum fiber length along the tendon, which is the maximum
               of two values: the smallest fiber length along the tendon permitted by the
               pennation model, and the minimum fiber length along the tendon on the
               active-force-length curve. When the fiber length reaches this value, it is
               constrained to this length along the tendon until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinimumFiberLengthAlongTendon(self)

    def getTendonForceMultiplier(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :rtype: float
               :return: The normalized force term associated with the tendon element,
               :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForceMultiplier(self, s)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        :rtype: float
        :return: The stiffness of the muscle fibers along the tendon (N/m).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberStiffnessAlongTendon(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The velocity of the fiber (m/s).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberVelocity(self, s)

    def getActivationDerivative(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The time derivative of activation.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivationDerivative(self, s)

    def getPassiveFiberElasticForce(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the damping
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the damping
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForceAlongTendon(self, s)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :type activation: float
               :param activation: The desired activation level.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setActivation(self, s, activation)

    def setFiberLength(self, s: "State", fiberLength: "double") -> "void":
        r"""
        :type s: :py:class:`State`, out
        :param s: The state of the system.
               :type fiberLength: float
               :param fiberLength: The desired fiber length (m).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setFiberLength(self, s, fiberLength)

    def computeActuation(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`, in
        :param s: The state of the system.
               :rtype: float
               :return: The tensile force the muscle is generating (N).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        Computes the fiber length such that the fiber and tendon are developing
           the same force, distributing the velocity of the entire musculotendon
           actuator between the fiber and tendon according to their relative
           stiffnesses.
               :type s: :py:class:`State`, in/out
               :param s: The state of the system.
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeInitialFiberEquilibrium(self, s)

    def computeFiberEquilibrium(self, s: "State", solveForVelocity: "bool"=False) -> "void":
        r"""
        Computes the fiber length such that the fiber and tendon are developing
               the same force, either assuming muscle-tendon velocity as provided
               by the state or zero as designated by the useZeroVelocity flag.
               :type s: :py:class:`State`, in/out
               :param s:         The state of the system.
               :type solveForVelocity: boolean, optional
               :param solveForVelocity:  Flag indicating to solve for fiber velocity,
                                            which by default is false (zero fiber-velocity)
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_computeFiberEquilibrium(self, s, solveForVelocity)

    def calcActiveFiberForceAlongTendon(self, activation: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Millard2012EquilibriumMuscleIterator_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcFiberStateGivenBoundaryCond(self, lengthMT: "double", velocityMT: "double", tendonForce: "double", dTendonForceDT: "double") -> "SimTK::Vec4":
        return _simulation.Millard2012EquilibriumMuscleIterator_calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def get_max_isometric_force(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_isometric_force(self, *args)

    def get_optimal_fiber_length(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_optimal_fiber_length(self, *args)

    def get_tendon_slack_length(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_tendon_slack_length(self, *args)

    def get_pennation_angle_at_optimal(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_pennation_angle_at_optimal(self, *args)

    def get_max_contraction_velocity(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_contraction_velocity(self, *args)

    def get_ignore_tendon_compliance(self, *args) -> "bool const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ignore_tendon_compliance(self, *args)

    def get_ignore_activation_dynamics(self, *args) -> "bool const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_ignore_activation_dynamics(self, *args)
    _has_output_excitation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_excitation_get)
    _has_output_activation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_activation_get)
    _has_output_fiber_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_get)
    _has_output_pennation_angle = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_pennation_angle_get)
    _has_output_cos_pennation_angle = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_cos_pennation_angle_get)
    _has_output_tendon_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_length_get)
    _has_output_normalized_fiber_length = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_length_get)
    _has_output_fiber_length_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_along_tendon_get)
    _has_output_tendon_strain = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_strain_get)
    _has_output_passive_force_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_force_multiplier_get)
    _has_output_active_force_length_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_force_length_multiplier_get)
    _has_output_fiber_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_get)
    _has_output_normalized_fiber_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_velocity_get)
    _has_output_fiber_velocity_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_along_tendon_get)
    _has_output_tendon_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_velocity_get)
    _has_output_force_velocity_multiplier = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_force_velocity_multiplier_get)
    _has_output_pennation_angular_velocity = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_pennation_angular_velocity_get)
    _has_output_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_get)
    _has_output_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_along_tendon_get)
    _has_output_active_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_get)
    _has_output_passive_fiber_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_get)
    _has_output_active_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_along_tendon_get)
    _has_output_passive_fiber_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_along_tendon_get)
    _has_output_tendon_force = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_force_get)
    _has_output_fiber_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_get)
    _has_output_fiber_stiffness_along_tendon = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_along_tendon_get)
    _has_output_tendon_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_stiffness_get)
    _has_output_muscle_stiffness = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_muscle_stiffness_get)
    _has_output_fiber_active_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_active_power_get)
    _has_output_fiber_passive_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_fiber_passive_power_get)
    _has_output_tendon_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tendon_power_get)
    _has_output_muscle_power = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_muscle_power_get)

    def getMaxIsometricForce(self) -> "double":
        r""" get/set the maximum isometric force (in N) that the fibers can generate"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxIsometricForce(self)

    def getOptimalFiberLength(self) -> "double":
        r""" get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getOptimalFiberLength(self)

    def getTendonSlackLength(self) -> "double":
        r""" get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonSlackLength(self)

    def getPennationAngleAtOptimalFiberLength(self) -> "double":
        r""" get/set the angle (in radians) between fibers at their optimal fiber length and the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngleAtOptimalFiberLength(self)

    def getMaxContractionVelocity(self) -> "double":
        r""" get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxContractionVelocity(self)

    def getIgnoreTendonCompliance(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore tendon compliance when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getIgnoreTendonCompliance(self, s)

    def setIgnoreTendonCompliance(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Millard2012EquilibriumMuscleIterator_setIgnoreTendonCompliance(self, s, ignore)

    def getIgnoreActivationDynamics(self, s: "State") -> "bool":
        r"""
        Get/set Modeling (runtime) option to ignore activation dynamics when
           computing muscle dynamics. This does not directly modify the persistent
           property value. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getIgnoreActivationDynamics(self, s)

    def setIgnoreActivationDynamics(self, s: "State", ignore: "bool") -> "void":
        return _simulation.Millard2012EquilibriumMuscleIterator_setIgnoreActivationDynamics(self, s, ignore)

    def getActivation(self, s: "State") -> "double":
        r"""
        get the activation level of the muscle, which modulates the active force
               of the muscle and has a normalized (0 to 1) value
               Note: method remains virtual to permit override by deprecated muscles.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getActivation(self, s)

    def getFiberLength(self, s: "State") -> "double":
        r""" get the current working fiber length (m) for the muscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberLength(self, s)

    def getPennationAngle(self, s: "State") -> "double":
        r""" get the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngle(self, s)

    def getCosPennationAngle(self, s: "State") -> "double":
        r""" get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getCosPennationAngle(self, s)

    def getTendonLength(self, s: "State") -> "double":
        r""" get the current tendon length (m)  given the current joint angles and fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonLength(self, s)

    def getNormalizedFiberLength(self, s: "State") -> "double":
        r""" get the current normalized fiber length (fiber_length/optimal_fiber_length)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNormalizedFiberLength(self, s)

    def getFiberLengthAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberLengthAlongTendon(self, s)

    def getTendonStrain(self, s: "State") -> "double":
        r""" get the current tendon strain (delta_l/tendon_slack_length is dimensionless)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonStrain(self, s)

    def getFiberPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the fiber due to its parallel elastic element"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberPotentialEnergy(self, s)

    def getTendonPotentialEnergy(self, s: "State") -> "double":
        r""" the potential energy (J) stored in the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonPotentialEnergy(self, s)

    def getMusclePotentialEnergy(self, s: "State") -> "double":
        r""" the total potential energy (J) stored in the muscle"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMusclePotentialEnergy(self, s)

    def getPassiveForceMultiplier(self, s: "State") -> "double":
        r""" get the passive fiber (parallel elastic element) force multiplier"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveForceMultiplier(self, s)

    def getActiveForceLengthMultiplier(self, s: "State") -> "double":
        r""" get the active fiber (contractile element) force multiplier due to current fiber length"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveForceLengthMultiplier(self, s)

    def getNormalizedFiberVelocity(self, s: "State") -> "double":
        r"""
        get normalized fiber velocity. This is the fiber velocity in m/s divided by
           the maximum contraction velocity expressed in m/s; therefore, this quantity is
           dimensionless and generally lies in the range [-1, 1].
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNormalizedFiberVelocity(self, s)

    def getFiberVelocityAlongTendon(self, s: "State") -> "double":
        r""" get the current fiber velocity (m/s) projected onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberVelocityAlongTendon(self, s)

    def getPennationAngularVelocity(self, s: "State") -> "double":
        r""" get pennation angular velocity (radians/s)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPennationAngularVelocity(self, s)

    def getTendonVelocity(self, s: "State") -> "double":
        r""" get the tendon velocity (m/s) positive is lengthening"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonVelocity(self, s)

    def getForceVelocityMultiplier(self, s: "State") -> "double":
        r""" get the dimensionless multiplier resulting from the fiber's force-velocity curve"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getForceVelocityMultiplier(self, s)

    def getFiberForce(self, s: "State") -> "double":
        r""" get the current fiber force (N) applied to the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForce(self, s)

    def getFiberForceAlongTendon(self, s: "State") -> "double":
        r"""get the force of the fiber (N/m) along the direction of the tendon"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberForceAlongTendon(self, s)

    def getActiveFiberForce(self, s: "State") -> "double":
        r""" get the current active fiber force (N) due to activation*force_length*force_velocity relationships"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveFiberForce(self, s)

    def getPassiveFiberForce(self, s: "State") -> "double":
        r""" get the total force applied by all passive elements in the fiber (N)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberForce(self, s)

    def getActiveFiberForceAlongTendon(self, s: "State") -> "double":
        r""" get the current active fiber force (N) projected onto the tendon direction"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getActiveFiberForceAlongTendon(self, s)

    def getPassiveFiberForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the total force applied by all passive elements in the fiber (N)
               projected onto the tendon direction
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPassiveFiberForceAlongTendon(self, s)

    def getTendonForce(self, s: "State") -> "double":
        r""" get the current tendon force (N) applied to bones"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonForce(self, s)

    def getFiberStiffness(self, s: "State") -> "double":
        r"""
        get the current fiber stiffness (N/m) defined as the partial derivative
               of fiber force with respect to fiber length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberStiffness(self, s)

    def getTendonStiffness(self, s: "State") -> "double":
        r"""
        get the current tendon stiffness (N/m) defined as the partial derivative
               of tendon force with respect to tendon length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonStiffness(self, s)

    def getMuscleStiffness(self, s: "State") -> "double":
        r"""
        get the current muscle stiffness (N/m) defined as the partial derivative
               of muscle force with respect to muscle length
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getMuscleStiffness(self, s)

    def getFiberActivePower(self, s: "State") -> "double":
        r""" get the current active fiber power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberActivePower(self, s)

    def getFiberPassivePower(self, s: "State") -> "double":
        r""" get the current passive fiber power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getFiberPassivePower(self, s)

    def getTendonPower(self, s: "State") -> "double":
        r""" get the current tendon power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getTendonPower(self, s)

    def getMusclePower(self, s: "State") -> "double":
        r""" get the current muscle power (W)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getMusclePower(self, s)

    def getStress(self, s: "State") -> "double":
        r""" get the stress in the muscle (part of the Actuator interface as well)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getStress(self, s)

    def setExcitation(self, s: "State", excitation: "double") -> "void":
        r"""
        set the excitation (control) for this muscle. NOTE if controllers are connected to the
               muscle and are adding in their controls, and setExcitation is called after the model's
               computeControls(), then setExcitation will override the controller values. If called
               before computeControls, then controller value(s) are added to the excitation set here.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setExcitation(self, s, excitation)

    def getExcitation(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getExcitation(self, s)

    def computeEquilibrium(self, s: "State") -> "void":
        r""" Find and set the equilibrium state of the muscle (if any)"""
        return _simulation.Millard2012EquilibriumMuscleIterator_computeEquilibrium(self, s)

    def get_GeometryPath(self, *args) -> "OpenSim::GeometryPath const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_GeometryPath(self, *args)

    def get_optimal_force(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_optimal_force(self, *args)
    _has_output_tension = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_tension_get)

    def getGeometryPath(self) -> "OpenSim::GeometryPath const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_getGeometryPath(self)

    def hasGeometryPath(self) -> "bool":
        return _simulation.Millard2012EquilibriumMuscleIterator_hasGeometryPath(self)

    def getOptimalForce(self) -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getOptimalForce(self)

    def getLength(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getLength(self, s)

    def getLengtheningSpeed(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getLengtheningSpeed(self, s)

    def getPower(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getPower(self, s)

    def computeMomentArm(self, s: "State", aCoord: "Coordinate") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_computeMomentArm(self, s, aCoord)

    def get_min_control(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_min_control(self, *args)

    def get_max_control(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_max_control(self, *args)
    _has_output_actuation = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_actuation_get)
    _has_output_speed = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_speed_get)

    def getControl(self, s: "State") -> "double":
        r""" Convenience method to get control given scalar (double) valued control"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getControl(self, s)

    def numControls(self) -> "int":
        return _simulation.Millard2012EquilibriumMuscleIterator_numControls(self)

    def setActuation(self, s: "State", aActuation: "double") -> "void":
        return _simulation.Millard2012EquilibriumMuscleIterator_setActuation(self, s, aActuation)

    def getActuation(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getActuation(self, s)

    def setSpeed(self, s: "State", aspeed: "double") -> "void":
        return _simulation.Millard2012EquilibriumMuscleIterator_setSpeed(self, s, aspeed)

    def getSpeed(self, s: "State") -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getSpeed(self, s)

    def getMinControl(self) -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getMinControl(self)

    def getMaxControl(self) -> "double":
        return _simulation.Millard2012EquilibriumMuscleIterator_getMaxControl(self)

    def overrideActuation(self, s: "State", flag: "bool") -> "void":
        r"""
        Enable/disable a ScalarActuator's override actuation.

        The actuation normally produced by a ScalarActuator can be overridden and
        When the ScalarActuator's actuation is overridden, the ScalarActuator will
        by default produce a constant actuation which can be set with
        setOverrideActuation().

        :type s: :py:class:`State`
        :param s:    current state
        :type flag: boolean
        :param flag: true = override ScalarActuator's output actuation
                        false = use ScalarActuator's computed force (normal operation)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_overrideActuation(self, s, flag)

    def isActuationOverridden(self, s: "State") -> "bool":
        r""" return ScalarActuator's override status"""
        return _simulation.Millard2012EquilibriumMuscleIterator_isActuationOverridden(self, s)

    def setOverrideActuation(self, s: "State", value: "double") -> "void":
        r"""
        set the actuation value used when the override is true

        :type s: :py:class:`State`
        :param s:      current state
        :type value: float
        :param value:  value of override actuation
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setOverrideActuation(self, s, value)

    def getOverrideActuation(self, s: "State") -> "double":
        r"""return override actuation"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getOverrideActuation(self, s)

    def getControls(self, modelControls: "Vector", actuatorControls: "Vector") -> "void":
        r"""
        Convenience methods for getting, setting and adding to actuator controls from/into
               the model controls. These methods have no effect on the realization stage.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getControls(self, modelControls, actuatorControls)

    def setControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" set actuator controls subvector into the right slot in the system-wide model controls"""
        return _simulation.Millard2012EquilibriumMuscleIterator_setControls(self, actuatorControls, modelControls)

    def addInControls(self, actuatorControls: "Vector", modelControls: "Vector") -> "void":
        r""" add actuator controls to the values already occupying the slot in the system-wide model controls"""
        return _simulation.Millard2012EquilibriumMuscleIterator_addInControls(self, actuatorControls, modelControls)

    def get_appliesForce(self, *args) -> "bool const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_get_appliesForce(self, *args)
    _has_output_potential_energy = property(_simulation.Millard2012EquilibriumMuscleIterator__has_output_potential_energy_get)

    def shouldBeParallelized(self) -> "bool":
        r"""
        Tell SimBody to parallelize this force. Should be
        set to true for any forces that will take time to
        complete their calcForce method. Note that all forces
        that set this flag to false will be put in series on a
        thread that is running in parallel with other forces
        that marked this flag as true.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_shouldBeParallelized(self)

    def appliesForce(self, s: "State") -> "bool":
        r""" Return if the Force is applied (or enabled) or not."""
        return _simulation.Millard2012EquilibriumMuscleIterator_appliesForce(self, s)

    def setAppliesForce(self, s: "State", applyForce: "bool") -> "void":
        r""" %Set whether or not the Force is applied."""
        return _simulation.Millard2012EquilibriumMuscleIterator_setAppliesForce(self, s, applyForce)

    def getModel(self) -> "OpenSim::Model const &":
        r""" Get a const reference to the Model this component is part of."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getModel(self)

    def hasModel(self) -> "bool":
        r""" Does this ModelComponent have a Model associated with it?"""
        return _simulation.Millard2012EquilibriumMuscleIterator_hasModel(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _simulation.Millard2012EquilibriumMuscleIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _simulation.Millard2012EquilibriumMuscleIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _simulation.Millard2012EquilibriumMuscleIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _simulation.Millard2012EquilibriumMuscleIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _simulation.Millard2012EquilibriumMuscleIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _simulation.Millard2012EquilibriumMuscleIterator_toString(self)

# Register Millard2012EquilibriumMuscleIterator in _simulation:
_simulation.Millard2012EquilibriumMuscleIterator_swigregister(Millard2012EquilibriumMuscleIterator)

class ActiveForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ActiveForceLengthCurve, commonly used
       to model the active element in muscle models. The active-force-length curve
       is dimensionless: force is normalized to maximum isometric force and length
       is normalized to resting fiber length. Five properties are used to construct
       a curve:

       :param minActiveNormFiberLength:
               The normalized fiber length where the steep ascending limb of the
               active-force-length curve transitions to the minimum value and has first
               and second derivatives of 0.
       :param transitionNormFiberLength:
               The normalized fiber length where the steep ascending limb transitions
               to the shallow ascending limb.
       :param maxActiveNormFiberLength:
               The normalized fiber length where the descending limb transitions to the
               minimum value and has first and second derivatives of 0.
       :param shallowAscendingSlope:
               The slope of the shallow ascending limb.
       :param minimumValue:
               The minimum value of the active-force-length curve. If you are using an
               equilibrium model, this value must be greater than 0, as a value of 0
               will cause a singularity in the muscle dynamic equations.

       Image: fig_ActiveForceLengthCurve.png

       **Conditions**
           0 < minActiveNormFiberLength < transitionNormFiberLength < 1 < maxActiveNormFiberLength
       0 <= shallowAscendingSlope < 1/(1-transitionNormFiberLength)
       0 <= minimumValue

       **Default Parameter Values**
       The default parameters have been chosen so that the resulting curve closely
       matches the active-force-length curve for human sarcomeres, as documented by
       Nigg and Herzog (1994). The descending limb has been adjusted to match the
       in-vitro human fiber data reported by Gollapudi and Lin (2009). The default
       shoulder value is set to 0.1. This relatively large value is used to ensure
       that muscle model dynamic equations with an active-force-length singularity
       do not take an unreasonable amount of time to simulate (simulation time
       grows as the value of the active-force-length curve approaches 0). %Muscle
       model formulations that do not have this singularity (e.g., the
       Millard2012AccelerationMuscle model) can use a minimumValue of 0.

           minActiveNormFiberLength ..... 0.4441
       transitionNormFiberLength .... 0.73
       maxActiveNormFiberLength ..... 1.8123
       shallowAscendingSlope ........ 0.8616
       minimumValue ................. 0.1

       **Example**

       .. code-block:: c++

           ActiveForceLengthCurve falCurve1(0.44, 0.73, 1.8, 0.86, 0.1);
           double falVal  = falCurve1.calcValue(1.0);
           double dfalVal = falCurve1.calcDerivative(1.0, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       **References**
       * Gollapudi, S.K., Lin, D.C. (2009) Experimental determination of
           sarcomere force-length relationship in type-I human skeletal muscle
           fibers. Journal of Biomechanics 42(13), 2011--2016.
       * Nigg, B.M., Herzog, W. Biomechanics of the Musculo-skeletal System.
           Wiley, 1994.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActiveForceLengthCurve *":
        return _simulation.ActiveForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ActiveForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ActiveForceLengthCurve_getClassName()

    def clone(self) -> "OpenSim::ActiveForceLengthCurve *":
        return _simulation.ActiveForceLengthCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ActiveForceLengthCurve_getConcreteClassName(self)

    def copyProperty_min_norm_active_fiber_length(self, source: "ActiveForceLengthCurve") -> "void":
        return _simulation.ActiveForceLengthCurve_copyProperty_min_norm_active_fiber_length(self, source)

    def append_min_norm_active_fiber_length(self, value: "double const &") -> "int":
        return _simulation.ActiveForceLengthCurve_append_min_norm_active_fiber_length(self, value)

    def constructProperty_min_norm_active_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.ActiveForceLengthCurve_constructProperty_min_norm_active_fiber_length(self, initValue)

    def get_min_norm_active_fiber_length(self, *args) -> "double const &":
        return _simulation.ActiveForceLengthCurve_get_min_norm_active_fiber_length(self, *args)

    def upd_min_norm_active_fiber_length(self, *args) -> "double &":
        return _simulation.ActiveForceLengthCurve_upd_min_norm_active_fiber_length(self, *args)

    def set_min_norm_active_fiber_length(self, *args) -> "void":
        return _simulation.ActiveForceLengthCurve_set_min_norm_active_fiber_length(self, *args)

    def copyProperty_transition_norm_fiber_length(self, source: "ActiveForceLengthCurve") -> "void":
        return _simulation.ActiveForceLengthCurve_copyProperty_transition_norm_fiber_length(self, source)

    def append_transition_norm_fiber_length(self, value: "double const &") -> "int":
        return _simulation.ActiveForceLengthCurve_append_transition_norm_fiber_length(self, value)

    def constructProperty_transition_norm_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.ActiveForceLengthCurve_constructProperty_transition_norm_fiber_length(self, initValue)

    def get_transition_norm_fiber_length(self, *args) -> "double const &":
        return _simulation.ActiveForceLengthCurve_get_transition_norm_fiber_length(self, *args)

    def upd_transition_norm_fiber_length(self, *args) -> "double &":
        return _simulation.ActiveForceLengthCurve_upd_transition_norm_fiber_length(self, *args)

    def set_transition_norm_fiber_length(self, *args) -> "void":
        return _simulation.ActiveForceLengthCurve_set_transition_norm_fiber_length(self, *args)

    def copyProperty_max_norm_active_fiber_length(self, source: "ActiveForceLengthCurve") -> "void":
        return _simulation.ActiveForceLengthCurve_copyProperty_max_norm_active_fiber_length(self, source)

    def append_max_norm_active_fiber_length(self, value: "double const &") -> "int":
        return _simulation.ActiveForceLengthCurve_append_max_norm_active_fiber_length(self, value)

    def constructProperty_max_norm_active_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.ActiveForceLengthCurve_constructProperty_max_norm_active_fiber_length(self, initValue)

    def get_max_norm_active_fiber_length(self, *args) -> "double const &":
        return _simulation.ActiveForceLengthCurve_get_max_norm_active_fiber_length(self, *args)

    def upd_max_norm_active_fiber_length(self, *args) -> "double &":
        return _simulation.ActiveForceLengthCurve_upd_max_norm_active_fiber_length(self, *args)

    def set_max_norm_active_fiber_length(self, *args) -> "void":
        return _simulation.ActiveForceLengthCurve_set_max_norm_active_fiber_length(self, *args)

    def copyProperty_shallow_ascending_slope(self, source: "ActiveForceLengthCurve") -> "void":
        return _simulation.ActiveForceLengthCurve_copyProperty_shallow_ascending_slope(self, source)

    def append_shallow_ascending_slope(self, value: "double const &") -> "int":
        return _simulation.ActiveForceLengthCurve_append_shallow_ascending_slope(self, value)

    def constructProperty_shallow_ascending_slope(self, initValue: "double const &") -> "void":
        return _simulation.ActiveForceLengthCurve_constructProperty_shallow_ascending_slope(self, initValue)

    def get_shallow_ascending_slope(self, *args) -> "double const &":
        return _simulation.ActiveForceLengthCurve_get_shallow_ascending_slope(self, *args)

    def upd_shallow_ascending_slope(self, *args) -> "double &":
        return _simulation.ActiveForceLengthCurve_upd_shallow_ascending_slope(self, *args)

    def set_shallow_ascending_slope(self, *args) -> "void":
        return _simulation.ActiveForceLengthCurve_set_shallow_ascending_slope(self, *args)

    def copyProperty_minimum_value(self, source: "ActiveForceLengthCurve") -> "void":
        return _simulation.ActiveForceLengthCurve_copyProperty_minimum_value(self, source)

    def append_minimum_value(self, value: "double const &") -> "int":
        return _simulation.ActiveForceLengthCurve_append_minimum_value(self, value)

    def constructProperty_minimum_value(self, initValue: "double const &") -> "void":
        return _simulation.ActiveForceLengthCurve_constructProperty_minimum_value(self, initValue)

    def get_minimum_value(self, *args) -> "double const &":
        return _simulation.ActiveForceLengthCurve_get_minimum_value(self, *args)

    def upd_minimum_value(self, *args) -> "double &":
        return _simulation.ActiveForceLengthCurve_upd_minimum_value(self, *args)

    def set_minimum_value(self, *args) -> "void":
        return _simulation.ActiveForceLengthCurve_set_minimum_value(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an active-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs an active-force-length curve using the provided parameters
           and assigns a default name.
        """
        _simulation.ActiveForceLengthCurve_swiginit(self, _simulation.new_ActiveForceLengthCurve(*args))

    def getMinActiveFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized fiber length where the steep ascending limb of
               the active-force-length curve transitions to the minimum activation value
               and simultaneously achieves a first and second derivative of 0.
        """
        return _simulation.ActiveForceLengthCurve_getMinActiveFiberLength(self)

    def getTransitionFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized fiber length where the steep ascending limb
               of the active-force-length curve transitions to the shallow ascending limb.
        """
        return _simulation.ActiveForceLengthCurve_getTransitionFiberLength(self)

    def getMaxActiveFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized fiber length where the descending limb of the
               active-force-length curve transitions to the minimum activation value and
               simultaneously achieves first and second derivatives of 0.
        """
        return _simulation.ActiveForceLengthCurve_getMaxActiveFiberLength(self)

    def getShallowAscendingSlope(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the shallow ascending limb
               (d active_force_length / d normalized_fiber_length).
        """
        return _simulation.ActiveForceLengthCurve_getShallowAscendingSlope(self)

    def getMinValue(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum active-force-length value permitted in the
               simulation. This value must be non-zero for an equilibrium model.
        """
        return _simulation.ActiveForceLengthCurve_getMinValue(self)

    def setActiveFiberLengths(self, minActiveNormFiberLength: "double", transitionNormFiberLength: "double", maxActiveNormFiberLength: "double", shallowAscendingSlope: "double") -> "void":
        r"""
        :type minActiveNormFiberLength: float
        :param minActiveNormFiberLength:
                The normalized fiber length where the steep ascending limb of the
                active-force-length curve transitions to the minimum value and has first
                and second derivatives of 0.
        :type transitionNormFiberLength: float
        :param transitionNormFiberLength:
                The normalized fiber length where the steep ascending limb transitions
                to the shallow ascending limb.
        :type maxActiveNormFiberLength: float
        :param maxActiveNormFiberLength:
                The normalized fiber length where the descending limb transitions to the
                minimum value and has first and second derivatives of 0.
        :type shallowAscendingSlope: float
        :param shallowAscendingSlope:
                The slope of the shallow ascending limb.

        **Conditions**
            0 < minActiveNormFiberLength < transitionNormFiberLength < 1 < maxActiveNormFiberLength
        0 <= shallowAscendingSlope < 1/(1-transitionNormFiberLength)
        """
        return _simulation.ActiveForceLengthCurve_setActiveFiberLengths(self, minActiveNormFiberLength, transitionNormFiberLength, maxActiveNormFiberLength, shallowAscendingSlope)

    def setMinValue(self, minimumValue: "double") -> "void":
        r"""
        :type minimumValue: float
        :param minimumValue:
                The minimum value of the active-force-length curve. If you are using an
                equilibrium model, this value must be greater than 0, as a value of 0
                will cause a singularity in the muscle dynamic equations.
        """
        return _simulation.ActiveForceLengthCurve_setMinValue(self, minimumValue)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the active-force-length curve at a normalized fiber length of
           'normFiberLength'.
        """
        return _simulation.ActiveForceLengthCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculates the derivative of the active-force-length multiplier with
           respect to the normalized fiber length.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the active-force-length curve with respect to the
                   normalized fiber length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ActiveForceLengthCurve_calcDerivative(self, *args)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ActiveForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ActiveForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the linear extrapolation region (the region less
           than minActiveNormFiberLength), through the curve, out to the other linear
           extrapolation region (the region greater than maxActiveNormFiberLength). The
           width of each linear extrapolation region is 10% of the curve domain, or
           0.1*(maxActiveNormFiberLength-minActiveNormFiberLength). The curve is
           sampled quite densely: the active-force-length .csv file will have 500+20
           rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ActiveForceLengthCurve.csv', 1, 0);
        """
        return _simulation.ActiveForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.ActiveForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ActiveForceLengthCurve

# Register ActiveForceLengthCurve in _simulation:
_simulation.ActiveForceLengthCurve_swigregister(ActiveForceLengthCurve)

def ActiveForceLengthCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActiveForceLengthCurve *":
    return _simulation.ActiveForceLengthCurve_safeDownCast(obj)

def ActiveForceLengthCurve_getClassName() -> "std::string const &":
    return _simulation.ActiveForceLengthCurve_getClassName()

class FiberCompressiveForceCosPennationCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberCompressiveForceCosPennationCurve,
    which is used to ensure that the pennation angle approaches but never reaches
    an angle of 90 degrees. Preventing the fibers from achieving a pennation
    angle of 90 degrees is important for equilibrium muscle models which
    have a singularity at this value.

    This curve is designed to work with the muscle model
    in such a way that it acts like a spring that the pennated muscle fibers
    contact it as the fiber rotates (circled in red). When the spring engages it
    will exert a force on the fiber that will prevent it from shortening further,
    thus preventing the pennation angle from reaching 90 degrees.

    Note that this object should be updated through the set methods provided.
    These set methods will take care of rebuilding the curve correctly. If you
    modify the properties directly, the curve will not be rebuilt, and upon
    calling a function like calcValue, calcDerivative, or printCurveToCSVFile
    an exception will be thrown because the curve is out of date with its
    properties.

    Image: fig_FiberCompressiveForceCosPennationCurve.png

     Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberCompressiveForceCosPennationCurve *":
        return _simulation.FiberCompressiveForceCosPennationCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FiberCompressiveForceCosPennationCurve_getClassName()

    def clone(self) -> "OpenSim::FiberCompressiveForceCosPennationCurve *":
        return _simulation.FiberCompressiveForceCosPennationCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FiberCompressiveForceCosPennationCurve_getConcreteClassName(self)

    def copyProperty_engagement_angle_in_degrees(self, source: "FiberCompressiveForceCosPennationCurve") -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_engagement_angle_in_degrees(self, source)

    def append_engagement_angle_in_degrees(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceCosPennationCurve_append_engagement_angle_in_degrees(self, value)

    def constructProperty_engagement_angle_in_degrees(self, initValue: "double const &") -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_engagement_angle_in_degrees(self, initValue)

    def get_engagement_angle_in_degrees(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceCosPennationCurve_get_engagement_angle_in_degrees(self, *args)

    def upd_engagement_angle_in_degrees(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_engagement_angle_in_degrees(self, *args)

    def set_engagement_angle_in_degrees(self, *args) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_set_engagement_angle_in_degrees(self, *args)

    def copyProperty_stiffness_at_perpendicular(self, source: "FiberCompressiveForceCosPennationCurve") -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_stiffness_at_perpendicular(self, source)

    def append_stiffness_at_perpendicular(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceCosPennationCurve_append_stiffness_at_perpendicular(self, value)

    def constructProperty_stiffness_at_perpendicular(self, *args) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_stiffness_at_perpendicular(self, *args)

    def get_stiffness_at_perpendicular(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceCosPennationCurve_get_stiffness_at_perpendicular(self, *args)

    def upd_stiffness_at_perpendicular(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_stiffness_at_perpendicular(self, *args)

    def set_stiffness_at_perpendicular(self, *args) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_set_stiffness_at_perpendicular(self, *args)

    def copyProperty_curviness(self, source: "FiberCompressiveForceCosPennationCurve") -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceCosPennationCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceCosPennationCurve_get_curviness(self, *args)

    def upd_curviness(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceCosPennationCurve_upd_curviness(self, *args)

    def set_curviness(self, *args) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor creates an curve with the default property values,
           and assigns it a default name *

        |

        *Overload 2:*
        Constructs a C2 continuous compressive fiber force cos pennation curve.
           The sole purpose of this curve is to prevent the pennation angle from
           reaching an angle of 90 degrees. Details to appear in Millard et al. 2012.

           :type engagementAngleInDegrees: float
           :param engagementAngleInDegrees:
                       The pennation angle engagement angle of the fiber compressive
                       force pennation curve. Making the spring engage too
                       far from 90 degrees may unrealistically limit the force
                       production capability of the muscle. An engagement angle of
                       80 degrees is a good place to start.

           :type stiffnessAtPerpendicular: float
           :param stiffnessAtPerpendicular:
                       This is the stiffness of the compressive elastic force length
                       spring when the pennation angle reaches 90 degrees. Note that
                       the units of this stiffness are
                       (normalized force) / cos(engagmentAngleInDegrees). If the
                       engagement angle is 80 degrees, a good stiffness to start with
                       is -2*(1/cosd(engagementAngleInDegrees))

           :type curviness: float
           :param curviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtPerpendicularFiber' and the
                       x axis as shown in the figure. A good curviness parameter value
                       to start with is 0.5.

           :type muscleName: string
           :param muscleName:
                       The name of the muscle this curve belongs to. This name is used
                       to create the name of this curve, which is formed simply by
                       appending "_FiberCompressiveForceCosPennationCurve" to the
                       string in muscleName. This name is used for making intelligible
                       error messages and also for naming the XML version of this curve
                       when it is serialized.

           **Conditions**
                   0 < engagmentAngleInDegrees < 90
               stiffnessAtPerpendicular < -1/engagmentAngleInDegrees
               0 <= curviness <= 1

           **Computational Costs**
                   ~174,100 flops

           **Default Parameter Values**
                   engagmentAngleInDegrees = 80

        |

        *Overload 3:*

            Constructs a C2 continuous compressive fiber force cos pennation curve
            using only the mandatory property, engagmentAngleInDegrees. The
            sole purpose of this curve is to prevent the pennation angle from reaching
            an angle of 90 degrees. Details to appear in Millard et al. 2012.

           :type engagementAngleInDegrees: float
           :param engagementAngleInDegrees:
                           The pennation angle engagement angle of the fiber compressive
                           force pennation curve. Making the spring engage too
                           far from 90 degrees may unrealistically limit the force
                           production capability of the muscle. An engagement angle of
                           80 degrees is a good place to start.

           :type muscleName: string
           :param muscleName:
                           The name of the muscle this curve belongs to. This name is used
                           to create the name of this curve, which is formed simply by
                           appending "_FiberCompressiveForceCosPennationCurve" to the
                           string in muscleName. This name is used for making intelligible
                           error messages and also for naming the XML version of this curve
                           when it is serialized.

           ** Optional Parameters **
               If the optional parameters have not yet been set, they are computed when
               functions getStiffnessAtPerpendicularInUse(), and getCurvinessInUse()
               are called. See the documentation for these functions for details

           **Conditions:**
                           0 < engagmentAngleInDegrees < 90

           **Computational Costs**

                   ~174,100 flops

           ** Default Parameter Values **


                             engagmentAngleInDegrees = 80

           **Example:**
        """
        _simulation.FiberCompressiveForceCosPennationCurve_swiginit(self, _simulation.new_FiberCompressiveForceCosPennationCurve(*args))

    def getEngagementAngleInDegrees(self) -> "double":
        r"""
        :rtype: float
        :return: The pennation angle engagement angle of the fiber compressive
                        force pennation curve.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getEngagementAngleInDegrees(self)

    def getStiffnessAtPerpendicularInUse(self) -> "double":
        r"""
        :rtype: float
        :return: This is the stiffness of the compressive elastic force length
                       spring when the pennation angle reaches 90 degrees. If this
                       property has been set, the property value is returned. If this
                       property is empty, then a value is computed and returned. The
                       value is computed using the following:

                                   stiffnessAtPerpendicular = -2 * 1/cosd(engagementAngleInDegrees)

                   where cosd is a cosine function that takes its argument in units
                   of degrees
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getStiffnessAtPerpendicularInUse(self)

    def getCurvinessInUse(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'StiffnessAtPerpendicularFiber'.

                   If this property is empty, then a value is computed and
                   returned. The value is computed using the following:

                                   curviness = 0.1
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self) -> "bool":
        r"""
        :rtype: boolean
        :return: true if the internal fitting routine (which takes only one
            argument, the engagementAngleInDegrees) is being used. False is returned if
            the user has set the optional parameters.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_isFittedCurveBeingUsed(self)

    def setEngagementAngleInDegrees(self, aEngagementAngleInDegrees: "double") -> "void":
        r"""
        :type aEngagementAngleInDegrees: float
        :param aEngagementAngleInDegrees:
                    Sets the pennation angle engagement angle of the fiber compressive
                    force pennation curve.
            **Cost **
             The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_setEngagementAngleInDegrees(self, aEngagementAngleInDegrees)

    def setOptionalProperties(self, aStiffnessAtPerpendicular: "double", aCurviness: "double") -> "void":
        r"""
        :type aStiffnessAtPerpendicular: float
        :param aStiffnessAtPerpendicular:
                   This is the stiffness of the compressive elastic force length
                   spring when the pennation angle reaches 90 degrees.

        :type aCurviness: float
        :param aCurviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure.

        **Cost **
        The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_setOptionalProperties(self, aStiffnessAtPerpendicular, aCurviness)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*

           Calculates the value of the curve evaluated at cosPennationAngle.
           :type cosPennationAngle: float
           :param cosPennationAngle:: The cosine of the fiber pennation angle

           :rtype: float
           :return: the normalized force generated by the compressive force element


           **Computational Costs**
                   x in curve domain  : ~282 flops
               x in linear section:   ~5 flops


        |

        *Overload 2:*
        Implement the generic OpenSim::Function interface *
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*

           Calculates the derivative of the fiber compressive force pennation angle
           curve w.r.t. to cosPennationAngle.

           :type cosPennationAngle: float
           :param cosPennationAngle::
                           The cosine of the fiber pennation angle

           :type order: int
           :param order:: the order of the derivative. Only values of 0,1 and 2 are
                             acceptable.

           :rtype: float
           :return: the derivative of the fiber compressive force pennation angle
               curve w.r.t. to cosPennationAngle

           **Computational Costs**
                   x in curve domain  : ~391 flops
               x in linear section:   ~2 flops


        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcDerivative(self, *args)

    def calcIntegral(self, cosPennationAngle: "double") -> "double":
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                        The cosine of the pennation angle

        :rtype: float
        :return: Computes the normalized area under the curve. For this curve,
                    this quantity corresponds to the normalized potential energy stored
                    in the fiber compressive force cos pennation spring - simply
                    multiply this quantity by the number of NormForce
                    (where NormForce corresponds to the number of
                    Newtons that 1 normalized force corresponds to) to obtain
                    the potential energy stored in the fiber in units of Joules. Note
                    that NormDistance is omitted because the length dimension of this
                    curve is not normalized, only the force dimension.

        **Computational Costs**

                x in curve domain  : ~13 flops
            x in linear section: ~19 flops
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_calcIntegral(self, cosPennationAngle)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        This function returns a SimTK::Vec2 that contains in its 0th element
        the lowest value of the curve domain, and in its 1st element the highest
        value in the curve domain of the curve. Outside of this domain the curve
        is approximated using linear extrapolation.

        :rtype: :py:class:`Vec2`
        :return: The minimum and maximum value of the domain, x, of the curve
                       y(x). Within this range y(x) is a curve, outside of this range
                       the function y(x) is a C2 (continuous to the second
                       derivative) linear extrapolation
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        This function will generate a csv file with a name that matches the
               curve name (e.g. "bicepfemoris_FiberCompressiveForceCosPennationCurve.csv").
              This function is not const to permit the curve to be rebuilt if it is out of
               date with its properties.

               :type path: string
               :param path: The full path to the location. Note '/' slashes must be used,
                        and do not put a '/' after the last folder.

               The file will contain the following columns:

                      Col# 1, 2,     3,       4,  
                    x, y, dy/dx, d2y/dx2,

               The curve will be sampled from its linear extrapolation region
               (the region with normalized fiber velocities < -1), through
               the curve, out to the other linear extrapolation region
               (the region with normalized fiber velocities > 1). The width of
               each linear extrapolation region is 10% of the entire range of x, or
               0.1*(x1-x0).

               The curve is sampled quite densely: there are 200+20 rows

               **Computational Costs**
                           ~194,800 flops

               **Example**
               To read the csv file with a header in from Matlab, you need to use
               csvread set so that it will ignore the header row. This is accomplished
               by using the extra two numerical arguments for csvread to tell the
               function to begin reading from the 1st row, and the 0th index (csvread
               is 0 indexed). This is necessary to skip reading in the text header
                       data=csvread('bicepfemoris_FiberCompressiveForceCosPennationCurve.csv',1,0);
        """
        return _simulation.FiberCompressiveForceCosPennationCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.FiberCompressiveForceCosPennationCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberCompressiveForceCosPennationCurve

# Register FiberCompressiveForceCosPennationCurve in _simulation:
_simulation.FiberCompressiveForceCosPennationCurve_swigregister(FiberCompressiveForceCosPennationCurve)

def FiberCompressiveForceCosPennationCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberCompressiveForceCosPennationCurve *":
    return _simulation.FiberCompressiveForceCosPennationCurve_safeDownCast(obj)

def FiberCompressiveForceCosPennationCurve_getClassName() -> "std::string const &":
    return _simulation.FiberCompressiveForceCosPennationCurve_getClassName()

class FiberCompressiveForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberCompressiveForceLengthCurve,
    which is used to ensure that the fiber cannot generate force at, nor shorten
    beyond a minimum normalized length.

    Image: fig_FiberCompressiveForceLengthCurve.png

     Note that this object should be updated through the set methods provided.
    These set methods will take care of rebuilding the curve correctly. If you
    modify the properties directly, the curve will not be rebuilt, and upon
    calling a function like calcValue, calcDerivative, or printCurveToCSVFile
    an exception will be thrown because the curve is out of date with its
    properties.

     Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberCompressiveForceLengthCurve *":
        return _simulation.FiberCompressiveForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FiberCompressiveForceLengthCurve_getClassName()

    def clone(self) -> "OpenSim::FiberCompressiveForceLengthCurve *":
        return _simulation.FiberCompressiveForceLengthCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FiberCompressiveForceLengthCurve_getConcreteClassName(self)

    def copyProperty_norm_length_at_zero_force(self, source: "FiberCompressiveForceLengthCurve") -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_norm_length_at_zero_force(self, source)

    def append_norm_length_at_zero_force(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceLengthCurve_append_norm_length_at_zero_force(self, value)

    def constructProperty_norm_length_at_zero_force(self, initValue: "double const &") -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_norm_length_at_zero_force(self, initValue)

    def get_norm_length_at_zero_force(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceLengthCurve_get_norm_length_at_zero_force(self, *args)

    def upd_norm_length_at_zero_force(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceLengthCurve_upd_norm_length_at_zero_force(self, *args)

    def set_norm_length_at_zero_force(self, *args) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_set_norm_length_at_zero_force(self, *args)

    def copyProperty_stiffness_at_zero_length(self, source: "FiberCompressiveForceLengthCurve") -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_stiffness_at_zero_length(self, source)

    def append_stiffness_at_zero_length(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceLengthCurve_append_stiffness_at_zero_length(self, value)

    def constructProperty_stiffness_at_zero_length(self, *args) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_stiffness_at_zero_length(self, *args)

    def get_stiffness_at_zero_length(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceLengthCurve_get_stiffness_at_zero_length(self, *args)

    def upd_stiffness_at_zero_length(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceLengthCurve_upd_stiffness_at_zero_length(self, *args)

    def set_stiffness_at_zero_length(self, *args) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_set_stiffness_at_zero_length(self, *args)

    def copyProperty_curviness(self, source: "FiberCompressiveForceLengthCurve") -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value: "double const &") -> "int":
        return _simulation.FiberCompressiveForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args) -> "double const &":
        return _simulation.FiberCompressiveForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args) -> "double &":
        return _simulation.FiberCompressiveForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor creates an object with a default name that doesn't
           yet define a curve. *

        |

        *Overload 2:*
        Constructs a C2 continuous compressive fiber force length curve. This
           curve is used in the fiber model as a means of ensuring that the fiber
           cannot generate a tensile force at, nor shorten beyond, some minimum length.
           Details to appear in Millard et al. 2012.

           :type normLengthAtZeroForce: float
           :param normLengthAtZeroForce:
                       The normalized fiber length at which the compressive element
                       begins to engage. Normalized length is defined as
                       length_norm = l/l0, where l is the length of the fiber,
                       and l0 is the resting length of the fiber.

           :type stiffnessAtZeroLength: float
           :param stiffnessAtZeroLength:
                       This is the stiffness of the compressive elastic force length
                       spring when the fiber reaches a normalized length of 0.

           :type curviness: float
           :param curviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtZeroLength' and the
                       x axis as shown in the figure.

           :type muscleName: string
           :param muscleName:
                       The name of the muscle this curve belongs to. This name is used
                       to create the name of this curve, which is formed simply by
                       appending "_FiberCompressiveForceLengthCurve" to the string in
                       muscleName. This name is used for making intelligible error
                       messages and also for naming the XML version of this curve when
                       it is serialized.

           **Conditions**
                   normLengthAtZeroForce > 0
               stiffnessAtZeroLength < -1/normLengthAtZeroForce
               0 <= curviness <= 1

           **Computational Costs**
                   ~174,100 flops

           **Default Parameter Values**

                   normLengthAtZeroForce   = 0.6
               stiffnessAtZeroLength   = -8.4
               curviness               = 0.5
        """
        _simulation.FiberCompressiveForceLengthCurve_swiginit(self, _simulation.new_FiberCompressiveForceLengthCurve(*args))

    def getNormLengthAtZeroForce(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized fiber length at which the compressive element
                        begins to engage. Normalized length is defined as
                        length_norm = l/l0, where l is the length of the fiber,
                        and l0 is the resting length of the fiber.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getNormLengthAtZeroForce(self)

    def getStiffnessAtZeroLengthInUse(self) -> "double":
        r"""
        :rtype: float
        :return: This is the stiffness of the compressive elastic force length
                       spring when the fiber reaches a normalized length of 0. If this
                       optional property is not specified, a suitable value will be
                       calculated and used instead.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getStiffnessAtZeroLengthInUse(self)

    def getCurvinessInUse(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure. If this optional property
                       is not specified, a suitable value will be calculated and used
                       instead.
        """
        return _simulation.FiberCompressiveForceLengthCurve_getCurvinessInUse(self)

    def setNormLengthAtZeroForce(self, aNormLengthAtZeroForce: "double") -> "void":
        r"""
        :type aNormLengthAtZeroForce: float
        :param aNormLengthAtZeroForce:
                    Sets the normalized fiber length at which the compressive element
                    begins to engage. Normalized length is defined as
                    length_norm = l/l0, where l is the length of the fiber,
                    and l0 is the resting length of the fiber. This length must be
                    greater than 0.

        **Cost **
        The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_setNormLengthAtZeroForce(self, aNormLengthAtZeroForce)

    def setOptionalProperties(self, aStiffnessAtZeroLength: "double", aCurviness: "double") -> "void":
        r"""
        :type aStiffnessAtZeroLength: float
        :param aStiffnessAtZeroLength:
                   Sets the stiffness of the compressive elastic force length
                   spring when the fiber reaches a normalized length of 0. This
                   stiffness must be less than -1/normLengthAtZeroForce

        :type aCurviness: float
        :param aCurviness:
                       A dimensionless parameter between [0-1] that controls how
                       the curve is drawn: 0 will create a curve that is
                       very close to a straight line segment while a value of 1 will
                       create a curve that smoothly fills the corner formed by the
                       linear extrapolation of 'stiffnessAtOneNormForce' and the
                       x axis as shown in the figure.
            **Cost **
            The curve is rebuilt at a cost of ~174,100 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_setOptionalProperties(self, aStiffnessAtZeroLength, aCurviness)

    def isFittedCurveBeingUsed(self) -> "bool":
        r"""
        :rtype: boolean
        :return: true if the optional properties are empty and the fitted curve is
                     being used. This function returns false if the optional properties
                     are filled and are being used to construct the curve.
        """
        return _simulation.FiberCompressiveForceLengthCurve_isFittedCurveBeingUsed(self)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*

           Calculates the value of the curve evaluated at the desired normalized fiber
           length.

           :type aNormLength: float
           :param aNormLength::
                           The normalized fiber length used to evaluate the fiber
                           compressive force length curve for the corresponding normalized
                           force. Here aNormLength = l/l0, where l is the length of the fiber and
                           l0 is the resting length of the fiber.  Thus normalized length
                           of 1.0 means the fiber is at its resting length.

           :rtype: float
           :return: the value of the normalized force generated by the fiber

           **Computational Costs**
                   x in curve domain  : ~282 flops
               x in linear section:   ~5 flops


        |

        *Overload 2:*
        Implement the generic OpenSim::Function interface *
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*

           Calculates the derivative of the fiber force length curve w.r.t.
           to the normalized fiber length.

           :type aNormLength: float
           :param aNormLength::
                           The normalized fiber length used to evaluate the compressive
                           fiber force length curve for the corresponding normalized force. Here
                           aNormLength = l/l0, where l is the length of the fiber and l0
                           is the resting length of the fiber.  Thus normalized length of
                           1.0 means the fiber is at its resting length.

           :type order: int
           :param order:: the order of the derivative. Only values of 0,1 and 2 are
                             acceptable.

           :rtype: float
           :return: the derivative of the normalized fiber force length curve w.r.t.
                   normalized fiber length

           **Computational Costs**
                   x in curve domain  : ~391 flops
               x in linear section:   ~2 flops


        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, aNormLength: "double") -> "double":
        r"""
        :type aNormLength: float
        :param aNormLength:
                        Here aNormLength = l/l0, where l is the length
                        of the fiber and l0 is the resting length of the fiber.
                        Thus normalized length of 1.0 means the fiber is at its
                        resting length.

        :rtype: float
        :return: Computes the normalized area under the curve. For this curve,
                    this quantity corresponds to the normalized potential energy stored
                    in the fiber compressive force length spring - simply
                    multiply this quantity by the number of NormForce*NormDistance
                    (where NormForce corresponds to the number of
                    Newtons that 1 normalized force corresponds to, and NormDistance
                    is the distance in meters that a normalized value of 1 corresponds
                    to) to obtain the potential energy stored in the fiber in units of
                    Joules.

        **Computational Costs**

                x in curve domain  : ~13 flops
            x in linear section: ~19 flops
        """
        return _simulation.FiberCompressiveForceLengthCurve_calcIntegral(self, aNormLength)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        This function returns a SimTK::Vec2 that contains in its 0th element
        the lowest value of the curve domain, and in its 1st element the highest
        value in the curve domain of the curve. Outside of this domain the curve
        is approximated using linear extrapolation.

        :rtype: :py:class:`Vec2`
        :return: The minimum and maximum value of the domain, x, of the curve
                       y(x). Within this range y(x) is a curve, outside of this range
                       the function y(x) is a C2 (continuous to the second
                       derivative) linear extrapolation
        """
        return _simulation.FiberCompressiveForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        This function will generate a csv file with a name that matches the
               curve name (e.g. "bicepfemoris_FiberCompressiveForceLengthCurve.csv");
               This function is not const to permit the curve to be rebuilt if it is out
               of date with its properties.

               :type path: string
               :param path: The full path to the location. Note '/' slashes must be used,
                        and do not put a '/' after the last folder.

               The file will contain the following columns:

                      Col# 1, 2,     3,       4,  
                    x, y, dy/dx, d2y/dx2,

               The curve will be sampled from its linear extrapolation region
               (the region with normalized fiber velocities < -1), through
               the curve, out to the other linear extrapolation region
               (the region with normalized fiber velocities > 1). The width of
               each linear extrapolation region is 10% of the entire range of x, or
               0.1*(x1-x0).

               The curve is sampled quite densely: there are 200+20 rows

               **Computational Costs**
                           ~194,800 flops

               **Example**
               To read the csv file with a header in from Matlab, you need to use
               csvread set so that it will ignore the header row. This is accomplished
               by using the extra two numerical arguments for csvread to tell the
               function to begin reading from the 1st row, and the 0th index (csvread
               is 0 indexed). This is necessary to skip reading in the text header
                       data=csvread('bicepfemoris_fiberCompressiveForceLengthCurve.csv',1,0);
        """
        return _simulation.FiberCompressiveForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.FiberCompressiveForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberCompressiveForceLengthCurve

# Register FiberCompressiveForceLengthCurve in _simulation:
_simulation.FiberCompressiveForceLengthCurve_swigregister(FiberCompressiveForceLengthCurve)

def FiberCompressiveForceLengthCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberCompressiveForceLengthCurve *":
    return _simulation.FiberCompressiveForceLengthCurve_safeDownCast(obj)

def FiberCompressiveForceLengthCurve_getClassName() -> "std::string const &":
    return _simulation.FiberCompressiveForceLengthCurve_getClassName()

class FiberForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable FiberForceLengthCurve, commonly used to
       model the parallel elastic element in muscle models. The fiber-force-length
       curve is dimensionless: force is normalized to maximum isometric force and
       length is normalized to resting fiber length. The user can adjust the
       maximum strain at no load and the strain developed under 1 normalized unit
       of force using the fitted curve. Additionally, if desired, it is possible to
       directly set the low-force stiffness of the fiber, the stiffness of the
       fiber at 1 normalized unit of force, and the shape of the curve (its
       'curviness'):

       ### Properties
       - ``strainAtZeroForce``

           The fiber strain at which the fiber starts to develop force.
           strainAtZeroForce = 0.0 means that the fiber will begin developing
           tension when it is at its resting length.

       - ``strainAtOneNormForce``

           The fiber strain at which the fiber develops 1 unit of normalized force.
           strainAtOneNormForce = 0.6 means that the fiber will develop a tension
           of 1 normalized force when it is strained by 60% of its resting length
           or, equivalently, when it is stretched to 1.6 times its resting length.

       - ``stiffnessAtLowForce``

           The normalized stiffness (slope of the curve) when the fiber is just
           beginning to develop tensile force.

       - ``stiffnessAtOneNormForce``

           The normalized stiffness (slope of the curve) when the fiber develops a
           tension of 1 normalized unit of force.

       - ``curviness``

           A dimensionless parameter between 0 and 1 that describes the shape of
           the curve: a value of 0 indicates a curve that is very close to a
           straight line segment and a value of 1 indicates a curve that smoothly
           fills the corner formed by the linear extrapolation of
           'stiffnessAtOneNormForce' and the x-axis, as shown in the figure.

       Note that we use the Cauchy or engineering definition of strain throughout:
       strain = (l-l0)/l0, where l is the current fiber length and l0 is its
       resting length.

       ### Required Properties
       - ``strainAtZeroForce``
       - ``strainAtOneNormForce``

       ### Optional Properties
       - ``stiffnessAtLowForce``
       - ``stiffnessAtOneNormForce``
       - ``curviness``

       Image: fig_FiberForceLengthCurve.png

       ### Conditions
           strainAtZeroForce < strainAtOneNormForce
       stiffnessAtOneNormForce > 1/(strainAtOneNormForce-strainAtZeroForce)
       0 < stiffnessAtLowForce < stiffnessAtOneNormForce
       0 <= curviness <= 1

       The required parameters can be set using either the constructor or the
       setCurveStrains function; the optional parameters can be set using the
       setOptionalProperties function. Note that filling in one optional parameter
       but not the others will throw an exception when the curve is built. The
       optional parameters can be used to vary the shape of the curve from a close
       approximation of a line to a sharply-bent curve.

       The advantage of this curve over the typical exponential curve used in the
       literature is that it is continuous to the second derivative; the usual
       linearly-extrapolated exponential curve is only C0-continuous. The improved
       smoothness of this curve makes the equations somewhat easier to simulate
       and, more importantly, permits the use of derivative-based numerical methods
       on the curve. In addition, the extra parameters in this curve formulation
       can be adjusted to match a wide variety of shapes, should it be desired to
       fit the curve to a different set of experimental data.

       ### Default Parameter Values
       If the optional parameters are not specified, the curve is fit to the
       experimentally measured fiber-force-length curves of Winters et al. (2010,
       Fig. 3a).

           strainAtZeroForce .......... 0.0
       strainAtOneNormForce ....... 0.7
       stiffnessAtLowForce ........ 0.2
       stiffnessAtOneNormForce .... 2.0 / (strainAtOneNormForce-strainAtZeroForce) = 2.86
       curviness .................. 0.75

       ### Example

       .. code-block:: c++

       Make a fitted fiber-force-length curve.
           FiberForceLengthCurve fpeCurve1;
           fpeCurve1.setCurveStrains(0.0, 0.7);
           double fpeVal1 = fpeCurve1.calcValue(0.1);

       Make a custom fiber-force-length curve by supplying all parameters.
           FiberForceLengthCurve fpeCurve2(0.0, 0.7, 0.2, 2.86, 0.75);
           double fpeVal2  = fpeCurve2.calcValue(0.02);
           double dfpeVal2 = fpeCurve2.calcDerivative(0.02, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       ### References
       - Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
         simulate dynamic contractions in older adults. ASME Journal of
         Biomechanical Engineering 125:70--77.
       - Winters, T.M., Takahashi, M., Lieber, R.L., and Ward, S. (2010) Whole
         muscle length-tension relationships are accurately modeled as scaled
         sarcomeres in rabbit hindlimb muscles. Journal of Biomechanics
         44:109--115.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberForceLengthCurve *":
        return _simulation.FiberForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.FiberForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.FiberForceLengthCurve_getClassName()

    def clone(self) -> "OpenSim::FiberForceLengthCurve *":
        return _simulation.FiberForceLengthCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.FiberForceLengthCurve_getConcreteClassName(self)

    def copyProperty_strain_at_zero_force(self, source: "FiberForceLengthCurve") -> "void":
        return _simulation.FiberForceLengthCurve_copyProperty_strain_at_zero_force(self, source)

    def append_strain_at_zero_force(self, value: "double const &") -> "int":
        return _simulation.FiberForceLengthCurve_append_strain_at_zero_force(self, value)

    def constructProperty_strain_at_zero_force(self, initValue: "double const &") -> "void":
        return _simulation.FiberForceLengthCurve_constructProperty_strain_at_zero_force(self, initValue)

    def get_strain_at_zero_force(self, *args) -> "double const &":
        return _simulation.FiberForceLengthCurve_get_strain_at_zero_force(self, *args)

    def upd_strain_at_zero_force(self, *args) -> "double &":
        return _simulation.FiberForceLengthCurve_upd_strain_at_zero_force(self, *args)

    def set_strain_at_zero_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_set_strain_at_zero_force(self, *args)

    def copyProperty_strain_at_one_norm_force(self, source: "FiberForceLengthCurve") -> "void":
        return _simulation.FiberForceLengthCurve_copyProperty_strain_at_one_norm_force(self, source)

    def append_strain_at_one_norm_force(self, value: "double const &") -> "int":
        return _simulation.FiberForceLengthCurve_append_strain_at_one_norm_force(self, value)

    def constructProperty_strain_at_one_norm_force(self, initValue: "double const &") -> "void":
        return _simulation.FiberForceLengthCurve_constructProperty_strain_at_one_norm_force(self, initValue)

    def get_strain_at_one_norm_force(self, *args) -> "double const &":
        return _simulation.FiberForceLengthCurve_get_strain_at_one_norm_force(self, *args)

    def upd_strain_at_one_norm_force(self, *args) -> "double &":
        return _simulation.FiberForceLengthCurve_upd_strain_at_one_norm_force(self, *args)

    def set_strain_at_one_norm_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_set_strain_at_one_norm_force(self, *args)

    def copyProperty_stiffness_at_low_force(self, source: "FiberForceLengthCurve") -> "void":
        return _simulation.FiberForceLengthCurve_copyProperty_stiffness_at_low_force(self, source)

    def append_stiffness_at_low_force(self, value: "double const &") -> "int":
        return _simulation.FiberForceLengthCurve_append_stiffness_at_low_force(self, value)

    def constructProperty_stiffness_at_low_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_constructProperty_stiffness_at_low_force(self, *args)

    def get_stiffness_at_low_force(self, *args) -> "double const &":
        return _simulation.FiberForceLengthCurve_get_stiffness_at_low_force(self, *args)

    def upd_stiffness_at_low_force(self, *args) -> "double &":
        return _simulation.FiberForceLengthCurve_upd_stiffness_at_low_force(self, *args)

    def set_stiffness_at_low_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_set_stiffness_at_low_force(self, *args)

    def copyProperty_stiffness_at_one_norm_force(self, source: "FiberForceLengthCurve") -> "void":
        return _simulation.FiberForceLengthCurve_copyProperty_stiffness_at_one_norm_force(self, source)

    def append_stiffness_at_one_norm_force(self, value: "double const &") -> "int":
        return _simulation.FiberForceLengthCurve_append_stiffness_at_one_norm_force(self, value)

    def constructProperty_stiffness_at_one_norm_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_constructProperty_stiffness_at_one_norm_force(self, *args)

    def get_stiffness_at_one_norm_force(self, *args) -> "double const &":
        return _simulation.FiberForceLengthCurve_get_stiffness_at_one_norm_force(self, *args)

    def upd_stiffness_at_one_norm_force(self, *args) -> "double &":
        return _simulation.FiberForceLengthCurve_upd_stiffness_at_one_norm_force(self, *args)

    def set_stiffness_at_one_norm_force(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_set_stiffness_at_one_norm_force(self, *args)

    def copyProperty_curviness(self, source: "FiberForceLengthCurve") -> "void":
        return _simulation.FiberForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value: "double const &") -> "int":
        return _simulation.FiberForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args) -> "double const &":
        return _simulation.FiberForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args) -> "double &":
        return _simulation.FiberForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args) -> "void":
        return _simulation.FiberForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a fiber-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a fiber-force-length curve using the provided parameters and
           assigns a default name. See class documentation for the meaning of these
           parameters, each of which corresponds to a property.
        """
        _simulation.FiberForceLengthCurve_swiginit(self, _simulation.new_FiberForceLengthCurve(*args))

    def getStrainAtZeroForce(self) -> "double":
        r"""
        :rtype: float
        :return: The fiber strain at which the fiber starts to develop force.
               strainAtZeroForce = 0.0 means that the fiber will begin developing tension
               when it is at its resting length. This property is set to 0 by default.
        """
        return _simulation.FiberForceLengthCurve_getStrainAtZeroForce(self)

    def getStrainAtOneNormForce(self) -> "double":
        r"""
        :rtype: float
        :return: The fiber strain at which the fiber develops 1 unit of
               normalized force. strainAtOneNormForce = 0.6 means that the fiber will
               develop a tension of 1 normalized force when it is strained by 60% of its
               resting length or, equivalently, when it is stretched to 1.6 times its
               resting length. This property is set to 0.6 by default.
        """
        return _simulation.FiberForceLengthCurve_getStrainAtOneNormForce(self)

    def getStiffnessAtLowForceInUse(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the curve) when the fiber is
               just beginning to develop tensile force. This property is set to 0.125 by
               default.
        """
        return _simulation.FiberForceLengthCurve_getStiffnessAtLowForceInUse(self)

    def getStiffnessAtOneNormForceInUse(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the curve) when the fiber
               develops a tension of 1 normalized unit of force. This property is set to
               5.0 by default.
        """
        return _simulation.FiberForceLengthCurve_getStiffnessAtOneNormForceInUse(self)

    def getCurvinessInUse(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the curve: a value of 0 indicates a curve that is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly fills
               the corner formed by the linear extrapolation of 'stiffnessAtOneNormForce'
               and the x-axis, as shown in the figure in the class description. This
               property is set to 0.75 by default.
        """
        return _simulation.FiberForceLengthCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self) -> "bool":
        r"""
        :rtype: boolean
        :return: True if the optional properties are empty and the fitted curve
               is being used, false if the optional properties are filled and are being
               used to construct the curve.
        """
        return _simulation.FiberForceLengthCurve_isFittedCurveBeingUsed(self)

    def setCurveStrains(self, aStrainAtZeroForce: "double", aStrainAtOneNormForce: "double") -> "void":
        r"""
        :type aStrainAtZeroForce: float
        :param aStrainAtZeroForce:
                The fiber strain at which the fiber starts to develop force.
                strainAtZeroForce = 0.0 means that the fiber will begin developing
                tension when it is at its resting length.
        :type aStrainAtOneNormForce: float
        :param aStrainAtOneNormForce:
                The fiber strain at which the fiber develops 1 unit of normalized force.
                strainAtOneNormForce = 0.6 means that the fiber will develop a tension
                of 1 normalized force when it is strained by 60% of its resting length
                or, equivalently, when it is stretched to 1.6 times its resting length.

        **Conditions**
            strainAtZeroForce < strainAtOneNormForce
        """
        return _simulation.FiberForceLengthCurve_setCurveStrains(self, aStrainAtZeroForce, aStrainAtOneNormForce)

    def setOptionalProperties(self, stiffnessAtLowForce: "double", stiffnessAtOneNormForce: "double", curviness: "double") -> "void":
        r"""
        :type stiffnessAtLowForce: float
        :param stiffnessAtLowForce:
                The normalized stiffness (slope of the curve) when the fiber is just
                beginning to develop tensile force.
        :type stiffnessAtOneNormForce: float
        :param stiffnessAtOneNormForce:
                The normalized stiffness (slope of the curve) when the fiber develops a
                tension of 1 normalized unit of force.
        :type curviness: float
        :param curviness:
                A dimensionless parameter between 0 and 1 that controls the shape of the
                curve: a value of 0 will create a curve that is very close to a straight
                line segment and a value of 1 will create a curve that smoothly fills
                the corner formed by the linear extrapolation of
                'stiffnessAtOneNormForce' and the x-axis, as shown in the figure in the
                class description.

        **Conditions**
            stiffnessAtOneNormForce > 1/(strainAtOneNormForce-strainAtZeroForce)
        0 < stiffnessAtLowForce < stiffnessAtOneNormForce
        0 <= curviness <= 1
        """
        return _simulation.FiberForceLengthCurve_setOptionalProperties(self, stiffnessAtLowForce, stiffnessAtOneNormForce, curviness)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the fiber-force-length curve at a normalized fiber length of
           'normFiberLength'.
        """
        return _simulation.FiberForceLengthCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculates the derivative of the fiber-force-length multiplier with
           respect to the normalized fiber length.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the fiber-force-length curve with respect to the
                   normalized fiber length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.FiberForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, normFiberLength: "double") -> "double":
        r"""
        Calculates the normalized area under the curve. Since it is expensive to
           construct, the curve is built only when necessary.
           :type normFiberLength: float
           :param normFiberLength:
                   The normalized length of the muscle fiber.
           :rtype: float
           :return: The normalized area under the curve, which corresponds to the
                   normalized potential energy stored in the fiber. To calculate the
                   potential energy stored in the fiber in units of Joules, multiply the
                   returned quantity by normForce*normLength (where normForce is the number
                   of Newtons represented by a normalized force of 1.0 and normLength is
                   the number of meters represented by a normalized length of 1.0).
        """
        return _simulation.FiberForceLengthCurve_calcIntegral(self, normFiberLength)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.FiberForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_FiberForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the zero-force region, through the curve, out to
           strains beyond which the fiber generates passive normalized forces greater
           than 1. The curve is sampled quite densely: the fiber-force-length .csv file
           will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_FiberForceLengthCurve.csv', 1, 0);
        """
        return _simulation.FiberForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.FiberForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_FiberForceLengthCurve

# Register FiberForceLengthCurve in _simulation:
_simulation.FiberForceLengthCurve_swigregister(FiberForceLengthCurve)

def FiberForceLengthCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FiberForceLengthCurve *":
    return _simulation.FiberForceLengthCurve_safeDownCast(obj)

def FiberForceLengthCurve_getClassName() -> "std::string const &":
    return _simulation.FiberForceLengthCurve_getClassName()

class ForceVelocityCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ForceVelocityCurve for use in muscle
       models. The force-velocity curve is dimensionless: force is normalized to
       maximum isometric force and velocity is normalized to the maximum muscle
       contraction velocity (vmax), where vmax is expressed in units of
       optimal_fiber_lengths per second. Negative normalized velocities correspond
       to concentric contraction (i.e., shortening). The force-velocity curve is
       constructed from 8 properties:

       :param concentricSlopeAtVmax:
               The slope of the force-velocity curve at a normalized velocity of -1,
               which is the minimum slope of the concentric side of the force-velocity
               curve. A physiologically accurate value for this parameter is 0, though
               values greater than 0 are necessary when the force-velocity curve must
               be inverted.
       :param concentricSlopeNearVmax:
               The slope of the force-velocity curve near the maximum normalized
               concentric (shortening) contraction velocity (between approximately -0.8
               and -1).
       :param isometricSlope:
               The slope of the force-velocity curve at a normalized velocity of 0,
               which is the maximum slope of the force-velocity curve. A
               physiologically accurate value for this parameter is 5 (according to
               Lieber, page 55), which is the default value. Although this parameter
               can be changed, it must be positive and greater than
               max( (maxEccentricMultiplier-1)/1, 1). The value of this parameter also
               affects how much the eccentric and concentric curves can be bent by the
               'eccentricCurviness' and 'concentricCurviness' parameters, as it places
               an upper limit on the maximum slope of the force-velocity curve.
       :param eccentricSlopeAtVmax:
               The slope of the force-velocity curve at a normalized velocity of 1,
               which is the minimum slope of the eccentric side of the force-velocity
               curve.
       :param eccentricSlopeNearVmax:
               The slope of the force-velocity curve near the maximum normalized
               eccentric (lengthening) contraction velocity (between approximately 0.8
               and 1).
       :param maxEccentricVelocityForceMultiplier:
               The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
               Physiologically accurate values for this parameter range between 1.1
               and 1.8, and may vary between subjects.
       :param concentricCurviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the concentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure.
       :param eccentricCurviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the eccentric curve: a value of 0 indicates that the curve is very close
               to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure.

       Image: fig_ForceVelocityCurve.png

       **Conditions**
            1)  0 <= concentricSlopeAtVmax < 1
       2a)  1 < isometricSlope
       2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3)  0 <= eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        4)  1 < maxEccentricVelocityForceMultiplier
        5)  0 <= concentricCurviness <= 1
        6)  0 <= eccentricCurviness <= 1

       **Default Parameter Values**
           concentricSlopeAtVmax .................. 0.0
       concentricSlopeNearVmax ................ 0.25
       isometricSlope ......................... 5.0
       eccentricSlopeAtVmax ................... 0.0
       eccentricSlopeNearVmax ................. 0.15
       maxEccentricVelocityForceMultiplier .... 1.4
       concentricCurviness .................... 0.6
       eccentricCurviness ..................... 0.9

       **Example**

       .. code-block:: c++

               ForceVelocityCurve fvCurve(0.0, 0.25, 5.0, 0.0, 0.15, 1.4, 0.6, 0.9);
               double falVal  = fvCurve.calcValue(1.0);
               double dfalVal = fvCurve.calcDerivative(1.0, 1);

       **References**
       * Lieber, R.L. (2010) Skeletal %Muscle Structure, %Function, and
           Plasticity: The Physiological Basis of Rehabilitation, 3rd ed.
           Baltimore: Lippincott Williams & Wilkins.

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceVelocityCurve *":
        return _simulation.ForceVelocityCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ForceVelocityCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ForceVelocityCurve_getClassName()

    def clone(self) -> "OpenSim::ForceVelocityCurve *":
        return _simulation.ForceVelocityCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ForceVelocityCurve_getConcreteClassName(self)

    def copyProperty_concentric_slope_at_vmax(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_concentric_slope_at_vmax(self, source)

    def append_concentric_slope_at_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_concentric_slope_at_vmax(self, value)

    def constructProperty_concentric_slope_at_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_concentric_slope_at_vmax(self, initValue)

    def get_concentric_slope_at_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_concentric_slope_at_vmax(self, *args)

    def upd_concentric_slope_at_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_concentric_slope_at_vmax(self, *args)

    def set_concentric_slope_at_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_concentric_slope_at_vmax(self, *args)

    def copyProperty_concentric_slope_near_vmax(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_concentric_slope_near_vmax(self, source)

    def append_concentric_slope_near_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_concentric_slope_near_vmax(self, value)

    def constructProperty_concentric_slope_near_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_concentric_slope_near_vmax(self, initValue)

    def get_concentric_slope_near_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_concentric_slope_near_vmax(self, *args)

    def upd_concentric_slope_near_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_concentric_slope_near_vmax(self, *args)

    def set_concentric_slope_near_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_concentric_slope_near_vmax(self, *args)

    def copyProperty_isometric_slope(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_isometric_slope(self, source)

    def append_isometric_slope(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_isometric_slope(self, value)

    def constructProperty_isometric_slope(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_isometric_slope(self, initValue)

    def get_isometric_slope(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_isometric_slope(self, *args)

    def upd_isometric_slope(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_isometric_slope(self, *args)

    def set_isometric_slope(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_isometric_slope(self, *args)

    def copyProperty_eccentric_slope_at_vmax(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_slope_at_vmax(self, source)

    def append_eccentric_slope_at_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_eccentric_slope_at_vmax(self, value)

    def constructProperty_eccentric_slope_at_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_slope_at_vmax(self, initValue)

    def get_eccentric_slope_at_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_eccentric_slope_at_vmax(self, *args)

    def upd_eccentric_slope_at_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_eccentric_slope_at_vmax(self, *args)

    def set_eccentric_slope_at_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_eccentric_slope_at_vmax(self, *args)

    def copyProperty_eccentric_slope_near_vmax(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_slope_near_vmax(self, source)

    def append_eccentric_slope_near_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_eccentric_slope_near_vmax(self, value)

    def constructProperty_eccentric_slope_near_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_slope_near_vmax(self, initValue)

    def get_eccentric_slope_near_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_eccentric_slope_near_vmax(self, *args)

    def upd_eccentric_slope_near_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_eccentric_slope_near_vmax(self, *args)

    def set_eccentric_slope_near_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_eccentric_slope_near_vmax(self, *args)

    def copyProperty_max_eccentric_velocity_force_multiplier(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_max_eccentric_velocity_force_multiplier(self, source)

    def append_max_eccentric_velocity_force_multiplier(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_max_eccentric_velocity_force_multiplier(self, value)

    def constructProperty_max_eccentric_velocity_force_multiplier(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_max_eccentric_velocity_force_multiplier(self, initValue)

    def get_max_eccentric_velocity_force_multiplier(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_max_eccentric_velocity_force_multiplier(self, *args)

    def upd_max_eccentric_velocity_force_multiplier(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_max_eccentric_velocity_force_multiplier(self, *args)

    def set_max_eccentric_velocity_force_multiplier(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_max_eccentric_velocity_force_multiplier(self, *args)

    def copyProperty_concentric_curviness(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_concentric_curviness(self, source)

    def append_concentric_curviness(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_concentric_curviness(self, value)

    def constructProperty_concentric_curviness(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_concentric_curviness(self, initValue)

    def get_concentric_curviness(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_concentric_curviness(self, *args)

    def upd_concentric_curviness(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_concentric_curviness(self, *args)

    def set_concentric_curviness(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_concentric_curviness(self, *args)

    def copyProperty_eccentric_curviness(self, source: "ForceVelocityCurve") -> "void":
        return _simulation.ForceVelocityCurve_copyProperty_eccentric_curviness(self, source)

    def append_eccentric_curviness(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityCurve_append_eccentric_curviness(self, value)

    def constructProperty_eccentric_curviness(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityCurve_constructProperty_eccentric_curviness(self, initValue)

    def get_eccentric_curviness(self, *args) -> "double const &":
        return _simulation.ForceVelocityCurve_get_eccentric_curviness(self, *args)

    def upd_eccentric_curviness(self, *args) -> "double &":
        return _simulation.ForceVelocityCurve_upd_eccentric_curviness(self, *args)

    def set_eccentric_curviness(self, *args) -> "void":
        return _simulation.ForceVelocityCurve_set_eccentric_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a force-velocity curve using the default
           property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a force-velocity curve using the provided parameters and
           assigns a default name.
        """
        _simulation.ForceVelocityCurve_swiginit(self, _simulation.new_ForceVelocityCurve(*args))

    def getConcentricSlopeAtVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of -1, which is the minimum slope of the concentric side of the
               force-velocity curve.
        """
        return _simulation.ForceVelocityCurve_getConcentricSlopeAtVmax(self)

    def getConcentricSlopeNearVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized concentric (shortening) contraction velocity (between
               approximately -0.8 and -1).
        """
        return _simulation.ForceVelocityCurve_getConcentricSlopeNearVmax(self)

    def getIsometricSlope(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 0, which is the maximum slope of the force-velocity curve.
        """
        return _simulation.ForceVelocityCurve_getIsometricSlope(self)

    def getEccentricSlopeAtVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 1, which is the minimum slope of the eccentric side of the force-velocity
               curve.
        """
        return _simulation.ForceVelocityCurve_getEccentricSlopeAtVmax(self)

    def getEccentricSlopeNearVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized eccentric (lengthening) contraction velocity (between
               approximately 0.8 and 1).
        """
        return _simulation.ForceVelocityCurve_getEccentricSlopeNearVmax(self)

    def getMaxEccentricVelocityForceMultiplier(self) -> "double":
        r"""
        :rtype: float
        :return: The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
        """
        return _simulation.ForceVelocityCurve_getMaxEccentricVelocityForceMultiplier(self)

    def getConcentricCurviness(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the concentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure in
               the class description.
        """
        return _simulation.ForceVelocityCurve_getConcentricCurviness(self)

    def getEccentricCurviness(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the eccentric curve: a value of 0 indicates that the curve is very
               close to a straight line segment and a value of 1 indicates a curve that
               smoothly fills the corner formed by the linear extrapolation of
               'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure in the
               class description.
        """
        return _simulation.ForceVelocityCurve_getEccentricCurviness(self)

    def setCurveShape(self, aConcentricSlopeAtVmax: "double", aConcentricSlopeNearVmax: "double", aIsometricSlope: "double", aEccentricSlopeAtVmax: "double", aEccentricSlopeNearVmax: "double", aMaxForceMultiplier: "double") -> "void":
        r"""
        :type aConcentricSlopeAtVmax: float
        :param aConcentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of -1,
                which is the minimum slope of the concentric side of the force-velocity
                curve.
        :type aConcentricSlopeNearVmax: float
        :param aConcentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                concentric (shortening) contraction velocity (between approximately
                -0.8 and -1).
        :type aIsometricSlope: float
        :param aIsometricSlope:
                The slope of the force-velocity curve at a normalized velocity of 0,
                which is the maximum slope of the force-velocity curve.
        :type aEccentricSlopeAtVmax: float
        :param aEccentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of 1,
                which is the minimum slope of the eccentric side of the force-velocity
                curve.
        :type aEccentricSlopeNearVmax: float
        :param aEccentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                eccentric (lengthening) contraction velocity (between approximately 0.8
                and 1).
        :type aMaxForceMultiplier: float
        :param aMaxForceMultiplier:
                The value of the force-velocity curve (i.e., the force-velocity
                multiplier) at the maximum eccentric contraction velocity.

        **Conditions**
            1a)  0 <= concentricSlopeAtVmax < 1
        1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
        2a)  1 < isometricSlope
        2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3a)  0 <= eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        3b)  eccentricSlopeAtVmax < eccentricSlopeNearVmax < (maxEccentricVelocityForceMultiplier-1)/1
         4)  1 < maxEccentricVelocityForceMultiplier
        """
        return _simulation.ForceVelocityCurve_setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier)

    def setConcentricCurviness(self, aConcentricCurviness: "double") -> "void":
        r"""
        :type aConcentricCurviness: float
        :param aConcentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the concentric curve: a value of 0 indicates that the curve is very
                close to a straight line segment and a value of 1 indicates a curve that
                smoothly fills the corner formed by the linear extrapolation of
                'concentricSlopeNearVmax' and 'isometricSlope', as shown in the figure
                in the class description.

        **Conditions**
            0 <= concentricCurviness <= 1
        """
        return _simulation.ForceVelocityCurve_setConcentricCurviness(self, aConcentricCurviness)

    def setEccentricCurviness(self, aEccentricCurviness: "double") -> "void":
        r"""
        :type aEccentricCurviness: float
        :param aEccentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the eccentric curve: a value of 0 indicates that the curve is very close
                to a straight line segment and a value of 1 indicates a curve that
                smoothly fills the corner formed by the linear extrapolation of
                'isometricSlope' and 'eccentricSlopeNearVmax', as shown in the figure in
                the class description.

        **Conditions**
            0 <= eccentricCurviness <= 1
        """
        return _simulation.ForceVelocityCurve_setEccentricCurviness(self, aEccentricCurviness)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the force-velocity curve at a normalized fiber velocity of
           'normFiberVelocity'.
        """
        return _simulation.ForceVelocityCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculates the derivative of the force-velocity multiplier with respect
           to the normalized fiber velocity.
           :type normFiberVelocity: float
           :param normFiberVelocity:
                   The normalized velocity of the muscle fiber.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the force-velocity curve with respect to the
                   normalized fiber velocity.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ForceVelocityCurve_calcDerivative(self, *args)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ForceVelocityCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ForceVelocityCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the concentric linear extrapolation region (the
           region with normalized fiber velocities < -1), through the curve, out to the
           eccentric linear extrapolation region (the region with normalized fiber
           velocities > 1). The width of each linear extrapolation region is 10% of the
           curve domain, or 0.1*(x1-x0). The curve is sampled quite densely: the
           force-velocity .csv file will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ForceVelocityCurve.csv', 1, 0);
        """
        return _simulation.ForceVelocityCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.ForceVelocityCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ForceVelocityCurve

# Register ForceVelocityCurve in _simulation:
_simulation.ForceVelocityCurve_swigregister(ForceVelocityCurve)

def ForceVelocityCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceVelocityCurve *":
    return _simulation.ForceVelocityCurve_safeDownCast(obj)

def ForceVelocityCurve_getClassName() -> "std::string const &":
    return _simulation.ForceVelocityCurve_getClassName()

class ForceVelocityInverseCurve(opensim.common.Function):
    r"""
    This class serves as a serializable ForceVelocityInverseCurve for use in
       equilibrium muscle models. The inverse force-velocity curve is
       dimensionless: force is normalized to maximum isometric force and velocity
       is normalized to the maximum muscle contraction velocity (vmax), where vmax
       is expressed in units of optimal_fiber_lengths per second. Negative
       normalized velocities correspond to concentric contraction (i.e.,
       shortening). The inverse force-velocity curve is constructed from 8
       properties, which are identical to those used to construct the
       corresponding force-velocity curve. See ForceVelocityCurve for descriptions
       of these parameters.

       :param concentricSlopeAtVmax:
               An exception will be thrown if this parameter is set to 0.
       :param concentricSlopeNearVmax:
               An exception will be thrown if this parameter is set to 0.
       :param isometricSlope:
       :param eccentricSlopeAtVmax:
               An exception will be thrown if this parameter is set to 0.
       :param eccentricSlopeNearVmax:
               An exception will be thrown if this parameter is set to 0.
       :param maxEccentricVelocityForceMultiplier:
       :param concentricCurviness:
       :param eccentricCurviness:

       Image: fig_ForceVelocityInverseCurve.png


       Image: fig_ForceVelocityCurve.png

       **Conditions**
           1a)  0 < concentricSlopeAtVmax < 1
       1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
       2a)  1 < isometricSlope
       2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricSlope
        3)  0 < eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        4)  1 < maxEccentricVelocityForceMultiplier
        5)  0 <= concentricCurviness <= 1
        6)  0 <= eccentricCurviness <= 1

       **Default Parameter Values**
           concentricSlopeAtVmax .................. 0.1
       concentricSlopeNearVmax ................ 0.25
       isometricSlope ......................... 5.0
       eccentricSlopeAtVmax ................... 0.1
       eccentricSlopeNearVmax ................. 0.15
       maxEccentricVelocityForceMultiplier .... 1.4
       concentricCurviness .................... 0.6
       eccentricCurviness ..................... 0.9

       **Example**

       .. code-block:: c++

               ForceVelocityInverseCurve fvInvCurve(0.1, 0.25, 5.0, 0.1, 0.15, 1.4, 0.6, 0.9);
               double fvInvVal  = fvInvCurve.calcValue(1.0);
               double dfvInvVal = fvInvCurve.calcDerivative(1.0, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceVelocityInverseCurve *":
        return _simulation.ForceVelocityInverseCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.ForceVelocityInverseCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.ForceVelocityInverseCurve_getClassName()

    def clone(self) -> "OpenSim::ForceVelocityInverseCurve *":
        return _simulation.ForceVelocityInverseCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.ForceVelocityInverseCurve_getConcreteClassName(self)

    def copyProperty_concentric_slope_at_vmax(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_slope_at_vmax(self, source)

    def append_concentric_slope_at_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_concentric_slope_at_vmax(self, value)

    def constructProperty_concentric_slope_at_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_slope_at_vmax(self, initValue)

    def get_concentric_slope_at_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_concentric_slope_at_vmax(self, *args)

    def upd_concentric_slope_at_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_concentric_slope_at_vmax(self, *args)

    def set_concentric_slope_at_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_concentric_slope_at_vmax(self, *args)

    def copyProperty_concentric_slope_near_vmax(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_slope_near_vmax(self, source)

    def append_concentric_slope_near_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_concentric_slope_near_vmax(self, value)

    def constructProperty_concentric_slope_near_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_slope_near_vmax(self, initValue)

    def get_concentric_slope_near_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_concentric_slope_near_vmax(self, *args)

    def upd_concentric_slope_near_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_concentric_slope_near_vmax(self, *args)

    def set_concentric_slope_near_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_concentric_slope_near_vmax(self, *args)

    def copyProperty_isometric_slope(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_isometric_slope(self, source)

    def append_isometric_slope(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_isometric_slope(self, value)

    def constructProperty_isometric_slope(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_isometric_slope(self, initValue)

    def get_isometric_slope(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_isometric_slope(self, *args)

    def upd_isometric_slope(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_isometric_slope(self, *args)

    def set_isometric_slope(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_isometric_slope(self, *args)

    def copyProperty_eccentric_slope_at_vmax(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_slope_at_vmax(self, source)

    def append_eccentric_slope_at_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_eccentric_slope_at_vmax(self, value)

    def constructProperty_eccentric_slope_at_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_slope_at_vmax(self, initValue)

    def get_eccentric_slope_at_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_eccentric_slope_at_vmax(self, *args)

    def upd_eccentric_slope_at_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_slope_at_vmax(self, *args)

    def set_eccentric_slope_at_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_eccentric_slope_at_vmax(self, *args)

    def copyProperty_eccentric_slope_near_vmax(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_slope_near_vmax(self, source)

    def append_eccentric_slope_near_vmax(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_eccentric_slope_near_vmax(self, value)

    def constructProperty_eccentric_slope_near_vmax(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_slope_near_vmax(self, initValue)

    def get_eccentric_slope_near_vmax(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_eccentric_slope_near_vmax(self, *args)

    def upd_eccentric_slope_near_vmax(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_slope_near_vmax(self, *args)

    def set_eccentric_slope_near_vmax(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_eccentric_slope_near_vmax(self, *args)

    def copyProperty_max_eccentric_velocity_force_multiplier(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_max_eccentric_velocity_force_multiplier(self, source)

    def append_max_eccentric_velocity_force_multiplier(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_max_eccentric_velocity_force_multiplier(self, value)

    def constructProperty_max_eccentric_velocity_force_multiplier(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_max_eccentric_velocity_force_multiplier(self, initValue)

    def get_max_eccentric_velocity_force_multiplier(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_max_eccentric_velocity_force_multiplier(self, *args)

    def upd_max_eccentric_velocity_force_multiplier(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_max_eccentric_velocity_force_multiplier(self, *args)

    def set_max_eccentric_velocity_force_multiplier(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_max_eccentric_velocity_force_multiplier(self, *args)

    def copyProperty_concentric_curviness(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_concentric_curviness(self, source)

    def append_concentric_curviness(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_concentric_curviness(self, value)

    def constructProperty_concentric_curviness(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_concentric_curviness(self, initValue)

    def get_concentric_curviness(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_concentric_curviness(self, *args)

    def upd_concentric_curviness(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_concentric_curviness(self, *args)

    def set_concentric_curviness(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_concentric_curviness(self, *args)

    def copyProperty_eccentric_curviness(self, source: "ForceVelocityInverseCurve") -> "void":
        return _simulation.ForceVelocityInverseCurve_copyProperty_eccentric_curviness(self, source)

    def append_eccentric_curviness(self, value: "double const &") -> "int":
        return _simulation.ForceVelocityInverseCurve_append_eccentric_curviness(self, value)

    def constructProperty_eccentric_curviness(self, initValue: "double const &") -> "void":
        return _simulation.ForceVelocityInverseCurve_constructProperty_eccentric_curviness(self, initValue)

    def get_eccentric_curviness(self, *args) -> "double const &":
        return _simulation.ForceVelocityInverseCurve_get_eccentric_curviness(self, *args)

    def upd_eccentric_curviness(self, *args) -> "double &":
        return _simulation.ForceVelocityInverseCurve_upd_eccentric_curviness(self, *args)

    def set_eccentric_curviness(self, *args) -> "void":
        return _simulation.ForceVelocityInverseCurve_set_eccentric_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an inverse force-velocity curve using
           the default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs an inverse force-velocity curve using the provided parameters
           and assigns a default name.
        """
        _simulation.ForceVelocityInverseCurve_swiginit(self, _simulation.new_ForceVelocityInverseCurve(*args))

    def getConcentricSlopeAtVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of -1, which is the minimum slope of the concentric side of the
               force-velocity curve.
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricSlopeAtVmax(self)

    def getConcentricSlopeNearVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized concentric (shortening) contraction velocity (between
               approximately -0.8 and -1).
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricSlopeNearVmax(self)

    def getIsometricSlope(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 0, which is the maximum slope of the force-velocity curve.
        """
        return _simulation.ForceVelocityInverseCurve_getIsometricSlope(self)

    def getEccentricSlopeAtVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve at a normalized velocity
               of 1, which is the minimum slope of the eccentric side of the force-velocity
               curve.
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricSlopeAtVmax(self)

    def getEccentricSlopeNearVmax(self) -> "double":
        r"""
        :rtype: float
        :return: The slope of the force-velocity curve near the maximum
               normalized eccentric (lengthening) contraction velocity (between
               approximately 0.8 and 1).
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricSlopeNearVmax(self)

    def getMaxEccentricVelocityForceMultiplier(self) -> "double":
        r"""
        :rtype: float
        :return: The value of the force-velocity curve (i.e., the force-velocity
               multiplier) at the maximum eccentric contraction velocity.
        """
        return _simulation.ForceVelocityInverseCurve_getMaxEccentricVelocityForceMultiplier(self)

    def getConcentricCurviness(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the concentric branch of the force-velocity curve: a value of 0
               indicates that the curve is very close to a straight line segment and a
               value of 1 indicates a curve that smoothly fills the corner formed by the
               linear extrapolation of 'concentricSlopeNearVmax' and 'isometricSlope', as
               shown in the figure in the class description.
        """
        return _simulation.ForceVelocityInverseCurve_getConcentricCurviness(self)

    def getEccentricCurviness(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the eccentric branch of the force-velocity curve: a value of 0
               indicates that the curve is very close to a straight line segment and a
               value of 1 indicates a curve that smoothly fills the corner formed by the
               linear extrapolation of 'isometricSlope' and 'eccentricSlopeNearVmax', as
               shown in the figure in the class description.
        """
        return _simulation.ForceVelocityInverseCurve_getEccentricCurviness(self)

    def setCurveShape(self, aConcentricSlopeAtVmax: "double", aConcentricSlopeNearVmax: "double", aIsometricSlope: "double", aEccentricSlopeAtVmax: "double", aEccentricSlopeNearVmax: "double", aMaxForceMultiplier: "double") -> "void":
        r"""
        :type aConcentricSlopeAtVmax: float
        :param aConcentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of -1,
                which is the minimum slope of the concentric side of the force-velocity
                curve.
        :type aConcentricSlopeNearVmax: float
        :param aConcentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                concentric (shortening) contraction velocity (between approximately
                -0.8 and -1).
        :type aIsometricSlope: float
        :param aIsometricSlope:
                The slope of the force-velocity curve at a normalized velocity of 0,
                which is the maximum slope of the force-velocity curve.
        :type aEccentricSlopeAtVmax: float
        :param aEccentricSlopeAtVmax:
                The slope of the force-velocity curve at a normalized velocity of 1,
                which is the minimum slope of the eccentric side of the force-velocity
                curve.
        :type aEccentricSlopeNearVmax: float
        :param aEccentricSlopeNearVmax:
                The slope of the force-velocity curve near the maximum normalized
                eccentric (lengthening) contraction velocity (between approximately 0.8
                and 1).
        :type aMaxForceMultiplier: float
        :param aMaxForceMultiplier:
                The value of the force-velocity curve (i.e., the force-velocity
                multiplier) at the maximum eccentric contraction velocity.

        **Conditions**
            1a)  0 < concentricSlopeAtVmax < 1
        1b)  concentricSlopeAtVmax < concentricSlopeNearVmax < 1
        2a)  1 < isometricSlope
        2b)  (maxEccentricVelocityForceMultiplier-1)/1 < isometricMaxSlope
        3a)  0 < eccentricSlopeAtVmax < (maxEccentricVelocityForceMultiplier-1)/1
        3b)  eccentricSlopeAtVmax < eccentricSlopeNearVmax < (maxEccentricVelocityForceMultiplier-1)/1
         4)  1 < maxEccentricVelocityForceMultiplier
        """
        return _simulation.ForceVelocityInverseCurve_setCurveShape(self, aConcentricSlopeAtVmax, aConcentricSlopeNearVmax, aIsometricSlope, aEccentricSlopeAtVmax, aEccentricSlopeNearVmax, aMaxForceMultiplier)

    def setConcentricCurviness(self, aConcentricCurviness: "double") -> "void":
        r"""
        :type aConcentricCurviness: float
        :param aConcentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the concentric branch of the force-velocity curve: a value of 0
                indicates that the curve is very close to a straight line segment and a
                value of 1 indicates a curve that smoothly fills the corner formed by
                the linear extrapolation of 'concentricSlopeNearVmax' and
                'isometricSlope', as shown in the figure in the class description.

        **Conditions**
            0 <= concentricCurviness <= 1
        """
        return _simulation.ForceVelocityInverseCurve_setConcentricCurviness(self, aConcentricCurviness)

    def setEccentricCurviness(self, aEccentricCurviness: "double") -> "void":
        r"""
        :type aEccentricCurviness: float
        :param aEccentricCurviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the eccentric branch of the force-velocity curve: a value of 0 indicates
                that the curve is very close to a straight line segment and a value of 1
                indicates a curve that smoothly fills the corner formed by the linear
                extrapolation of 'isometricSlope' and 'eccentricSlopeNearVmax', as shown
                in the figure in the class description.

        **Conditions**
            0 <= eccentricCurviness <= 1
        """
        return _simulation.ForceVelocityInverseCurve_setEccentricCurviness(self, aEccentricCurviness)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the inverse force-velocity curve at a force-velocity
           multiplier value of 'aForceVelocityMultiplier'.
        """
        return _simulation.ForceVelocityInverseCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculates the derivative of the inverse force-velocity curve with
           respect to the force-velocity multiplier.
           :type aForceVelocityMultiplier: float
           :param aForceVelocityMultiplier:
                   The force-velocity multiplier value.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the inverse force-velocity curve with respect to the
                   force-velocity multiplier.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.ForceVelocityInverseCurve_calcDerivative(self, *args)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.ForceVelocityInverseCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_ForceVelocityInverseCurve.csv"). This function is not const
           to permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the concentric linear extrapolation region (the
           region with normalized fiber velocities < -1), through the curve, out to the
           eccentric linear extrapolation region (the region with normalized fiber
           velocities > 1). The width of each linear extrapolation region is 10% of the
           curve domain, or 0.1*(x1-x0). The curve is sampled quite densely: the
           inverse force-velocity .csv file will have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_ForceVelocityInverseCurve.csv', 1, 0);
        """
        return _simulation.ForceVelocityInverseCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.ForceVelocityInverseCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_ForceVelocityInverseCurve

# Register ForceVelocityInverseCurve in _simulation:
_simulation.ForceVelocityInverseCurve_swigregister(ForceVelocityInverseCurve)

def ForceVelocityInverseCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForceVelocityInverseCurve *":
    return _simulation.ForceVelocityInverseCurve_safeDownCast(obj)

def ForceVelocityInverseCurve_getClassName() -> "std::string const &":
    return _simulation.ForceVelocityInverseCurve_getClassName()

class TendonForceLengthCurve(opensim.common.Function):
    r"""
    This class serves as a serializable TendonForceLengthCurve for use in muscle
       models. The tendon-force-length curve is dimensionless: force is normalized
       to maximum isometric force and length is normalized to tendon slack length.
       The user can adjust the strain the tendon undergoes at 1 unit load (e0), its
       stiffness at a strain of e0, and the shape of the tendon curve (its
       'curviness'):

       :param strainAtOneNormForce:
               The tendon strain at which the tendon develops 1 unit of normalized
               force. strainAtOneNormForce = 0.04 means that the tendon will develop a
               tension of 1 normalized force when it is strained by 4% of its slack
               length or, equivalently, is stretched to 1.04 times its resting length.
       :param stiffnessAtOneNormForce:
               The normalized stiffness (slope of the tendon curve) when the tendon is
               strained by strainAtOneNormForce under a load of 1 normalized unit of
               force.
       :param normForceAtToeEnd:
               The normalized force developed at the end of the 'toe' region. The toe
               region lies between 0 strain and some intermediate strain less than the
               strain required to develop 1 unit of normalized force. The toe region is
               nonlinear and more compliant than the rest of the tendon curve.
       :param curviness:
               A dimensionless parameter between 0 and 1 that describes the shape of
               the curve: a value of 0 indicates that the curve is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly
               fills the corner formed by the linear extrapolation of
               'stiffnessAtOneNormForce' and the x-axis, as shown in the figure.

       Note that we use the Cauchy or engineering definition of strain throughout:
       strain = (l-l0)/l0, where l is the current tendon length and l0 is its slack
       length.

       **Required Parameters**
       * strainAtOneNormForce

       **Optional Parameters**
       * stiffnessAtOneNormForce
       * normForceAtToeEnd
       * curviness

       Image: fig_TendonForceLengthCurve.png

       **Conditions**
           strainAtOneNormForce > 0
       stiffnessAtOneNormForce > 1/strainAtOneNormForce
       0 < normForceAtToeEnd < 1
       0 <= curviness <= 1

       All parameters but the strain of the tendon at 1 unit load (e0) are
       optional. Note that filling in one optional parameter but not the others
       will throw an exception when the curve is built. The optional parameters can
       be used to vary the shape of the curve from a close approximation of a line
       to a sharply-bent curve.

       This curve has the advantage of being C2-continuous, which results in faster
       simulations when compared to the popular method of using a linearly
       extrapolated exponential (C0-continuous) curve to parameterize the
       tendon-force-length relationship. See Millard et al. (2013) for details.

       **Default Parameter Values**
       If the optional parameters are not specified, the curve is fit to match the
       average dimensionless in-vivo tendon curve reported by Maganaris et al. and
       Magnusson et al. In addition, the generated curve will have a characteristic
       toe region that is fit to the in-vivo literature. Note that this curve is
       not being fit to the commonly used linearly extrapolated exponential curve
       documented by Thelen, as it makes the toe region about half as stiff as both
       the in-vitro and in-vivo data indicate is reasonable. Additionally, the
       linear section of the curve would be nearly twice as stiff as the data
       indicates is reasonable.

           strainAtOneNormForce ....... 0.049
       stiffnessAtOneNormForce .... 1.375/strainAtOneNormForce
       normForceAtToeEnd .......... 2.0/3.0
       curviness .................. 0.5

       **Example**

       .. code-block:: c++

               TendonForceLengthCurve fseCurve(0.049, 28.1, 0.67, 0.5);
               double fseVal   = fseCurve.calcValue(0.02);
               double dfselVal = fseCurve.calcDerivative(0.02, 1);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the curve correctly. If you
       modify the properties directly, the curve will not be rebuilt, and upon
       calling a function like calcValue, calcDerivative, or printCurveToCSVFile,
       an exception will be thrown because the curve is out-of-date with its
       properties.

       **References**
       * Lewis, G., Shaw, K.M. (1997) Tensile properties of human tendo Achillis:
           effect of donor age and strain rate. The Journal of Foot and Ankle
           Surgery 36:435--445.
       * Maganaris, C.N., Paul, J.P. (2002) Tensile properties of the in vivo
           gastrocnemius tendon. Journal of Biomechanics 35:1639--1646.
       * Magnusson, S.P., Aagaard, P., Rosager, S., Dyhre-Poulsen, P., Kjaer, M.
           (2001) Load-displacement properties of the human triceps surae
           aponeurosis in vivo. Journal of Physiology 531:277--288.
       * Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
           simulate dynamic contractions in older adults. ASME Journal of
           Biomechanical Engineering 125:70--77.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TendonForceLengthCurve *":
        return _simulation.TendonForceLengthCurve_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.TendonForceLengthCurve_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.TendonForceLengthCurve_getClassName()

    def clone(self) -> "OpenSim::TendonForceLengthCurve *":
        return _simulation.TendonForceLengthCurve_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.TendonForceLengthCurve_getConcreteClassName(self)

    def copyProperty_strain_at_one_norm_force(self, source: "TendonForceLengthCurve") -> "void":
        return _simulation.TendonForceLengthCurve_copyProperty_strain_at_one_norm_force(self, source)

    def append_strain_at_one_norm_force(self, value: "double const &") -> "int":
        return _simulation.TendonForceLengthCurve_append_strain_at_one_norm_force(self, value)

    def constructProperty_strain_at_one_norm_force(self, initValue: "double const &") -> "void":
        return _simulation.TendonForceLengthCurve_constructProperty_strain_at_one_norm_force(self, initValue)

    def get_strain_at_one_norm_force(self, *args) -> "double const &":
        return _simulation.TendonForceLengthCurve_get_strain_at_one_norm_force(self, *args)

    def upd_strain_at_one_norm_force(self, *args) -> "double &":
        return _simulation.TendonForceLengthCurve_upd_strain_at_one_norm_force(self, *args)

    def set_strain_at_one_norm_force(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_set_strain_at_one_norm_force(self, *args)

    def copyProperty_stiffness_at_one_norm_force(self, source: "TendonForceLengthCurve") -> "void":
        return _simulation.TendonForceLengthCurve_copyProperty_stiffness_at_one_norm_force(self, source)

    def append_stiffness_at_one_norm_force(self, value: "double const &") -> "int":
        return _simulation.TendonForceLengthCurve_append_stiffness_at_one_norm_force(self, value)

    def constructProperty_stiffness_at_one_norm_force(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_constructProperty_stiffness_at_one_norm_force(self, *args)

    def get_stiffness_at_one_norm_force(self, *args) -> "double const &":
        return _simulation.TendonForceLengthCurve_get_stiffness_at_one_norm_force(self, *args)

    def upd_stiffness_at_one_norm_force(self, *args) -> "double &":
        return _simulation.TendonForceLengthCurve_upd_stiffness_at_one_norm_force(self, *args)

    def set_stiffness_at_one_norm_force(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_set_stiffness_at_one_norm_force(self, *args)

    def copyProperty_norm_force_at_toe_end(self, source: "TendonForceLengthCurve") -> "void":
        return _simulation.TendonForceLengthCurve_copyProperty_norm_force_at_toe_end(self, source)

    def append_norm_force_at_toe_end(self, value: "double const &") -> "int":
        return _simulation.TendonForceLengthCurve_append_norm_force_at_toe_end(self, value)

    def constructProperty_norm_force_at_toe_end(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_constructProperty_norm_force_at_toe_end(self, *args)

    def get_norm_force_at_toe_end(self, *args) -> "double const &":
        return _simulation.TendonForceLengthCurve_get_norm_force_at_toe_end(self, *args)

    def upd_norm_force_at_toe_end(self, *args) -> "double &":
        return _simulation.TendonForceLengthCurve_upd_norm_force_at_toe_end(self, *args)

    def set_norm_force_at_toe_end(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_set_norm_force_at_toe_end(self, *args)

    def copyProperty_curviness(self, source: "TendonForceLengthCurve") -> "void":
        return _simulation.TendonForceLengthCurve_copyProperty_curviness(self, source)

    def append_curviness(self, value: "double const &") -> "int":
        return _simulation.TendonForceLengthCurve_append_curviness(self, value)

    def constructProperty_curviness(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_constructProperty_curviness(self, *args)

    def get_curviness(self, *args) -> "double const &":
        return _simulation.TendonForceLengthCurve_get_curviness(self, *args)

    def upd_curviness(self, *args) -> "double &":
        return _simulation.TendonForceLengthCurve_upd_curviness(self, *args)

    def set_curviness(self, *args) -> "void":
        return _simulation.TendonForceLengthCurve_set_curviness(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a tendon-force-length curve using the
           default property values and assigns a default name.

        |

        *Overload 2:*
        Constructs a tendon-force-length curve using the provided parameters and
           assigns a default name.

        |

        *Overload 3:*
        This constructor will create a C2-continuous tendon-force-length curve
           that is fit to match the average dimensionless in-vivo tendon curve reported
           by Maganaris et al. and Magnusson et al. In addition, the generated curve
           will have a characteristic toe region that is fit to the in-vivo literature.
           :type strainAtOneNormForce: float
           :param strainAtOneNormForce:
                   The tendon strain at which the tendon develops 1 unit of normalized
                   force. strainAtOneNormForce = 0.04 means that the tendon will develop a
                   tension of 1 normalized force when it is strained by 4% of its slack
                   length or, equivalently, is stretched to 1.04 times its resting length.

           **Conditions**
               strainAtOneNormForce > 0
        """
        _simulation.TendonForceLengthCurve_swiginit(self, _simulation.new_TendonForceLengthCurve(*args))

    def getStrainAtOneNormForce(self) -> "double":
        r"""
        :rtype: float
        :return: The tendon strain at which the tendon develops 1 unit of
               normalized force. strainAtOneNormForce = 0.04 means that the tendon will
               develop a tension of 1 normalized force when it is strained by 4% of its
               slack length or, equivalently, is stretched to 1.04 times its resting
               length. This property is set to 0.049 by default.
        """
        return _simulation.TendonForceLengthCurve_getStrainAtOneNormForce(self)

    def getStiffnessAtOneNormForceInUse(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized stiffness (slope of the tendon curve) when the
               tendon is strained by strainAtOneNormForce under a load of 1 normalized unit
               of force. This property is set to 1.375/strainAtOneNormForce by default.
        """
        return _simulation.TendonForceLengthCurve_getStiffnessAtOneNormForceInUse(self)

    def getNormForceAtToeEndInUse(self) -> "double":
        r"""
        :rtype: float
        :return: The normalized force developed at the end of the 'toe' region.
               The toe region lies between 0 strain and some intermediate strain less than
               the strain required to develop 1 unit of normalized force. The toe region is
               nonlinear and more compliant than the rest of the tendon curve. This
               property is set to 2.0/3.0 by default.
        """
        return _simulation.TendonForceLengthCurve_getNormForceAtToeEndInUse(self)

    def getCurvinessInUse(self) -> "double":
        r"""
        :rtype: float
        :return: A dimensionless parameter between 0 and 1 that describes the
               shape of the curve: a value of 0 indicates that the curve is very close to a
               straight line segment and a value of 1 indicates a curve that smoothly fills
               the corner formed by the linear extrapolation of 'stiffnessAtOneNormForce'
               and the x-axis, as shown in the figure in the class description. This
               property is set to 0.5 by default.
        """
        return _simulation.TendonForceLengthCurve_getCurvinessInUse(self)

    def isFittedCurveBeingUsed(self) -> "bool":
        r"""
        :rtype: boolean
        :return: True if the optional properties are empty and the fitted curve
               is being used, false if the optional properties are filled and are being
               used to construct the curve.
        """
        return _simulation.TendonForceLengthCurve_isFittedCurveBeingUsed(self)

    def setStrainAtOneNormForce(self, aStrainAtOneNormForce: "double") -> "void":
        r"""
        :type aStrainAtOneNormForce: float
        :param aStrainAtOneNormForce:
                The tendon strain at which the tendon develops 1 unit of normalized
                force. strainAtOneNormForce = 0.04 means that the tendon will develop a
                tension of 1 normalized force when it is strained by 4% of its slack
                length or, equivalently, is stretched to 1.04 times its resting length.
        """
        return _simulation.TendonForceLengthCurve_setStrainAtOneNormForce(self, aStrainAtOneNormForce)

    def setOptionalProperties(self, stiffnessAtOneNormForce: "double", normForceAtToeEnd: "double", curviness: "double") -> "void":
        r"""
        :type stiffnessAtOneNormForce: float
        :param stiffnessAtOneNormForce:
                The normalized stiffness (slope of the tendon curve) when the tendon is
                strained by strainAtOneNormForce under a load of 1 normalized unit of
                force.
        :type normForceAtToeEnd: float
        :param normForceAtToeEnd:
                The normalized force developed at the end of the 'toe' region. The toe
                region lies between 0 strain and some intermediate strain less than the
                strain required to develop 1 unit of normalized force. The toe region is
                nonlinear and more compliant than the rest of the tendon curve.
        :type curviness: float
        :param curviness:
                A dimensionless parameter between 0 and 1 that describes the shape of
                the curve: a value of 0 indicates that the curve is very close to a
                straight line segment and a value of 1 indicates a curve that smoothly
                fills the corner formed by the linear extrapolation of
                'stiffnessAtOneNormForce' and the x-axis, as shown in the figure in the
                class description.
        """
        return _simulation.TendonForceLengthCurve_setOptionalProperties(self, stiffnessAtOneNormForce, normForceAtToeEnd, curviness)

    def calcValue(self, *args) -> "double":
        r"""
        *Overload 1:*
        Implement the generic OpenSim::Function interface *

        |

        *Overload 2:*
        Evaluates the tendon-force-length curve at a normalized tendon length of
           'aNormLength'.
        """
        return _simulation.TendonForceLengthCurve_calcValue(self, *args)

    def calcDerivative(self, *args) -> "double":
        r"""
        *Overload 1:*
        Calculates the derivative of the tendon-force-length multiplier with
           respect to the normalized tendon length.
           :type aNormLength: float
           :param aNormLength:
                   The normalized length of the tendon.
           :type order: int
           :param order:
                   The order of the derivative. Only values of 0, 1, and 2 are acceptable.
           :rtype: float
           :return: 
                   The derivative of the tendon-force-length curve with respect to the
                   normalized tendon length.

        |

        *Overload 2:*
        If possible, use the simpler overload above.
        """
        return _simulation.TendonForceLengthCurve_calcDerivative(self, *args)

    def calcIntegral(self, aNormLength: "double") -> "double":
        r"""
        Calculates the normalized area under the curve. Since it is expensive to
           construct, the curve is built only when necessary.
           :type aNormLength: float
           :param aNormLength:
                   The normalized length of the tendon.
           :rtype: float
           :return: The normalized area under the curve, which corresponds to the
                   normalized potential energy stored in the tendon. To calculate the
                   potential energy stored in the tendon in units of Joules, multiply the
                   returned quantity by normForce*normLength (where normForce is the number
                   of Newtons represented by a normalized force of 1.0 and normLength is
                   the number of meters represented by a normalized length of 1.0).
        """
        return _simulation.TendonForceLengthCurve_calcIntegral(self, aNormLength)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        Returns a SimTK::Vec2 containing the lower (0th element) and upper (1st
           element) bounds on the domain of the curve. Outside this domain, the curve
           is approximated using linear extrapolation.
           :rtype: :py:class:`Vec2`
           :return: 
                   The minimum and maximum value of the domain, x, of the curve y(x).
                   Within this range, y(x) is a curve; outside this range, the function
                   y(x) is a C2-continuous linear extrapolation.
        """
        return _simulation.TendonForceLengthCurve_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &") -> "void":
        r"""
        Generates a .csv file with a name that matches the curve name (e.g.,
           "bicepsfemoris_TendonForceLengthCurve.csv"). This function is not const to
           permit the curve to be rebuilt if it is out-of-date with its properties.
           :type path: string
           :param path:
                   The full destination path. Note that forward slashes ('/') must be used
                   and there should not be a slash after the last folder.

           The file will contain the following data:
               column: 1 | 2 |     3 |       4
             data: x | y | dy/dx | d2y/dx2

           Samples will be taken from the zero-force region, through the curve, out to
           strains beyond which the tendon generates normalized forces greater than 1.
           The curve is sampled quite densely: the tendon-force-length .csv file will
           have 200+20 rows.

           **Example**
           To read the .csv file into Matlab, you need to set csvread to ignore the
           header row. Since csvread is 0-indexed, the following example will begin
           reading the .csv file from the first column of the second row:
               data = csvread('bicepsfemoris_TendonForceLengthCurve.csv', 1, 0);
        """
        return _simulation.TendonForceLengthCurve_printMuscleCurveToCSVFile(self, path)

    def ensureCurveUpToDate(self) -> "void":
        return _simulation.TendonForceLengthCurve_ensureCurveUpToDate(self)
    __swig_destroy__ = _simulation.delete_TendonForceLengthCurve

# Register TendonForceLengthCurve in _simulation:
_simulation.TendonForceLengthCurve_swigregister(TendonForceLengthCurve)

def TendonForceLengthCurve_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TendonForceLengthCurve *":
    return _simulation.TendonForceLengthCurve_safeDownCast(obj)

def TendonForceLengthCurve_getClassName() -> "std::string const &":
    return _simulation.TendonForceLengthCurve_getClassName()

class MuscleFirstOrderActivationDynamicModel(ModelComponent):
    r"""
    This is a muscle modeling utility class that computes the time derivative of
       activation using a first-order dynamic model. This activation model is a
       modification of those used by Thelen (2003) and Winters (1995). The time
       derivative of activation (/dt:math:`) is calculated as follows:    \f[ \frac{da}{dt} = \frac{u-a}{\tau(u,a)}     where` is excitation, \f$a:math:`is activation, and`\tau(u,a):math:`is a    variable time constant:     \tau(u,a) = t_{\rm{act}} (0.5 + 1.5a) \quad {\rm{if}}\ u > a      \tau(u,a) = t_{\rm{deact}} / (0.5 + 1.5a) \quad {\rm{otherwise}}     Since equilibrium muscle models typically have a numerical singularity in    their state equations when activation is zero, we apply a lower activation    bound (_{`) to both activation and excitation.

       @param tauActivation
           Activation time constant. A typical value is 0.010 s (10 ms).
       @param tauDeactivation
           Deactivation time constant. A typical value is 0.040 s (40 ms).
       @param minActivation
           The minimum permissible activation. To avoid a numerical singularity at
           a = 0, this value is typically set to between 0.01 and 0.1 for use with
           an equilibrium muscle model.
       @param muscleName
           The name of the muscle to which this activation dynamic model belongs.
           This string is used for reporting meaningful error messages.

       <B>Conditions</B>
       \verbatim
       tauActivation > 0
       tauDeactivation > 0
       0 <= minActivation < 1


       **Default Parameter Values**
           tauActivation ...... 0.010
       tauDeactivation .... 0.040
       minActivation ...... 0.01

       **References**
       * Thelen, D.G. (2003) Adjustment of muscle mechanics model parameters to
           simulate dynamic contractions in older adults. ASME Journal of
           Biomechanical Engineering 125(1):70--77.
       * Winters, J.M. (1995) An improved muscle-reflex actuator for use in
           large-scale neuromusculoskeletal models. Annals of Biomedical
           Engineering 23(4):359--374.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleFirstOrderActivationDynamicModel *":
        return _simulation.MuscleFirstOrderActivationDynamicModel_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_getClassName()

    def clone(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel *":
        return _simulation.MuscleFirstOrderActivationDynamicModel_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source: "MuscleFirstOrderActivationDynamicModel") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value: "double const &") -> "int":
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args) -> "double &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args) -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source: "MuscleFirstOrderActivationDynamicModel") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value: "double const &") -> "int":
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args) -> "double &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args) -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source: "MuscleFirstOrderActivationDynamicModel") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value: "double const &") -> "int":
        return _simulation.MuscleFirstOrderActivationDynamicModel_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args) -> "double const &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args) -> "double &":
        return _simulation.MuscleFirstOrderActivationDynamicModel_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args) -> "void":
        return _simulation.MuscleFirstOrderActivationDynamicModel_set_minimum_activation(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates an activation dynamic model with the
           default property values and assigns it a default name. *

        |

        *Overload 2:*
        Creates an activation dynamic model using the provided parameters.
        """
        _simulation.MuscleFirstOrderActivationDynamicModel_swiginit(self, _simulation.new_MuscleFirstOrderActivationDynamicModel(*args))

    def clampActivation(self, activation: "double") -> "double":
        r"""
        :rtype: float
        :return: Activation clamped to the range [minActivation, 1.0].
        """
        return _simulation.MuscleFirstOrderActivationDynamicModel_clampActivation(self, activation)

    def calcDerivative(self, activation: "double", excitation: "double") -> "double":
        r""" Calculates the time derivative of activation."""
        return _simulation.MuscleFirstOrderActivationDynamicModel_calcDerivative(self, activation, excitation)
    __swig_destroy__ = _simulation.delete_MuscleFirstOrderActivationDynamicModel

# Register MuscleFirstOrderActivationDynamicModel in _simulation:
_simulation.MuscleFirstOrderActivationDynamicModel_swigregister(MuscleFirstOrderActivationDynamicModel)

def MuscleFirstOrderActivationDynamicModel_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleFirstOrderActivationDynamicModel *":
    return _simulation.MuscleFirstOrderActivationDynamicModel_safeDownCast(obj)

def MuscleFirstOrderActivationDynamicModel_getClassName() -> "std::string const &":
    return _simulation.MuscleFirstOrderActivationDynamicModel_getClassName()

class MuscleFixedWidthPennationModel(ModelComponent):
    r"""
    This is a muscle modeling utility class containing kinematic equations that
       describe the deformation of muscle fibers as they change length using a
       fixed-width-parallelogram pennation model. This pennation model makes
       several assumptions:
       * Fibers are straight, parallel, of equal length, and coplanar.
       * The area and height of the parallelogram remains constant.

       The parallelogram maintains a constant area and height by shearing as the
       muscle fibers change length, as shown in the figure below. The constant-area
       assumption is intended to mimic the constant-volume property of
       incompressible biological muscle. For details, please refer to Zajac (1989)
       and Millard et al. (2013).

       :param optimalFiberLength:
               The optimal length of the muscle fibers (meters).
       :param optimalPennationAngle:
               The angle between the tendon and fibers at optimal fiber length
               (radians).
       :param maximumPennationAngle:
               The maximum pennation angle permitted (radians). This parameter is
               particularly useful for avoiding a pennation angle singularity at Pi/2
               radians.

       Image: fig_MuscleFixedWidthPennationModel.png

       **Conditions**
           optimalFiberLength > 0
       0 <= optimalPennationAngle < Pi/2
       0 <= maximumPennationAngle <= Pi/2

       **Default Parameter Values**
           optimalFiberLength ....... 0.1
       optimalPennationAngle .... 0.0
       maximumPennationAngle .... acos(0.1) = 84.3 degrees

       **Example**

       .. code-block:: c++

           double optFibLen = 0.1;
           double optPenAng = SimTK::Pi/4.0;
           double maxPenAng = acos(0.001);
           MuscleFixedWidthPennationModel fibKin = MuscleFixedWidthPennationModel(optFibLen, optPenAng, maxPenAng);

       Note that this object should be updated through the set methods provided.
       These set methods will take care of rebuilding the object correctly. If you
       modify the properties directly, the object will not be rebuilt, and upon
       calling any function, an exception will be thrown because the object is
       out-of-date with its properties.

       **References**
       * Zajac, F.E. (1989) %Muscle and tendon: properties, models, scaling, and
           application to biomechanics and motor control. Critical Reviews in
           Biomedical Engineering 17(4):359--411.
       * Millard, M., Uchida, T., Seth, A., Delp, S.L. (2013) Flexing
           computational muscle: modeling and simulation of musculotendon dynamics.
           ASME Journal of Biomechanical Engineering 135(2):021005.
           http://dx.doi.org/10.1115/1.4023390.

       Author: Matt Millard
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleFixedWidthPennationModel *":
        return _simulation.MuscleFixedWidthPennationModel_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.MuscleFixedWidthPennationModel_getClassName()

    def clone(self) -> "OpenSim::MuscleFixedWidthPennationModel *":
        return _simulation.MuscleFixedWidthPennationModel_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.MuscleFixedWidthPennationModel_getConcreteClassName(self)

    def copyProperty_optimal_fiber_length(self, source: "MuscleFixedWidthPennationModel") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_optimal_fiber_length(self, source)

    def append_optimal_fiber_length(self, value: "double const &") -> "int":
        return _simulation.MuscleFixedWidthPennationModel_append_optimal_fiber_length(self, value)

    def constructProperty_optimal_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_optimal_fiber_length(self, initValue)

    def get_optimal_fiber_length(self, *args) -> "double const &":
        return _simulation.MuscleFixedWidthPennationModel_get_optimal_fiber_length(self, *args)

    def upd_optimal_fiber_length(self, *args) -> "double &":
        return _simulation.MuscleFixedWidthPennationModel_upd_optimal_fiber_length(self, *args)

    def set_optimal_fiber_length(self, *args) -> "void":
        return _simulation.MuscleFixedWidthPennationModel_set_optimal_fiber_length(self, *args)

    def copyProperty_pennation_angle_at_optimal(self, source: "MuscleFixedWidthPennationModel") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_pennation_angle_at_optimal(self, source)

    def append_pennation_angle_at_optimal(self, value: "double const &") -> "int":
        return _simulation.MuscleFixedWidthPennationModel_append_pennation_angle_at_optimal(self, value)

    def constructProperty_pennation_angle_at_optimal(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_pennation_angle_at_optimal(self, initValue)

    def get_pennation_angle_at_optimal(self, *args) -> "double const &":
        return _simulation.MuscleFixedWidthPennationModel_get_pennation_angle_at_optimal(self, *args)

    def upd_pennation_angle_at_optimal(self, *args) -> "double &":
        return _simulation.MuscleFixedWidthPennationModel_upd_pennation_angle_at_optimal(self, *args)

    def set_pennation_angle_at_optimal(self, *args) -> "void":
        return _simulation.MuscleFixedWidthPennationModel_set_pennation_angle_at_optimal(self, *args)

    def copyProperty_maximum_pennation_angle(self, source: "MuscleFixedWidthPennationModel") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value: "double const &") -> "int":
        return _simulation.MuscleFixedWidthPennationModel_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue: "double const &") -> "void":
        return _simulation.MuscleFixedWidthPennationModel_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args) -> "double const &":
        return _simulation.MuscleFixedWidthPennationModel_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args) -> "double &":
        return _simulation.MuscleFixedWidthPennationModel_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args) -> "void":
        return _simulation.MuscleFixedWidthPennationModel_set_maximum_pennation_angle(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor creates a fixed-width-parallelogram pennation
           model with the default property values.

        |

        *Overload 2:*
        Creates a fixed-width-parallelogram pennation model using the provided
           parameters.
        """
        _simulation.MuscleFixedWidthPennationModel_swiginit(self, _simulation.new_MuscleFixedWidthPennationModel(*args))

    def getParallelogramHeight(self) -> "double":
        r"""
        :rtype: float
        :return: The height of the fixed-width parallelogram.
        """
        return _simulation.MuscleFixedWidthPennationModel_getParallelogramHeight(self)

    def getMinimumFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum possible fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum possible fiber length along the tendon.
        """
        return _simulation.MuscleFixedWidthPennationModel_getMinimumFiberLengthAlongTendon(self)

    def calcPennationAngle(self, fiberLength: "double") -> "double":
        r"""
        Calculates the pennation angle (the orientation of the parallelogram)
           given the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngle(self, fiberLength)

    def calcTendonLength(self, cosPennationAngle: "double", fiberLength: "double", muscleLength: "double") -> "double":
        r"""
        Calculates the length of the tendon given the cosine of the pennation
           angle, the length of the fiber, and the length of the entire musculotendon
           actuator.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcTendonLength(self, cosPennationAngle, fiberLength, muscleLength)

    def calcFiberLengthAlongTendon(self, fiberLength: "double", cosPennationAngle: "double") -> "double":
        r"""
        Calculates the length of the fiber projected onto the axis of the
           tendon.
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberLengthAlongTendon(self, fiberLength, cosPennationAngle)

    def calcPennationAngularVelocity(self, tanPennationAngle: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        r"""
        Calculates the angular velocity of the parallelogram (i.e., the time
           derivative of the pennation angle.
           :type tanPennationAngle: float
           :param tanPennationAngle:
                   The tangent of the pennation angle.
           :type fiberLength: float
           :param fiberLength:
                   The length of the fiber (m).
           :type fiberVelocity: float
           :param fiberVelocity:
                   The lengthening velocity of the fiber (m/s).
           :rtype: float
           :return: 
                   The angular velocity of the parallelogram (rad/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngularVelocity(self, tanPennationAngle, fiberLength, fiberVelocity)

    def calcTendonVelocity(self, cosPennationAngle: "double", sinPennationAngle: "double", pennationAngularVelocity: "double", fiberLength: "double", fiberVelocity: "double", muscleVelocity: "double") -> "double":
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type muscleVelocity: float
        :param muscleVelocity:
                The lengthening velocity of the muscle path (m/s).
        :rtype: float
        :return: 
                The lengthening velocity of the tendon (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcTendonVelocity(self, cosPennationAngle, sinPennationAngle, pennationAngularVelocity, fiberLength, fiberVelocity, muscleVelocity)

    def calcFiberVelocityAlongTendon(self, fiberLength: "double", fiberVelocity: "double", sinPennationAngle: "double", cosPennationAngle: "double", pennationAngularVelocity: "double") -> "double":
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :rtype: float
        :return: 
                The lengthening velocity of the fiber projected onto the axis of the
                tendon (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberVelocityAlongTendon(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity)

    def calcPennationAngularAcceleration(self, fiberLength: "double", fiberVelocity: "double", fiberAcceleration: "double", sinPennationAngle: "double", cosPennationAngle: "double", pennationAngularVelocity: "double") -> "double":
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type fiberAcceleration: float
        :param fiberAcceleration:
                The lengthening acceleration of the fiber (m/s^2).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :rtype: float
        :return: 
                The angular acceleration of the parallelogram (rad/s^2).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcPennationAngularAcceleration(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity)

    def calcFiberAccelerationAlongTendon(self, fiberLength: "double", fiberVelocity: "double", fiberAcceleration: "double", sinPennationAngle: "double", cosPennationAngle: "double", pennationAngularVelocity: "double", pennationAngularAcceleration: "double") -> "double":
        r"""
        :type fiberLength: float
        :param fiberLength:
                The length of the fiber (m).
        :type fiberVelocity: float
        :param fiberVelocity:
                The lengthening velocity of the fiber (m/s).
        :type fiberAcceleration: float
        :param fiberAcceleration:
                The lengthening acceleration of the fiber (m/s^2).
        :type sinPennationAngle: float
        :param sinPennationAngle:
                The sine of the pennation angle.
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type pennationAngularVelocity: float
        :param pennationAngularVelocity:
                The angular velocity of the parallelogram (rad/s).
        :type pennationAngularAcceleration: float
        :param pennationAngularAcceleration:
                The angular acceleration of the parallelogram (rad/s^2).
        :rtype: float
        :return: 
                The acceleration of the fiber projected onto the axis of the tendon
                (m/s^2).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberAccelerationAlongTendon(self, fiberLength, fiberVelocity, fiberAcceleration, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, pennationAngularAcceleration)

    def calc_DFiberLengthAlongTendon_DfiberLength(self, fiberLength: "double", sinPennationAngle: "double", cosPennationAngle: "double", DpennationAngle_DfiberLength: "double") -> "double":
        r"""
        Calculates the partial derivative of the fiber length along the tendon
           with respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DFiberLengthAlongTendon_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength)

    def calc_DPennationAngularVelocity_DfiberLength(self, fiberLength: "double", fiberVelocity: "double", sinPennationAngle: "double", cosPennationAngle: "double", pennationAngularVelocity: "double", DpennationAngle_DfiberLength: "double") -> "double":
        r"""
        Calculates the partial derivative of the pennation angular velocity with
           respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DPennationAngularVelocity_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength)

    def calc_DFiberVelocityAlongTendon_DfiberLength(self, fiberLength: "double", fiberVelocity: "double", sinPennationAngle: "double", cosPennationAngle: "double", pennationAngularVelocity: "double", DpennationAngle_DfiberLength: "double", DpennationAngularVelocity_DfiberLength: "double") -> "double":
        r"""
        Calculates the partial derivative of the fiber velocity along the tendon
           with respect to the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DFiberVelocityAlongTendon_DfiberLength(self, fiberLength, fiberVelocity, sinPennationAngle, cosPennationAngle, pennationAngularVelocity, DpennationAngle_DfiberLength, DpennationAngularVelocity_DfiberLength)

    def calc_DPennationAngle_DfiberLength(self, fiberLength: "double") -> "double":
        r"""
        Calculates the partial derivative of the pennation angle with respect to
           the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DPennationAngle_DfiberLength(self, fiberLength)

    def calc_DTendonLength_DfiberLength(self, fiberLength: "double", sinPennationAngle: "double", cosPennationAngle: "double", DpennationAngle_DfiberLength: "double") -> "double":
        r"""
        Calculates the partial derivative of the tendon length with respect to
           the fiber length.
        """
        return _simulation.MuscleFixedWidthPennationModel_calc_DTendonLength_DfiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, DpennationAngle_DfiberLength)

    def calcFiberLength(self, muscleLength: "double", tendonLength: "double") -> "double":
        r"""
        :type muscleLength: float
        :param muscleLength:
                The length of the musculotendon actuator (m).
        :type tendonLength: float
        :param tendonLength:
                The length of the tendon (m).
        :rtype: float
        :return: 
                The length of the fiber (m).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberLength(self, muscleLength, tendonLength)

    def calcFiberVelocity(self, cosPennationAngle: "double", muscleVelocity: "double", tendonVelocity: "double") -> "double":
        r"""
        :type cosPennationAngle: float
        :param cosPennationAngle:
                The cosine of the pennation angle.
        :type muscleVelocity: float
        :param muscleVelocity:
                The lengthening velocity of the musculotendon actuator (m/s).
        :type tendonVelocity: float
        :param tendonVelocity:
                The lengthening velocity of the tendon (m/s).
        :rtype: float
        :return: 
                The lengthening velocity of the fiber (m/s).
        """
        return _simulation.MuscleFixedWidthPennationModel_calcFiberVelocity(self, cosPennationAngle, muscleVelocity, tendonVelocity)
    __swig_destroy__ = _simulation.delete_MuscleFixedWidthPennationModel

# Register MuscleFixedWidthPennationModel in _simulation:
_simulation.MuscleFixedWidthPennationModel_swigregister(MuscleFixedWidthPennationModel)

def MuscleFixedWidthPennationModel_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MuscleFixedWidthPennationModel *":
    return _simulation.MuscleFixedWidthPennationModel_safeDownCast(obj)

def MuscleFixedWidthPennationModel_getClassName() -> "std::string const &":
    return _simulation.MuscleFixedWidthPennationModel_getClassName()

class Thelen2003Muscle(ActivationFiberLengthMuscle):
    r"""
    Implementation of a two state (activation and fiber-length) Muscle model by
    Thelen 2003.\ This a complete rewrite of a previous implementation (present in
    OpenSim 2.4 and earlier) contained numerous errors.

    The Thelen2003Muscle model uses a standard equilibrium muscle equation

    .. math::

        (a(t) f_{AL}(l_{CE}) f_{V}(\dot{l}_{CE}) 
         - f_{PE}(l_{CE}))\cos \phi - f_{SE}(l_{T}) = 0

    Rearranging the above equation and solving for :math:`f_{V}(\dot{l}_{CE})`
    yields

    .. math::

        f_{V}(\dot{l}_{CE}) = 
         \frac{ \frac{f_{SE}(l_{T})}{\cos\phi} - f_{PE}(l_{CE}) }{ a(t) f_{AL}(l_{CE}) }

    The force velocity curve is usually inverted to compute the fiber velocity,

    .. math::

        \dot{l}_{CE} = f_{V}^{-1}( 
         \frac{ \frac{f_{SE}(l_{T})}{\cos\phi} - f_{PE}(l_{CE}) }{ a(t) f_{AL}(l_{CE}) }
         )

    which is then integrated to simulate the musculotendon dynamics. In general,
    the previous equation has 4 singularity conditions:

    -# :math:`a(t) \rightarrow 0`
    -# :math:`f_{AL}(l_{CE}) \rightarrow 0`
    -# :math:`\phi \rightarrow \frac{\pi}{2}`
    -# :math:`f_{V}(\dot{l}_{CE}) \le 0` or
       :math:`f_{V}(\dot{l}_{CE}) \ge F^M_{len}`

    This implementation has been slightly modified from the model presented in the
    journal paper (marked with a *) to prevent some of these singularities:

    -# *:math:`a(t) \rightarrow a_{min} > 0` : A modified activation dynamic
       equation is used - MuscleFirstOrderActivationDynamicModel - which smoothly
       approaches some minimum value that is greater than zero.
    -# :math:`f_{AL}(l_{CE}) > 0` . The active force length curve of the Thelen
       muscle is a Gaussian, which is always greater than 0.
    -# :math:`\phi \rightarrow \frac{\pi}{2}` . This singularity cannot be removed
       without changing the first equation, and still exists in the present
       Thelen2003Muscle formulation.
    -# *:math:`f_{V}(\dot{l}_{CE}) \le 0` or
       :math:`f_{V}(\dot{l}_{CE}) \ge F^M_{len}`: Equation 6 in Thelen 2003 has been
       modified so that :math:`V^M` is linearly extrapolated when :math:`F^M < 0`
       (during a concentric contraction), and when :math:`F^M > 0.95 F^M_{len}`
       (during an eccentric contraction). These two modifications make the force
       velocity curve invertible. The original force velocity curve as published
       by Thelen was not invertible.
    -# A unilateral constraint has been implemented to prevent the fiber from
       approaching a fiber length that is smaller than 0.01*optimal fiber length,
       or a fiber length that creates a pennation angle greater than the maximum
       pennation angle specified by the pennation model. Note that this unilateral
       constraint does not prevent the muscle fiber from becoming shorter than is
       physiologically possible (that is shorter than approximately half a
       normalized fiber length).

     ** References **

      DG Thelen, Adjustment of muscle mechanics model parameters to simulate dynamic
    contractions in older adults. Journal of biomechanical engineering, 2003.

    Author: Matt Millard
    Ajay Seth
    Peter Loan
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Thelen2003Muscle *":
        return _simulation.Thelen2003Muscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Thelen2003Muscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Thelen2003Muscle_getClassName()

    def clone(self) -> "OpenSim::Thelen2003Muscle *":
        return _simulation.Thelen2003Muscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Thelen2003Muscle_getConcreteClassName(self)

    def copyProperty_FmaxTendonStrain(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_FmaxTendonStrain(self, source)

    def append_FmaxTendonStrain(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_FmaxTendonStrain(self, value)

    def constructProperty_FmaxTendonStrain(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_FmaxTendonStrain(self, initValue)

    def get_FmaxTendonStrain(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_FmaxTendonStrain(self, *args)

    def upd_FmaxTendonStrain(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_FmaxTendonStrain(self, *args)

    def set_FmaxTendonStrain(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_FmaxTendonStrain(self, *args)

    def copyProperty_FmaxMuscleStrain(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_FmaxMuscleStrain(self, source)

    def append_FmaxMuscleStrain(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_FmaxMuscleStrain(self, value)

    def constructProperty_FmaxMuscleStrain(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_FmaxMuscleStrain(self, initValue)

    def get_FmaxMuscleStrain(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_FmaxMuscleStrain(self, *args)

    def upd_FmaxMuscleStrain(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_FmaxMuscleStrain(self, *args)

    def set_FmaxMuscleStrain(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_FmaxMuscleStrain(self, *args)

    def copyProperty_KshapeActive(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_KshapeActive(self, source)

    def append_KshapeActive(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_KshapeActive(self, value)

    def constructProperty_KshapeActive(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_KshapeActive(self, initValue)

    def get_KshapeActive(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_KshapeActive(self, *args)

    def upd_KshapeActive(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_KshapeActive(self, *args)

    def set_KshapeActive(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_KshapeActive(self, *args)

    def copyProperty_KshapePassive(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_KshapePassive(self, source)

    def append_KshapePassive(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_KshapePassive(self, value)

    def constructProperty_KshapePassive(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_KshapePassive(self, initValue)

    def get_KshapePassive(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_KshapePassive(self, *args)

    def upd_KshapePassive(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_KshapePassive(self, *args)

    def set_KshapePassive(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_KshapePassive(self, *args)

    def copyProperty_Af(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_Af(self, source)

    def append_Af(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_Af(self, value)

    def constructProperty_Af(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_Af(self, initValue)

    def get_Af(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_Af(self, *args)

    def upd_Af(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_Af(self, *args)

    def set_Af(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_Af(self, *args)

    def copyProperty_Flen(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_Flen(self, source)

    def append_Flen(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_Flen(self, value)

    def constructProperty_Flen(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_Flen(self, initValue)

    def get_Flen(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_Flen(self, *args)

    def upd_Flen(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_Flen(self, *args)

    def set_Flen(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_Flen(self, *args)

    def copyProperty_fv_linear_extrap_threshold(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_fv_linear_extrap_threshold(self, source)

    def append_fv_linear_extrap_threshold(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_fv_linear_extrap_threshold(self, value)

    def constructProperty_fv_linear_extrap_threshold(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_fv_linear_extrap_threshold(self, initValue)

    def get_fv_linear_extrap_threshold(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_fv_linear_extrap_threshold(self, *args)

    def upd_fv_linear_extrap_threshold(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_fv_linear_extrap_threshold(self, *args)

    def set_fv_linear_extrap_threshold(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_fv_linear_extrap_threshold(self, *args)

    def copyProperty_maximum_pennation_angle(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_maximum_pennation_angle(self, *args)

    def copyProperty_activation_time_constant(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source: "Thelen2003Muscle") -> "void":
        return _simulation.Thelen2003Muscle_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value: "double const &") -> "int":
        return _simulation.Thelen2003Muscle_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue: "double const &") -> "void":
        return _simulation.Thelen2003Muscle_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args) -> "double const &":
        return _simulation.Thelen2003Muscle_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args) -> "double &":
        return _simulation.Thelen2003Muscle_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args) -> "void":
        return _simulation.Thelen2003Muscle_set_minimum_activation(self, *args)
    FiberActiveForceLength = _simulation.Thelen2003Muscle_FiberActiveForceLength
    FiberPassiveForceLength = _simulation.Thelen2003Muscle_FiberPassiveForceLength
    FiberForceVelocity = _simulation.Thelen2003Muscle_FiberForceVelocity
    TendonForceLength = _simulation.Thelen2003Muscle_TendonForceLength

    def __init__(self, *args):
        _simulation.Thelen2003Muscle_swiginit(self, _simulation.new_Thelen2003Muscle(*args))

    def getActivationTimeConstant(self) -> "double":
        r"""*"""
        return _simulation.Thelen2003Muscle_getActivationTimeConstant(self)

    def setActivationTimeConstant(self, actTimeConstant: "double") -> "void":
        return _simulation.Thelen2003Muscle_setActivationTimeConstant(self, actTimeConstant)

    def getDeactivationTimeConstant(self) -> "double":
        return _simulation.Thelen2003Muscle_getDeactivationTimeConstant(self)

    def setDeactivationTimeConstant(self, deactTimeConstant: "double") -> "void":
        return _simulation.Thelen2003Muscle_setDeactivationTimeConstant(self, deactTimeConstant)

    def getMinimumActivation(self) -> "double":
        return _simulation.Thelen2003Muscle_getMinimumActivation(self)

    def setMinimumActivation(self, minimumActivation: "double") -> "void":
        return _simulation.Thelen2003Muscle_setMinimumActivation(self, minimumActivation)

    def getMaximumPennationAngle(self) -> "double":
        return _simulation.Thelen2003Muscle_getMaximumPennationAngle(self)

    def setMaximumPennationAngle(self, maximumPennationAngle: "double") -> "void":
        return _simulation.Thelen2003Muscle_setMaximumPennationAngle(self, maximumPennationAngle)

    def getMinimumFiberLength(self) -> "double":
        r"""
        *
             :rtype: float
             :return: the minimum fiber length, which is the maximum of two values:
                    the smallest fiber length allowed by the pennation model, and the
                    minimum fiber length in the active force length curve. When the fiber
                    length reaches this value, it is constrained to this value until the
                    fiber velocity goes positive.
        """
        return _simulation.Thelen2003Muscle_getMinimumFiberLength(self)

    def getActivationModel(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003Muscle_getActivationModel(self)

    def getPennationModel(self) -> "OpenSim::MuscleFixedWidthPennationModel const &":
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _simulation.Thelen2003Muscle_getPennationModel(self)

    def printCurveToCSVFile(self, ctype: "OpenSim::Thelen2003Muscle::CurveType const", path: "std::string const &") -> "void":
        return _simulation.Thelen2003Muscle_printCurveToCSVFile(self, ctype, path)

    def computeActuation(self, s: "State") -> "double":
        return _simulation.Thelen2003Muscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        Compute initial fiber length (velocity) such that muscle fiber and
               tendon are in static equilibrium and update the state

               Part of the Muscle.h interface

               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Thelen2003Muscle_computeInitialFiberEquilibrium(self, s)

    def calcActiveFiberForceAlongTendon(self, activation: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Thelen2003Muscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        return _simulation.Thelen2003Muscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)
    __swig_destroy__ = _simulation.delete_Thelen2003Muscle

# Register Thelen2003Muscle in _simulation:
_simulation.Thelen2003Muscle_swigregister(Thelen2003Muscle)

def Thelen2003Muscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Thelen2003Muscle *":
    return _simulation.Thelen2003Muscle_safeDownCast(obj)

def Thelen2003Muscle_getClassName() -> "std::string const &":
    return _simulation.Thelen2003Muscle_getClassName()

class Millard2012EquilibriumMuscle(Muscle):
    r"""
    This class implements a configurable equilibrium muscle model, as described in
    Millard et al.\ (2013). An equilibrium model assumes that the forces generated
    by the fiber and tendon are equal:

    .. math::

        f_{ISO}\Big(\mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE}) \mathbf{f}_V(\hat{v}_{CE})
        + \mathbf{f}_{PE}(\hat{l}_{CE}) + \beta \hat{v}_{CE}\Big) \cos \phi
        -  f_{ISO}\mathbf{f}_{SE}(\hat{l}_{T}) = 0

    Image: fig_Millard2012EquilibriumMuscle.png

    This model can be simulated in several configurations by adjusting three flags:

    * ignore_tendon_compliance: set to *true* to make the tendon rigid. This
    assumption is usually reasonable for short tendons, and can result in a
    performance improvement by eliminating high-frequency dynamics and removing the
    fiber length from the state vector.

    * ignore_activation_dynamics: set to *true* to use the excitation input
    as the activation signal. This results in faster simulations by reducing the
    size of the state vector.

    * fiber_damping: set to a value greater than 0.001 to include fiber damping in
    the model. The addition of damping reduces simulation time while allowing the
    muscle model to be more physiological (it can have an activation of zero, its
    active-force-length curve can go to zero, and its force-velocity curve can be
    asymptotic).

    **Elastic Tendon, No Fiber Damping**

    The most typical configuration used in the literature is to simulate a muscle
    with an elastic tendon, full fiber dynamics, and activation dynamics. The
    resulting formulation suffers from three singularities: :math:`\mathbf{a}(t)\rightarrow 0`, :math:`\phi \rightarrow 90^\circ`, and
    :math:`\mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0`. These situations are all
    handled in this model to ensure that it does not produce singularities and does
    not result in intolerably long simulation times.

    Numerical singularities arise from the manner in which the equilibrium equation
    is rearranged to yield an ordinary differential equation (ODE). The above
    equation is rearranged to isolate :math:`\mathbf{f}_V(\hat{v}_{CE})`. We then
    invert to solve for :math:`\hat{v}_{CE}`, which is then numerically integrated
    during a simulation:

    .. math::

        \hat{v}_{CE} = \mathbf{f}_V ^{-1} \Big(
         \frac{ ( \mathbf{f}_{SE}(\hat{l}_{T}) ) /
         \cos \phi
          -  \mathbf{f}_{PE}(\hat{l}_{CE}) }
          { \mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE})} \Big)

    The above equation becomes numerically stiff when terms in the denominator
    approach zero (when :math:`\mathbf{a}(t) \rightarrow 0`, :math:`\phi\rightarrow 90^\circ`, or :math:`\mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0`)
    or, additionally, when the slope of :math:`\mathbf{f}_V ^{-1}` is steep (which
    occurs at fiber velocities close to the maximum concentric and maximum
    eccentric fiber velocities).

    Singularities can be managed by ensuring that the muscle model is always
    activated (:math:`\mathbf{a}(t) > 0`), the fiber will stop contracting when a
    pennation angle of 90 degrees is approached (:math:`\phi < 90^\circ`), and the
    fiber will also stop contracting as its length approaches a lower bound
    (:math:`\hat{l}_{CE} > lowerbound`), which is typically around half the fiber's
    resting length (to ensure :math:`\mathbf{f}_L(\hat{l}_{CE}) > 0`). The fiber is
    prevented from reaching unphysiological lengths or its maximum pennation angle
    using a unilateral constraint. Additionally, the force-velocity curve is
    modified so that it is invertible.

    When an elastic tendon without fiber damping is selected, the minimum
    active-force-length value is set to 0.1, the minimum permissible activation is
    set to 0.01, and the maximum permissible pennation angle is set to acos(0.1) or
    84.3 degrees. This is done as a convenience for the user to prevent the model
    from taking an unreasonable amount of time to simulate.

    **(Rigid Tendon) or (Elastic Tendon with Fiber Damping)**

    Neither of these formulations has any singularities. The lower bound of the
    active-force-length curve can be zero (min( :math:`\mathbf{f}_L(\hat{l}_{CE})) = 0`), activation can be zero (i.e., the muscle can be turned off completely),
    and the force-velocity curve need not be invertible.

    The rigid tendon formulation removes the singularities by ignoring the
    elasticity of the tendon. This assumption is reasonable for many muscles, but it
    is up to the user to determine whether this assumption is valid.

    The formulation that uses an elastic tendon with fiber damping removes
    singularities by solving the equilibrium equation with Newton's method. This is
    possible because the partial derivative of the equilibrium equation with respect
    to fiber velocity is always positive if :math:`\beta > 0` and, thus, Newton's
    method can find a solution to the equilibrium equation.

    When either of these singularity-free formulations is selected, the minimum
    active-force-length value and the minimum permissible activation are set to
    zero. This is done as a convenience for the user, as these changes make the
    results of the model more realistic yet incur no performance penalty. The
    maximum pennation angle is left as acos(0.1) or 84.3 degrees, as allowing higher
    pennation angles results in an increasingly stiff fiber velocity state as
    pennation angle increases.

    **Usage**

    This object should be updated through the *set* methods provided.

    **Example**

    .. code-block:: c++

        double maxIsometricForce  = 5000;   //N
        double optimalFiberLength = 0.025;  //m
        double tendonSlackLength  = 0.25;   //m
        double pennationAngle     = 0.5;    //rad

        bool ignoreTendonCompliance   = false;
        bool ignoreActivationDynamics = false;
        double dampingCoefficient     = 0.001;

        Millard2012EquilibriumMuscle myMuscle("myMuscle",
                                              maxIsometricForce,
                                              optimalFiberLength,
                                              tendonSlackLength,
                                              pennationAngle);

        myMuscle.setMuscleConfiguration(ignoreTendonCompliance,
                                        ignoreActivationDynamics,
                                        dampingCoefficient);

    Please refer to the doxygen for more information on the properties that are
    objects themselves (MuscleFixedWidthPennationModel, ActiveForceLengthCurve,
    FiberForceLengthCurve, TendonForceLengthCurve, and ForceVelocityInverseCurve).

    **Reference**

    Millard, M., Uchida, T., Seth, A., Delp, S.L. (2013) Flexing computational
    muscle: modeling and simulation of musculotendon dynamics. ASME Journal of
    Biomechanical Engineering 135(2):021005. http://dx.doi.org/10.1115/1.4023390.

    Author: Matt Millard
    Tom Uchida
    Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Millard2012EquilibriumMuscle *":
        return _simulation.Millard2012EquilibriumMuscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _simulation.Millard2012EquilibriumMuscle_getClassName()

    def clone(self) -> "OpenSim::Millard2012EquilibriumMuscle *":
        return _simulation.Millard2012EquilibriumMuscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _simulation.Millard2012EquilibriumMuscle_getConcreteClassName(self)

    def copyProperty_fiber_damping(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_fiber_damping(self, *args)

    def copyProperty_default_activation(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_default_fiber_length(self, *args)

    def copyProperty_activation_time_constant(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_deactivation_time_constant(self, *args)

    def copyProperty_minimum_activation(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_minimum_activation(self, source)

    def append_minimum_activation(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_minimum_activation(self, value)

    def constructProperty_minimum_activation(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_minimum_activation(self, initValue)

    def get_minimum_activation(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_minimum_activation(self, *args)

    def upd_minimum_activation(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_minimum_activation(self, *args)

    def set_minimum_activation(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_minimum_activation(self, *args)

    def copyProperty_maximum_pennation_angle(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_maximum_pennation_angle(self, source)

    def append_maximum_pennation_angle(self, value: "double const &") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_maximum_pennation_angle(self, value)

    def constructProperty_maximum_pennation_angle(self, initValue: "double const &") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_maximum_pennation_angle(self, initValue)

    def get_maximum_pennation_angle(self, *args) -> "double const &":
        return _simulation.Millard2012EquilibriumMuscle_get_maximum_pennation_angle(self, *args)

    def upd_maximum_pennation_angle(self, *args) -> "double &":
        return _simulation.Millard2012EquilibriumMuscle_upd_maximum_pennation_angle(self, *args)

    def set_maximum_pennation_angle(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_maximum_pennation_angle(self, *args)

    def copyProperty_ActiveForceLengthCurve(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_ActiveForceLengthCurve(self, source)

    def append_ActiveForceLengthCurve(self, value: "ActiveForceLengthCurve") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_ActiveForceLengthCurve(self, value)

    def constructProperty_ActiveForceLengthCurve(self, initValue: "ActiveForceLengthCurve") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_ActiveForceLengthCurve(self, initValue)

    def get_ActiveForceLengthCurve(self, *args) -> "OpenSim::ActiveForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscle_get_ActiveForceLengthCurve(self, *args)

    def upd_ActiveForceLengthCurve(self, *args) -> "OpenSim::ActiveForceLengthCurve &":
        return _simulation.Millard2012EquilibriumMuscle_upd_ActiveForceLengthCurve(self, *args)

    def set_ActiveForceLengthCurve(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_ActiveForceLengthCurve(self, *args)

    def copyProperty_ForceVelocityCurve(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_ForceVelocityCurve(self, source)

    def append_ForceVelocityCurve(self, value: "ForceVelocityCurve") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_ForceVelocityCurve(self, value)

    def constructProperty_ForceVelocityCurve(self, initValue: "ForceVelocityCurve") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_ForceVelocityCurve(self, initValue)

    def get_ForceVelocityCurve(self, *args) -> "OpenSim::ForceVelocityCurve const &":
        return _simulation.Millard2012EquilibriumMuscle_get_ForceVelocityCurve(self, *args)

    def upd_ForceVelocityCurve(self, *args) -> "OpenSim::ForceVelocityCurve &":
        return _simulation.Millard2012EquilibriumMuscle_upd_ForceVelocityCurve(self, *args)

    def set_ForceVelocityCurve(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_ForceVelocityCurve(self, *args)

    def copyProperty_FiberForceLengthCurve(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_FiberForceLengthCurve(self, source)

    def append_FiberForceLengthCurve(self, value: "FiberForceLengthCurve") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_FiberForceLengthCurve(self, value)

    def constructProperty_FiberForceLengthCurve(self, initValue: "FiberForceLengthCurve") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_FiberForceLengthCurve(self, initValue)

    def get_FiberForceLengthCurve(self, *args) -> "OpenSim::FiberForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscle_get_FiberForceLengthCurve(self, *args)

    def upd_FiberForceLengthCurve(self, *args) -> "OpenSim::FiberForceLengthCurve &":
        return _simulation.Millard2012EquilibriumMuscle_upd_FiberForceLengthCurve(self, *args)

    def set_FiberForceLengthCurve(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_FiberForceLengthCurve(self, *args)

    def copyProperty_TendonForceLengthCurve(self, source: "Millard2012EquilibriumMuscle") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_copyProperty_TendonForceLengthCurve(self, source)

    def append_TendonForceLengthCurve(self, value: "TendonForceLengthCurve") -> "int":
        return _simulation.Millard2012EquilibriumMuscle_append_TendonForceLengthCurve(self, value)

    def constructProperty_TendonForceLengthCurve(self, initValue: "TendonForceLengthCurve") -> "void":
        return _simulation.Millard2012EquilibriumMuscle_constructProperty_TendonForceLengthCurve(self, initValue)

    def get_TendonForceLengthCurve(self, *args) -> "OpenSim::TendonForceLengthCurve const &":
        return _simulation.Millard2012EquilibriumMuscle_get_TendonForceLengthCurve(self, *args)

    def upd_TendonForceLengthCurve(self, *args) -> "OpenSim::TendonForceLengthCurve &":
        return _simulation.Millard2012EquilibriumMuscle_upd_TendonForceLengthCurve(self, *args)

    def set_TendonForceLengthCurve(self, *args) -> "void":
        return _simulation.Millard2012EquilibriumMuscle_set_TendonForceLengthCurve(self, *args)
    _has_output_passive_fiber_elastic_force = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_set)
    _has_output_passive_fiber_elastic_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_set)
    _has_output_passive_fiber_damping_force = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_set)
    _has_output_passive_fiber_damping_force_along_tendon = property(_simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_get, _simulation.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor. Produces a non-functional empty muscle.

        |

        *Overload 2:*
        Constructs a functional muscle using default curves and activation model
           parameters. The tendon is assumed to be elastic, full fiber dynamics are
           solved, and activation dynamics are included.
               :type aName: string
               :param aName: The name of the muscle.
               :type aMaxIsometricForce: float
               :param aMaxIsometricForce: The force generated by the muscle when fully
               activated at its optimal resting length with a contraction velocity of zero.
               :type aOptimalFiberLength: float
               :param aOptimalFiberLength: The optimal length of the muscle fiber.
               :type aTendonSlackLength: float
               :param aTendonSlackLength: The resting length of the tendon.
               :type aPennationAngle: float
               :param aPennationAngle: The angle of the fiber (in radians) relative to
               the tendon when the fiber is at its optimal resting length.
        """
        _simulation.Millard2012EquilibriumMuscle_swiginit(self, _simulation.new_Millard2012EquilibriumMuscle(*args))

    def getUseFiberDamping(self) -> "bool":
        r"""
        :rtype: boolean
        :return: A boolean indicating whether fiber damping is being used.
        """
        return _simulation.Millard2012EquilibriumMuscle_getUseFiberDamping(self)

    def getFiberDamping(self) -> "double":
        r"""
        :rtype: float
        :return: The fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberDamping(self)

    def getDefaultActivation(self) -> "double":
        r"""
        :rtype: float
        :return: The default activation level that is used as an initial
               condition if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscle_getDefaultActivation(self)

    def getDefaultFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The default fiber length that is used as an initial condition
               if none is provided by the user.
        """
        return _simulation.Millard2012EquilibriumMuscle_getDefaultFiberLength(self)

    def getActivationTimeConstant(self) -> "double":
        r"""
        :rtype: float
        :return: The activation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationTimeConstant(self)

    def getDeactivationTimeConstant(self) -> "double":
        r"""
        :rtype: float
        :return: The deactivation time constant (in seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_getDeactivationTimeConstant(self)

    def getMinimumActivation(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum activation level permitted by the muscle model.
               Note that this equilibrium model, like all equilibrium models, has a
               singularity when activation approaches 0, which means that a non-zero lower
               bound is required.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumActivation(self)

    def getActiveForceLengthCurve(self) -> "OpenSim::ActiveForceLengthCurve const &":
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: The ActiveForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self) -> "OpenSim::ForceVelocityCurve const &":
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: The ForceVelocityCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self) -> "OpenSim::FiberForceLengthCurve const &":
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: The FiberForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self) -> "OpenSim::TendonForceLengthCurve const &":
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: The TendonForceLengthCurve used by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getTendonForceLengthCurve(self)

    def getPennationModel(self) -> "OpenSim::MuscleFixedWidthPennationModel const &":
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: The MuscleFixedWidthPennationModel owned by this model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getPennationModel(self)

    def getActivationModel(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: The MuscleFirstOrderActivationDynamicModel owned by this
               model.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationModel(self)

    def getMinimumFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum fiber length, which is the maximum of two values:
               the smallest fiber length allowed by the pennation model, and the minimum
               fiber length on the active-force-length curve. When the fiber reaches this
               length, it is constrained to this value until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumFiberLength(self)

    def getMinimumFiberLengthAlongTendon(self) -> "double":
        r"""
        :rtype: float
        :return: The minimum fiber length along the tendon, which is the maximum
               of two values: the smallest fiber length along the tendon permitted by the
               pennation model, and the minimum fiber length along the tendon on the
               active-force-length curve. When the fiber length reaches this value, it is
               constrained to this length along the tendon until the fiber velocity becomes
               positive.
        """
        return _simulation.Millard2012EquilibriumMuscle_getMinimumFiberLengthAlongTendon(self)

    def getTendonForceMultiplier(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :rtype: float
               :return: The normalized force term associated with the tendon element,
               :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation.
        """
        return _simulation.Millard2012EquilibriumMuscle_getTendonForceMultiplier(self, s)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        :rtype: float
        :return: The stiffness of the muscle fibers along the tendon (N/m).
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberStiffnessAlongTendon(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The velocity of the fiber (m/s).
        """
        return _simulation.Millard2012EquilibriumMuscle_getFiberVelocity(self, s)

    def getActivationDerivative(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
           :rtype: float
           :return: The time derivative of activation.
        """
        return _simulation.Millard2012EquilibriumMuscle_getActivationDerivative(self, s)

    def getPassiveFiberElasticForce(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the elastic
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the damping
               element only (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s: "State") -> "double":
        r"""
        get the portion of the passive fiber force generated by the damping
               element only, projected onto the tendon direction (N)
        """
        return _simulation.Millard2012EquilibriumMuscle_getPassiveFiberDampingForceAlongTendon(self, s)

    def setMuscleConfiguration(self, ignoreTendonCompliance: "bool", ignoreActivationDynamics: "bool", dampingCoefficient: "double") -> "void":
        r"""
        :type ignoreTendonCompliance: boolean
        :param ignoreTendonCompliance: Use a rigid (true) or elastic tendon.
               :type ignoreActivationDynamics: boolean
               :param ignoreActivationDynamics: Treat the excitation input as the
               activation signal (true) or use a first-order activation dynamic model.
               :type dampingCoefficient: float
               :param dampingCoefficient: Specify the amount of damping to include in
               the model (must be either 0 or greater than 0.001).
        """
        return _simulation.Millard2012EquilibriumMuscle_setMuscleConfiguration(self, ignoreTendonCompliance, ignoreActivationDynamics, dampingCoefficient)

    def setFiberDamping(self, dampingCoefficient: "double") -> "void":
        r"""
        :type dampingCoefficient: float
        :param dampingCoefficient: Define the fiber damping coefficient.
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberDamping(self, dampingCoefficient)

    def setDefaultActivation(self, activation: "double") -> "void":
        r"""
        :type activation: float
        :param activation: The default activation level that is used to
               initialize the muscle.
        """
        return _simulation.Millard2012EquilibriumMuscle_setDefaultActivation(self, activation)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system.
               :type activation: float
               :param activation: The desired activation level.
        """
        return _simulation.Millard2012EquilibriumMuscle_setActivation(self, s, activation)

    def setDefaultFiberLength(self, fiberLength: "double") -> "void":
        r"""
        :type fiberLength: float
        :param fiberLength: The default fiber length that is used to initialize
               the muscle.
        """
        return _simulation.Millard2012EquilibriumMuscle_setDefaultFiberLength(self, fiberLength)

    def setActivationTimeConstant(self, activationTimeConstant: "double") -> "void":
        r"""
        :type activationTimeConstant: float
        :param activationTimeConstant: The activation time constant (in
               seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_setActivationTimeConstant(self, activationTimeConstant)

    def setDeactivationTimeConstant(self, deactivationTimeConstant: "double") -> "void":
        r"""
        :type deactivationTimeConstant: float
        :param deactivationTimeConstant: The deactivation time constant (in
               seconds).
        """
        return _simulation.Millard2012EquilibriumMuscle_setDeactivationTimeConstant(self, deactivationTimeConstant)

    def setMinimumActivation(self, minimumActivation: "double") -> "void":
        r"""
        :type minimumActivation: float
        :param minimumActivation: The minimum permissible activation level.
        """
        return _simulation.Millard2012EquilibriumMuscle_setMinimumActivation(self, minimumActivation)

    def setActiveForceLengthCurve(self, aActiveForceLengthCurve: "ActiveForceLengthCurve") -> "void":
        r"""
        :type aActiveForceLengthCurve: :py:class:`ActiveForceLengthCurve`
        :param aActiveForceLengthCurve: The ActiveForceLengthCurve used by the
               muscle model to scale active fiber force as a function of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setActiveForceLengthCurve(self, aActiveForceLengthCurve)

    def setForceVelocityCurve(self, aForceVelocityCurve: "ForceVelocityCurve") -> "void":
        r"""
        :type aForceVelocityCurve: :py:class:`ForceVelocityCurve`
        :param aForceVelocityCurve: The ForceVelocityCurve used by the muscle
               model to calculate the derivative of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setForceVelocityCurve(self, aForceVelocityCurve)

    def setFiberForceLengthCurve(self, aFiberForceLengthCurve: "FiberForceLengthCurve") -> "void":
        r"""
        :type aFiberForceLengthCurve: :py:class:`FiberForceLengthCurve`
        :param aFiberForceLengthCurve: The FiberForceLengthCurve used by the
               muscle model to calculate the passive force the muscle fiber generates as a
               function of fiber length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberForceLengthCurve(self, aFiberForceLengthCurve)

    def setTendonForceLengthCurve(self, aTendonForceLengthCurve: "TendonForceLengthCurve") -> "void":
        r"""
        :type aTendonForceLengthCurve: :py:class:`TendonForceLengthCurve`
        :param aTendonForceLengthCurve: The TendonForceLengthCurve used by the
               muscle model to calculate the force exerted by the tendon as a function of
               tendon length.
        """
        return _simulation.Millard2012EquilibriumMuscle_setTendonForceLengthCurve(self, aTendonForceLengthCurve)

    def setFiberLength(self, s: "State", fiberLength: "double") -> "void":
        r"""
        :type s: :py:class:`State`, out
        :param s: The state of the system.
               :type fiberLength: float
               :param fiberLength: The desired fiber length (m).
        """
        return _simulation.Millard2012EquilibriumMuscle_setFiberLength(self, s, fiberLength)

    def computeActuation(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`, in
        :param s: The state of the system.
               :rtype: float
               :return: The tensile force the muscle is generating (N).
        """
        return _simulation.Millard2012EquilibriumMuscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        Computes the fiber length such that the fiber and tendon are developing
           the same force, distributing the velocity of the entire musculotendon
           actuator between the fiber and tendon according to their relative
           stiffnesses.
               :type s: :py:class:`State`, in/out
               :param s: The state of the system.
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscle_computeInitialFiberEquilibrium(self, s)

    def computeFiberEquilibrium(self, s: "State", solveForVelocity: "bool"=False) -> "void":
        r"""
        Computes the fiber length such that the fiber and tendon are developing
               the same force, either assuming muscle-tendon velocity as provided
               by the state or zero as designated by the useZeroVelocity flag.
               :type s: :py:class:`State`, in/out
               :param s:         The state of the system.
               :type solveForVelocity: boolean, optional
               :param solveForVelocity:  Flag indicating to solve for fiber velocity,
                                            which by default is false (zero fiber-velocity)
               :raises: MuscleCannotEquilibrate
        """
        return _simulation.Millard2012EquilibriumMuscle_computeFiberEquilibrium(self, s, solveForVelocity)

    def calcActiveFiberForceAlongTendon(self, activation: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        r"""Conditional comment: DEPRECATED"""
        return _simulation.Millard2012EquilibriumMuscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def calcFiberStateGivenBoundaryCond(self, lengthMT: "double", velocityMT: "double", tendonForce: "double", dTendonForceDT: "double") -> "SimTK::Vec4":
        return _simulation.Millard2012EquilibriumMuscle_calcFiberStateGivenBoundaryCond(self, lengthMT, velocityMT, tendonForce, dTendonForceDT)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        return _simulation.Millard2012EquilibriumMuscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The
                optimal fiber length and tendon slack length are each multiplied by the
                ratio of the current path length and the path length before scaling.
        """
        return _simulation.Millard2012EquilibriumMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _simulation.delete_Millard2012EquilibriumMuscle

# Register Millard2012EquilibriumMuscle in _simulation:
_simulation.Millard2012EquilibriumMuscle_swigregister(Millard2012EquilibriumMuscle)

def Millard2012EquilibriumMuscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Millard2012EquilibriumMuscle *":
    return _simulation.Millard2012EquilibriumMuscle_safeDownCast(obj)

def Millard2012EquilibriumMuscle_getClassName() -> "std::string const &":
    return _simulation.Millard2012EquilibriumMuscle_getClassName()



