# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _moco
else:
    import _moco

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _moco.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _moco.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _moco.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _moco.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _moco.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _moco.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _moco.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _moco.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _moco.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _moco.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _moco.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _moco.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _moco.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _moco.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _moco.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _moco.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _moco.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _moco:
_moco.SwigPyIterator_swigregister(SwigPyIterator)

class StdVectorUnsigned(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _moco.StdVectorUnsigned_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _moco.StdVectorUnsigned___nonzero__(self)

    def __bool__(self) -> "bool":
        return _moco.StdVectorUnsigned___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _moco.StdVectorUnsigned___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _moco.StdVectorUnsigned___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _moco.StdVectorUnsigned___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _moco.StdVectorUnsigned___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _moco.StdVectorUnsigned___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _moco.StdVectorUnsigned___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _moco.StdVectorUnsigned___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _moco.StdVectorUnsigned_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _moco.StdVectorUnsigned_append(self, x)

    def empty(self) -> "bool":
        return _moco.StdVectorUnsigned_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _moco.StdVectorUnsigned_size(self)

    def swap(self, v: "StdVectorUnsigned") -> "void":
        return _moco.StdVectorUnsigned_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _moco.StdVectorUnsigned_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _moco.StdVectorUnsigned_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _moco.StdVectorUnsigned_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _moco.StdVectorUnsigned_rend(self)

    def clear(self) -> "void":
        return _moco.StdVectorUnsigned_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _moco.StdVectorUnsigned_get_allocator(self)

    def pop_back(self) -> "void":
        return _moco.StdVectorUnsigned_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _moco.StdVectorUnsigned_erase(self, *args)

    def __init__(self, *args):
        _moco.StdVectorUnsigned_swiginit(self, _moco.new_StdVectorUnsigned(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _moco.StdVectorUnsigned_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _moco.StdVectorUnsigned_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _moco.StdVectorUnsigned_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _moco.StdVectorUnsigned_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _moco.StdVectorUnsigned_resize(self, *args)

    def insert(self, *args) -> "void":
        return _moco.StdVectorUnsigned_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _moco.StdVectorUnsigned_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _moco.StdVectorUnsigned_capacity(self)
    __swig_destroy__ = _moco.delete_StdVectorUnsigned

# Register StdVectorUnsigned in _moco:
_moco.StdVectorUnsigned_swigregister(StdVectorUnsigned)

class StdVectorInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _moco.StdVectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _moco.StdVectorInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _moco.StdVectorInt___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _moco.StdVectorInt___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _moco.StdVectorInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _moco.StdVectorInt___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _moco.StdVectorInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _moco.StdVectorInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _moco.StdVectorInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _moco.StdVectorInt___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _moco.StdVectorInt_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _moco.StdVectorInt_append(self, x)

    def empty(self) -> "bool":
        return _moco.StdVectorInt_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _moco.StdVectorInt_size(self)

    def swap(self, v: "StdVectorInt") -> "void":
        return _moco.StdVectorInt_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _moco.StdVectorInt_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _moco.StdVectorInt_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _moco.StdVectorInt_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _moco.StdVectorInt_rend(self)

    def clear(self) -> "void":
        return _moco.StdVectorInt_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _moco.StdVectorInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _moco.StdVectorInt_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _moco.StdVectorInt_erase(self, *args)

    def __init__(self, *args):
        _moco.StdVectorInt_swiginit(self, _moco.new_StdVectorInt(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _moco.StdVectorInt_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _moco.StdVectorInt_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _moco.StdVectorInt_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _moco.StdVectorInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _moco.StdVectorInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _moco.StdVectorInt_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _moco.StdVectorInt_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _moco.StdVectorInt_capacity(self)
    __swig_destroy__ = _moco.delete_StdVectorInt

# Register StdVectorInt in _moco:
_moco.StdVectorInt_swigregister(StdVectorInt)

class StdVectorDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _moco.StdVectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _moco.StdVectorDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _moco.StdVectorDouble___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _moco.StdVectorDouble___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _moco.StdVectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _moco.StdVectorDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _moco.StdVectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _moco.StdVectorDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _moco.StdVectorDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _moco.StdVectorDouble___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _moco.StdVectorDouble_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _moco.StdVectorDouble_append(self, x)

    def empty(self) -> "bool":
        return _moco.StdVectorDouble_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _moco.StdVectorDouble_size(self)

    def swap(self, v: "StdVectorDouble") -> "void":
        return _moco.StdVectorDouble_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _moco.StdVectorDouble_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _moco.StdVectorDouble_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _moco.StdVectorDouble_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _moco.StdVectorDouble_rend(self)

    def clear(self) -> "void":
        return _moco.StdVectorDouble_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _moco.StdVectorDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _moco.StdVectorDouble_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _moco.StdVectorDouble_erase(self, *args)

    def __init__(self, *args):
        _moco.StdVectorDouble_swiginit(self, _moco.new_StdVectorDouble(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _moco.StdVectorDouble_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _moco.StdVectorDouble_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _moco.StdVectorDouble_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _moco.StdVectorDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _moco.StdVectorDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _moco.StdVectorDouble_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _moco.StdVectorDouble_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _moco.StdVectorDouble_capacity(self)
    __swig_destroy__ = _moco.delete_StdVectorDouble

# Register StdVectorDouble in _moco:
_moco.StdVectorDouble_swigregister(StdVectorDouble)

class StdVectorString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _moco.StdVectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _moco.StdVectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _moco.StdVectorString___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _moco.StdVectorString___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _moco.StdVectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _moco.StdVectorString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _moco.StdVectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _moco.StdVectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _moco.StdVectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _moco.StdVectorString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _moco.StdVectorString_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _moco.StdVectorString_append(self, x)

    def empty(self) -> "bool":
        return _moco.StdVectorString_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _moco.StdVectorString_size(self)

    def swap(self, v: "StdVectorString") -> "void":
        return _moco.StdVectorString_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _moco.StdVectorString_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _moco.StdVectorString_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _moco.StdVectorString_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _moco.StdVectorString_rend(self)

    def clear(self) -> "void":
        return _moco.StdVectorString_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _moco.StdVectorString_get_allocator(self)

    def pop_back(self) -> "void":
        return _moco.StdVectorString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _moco.StdVectorString_erase(self, *args)

    def __init__(self, *args):
        _moco.StdVectorString_swiginit(self, _moco.new_StdVectorString(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _moco.StdVectorString_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _moco.StdVectorString_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _moco.StdVectorString_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _moco.StdVectorString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _moco.StdVectorString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _moco.StdVectorString_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _moco.StdVectorString_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _moco.StdVectorString_capacity(self)
    __swig_destroy__ = _moco.delete_StdVectorString

# Register StdVectorString in _moco:
_moco.StdVectorString_swigregister(StdVectorString)

SHARED_PTR_DISOWN = _moco.SHARED_PTR_DISOWN
import opensim.tools
import opensim.analyses
import opensim.actuators
import opensim.simulation
import opensim.common
import opensim.simbody

def GetMocoVersionAndDate() -> "std::string":
    return _moco.GetMocoVersionAndDate()

def GetMocoVersion() -> "std::string":
    return _moco.GetMocoVersion()
class MocoScaleFactor(opensim.common.Component):
    r"""
     A scale factor is a scalar value optimized by Moco that can be used to scale
    a tracked reference quantity in the cost function. Scale factors can be added to
    a MocoProblem via MocoGoals, and this class enables the use of MocoParameter
    to optimize scale factors values by providing the 'scale_factor' property.
    MocoScaleFactor derives from Component, since it must be appended to the model
    internal to MocoProblem as MocoParameter can only optimize model parameter values
    contained in properties. Users do not need to interact with this class directly,
    but rather use the 'addScaleFactor()' interface provided by MocoGoals that
    support scale factors. How the scale factor is utilized in the cost function is
    specific to each MocoGoal.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoScaleFactor *":
        return _moco.MocoScaleFactor_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoScaleFactor_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoScaleFactor_getClassName()

    def clone(self) -> "OpenSim::MocoScaleFactor *":
        return _moco.MocoScaleFactor_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoScaleFactor_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoScaleFactor_swiginit(self, _moco.new_MocoScaleFactor(*args))

    def getScaleFactor(self) -> "double":
        return _moco.MocoScaleFactor_getScaleFactor(self)

    def setScaleFactor(self, value: "double") -> "void":
        return _moco.MocoScaleFactor_setScaleFactor(self, value)

    def getBounds(self) -> "MocoBounds":
        r"""
        Note: the return value is constructed fresh on every call from
        the internal property. Avoid repeated calls to this function.
        """
        return _moco.MocoScaleFactor_getBounds(self)

    def setBounds(self, bounds: "MocoBounds const &") -> "void":
        return _moco.MocoScaleFactor_setBounds(self, bounds)
    __swig_destroy__ = _moco.delete_MocoScaleFactor

# Register MocoScaleFactor in _moco:
_moco.MocoScaleFactor_swigregister(MocoScaleFactor)

def MocoScaleFactor_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoScaleFactor *":
    return _moco.MocoScaleFactor_safeDownCast(obj)

def MocoScaleFactor_getClassName() -> "std::string const &":
    return _moco.MocoScaleFactor_getClassName()

class MocoBounds(opensim.common.OpenSimObject):
    r""" Small struct-like class to handle bounds."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoBounds *":
        return _moco.MocoBounds_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoBounds_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoBounds_getClassName()

    def clone(self) -> "OpenSim::MocoBounds *":
        return _moco.MocoBounds_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoBounds_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The bounds are unset (NaN).

        |

        *Overload 2:*
        The lower and upper bound are equal (the variable is constrained to this
        single value).

        |

        *Overload 3:*
        The variable is constrained to be within [lower, upper].
        """
        _moco.MocoBounds_swiginit(self, _moco.new_MocoBounds(*args))

    @staticmethod
    def unconstrained() -> "OpenSim::MocoBounds":
        r""" Create bounds that are (-inf, inf), so the variable is unconstrained."""
        return _moco.MocoBounds_unconstrained()

    def isSet(self) -> "bool":
        r""" True if the lower and upper bounds are both not NaN."""
        return _moco.MocoBounds_isSet(self)

    def isEquality(self) -> "bool":
        r"""
        True if the lower and upper bounds are the same, resulting in an
        equality constraint.
        """
        return _moco.MocoBounds_isEquality(self)

    def isWithinBounds(self, value: "double const &") -> "bool":
        r""" Returns true if the provided value is within these bounds."""
        return _moco.MocoBounds_isWithinBounds(self, value)

    def getLower(self) -> "double":
        return _moco.MocoBounds_getLower(self)

    def getUpper(self) -> "double":
        return _moco.MocoBounds_getUpper(self)

    def getAsArray(self) -> "OpenSim::Array< double >":
        r"""
        The returned array has either 0, 1, or 2 elements.
           - 0 elements: bounds are not set.
           - 1 element: equality constraint
           - 2 elements: range (inequality constraint).
        """
        return _moco.MocoBounds_getAsArray(self)
    __swig_destroy__ = _moco.delete_MocoBounds

# Register MocoBounds in _moco:
_moco.MocoBounds_swigregister(MocoBounds)

def MocoBounds_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoBounds *":
    return _moco.MocoBounds_safeDownCast(obj)

def MocoBounds_getClassName() -> "std::string const &":
    return _moco.MocoBounds_getClassName()

def MocoBounds_unconstrained() -> "OpenSim::MocoBounds":
    r""" Create bounds that are (-inf, inf), so the variable is unconstrained."""
    return _moco.MocoBounds_unconstrained()


def __lshift__(stream: "std::ostream &", bounds: "MocoBounds") -> "std::ostream &":
    return _moco.__lshift__(stream, bounds)
class MocoInitialBounds(MocoBounds):
    r""" Used for specifying the bounds on a variable at the start of a phase."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialBounds *":
        return _moco.MocoInitialBounds_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInitialBounds_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInitialBounds_getClassName()

    def clone(self) -> "OpenSim::MocoInitialBounds *":
        return _moco.MocoInitialBounds_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInitialBounds_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoInitialBounds_swiginit(self, _moco.new_MocoInitialBounds(*args))
    __swig_destroy__ = _moco.delete_MocoInitialBounds

# Register MocoInitialBounds in _moco:
_moco.MocoInitialBounds_swigregister(MocoInitialBounds)

def MocoInitialBounds_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialBounds *":
    return _moco.MocoInitialBounds_safeDownCast(obj)

def MocoInitialBounds_getClassName() -> "std::string const &":
    return _moco.MocoInitialBounds_getClassName()

class MocoFinalBounds(MocoBounds):
    r""" Used for specifying the bounds on a variable at the end of a phase."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalBounds *":
        return _moco.MocoFinalBounds_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoFinalBounds_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoFinalBounds_getClassName()

    def clone(self) -> "OpenSim::MocoFinalBounds *":
        return _moco.MocoFinalBounds_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoFinalBounds_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoFinalBounds_swiginit(self, _moco.new_MocoFinalBounds(*args))
    __swig_destroy__ = _moco.delete_MocoFinalBounds

# Register MocoFinalBounds in _moco:
_moco.MocoFinalBounds_swigregister(MocoFinalBounds)

def MocoFinalBounds_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalBounds *":
    return _moco.MocoFinalBounds_safeDownCast(obj)

def MocoFinalBounds_getClassName() -> "std::string const &":
    return _moco.MocoFinalBounds_getClassName()

class MocoVariableInfo(opensim.common.OpenSimObject):
    r"""
     Bounds on continuous variables (states, controls, multipliers, etc). For
    states, the name should correspond to a path of a state variable in the
    model. For controls, the name should correspond to a path of an actuator
    in the model, or, for controls associated with actuators that have more than
    one control, the path of an actuator in the model appended by the control
    index (e.g. "/actuator_0").
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoVariableInfo *":
        return _moco.MocoVariableInfo_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoVariableInfo_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoVariableInfo_getClassName()

    def clone(self) -> "OpenSim::MocoVariableInfo *":
        return _moco.MocoVariableInfo_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoVariableInfo_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoVariableInfo_swiginit(self, _moco.new_MocoVariableInfo(*args))

    def getBounds(self) -> "OpenSim::MocoBounds":
        r"""
        Note: the return value is constructed fresh on every call from
        the internal property. Avoid repeated calls to this function.
        """
        return _moco.MocoVariableInfo_getBounds(self)

    def getInitialBounds(self) -> "OpenSim::MocoInitialBounds":
        
        return _moco.MocoVariableInfo_getInitialBounds(self)

    def getFinalBounds(self) -> "OpenSim::MocoFinalBounds":
        
        return _moco.MocoVariableInfo_getFinalBounds(self)

    def setBounds(self, bounds: "MocoBounds") -> "void":
        return _moco.MocoVariableInfo_setBounds(self, bounds)

    def setInitialBounds(self, bounds: "MocoInitialBounds") -> "void":
        return _moco.MocoVariableInfo_setInitialBounds(self, bounds)

    def setFinalBounds(self, bounds: "MocoFinalBounds") -> "void":
        return _moco.MocoVariableInfo_setFinalBounds(self, bounds)

    def validate(self) -> "void":
        r""" Throws an exception if initial and final bounds are not within bounds."""
        return _moco.MocoVariableInfo_validate(self)

    def printDescription(self) -> "void":
        r""" Print the bounds on this variable."""
        return _moco.MocoVariableInfo_printDescription(self)
    __swig_destroy__ = _moco.delete_MocoVariableInfo

# Register MocoVariableInfo in _moco:
_moco.MocoVariableInfo_swigregister(MocoVariableInfo)

def MocoVariableInfo_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoVariableInfo *":
    return _moco.MocoVariableInfo_safeDownCast(obj)

def MocoVariableInfo_getClassName() -> "std::string const &":
    return _moco.MocoVariableInfo_getClassName()

class MocoGoal(opensim.common.OpenSimObject):
    r"""
     A goal is a term in the cost functional to be minimized, or a set of endpoint
    constraints that must lie within provided bounds. Goals depend on the
    phase's initial and final states and controls, and optionally on the
    integral of a quantity over the phase.
    Not all goals support endpoint constraint mode; see
    getSupportsEndpointConstraint(). If a goal does support endpoint constraint
    mode, then the default mode is available via getMode(). Use endpoint
    constraint mode if you require the goal to be met strictly and do not want
    to allow a trade-off between this goal and other goals.
    The calculation of the goal may differ between cost and endpoint constraint
    modes; cost mode may require that outputs are squared, for example.

    # Stage dependency
    Some goals require less of IntegrandInput and GoalInput than others. To
    ensure goals are computed efficiently, goals can specify a stage dependency,
    which tells solvers what to do when preparing IntegrandInput and GoalInput.
    Here are the expectations for each SimTK::Stage:

    - SimTK::Stage::Topology: the time field of IntegrandInput and
        initial_time and final_time fields of GoalInput are available.
    - SimTK::Stage::Model: controls fields of IntegrandInput and
        GoalInput are available.
    - SimTK::Stage::Instance: MocoParameters are applied to the model.
    - SimTK::Stage::Time: state variables (SimTK::State::getY(), etc.) are
        available, and SimTK::Stage::getTime() is updated.
    - SimTK::Stage::Position: state, initial_state, and final_state can be used
        to compute position-dependent quantities.
    - SimTK::Stage::Velocity: state, initial_state, and final_state can be used
        to compute velocity-dependent quantities.
    - SimTK::Stage::Dynamics: state, initial_state, and final_state can be used
        to compute force-dependent quantities.
    - SimTK::Stage::Acceleration: state, initial_state, and final_state can be
        used to compute acceleration-dependent quantities, such as body
        accelerations and joint reactions.

    ## Scale factors
    Goals may include an option to add scale factors to the MocoProblem using
    `appendScaleFactor()`, which takes a MocoScaleFactor object for its argument.
    A copy of this component is added to the Model internal to MocoProblemRep and
    its property value is optimized via a MocoParameter. Scale factor usage is
    specific to each MocoGoal (if used at all).

    Title: For developers
    Every time the problem is solved, a copy of this goal is used. An individual
    instance of a goal is only ever used in a single problem. Therefore, there
    is no need to clear cache variables that you create in initializeImpl().
    Also, information stored in this goal does not persist across multiple
    solves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoGoal *":
        return _moco.MocoGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoGoal_getClassName()

    def clone(self) -> "OpenSim::MocoGoal *":
        return _moco.MocoGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoGoal_getConcreteClassName(self)

    def setEnabled(self, enabled: "bool") -> "void":
        r""" Set whether this goal is used in the problem."""
        return _moco.MocoGoal_setEnabled(self, enabled)

    def getEnabled(self) -> "bool":
        return _moco.MocoGoal_getEnabled(self)

    def setWeight(self, weight: "double") -> "void":
        r"""
        In cost mode, the goal is multiplied by this weight. Use the weight to
        control the relative importance of terms in the cost functional. The
        weight is ignored (e.g., set to 1) in endpoint constraint mode.
        """
        return _moco.MocoGoal_setWeight(self, weight)

    def getWeight(self) -> "double":
        return _moco.MocoGoal_getWeight(self)
    Mode_Cost = _moco.MocoGoal_Mode_Cost
    Mode_EndpointConstraint = _moco.MocoGoal_Mode_EndpointConstraint

    def setMode(self, mode: "std::string") -> "void":
        r"""
        Set the mode property to either 'cost' or 'endpoint_constraint'. This
        should be set before initializing. Setting to 'endpoint_constraint' if
        getSupportsEndpointConstraint() is false causes an exception during
        initializing.
        """
        return _moco.MocoGoal_setMode(self, mode)

    def getModeAsString(self) -> "std::string":
        r"""
        This returns the default mode of the goal, unless the user overrode
        the default using setMode().
        """
        return _moco.MocoGoal_getModeAsString(self)

    def getMode(self) -> "OpenSim::MocoGoal::Mode":
        return _moco.MocoGoal_getMode(self)

    def getModeIsCost(self) -> "bool":
        return _moco.MocoGoal_getModeIsCost(self)

    def getModeIsEndpointConstraint(self) -> "bool":
        return _moco.MocoGoal_getModeIsEndpointConstraint(self)

    def getDefaultMode(self) -> "OpenSim::MocoGoal::Mode":
        r"""
        Types of goals have a class-level default for whether they are enforced
        as a cost or endpoint constraint.
        """
        return _moco.MocoGoal_getDefaultMode(self)

    def getSupportsEndpointConstraint(self) -> "bool":
        r""" Can this goal be used in endpoint constraint mode?"""
        return _moco.MocoGoal_getSupportsEndpointConstraint(self)

    def getConstraintInfo(self) -> "MocoConstraintInfo const &":
        r"""
        Get bounds for the constraints that are enforced when using this goal in
        endpoint constraint mode.
        This info is ignored if getSupportsEndpointConstraint() is false.
        """
        return _moco.MocoGoal_getConstraintInfo(self)

    def updConstraintInfo(self) -> "MocoConstraintInfo &":
        return _moco.MocoGoal_updConstraintInfo(self)

    def getNumOutputs(self) -> "int":
        r""" Get the length of the return value of calcGoal()."""
        return _moco.MocoGoal_getNumOutputs(self)

    def getNumIntegrals(self) -> "int":
        r"""
        Get the number of integrals required by this cost.
        This returns either 0 (for a strictly-endpoint cost) or 1.
        initializeOnModel() has been invoked.
        """
        return _moco.MocoGoal_getNumIntegrals(self)

    def getStageDependency(self) -> "SimTK::Stage":
        r"""
        Obtain the stage that this goal depends on. Solvers can use this to more
        efficiently decide how to set the IntegrandInput and GoalInput. See the
        MocoGoal class description for details about the different stages. The
        stage dependency is the same for both modes of the goal (cost and
        endpoint constraint).
        """
        return _moco.MocoGoal_getStageDependency(self)

    def initializeOnModel(self, model: "Model") -> "void":
        r"""
        Perform error checks on user input for this goal, and cache
        quantities needed when computing the goal value.
        This function must be invoked before invoking calcIntegrand() or
        calcGoal().
        """
        return _moco.MocoGoal_initializeOnModel(self, model)

    def getScaleFactors(self) -> "std::vector< OpenSim::MocoScaleFactor,std::allocator< OpenSim::MocoScaleFactor > >":
        r"""
        Get a vector of the MocoScaleFactors added to this MocoGoal.
        Note: the return value is constructed fresh on every call from
        the internal property. Avoid repeated calls to this function.
        """
        return _moco.MocoGoal_getScaleFactors(self)

    def printDescription(self) -> "void":
        r"""
        Print the name type and mode of this goal. In cost mode, this prints the
        weight.
        """
        return _moco.MocoGoal_printDescription(self)
    __swig_destroy__ = _moco.delete_MocoGoal

# Register MocoGoal in _moco:
_moco.MocoGoal_swigregister(MocoGoal)

def MocoGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoGoal *":
    return _moco.MocoGoal_safeDownCast(obj)

def MocoGoal_getClassName() -> "std::string const &":
    return _moco.MocoGoal_getClassName()

class MocoFinalTimeGoal(MocoGoal):
    r""" Endpoint cost for final time."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalTimeGoal *":
        return _moco.MocoFinalTimeGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoFinalTimeGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoFinalTimeGoal_getClassName()

    def clone(self) -> "OpenSim::MocoFinalTimeGoal *":
        return _moco.MocoFinalTimeGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoFinalTimeGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoFinalTimeGoal_swiginit(self, _moco.new_MocoFinalTimeGoal(*args))
    __swig_destroy__ = _moco.delete_MocoFinalTimeGoal

# Register MocoFinalTimeGoal in _moco:
_moco.MocoFinalTimeGoal_swigregister(MocoFinalTimeGoal)

def MocoFinalTimeGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalTimeGoal *":
    return _moco.MocoFinalTimeGoal_safeDownCast(obj)

def MocoFinalTimeGoal_getClassName() -> "std::string const &":
    return _moco.MocoFinalTimeGoal_getClassName()

class MocoAverageSpeedGoal(MocoGoal):
    r"""
     This goal requires the average speed of the system to match a desired
    average speed. The average speed of the system is the displacement of the
    system's center of mass divided by the duration of the phase.

    In endpoint constraint mode, the goal is computed as follows:

    .. math::

        v_\mathrm{des} - \frac{r_\mathrm{com}(t_f) - r_\mathrm{com}(t_i)}{t_f - t_i}

    We use the following notation:
    - :math:`v_\mathrm{des}`: desired average speed.
    - :math:`r_\mathrm{com}(t)`: mass center position.
    - :math:`t_i`: initial time.
    - :math:`t_f`: final time.

    In cost mode, the value of the goal is the above quantity squared.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAverageSpeedGoal *":
        return _moco.MocoAverageSpeedGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoAverageSpeedGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoAverageSpeedGoal_getClassName()

    def clone(self) -> "OpenSim::MocoAverageSpeedGoal *":
        return _moco.MocoAverageSpeedGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoAverageSpeedGoal_getConcreteClassName(self)

    def copyProperty_desired_average_speed(self, source: "MocoAverageSpeedGoal") -> "void":
        return _moco.MocoAverageSpeedGoal_copyProperty_desired_average_speed(self, source)

    def append_desired_average_speed(self, value: "double const &") -> "int":
        return _moco.MocoAverageSpeedGoal_append_desired_average_speed(self, value)

    def constructProperty_desired_average_speed(self, initValue: "double const &") -> "void":
        return _moco.MocoAverageSpeedGoal_constructProperty_desired_average_speed(self, initValue)

    def get_desired_average_speed(self, *args) -> "double const &":
        return _moco.MocoAverageSpeedGoal_get_desired_average_speed(self, *args)

    def upd_desired_average_speed(self, *args) -> "double &":
        return _moco.MocoAverageSpeedGoal_upd_desired_average_speed(self, *args)

    def set_desired_average_speed(self, *args) -> "void":
        return _moco.MocoAverageSpeedGoal_set_desired_average_speed(self, *args)

    def __init__(self, *args):
        _moco.MocoAverageSpeedGoal_swiginit(self, _moco.new_MocoAverageSpeedGoal(*args))
    __swig_destroy__ = _moco.delete_MocoAverageSpeedGoal

# Register MocoAverageSpeedGoal in _moco:
_moco.MocoAverageSpeedGoal_swigregister(MocoAverageSpeedGoal)

def MocoAverageSpeedGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAverageSpeedGoal *":
    return _moco.MocoAverageSpeedGoal_safeDownCast(obj)

def MocoAverageSpeedGoal_getClassName() -> "std::string const &":
    return _moco.MocoAverageSpeedGoal_getClassName()

class SetMocoWeight(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MocoWeight,OpenSim::Object > *":
        return _moco.SetMocoWeight_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.SetMocoWeight_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.SetMocoWeight_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::MocoWeight,OpenSim::Object > *":
        return _moco.SetMocoWeight_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.SetMocoWeight_getConcreteClassName(self)
    __swig_destroy__ = _moco.delete_SetMocoWeight

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::MocoWeight,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _moco.SetMocoWeight_swiginit(self, _moco.new_SetMocoWeight(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _moco.SetMocoWeight_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _moco.SetMocoWeight_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _moco.SetMocoWeight_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _moco.SetMocoWeight_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`MocoWeight`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _moco.SetMocoWeight_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _moco.SetMocoWeight_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "MocoWeight") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`MocoWeight`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _moco.SetMocoWeight_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "MocoWeight") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`MocoWeight`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _moco.SetMocoWeight_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "MocoWeight") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MocoWeight`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _moco.SetMocoWeight_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MocoWeight`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _moco.SetMocoWeight_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _moco.SetMocoWeight_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "MocoWeight", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`MocoWeight`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _moco.SetMocoWeight_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::MocoWeight &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`MocoWeight`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`MocoWeight`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _moco.SetMocoWeight_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _moco.SetMocoWeight_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _moco.SetMocoWeight_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _moco.SetMocoWeight_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _moco.SetMocoWeight_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _moco.SetMocoWeight_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _moco.SetMocoWeight_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _moco.SetMocoWeight_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _moco.SetMocoWeight_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _moco.SetMocoWeight_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMocoWeight in _moco:
_moco.SetMocoWeight_swigregister(SetMocoWeight)

def SetMocoWeight_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MocoWeight,OpenSim::Object > *":
    return _moco.SetMocoWeight_safeDownCast(obj)

def SetMocoWeight_getClassName() -> "std::string const &":
    return _moco.SetMocoWeight_getClassName()

class MocoWeight(opensim.common.OpenSimObject):
    r"""
     This class contains a single property that holds a weighting factor to be
    used in a MocoGoal. The meaning of the name given to this object depends on
    where the weight is used. In a MocoStateTrackingCost, the name is the name
    (path) of a state variable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoWeight *":
        return _moco.MocoWeight_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoWeight_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoWeight_getClassName()

    def clone(self) -> "OpenSim::MocoWeight *":
        return _moco.MocoWeight_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoWeight_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoWeight_swiginit(self, _moco.new_MocoWeight(*args))

    def setWeight(self, weight: "double") -> "void":
        return _moco.MocoWeight_setWeight(self, weight)

    def getWeight(self) -> "double":
        return _moco.MocoWeight_getWeight(self)
    __swig_destroy__ = _moco.delete_MocoWeight

# Register MocoWeight in _moco:
_moco.MocoWeight_swigregister(MocoWeight)

def MocoWeight_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoWeight *":
    return _moco.MocoWeight_safeDownCast(obj)

def MocoWeight_getClassName() -> "std::string const &":
    return _moco.MocoWeight_getClassName()

class MocoWeightSet(SetMocoWeight):
    r"""
     A container for %Moco weights. The meaning of the weights depends upon
    where they are used. This container can be written to and read from an
    XML file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoWeightSet *":
        return _moco.MocoWeightSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoWeightSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoWeightSet_getClassName()

    def clone(self) -> "OpenSim::MocoWeightSet *":
        return _moco.MocoWeightSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoWeightSet_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoWeightSet_swiginit(self, _moco.new_MocoWeightSet(*args))
    __swig_destroy__ = _moco.delete_MocoWeightSet

# Register MocoWeightSet in _moco:
_moco.MocoWeightSet_swigregister(MocoWeightSet)

def MocoWeightSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoWeightSet *":
    return _moco.MocoWeightSet_safeDownCast(obj)

def MocoWeightSet_getClassName() -> "std::string const &":
    return _moco.MocoWeightSet_getClassName()

class MocoStateTrackingGoal(MocoGoal):
    r"""
    The squared difference between a state variable
    value and a reference state variable value, summed over the state variables for which a
    reference is provided, and integrated over the phase. This can be used to
    track joint angles, activations, etc.
    The reference can be provided as a file name to a STO or CSV file (or
    other file types for which there is a FileAdapter), or programmatically
    as a TimeSeriesTable. If columns for rotational coordinates are in degrees,
    those columns will be converted to radians.
    Tracking problems in direct collocation perform best when tracking smooth
    data, so it is recommended to filter the data in the reference you provide
    to the cost.

    ## Scale factors

    Use `addScaleFactor()` to add a MocoParameter to the MocoProblem that will
    scale the tracking reference data associated with a state in the tracking cost.
    Scale factors for this goal can be useful if the magnitude of the tracking
    reference data is either unknown or unreliable (e.g., pelvis height).
    Scale factors are applied to the tracking error calculations based on the
    following equation:

        error = modelValue - scaleFactor * referenceValue

    In other words, scale factors are applied when computing the tracking error for
    each state, not to the reference data directly.

    Adding a scale factor to a MocoStateTrackingGoal.

    .. code-block:: c++

        auto* stateTrackingGoal = problem.addGoal<MocoStateTrackingGoal>();
        ...
        stateTrackingGoal->addScaleFactor(
                'pelvis_ty_scale_factor', '/jointset/ground_pelvis/pelvis_ty/value',
                {0.5, 2.0});

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStateTrackingGoal *":
        return _moco.MocoStateTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoStateTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoStateTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoStateTrackingGoal *":
        return _moco.MocoStateTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoStateTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoStateTrackingGoal_swiginit(self, _moco.new_MocoStateTrackingGoal(*args))

    def setReference(self, ref: "TableProcessor") -> "void":
        r"""
        Provide a table containing reference values for the
        states you want to track. Each column label must be the path of a state
        variable, e.g., `knee/flexion/value`.
        The table is not loaded until the MocoProblem is initialized.
        """
        return _moco.MocoStateTrackingGoal_setReference(self, ref)

    def getReference(self) -> "OpenSim::TableProcessor const &":
        r""" If no reference has been provided, this returns an empty processor."""
        return _moco.MocoStateTrackingGoal_getReference(self)

    def setWeightForState(self, stateName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual state variable. If a weight is
        already set for the requested state, then the provided weight
        replaces the previous weight. An exception is thrown if a weight
        for an unknown state is provided.
        """
        return _moco.MocoStateTrackingGoal_setWeightForState(self, stateName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight the state variables in the cost.
        Replaces the weight set if it already exists.
        """
        return _moco.MocoStateTrackingGoal_setWeightSet(self, weightSet)

    def setPattern(self, pattern: "std::string") -> "void":
        r"""
        Only state paths matching the regular expression are tracked. The
        regular expression must match the entire state path for a state path to
        be tracked (that is, we use std::regex_match, not std::regex_search).
        To track only generalized coordinates, use `.*value$`.
        To track generalized coordinates and speeds, use `.*(value|speed)$`.
        To track only activations, use `.*activation$`.
        If the reference contains columns for states whose path does not match
        this pattern, you will get an error unless you use
        `setAllowUnusedReferences(true)`.
        """
        return _moco.MocoStateTrackingGoal_setPattern(self, pattern)

    def clearPattern(self) -> "void":
        r""" Unset the pattern, which causes all states to be matched."""
        return _moco.MocoStateTrackingGoal_clearPattern(self)

    def getPattern(self) -> "std::string":
        return _moco.MocoStateTrackingGoal_getPattern(self)

    def setAllowUnusedReferences(self, tf: "bool") -> "void":
        r"""
        Specify whether or not extra columns in the reference are allowed.
        If set true, the extra references will be ignored by the cost.
        If false, extra reference will cause an Exception to be raised.
        """
        return _moco.MocoStateTrackingGoal_setAllowUnusedReferences(self, tf)

    def setScaleWeightsWithRange(self, tf: "bool") -> "void":
        r"""
        Use the range, or the distance between the maximum and minimum value, of
        each reference quantity to scale the weight for the associated tracking
        error in the cost. The scale is computed by the inverse of the range,
        so a reference quantity that changes less across the trajectory has a
        larger weight. Each reference has a default weight of 1, so this flag
        works even if no user weights have be set. This may be useful when
        tracking quantities with different units, which may have tracking errors
        with different magnitudes.
        """
        return _moco.MocoStateTrackingGoal_setScaleWeightsWithRange(self, tf)

    def addScaleFactor(self, name: "std::string const &", state: "std::string const &", bounds: "MocoBounds") -> "void":
        r"""
        Add a MocoParameter to the problem that will scale the tracking reference
        data associated with the specified state. Scale factors are applied
        to the tracking error calculations based on the following equation:

            error = modelValue - scaleFactor * referenceValue

        In other words, the scale factor is applied when computing the tracking
        error for each state, not to the reference data directly.
        """

        if not type(bounds) is MocoBounds:
            bounds = self._convert(MocoBounds, bounds)


        return _moco.MocoStateTrackingGoal_addScaleFactor(self, name, state, bounds)


    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)

    __swig_destroy__ = _moco.delete_MocoStateTrackingGoal

# Register MocoStateTrackingGoal in _moco:
_moco.MocoStateTrackingGoal_swigregister(MocoStateTrackingGoal)

def MocoStateTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStateTrackingGoal *":
    return _moco.MocoStateTrackingGoal_safeDownCast(obj)

def MocoStateTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoStateTrackingGoal_getClassName()

class MocoMarkerTrackingGoal(MocoGoal):
    r"""
    The squared difference between a model marker
    location and an experimental reference marker location, summed over the markers for which an
    experimental data location is provided, and integrated over the phase.
    The reference can be provided as a file name to a TRC file, or
    programmatically as a TimeSeriesTable.

    ## Scale factors

    Use `addScaleFactor()` to add a MocoParameter to the MocoProblem that will
    scale the tracking reference data associated with a marker in the tracking cost.
    Scale factors for this goal can be useful if the magnitude of the tracking
    reference data is either unknown or unreliable (e.g., pelvis marker Y-value).
    Scale factors are applied to the tracking error calculations based on the
    following equation:

        error = modelValue - scaleFactor * referenceValue

    In other words, scale factors are applied when computing the tracking error for
    each marker, not to the reference data directly.

    Adding a scale factor to a MocoMarkerTrackingGoal.

    .. code-block:: c++

        auto* markerTrackingGoal = problem.addGoal<MocoMarkerTrackingGoal>();
        ...
        markerTrackingGoal->addScaleFactor(
                'LPSIS_y_scale_factor', 'LPSIS', 1, {0.5, 2.0});

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoMarkerTrackingGoal *":
        return _moco.MocoMarkerTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoMarkerTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoMarkerTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoMarkerTrackingGoal *":
        return _moco.MocoMarkerTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoMarkerTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoMarkerTrackingGoal_swiginit(self, _moco.new_MocoMarkerTrackingGoal(*args))

    def setMarkersReference(self, arg2: "MarkersReference") -> "void":
        r"""
        Provide a MarkersReference object containing the marker trajectories to
           be tracked by a model. The MarkersReferences can be created from a file
           of marker trajectories (e.g. .trc) or created programmatically via a
           TimeSeriesTableVec3. The marker weights property can be optionally
           specified to weight the tracking of individual markers in the cost
           function. Names of markers in the reference to be tracked should match
           the names of corresponding model markers.
        """
        return _moco.MocoMarkerTrackingGoal_setMarkersReference(self, arg2)

    def getMarkersReference(self) -> "OpenSim::MarkersReference":
        r"""
        If no MarkersReference has been specified, this returns an empty
           MarkersReference object.
        """
        return _moco.MocoMarkerTrackingGoal_getMarkersReference(self)

    def setAllowUnusedReferences(self, tf: "bool") -> "void":
        r"""
        Specify if the markers_reference can contain marker data for a marker
           not in the model. An exception is raised if set to false and marker
           data exists for a marker not included in the model.
        """
        return _moco.MocoMarkerTrackingGoal_setAllowUnusedReferences(self, tf)

    def addScaleFactor(self, name: "std::string const &", marker: "std::string const &", index: "int", bounds: "MocoBounds") -> "void":
        r"""
        Add a MocoParameter to the problem that will scale the tracking reference
        data associated with the specified marker. Scale factors are applied
        to the tracking error calculations based on the following equation:

            error = modelValue - scaleFactor * referenceValue

        In other words, the scale factor is applied when computing the tracking
        error for each marker, not to the reference data directly. You must
        specify both the marker name and the index corresponding to the direction
        in ground (i.e., X = 0, Y = 1, Z = 2) of the scaled value.
        """

        if not type(bounds) is MocoBounds:
            bounds = self._convert(MocoBounds, bounds)


        return _moco.MocoMarkerTrackingGoal_addScaleFactor(self, name, marker, index, bounds)


    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)

    __swig_destroy__ = _moco.delete_MocoMarkerTrackingGoal

# Register MocoMarkerTrackingGoal in _moco:
_moco.MocoMarkerTrackingGoal_swigregister(MocoMarkerTrackingGoal)

def MocoMarkerTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoMarkerTrackingGoal *":
    return _moco.MocoMarkerTrackingGoal_safeDownCast(obj)

def MocoMarkerTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoMarkerTrackingGoal_getClassName()

class MocoMarkerFinalGoal(MocoGoal):
    r"""
     The squared distance between a single model point location and reference
    location in the final state.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoMarkerFinalGoal *":
        return _moco.MocoMarkerFinalGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoMarkerFinalGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoMarkerFinalGoal_getClassName()

    def clone(self) -> "OpenSim::MocoMarkerFinalGoal *":
        return _moco.MocoMarkerFinalGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoMarkerFinalGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoMarkerFinalGoal_swiginit(self, _moco.new_MocoMarkerFinalGoal(*args))

    def setPointName(self, pointName: "std::string") -> "void":
        r"""
        The name of a Point (e.g., Marker, Station) in the model whose
        final location should match the reference.
        """
        return _moco.MocoMarkerFinalGoal_setPointName(self, pointName)

    def setReferenceLocation(self, refLocationInGround: "Vec3") -> "void":
        r""" Set the desired final location of the point, expressed in ground."""
        return _moco.MocoMarkerFinalGoal_setReferenceLocation(self, refLocationInGround)
    __swig_destroy__ = _moco.delete_MocoMarkerFinalGoal

# Register MocoMarkerFinalGoal in _moco:
_moco.MocoMarkerFinalGoal_swigregister(MocoMarkerFinalGoal)

def MocoMarkerFinalGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoMarkerFinalGoal *":
    return _moco.MocoMarkerFinalGoal_safeDownCast(obj)

def MocoMarkerFinalGoal_getClassName() -> "std::string const &":
    return _moco.MocoMarkerFinalGoal_getClassName()

class MocoControlGoal(MocoGoal):
    r"""
     Minimize the sum of the absolute value of the controls raised to a given
    exponent, integrated over the phase. The default weight for each control is
    1.0; this can be changed by calling setWeight() or editing the
    `control_weights` property in XML.
    The exponent must be an integer greater than or equal to 2,
    and is 2 by default.
    If conducting a predictive simulation, you likely want to set
    `divide_by_displacement` to true; otherwise, this cost is minimized by not
    moving. Dividing by displacement leads to a quantity similar to cost of
    transport.

    This goal is computed as follows:

    .. math::

        \frac{1}{d} \int_{t_i}^{t_f} \sum_{c \in C} w_c |x_c(t)|^p ~dt
    We use the following notation:
    - :math:`d`: displacement of the system, if `divide_by_displacement` is
      true; 1 otherwise.
    - :math:`C`: the set of control signals.
    - :math:`w_c`: the weight for control :math:`c`.
    - :math:`x_c(t)`: control signal :math:`c`.
    - :math:`p`: the `exponent`.

    If `p > 2`, we first take the absolute value of the control; this is to properly
    handle odd exponents.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlGoal *":
        return _moco.MocoControlGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoControlGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoControlGoal_getClassName()

    def clone(self) -> "OpenSim::MocoControlGoal *":
        return _moco.MocoControlGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoControlGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoControlGoal_swiginit(self, _moco.new_MocoControlGoal(*args))

    def setWeightForControl(self, controlName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight to use for the term in the cost associated with
        `controlName` (the name or path of the corresponding actuator). To
        remove a control from the cost function, set its weight to 0. If a
        weight is already set for the requested state, then the provided
        weight replaces the previous weight. Only controls with non-zero weights
        that are associated with actuators for which appliesForce is True are
        included in the cost function. Weights set here take precedence over
        weights specified with a regular expression.
        """
        return _moco.MocoControlGoal_setWeightForControl(self, controlName, weight)

    def setWeightForControlPattern(self, pattern: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set weights for all controls whose entire path matches the provided
        regular expression pattern.
        Multiple pairs of patterns and weights can be provided by calling this
        function multiple times.
        If a control matches multiple patterns, the weight associated with the
        last pattern is used.
        """
        return _moco.MocoControlGoal_setWeightForControlPattern(self, pattern, weight)

    def setExponent(self, exponent: "int") -> "void":
        r""" Set the exponent on the control signals."""
        return _moco.MocoControlGoal_setExponent(self, exponent)

    def getExponent(self) -> "double":
        return _moco.MocoControlGoal_getExponent(self)

    def setDivideByDisplacement(self, tf: "bool") -> "void":
        r"""
        Set if the goal should be divided by the displacement of the system's
           center of mass over the phase.
        """
        return _moco.MocoControlGoal_setDivideByDisplacement(self, tf)

    def getDivideByDisplacement(self) -> "bool":
        return _moco.MocoControlGoal_getDivideByDisplacement(self)
    __swig_destroy__ = _moco.delete_MocoControlGoal

# Register MocoControlGoal in _moco:
_moco.MocoControlGoal_swigregister(MocoControlGoal)

def MocoControlGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlGoal *":
    return _moco.MocoControlGoal_safeDownCast(obj)

def MocoControlGoal_getClassName() -> "std::string const &":
    return _moco.MocoControlGoal_getClassName()

class MocoControlTrackingGoalReference(opensim.common.OpenSimObject):
    r""" Associate a control variable with a column from the reference data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlTrackingGoalReference *":
        return _moco.MocoControlTrackingGoalReference_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoControlTrackingGoalReference_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoControlTrackingGoalReference_getClassName()

    def clone(self) -> "OpenSim::MocoControlTrackingGoalReference *":
        return _moco.MocoControlTrackingGoalReference_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoControlTrackingGoalReference_getConcreteClassName(self)

    def copyProperty_reference(self, source: "MocoControlTrackingGoalReference") -> "void":
        return _moco.MocoControlTrackingGoalReference_copyProperty_reference(self, source)

    def append_reference(self, value: "std::string const &") -> "int":
        return _moco.MocoControlTrackingGoalReference_append_reference(self, value)

    def constructProperty_reference(self, initValue: "std::string const &") -> "void":
        return _moco.MocoControlTrackingGoalReference_constructProperty_reference(self, initValue)

    def get_reference(self, *args) -> "std::string const &":
        return _moco.MocoControlTrackingGoalReference_get_reference(self, *args)

    def upd_reference(self, *args) -> "std::string &":
        return _moco.MocoControlTrackingGoalReference_upd_reference(self, *args)

    def set_reference(self, *args) -> "void":
        return _moco.MocoControlTrackingGoalReference_set_reference(self, *args)

    def __init__(self, *args):
        r"""
        Provide the name of a control and the label of the column from the
           reference that this control should track.
        """
        _moco.MocoControlTrackingGoalReference_swiginit(self, _moco.new_MocoControlTrackingGoalReference(*args))
    __swig_destroy__ = _moco.delete_MocoControlTrackingGoalReference

# Register MocoControlTrackingGoalReference in _moco:
_moco.MocoControlTrackingGoalReference_swigregister(MocoControlTrackingGoalReference)

def MocoControlTrackingGoalReference_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlTrackingGoalReference *":
    return _moco.MocoControlTrackingGoalReference_safeDownCast(obj)

def MocoControlTrackingGoalReference_getClassName() -> "std::string const &":
    return _moco.MocoControlTrackingGoalReference_getClassName()

class MocoControlTrackingGoal(MocoGoal):
    r"""
    The squared difference between a control
    variable value and a reference control variable value, summed over the control variables for which a
    reference is provided, and integrated over the phase. This can be used to
    track actuator controls, muscle excitations, etc.

    This goal is computed as follows:

    .. math::

        \int_{t_i}^{t_f}
                \sum_{c \in C} w_c \|x_{m,c}(t) - x_{e,c})\|^2 ~dt
    We use the following notation:
    - :math:`t_i`: the initial time of this phase.
    - :math:`t_f`: the final time of this phase.
    - :math:`C`: the set of control variables being tracked.
    - :math:`w_c`: the weight for control :math:`c`.
    - :math:`x_{m,c}(t)`: control signal :math:`c`.
    - :math:`x_{e,c}(t)`: reference data for control signal :math:`c`.

    This goal has two labeling modes: 'auto' and 'manual':
    - 'auto': The column labels of the reference must exactly match the names
              of controls, and all controls with a matching column in the
              reference data are tracked. By default, all column labels for the
              reference data must match the name of a control.
              Setting `allow_unused_references` to false allows
              the reference to contain columns whose labels do not match a
              control; such columns are then ignored.
    - 'manual': The association between controls and columns of the reference
                data is manually specified via the `reference_labels` property.
                Only the controls for which a reference label is specified are
                tracked.
                Enter this mode by providing reference labels through
                the `reference_labels` property or the `setReferenceLabel()`
                function.
                The `allow_unused_references` property does not apply in this
                mode.

    ## Control variable names

    Control variable names are based on paths to actuators,
    e.g., `/forceset/soleus_r`. For non-scalar actuators, the control variable
    name includes the index for the actuator control;
    e.g., `/forceset/body_actuator_0`, where
    'body_actuator' is the name of the actuator and `_0` specifies the
    control index.

    ## Reference data

    The reference can be provided as a file name to a STO or CSV file (or
    other file types for which there is a FileAdapter), or programmatically
    as a TimeSeriesTable.

    ## Scale factors

    Use `addScaleFactor()` to add a MocoParameter to the MocoProblem that will
    scale the tracking reference data associated with a control in the tracking cost.
    Scale factors for this goal can be useful if the magnitude of the tracking
    reference data is either unknown or unreliable (e.g., electromyography data).
    Scale factors are applied to the tracking error calculations based on the
    following equation:

        error = modelValue - scaleFactor * referenceValue

    In other words, scale factors are applied when computing the tracking error for
    each control, not to the reference data directly. Therefore, if a column in the
    reference data is tracked by two different controls, the scale factor will only
    scale the column for the associated control. The tracking error for the other
    control is unaffected.

    Adding a scale factor to a MocoControlTrackingGoal.

    .. code-block:: c++

        auto* controlTrackingGoal = problem.addGoal<MocoControlTrackingGoal>();
        ...
        controlTrackingGoal->addScaleFactor(
                'soleus_scale_factor', '/forceset/soleus_r', {0.01, 1.0});

    ## Helpful tips

    Tracking problems in direct collocation perform best when tracking smooth
    data, so it is recommended to filter the data in the reference you provide
    to the cost.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlTrackingGoal *":
        return _moco.MocoControlTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoControlTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoControlTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoControlTrackingGoal *":
        return _moco.MocoControlTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoControlTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoControlTrackingGoal_swiginit(self, _moco.new_MocoControlTrackingGoal(*args))

    def setReference(self, ref: "TableProcessor") -> "void":
        r"""
        Provide a table containing reference values for the
        controls you want to track.
        In 'auto' labeling mode, each column label must be a control variable
        name. In 'manual' labeling mode, the column labels need not be control
        variable names; use setReferenceLabel() to associate controls with
        columns.
        The table is not loaded until the MocoProblem is initialized.
        """
        return _moco.MocoControlTrackingGoal_setReference(self, ref)

    def setWeightForControl(self, controlName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual control variable. If a weight is
        already set for the requested control, then the provided weight
        replaces the previous weight.
        If no weight is specified for a control, a weight of 1.0 is used
        internally.
        Set the weight to 0 to avoid tracking a given control.
        An exception is thrown if a weight for an unknown control is provided.
        """
        return _moco.MocoControlTrackingGoal_setWeightForControl(self, controlName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight the control variables in the cost.
        Replaces the weight set if it already exists.
        """
        return _moco.MocoControlTrackingGoal_setWeightSet(self, weightSet)

    def setReferenceLabel(self, control: "std::string const &", label: "std::string const &") -> "void":
        r"""
        Set the column of the reference data that a given control should track.
        Multiple controls can track the same column of the reference data.
        This replaces the reference label for the given control, if one had
        already been provided.
        If controls are not manually associated with a reference label, then
        it is assumed that the column labels for the reference data exactly
        match the names of controls.
        """
        return _moco.MocoControlTrackingGoal_setReferenceLabel(self, control, label)

    def clearReferenceLabels(self) -> "void":
        r"""
        Clear the 'reference_labels' property, which ensures this goal is used
        in 'auto' labeling mode.
        """
        return _moco.MocoControlTrackingGoal_clearReferenceLabels(self)

    def setAllowUnusedReferences(self, tf: "bool") -> "void":
        r"""
        Specify whether the reference can have columns not associated with
        controls.
        If set true, then such columns will be ignored by the cost.
        If false, such columns will cause an Exception to be raised.
        Only takes effect in 'auto' labeling mode.
        """
        return _moco.MocoControlTrackingGoal_setAllowUnusedReferences(self, tf)

    def getReference(self) -> "OpenSim::TableProcessor const &":
        r""" If no reference has been provided, this returns an empty processor."""
        return _moco.MocoControlTrackingGoal_getReference(self)

    def hasReferenceLabel(self, control: "std::string const &") -> "bool":
        return _moco.MocoControlTrackingGoal_hasReferenceLabel(self, control)

    def getReferenceLabel(self, control: "std::string const &") -> "std::string":
        return _moco.MocoControlTrackingGoal_getReferenceLabel(self, control)

    def getAllowUnusedReferences(self) -> "bool":
        return _moco.MocoControlTrackingGoal_getAllowUnusedReferences(self)

    def addScaleFactor(self, name: "std::string const &", control: "std::string const &", bounds: "MocoBounds") -> "void":
        r"""
        Add a MocoParameter to the problem that will scale the tracking reference
        data associated with the specified control. Scale factors are applied
        to the tracking error calculations based on the following equation:

            error = modelValue - scaleFactor * referenceValue

        In other words, the scale factor is applied when computing the tracking
        error for each control, not to the reference data directly. Therefore, if
        a column in the reference data is tracked by two different controls, the
        scale factor will only scale the column for the associated control. The
        tracking error for the other control is unaffected.
        """

        if not type(bounds) is MocoBounds:
            bounds = self._convert(MocoBounds, bounds)


        return _moco.MocoControlTrackingGoal_addScaleFactor(self, name, control, bounds)


    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)

    __swig_destroy__ = _moco.delete_MocoControlTrackingGoal

# Register MocoControlTrackingGoal in _moco:
_moco.MocoControlTrackingGoal_swigregister(MocoControlTrackingGoal)

def MocoControlTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlTrackingGoal *":
    return _moco.MocoControlTrackingGoal_safeDownCast(obj)

def MocoControlTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoControlTrackingGoal_getClassName()

class MocoContactTrackingGoalGroup(opensim.common.OpenSimObject):
    r"""
    A contact group consists of the name of a single ExternalForce and a list of
    contact force component paths in the model. The MocoContactTrackingGoal
    calculates the difference between the data from the ExternalForce and the sum of
    the forces from the contact force components.

    ## Alternative frame paths

    Contact force elements that correspond to a single ExternalForce are
    typically attached to the same single body/frame. However, it is possible
    that these contact force elements are spread over multiple bodies. For
    example, the ground reaction force for the left foot may be modeled by
    contact force elements on separate calcaneus and toe body segments.
    The "applied_to_body" property of the associated ExternalForce will match
    only one of these multiple bodies (e.g., only the calcaneus), causing Moco
    to give an error, saying one of the contact elements does not seem to be
    associated with the ExternalForce. To handle this situation, specify the
    other* body (e.g., the toes) under alternative_frame_paths. Without
    specifying these alternative frames, Moco does not know which force to use
    (the force on the sphere or the force on the half-space) when summing the
    contact forces across contact force elements.

    See also: MocoContactTrackingGoal
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoContactTrackingGoalGroup *":
        return _moco.MocoContactTrackingGoalGroup_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoContactTrackingGoalGroup_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoContactTrackingGoalGroup_getClassName()

    def clone(self) -> "OpenSim::MocoContactTrackingGoalGroup *":
        return _moco.MocoContactTrackingGoalGroup_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoContactTrackingGoalGroup_getConcreteClassName(self)

    def copyProperty_contact_force_paths(self, source: "MocoContactTrackingGoalGroup") -> "void":
        return _moco.MocoContactTrackingGoalGroup_copyProperty_contact_force_paths(self, source)

    def get_contact_force_paths(self, i: "int") -> "std::string const &":
        return _moco.MocoContactTrackingGoalGroup_get_contact_force_paths(self, i)

    def upd_contact_force_paths(self, i: "int") -> "std::string &":
        return _moco.MocoContactTrackingGoalGroup_upd_contact_force_paths(self, i)

    def set_contact_force_paths(self, i: "int", value: "std::string const &") -> "void":
        return _moco.MocoContactTrackingGoalGroup_set_contact_force_paths(self, i, value)

    def append_contact_force_paths(self, value: "std::string const &") -> "int":
        return _moco.MocoContactTrackingGoalGroup_append_contact_force_paths(self, value)

    def constructProperty_contact_force_paths(self) -> "void":
        return _moco.MocoContactTrackingGoalGroup_constructProperty_contact_force_paths(self)

    def copyProperty_external_force_name(self, source: "MocoContactTrackingGoalGroup") -> "void":
        return _moco.MocoContactTrackingGoalGroup_copyProperty_external_force_name(self, source)

    def append_external_force_name(self, value: "std::string const &") -> "int":
        return _moco.MocoContactTrackingGoalGroup_append_external_force_name(self, value)

    def constructProperty_external_force_name(self, initValue: "std::string const &") -> "void":
        return _moco.MocoContactTrackingGoalGroup_constructProperty_external_force_name(self, initValue)

    def get_external_force_name(self, *args) -> "std::string const &":
        return _moco.MocoContactTrackingGoalGroup_get_external_force_name(self, *args)

    def upd_external_force_name(self, *args) -> "std::string &":
        return _moco.MocoContactTrackingGoalGroup_upd_external_force_name(self, *args)

    def set_external_force_name(self, *args) -> "void":
        return _moco.MocoContactTrackingGoalGroup_set_external_force_name(self, *args)

    def copyProperty_alternative_frame_paths(self, source: "MocoContactTrackingGoalGroup") -> "void":
        return _moco.MocoContactTrackingGoalGroup_copyProperty_alternative_frame_paths(self, source)

    def get_alternative_frame_paths(self, i: "int") -> "std::string const &":
        return _moco.MocoContactTrackingGoalGroup_get_alternative_frame_paths(self, i)

    def upd_alternative_frame_paths(self, i: "int") -> "std::string &":
        return _moco.MocoContactTrackingGoalGroup_upd_alternative_frame_paths(self, i)

    def set_alternative_frame_paths(self, i: "int", value: "std::string const &") -> "void":
        return _moco.MocoContactTrackingGoalGroup_set_alternative_frame_paths(self, i, value)

    def append_alternative_frame_paths(self, value: "std::string const &") -> "int":
        return _moco.MocoContactTrackingGoalGroup_append_alternative_frame_paths(self, value)

    def constructProperty_alternative_frame_paths(self) -> "void":
        return _moco.MocoContactTrackingGoalGroup_constructProperty_alternative_frame_paths(self)

    def __init__(self, *args):
        _moco.MocoContactTrackingGoalGroup_swiginit(self, _moco.new_MocoContactTrackingGoalGroup(*args))
    __swig_destroy__ = _moco.delete_MocoContactTrackingGoalGroup

# Register MocoContactTrackingGoalGroup in _moco:
_moco.MocoContactTrackingGoalGroup_swigregister(MocoContactTrackingGoalGroup)

def MocoContactTrackingGoalGroup_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoContactTrackingGoalGroup *":
    return _moco.MocoContactTrackingGoalGroup_safeDownCast(obj)

def MocoContactTrackingGoalGroup_getClassName() -> "std::string const &":
    return _moco.MocoContactTrackingGoalGroup_getClassName()

class MocoContactTrackingGoal(MocoGoal):
    r"""
    Minimize the error between compliant contact force elements in the model and
    experimentally measured contact forces.

    This class handles multiple groups of contact forces and a single
    experimental external loads file. Tracking ground reaction forces for the
    left and right feet in gait requires only one instance of this goal.

    Notes: The only contact element supported is SmoothSphereHalfSpaceForce.

    This goal does not include torques or centers of pressure.

    This goal is computed as follows:

    .. math::

        \frac{1}{mg} \int_{t_i}^{t_f}
                \sum_{j \in G}
                    \|\mathrm{proj}_{\hat{n}}(\vec{F}_{m,j} - \vec{F}_{e,j})\|^2 ~dt
    We use the following notation:
    - :math:`t_i`: the initial time of this phase.
    - :math:`t_f`: the final time of this phase.
    - :math:`mg`: the total weight of the system; replaced with
        :math:`m` if :math:`g = 0`.
    - :math:`G`: the set of contact groups.
    - :math:`\hat{n}`: a vector used for projecting the force error.
    - :math:`\mathrm{proj}_{\hat{n}}()`: this function projects the force error
        either onto :math:`\hat{n}` or onto the plane perpendicular to
        :math:`\hat{n}`.
    - :math:`\vec{F}_{m,j}` the sum of the contact forces in group :math:`j`,
        expressed in ground.
    - :math:`\vec{F}_{e,j}` the experimental contact force for group :math:`j`,
        expressed in ground.

    # Tracking a subset of force components

    The projection is useful for selecting which components of the force to
    track. The force can be projected to be onto a vector or
    onto a plane. For example, with gait, projecting onto the vector (0, 1, 0)
    allows tracking only the vertical component of a ground reaction force;
    projecting onto the plane perpendicular to the vector (0, 0, 1) allows
    ignoring the transverse force. See the projection and projection_vector
    properties.

    ## Usage

    To use this goal, specify the following:
    - a single ExternalLoads file or object, which is a set of ExternalForces.
    - a set of contact groups, each of which contains the name of an
        ExternalForce (within the ExternalLoads).

    ### Configuring the ExternalLoads

    The ExternalLoads class is the standard way to provide experimental contact
    forces in OpenSim. This class is a set of ExternalForce objects. For gait,
    typically the ExternalLoads contains 2 ExternalForces, one for each foot.
    This goal uses the following information from ExternalLoads:
    - **data_file**: This scalar file contains all experimental force data with
      columns named according to each ExternalForce's force_identifier.

    This goal uses the following information from each ExternalForce:
    - **name**: We use the name of the ExternalForce to associate it with a
      contact force group.
    - **applied_on_body**: All contact forces in the group with which this
      ExternalForce is associated must use this body as either the
      sphere_frame's base frame or the half_space_frame's base frame.
    - **force_expressed_in_body**: We use this to re-express the experimental
      force in ground. This is either the absolute path to a PhysicalFrame in
      the model, or the name of a Body in the model's BodySet.
    - **force_identifier**: The ExternalLoads data_file must include the 3
      columns
      `<force_identifier>x`, `<force_identifier>y`, `<force_identifier>z`.

    All other properties of ExternalLoads and ExternalForce are ignored by this
    goal. This means that experimental forces are processed differently by this
    goal than by other OpenSim tools such as Inverse Dynamics, Computed Muscle
    Control, and Forward.

    The ExternalLoads used by this goal is separate from the model. Using
    this goal implies that the model contains compliant contact forces, so
    adding ExternalLoads to the model would be redundant. This class uses the
    ExternalLoads *only* for computing the force error, not for applying forces
    to the model.

    ### Scale factors

    Add a MocoParameter to the problem that will scale the tracking reference
    data associated with a contact force group. Scale factors are applied
    to the tracking error calculations based on the following equation:

         error = modelValue - scaleFactor * referenceValue

    In other words, the scale factor is applied when computing the tracking
    error for each contact force group, not to the reference data directly.
    You must specify both the external force name associated with the contact
    force group and the index corresponding to the direction (i.e., X = 0,
    Y = 1, Z = 2) of the scaled force value. The direction is applied in
    whatever frame the reference data is expressed in based on the provided
    ExternalLoads in each contact group.

    Adding a scale factor to a MocoContactTrackingGoal.

    .. code-block:: c++

        auto* markerTrackingGoal = problem.addGoal<MocoContactTrackingGoal>();
        ...
        markerTrackingGoal->addScaleFactor(
                'RightGRF_vertical_scale_factor', 'Right_GRF', 1, {0.5, 2.0});

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoContactTrackingGoal *":
        return _moco.MocoContactTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoContactTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoContactTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoContactTrackingGoal *":
        return _moco.MocoContactTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoContactTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoContactTrackingGoal_swiginit(self, _moco.new_MocoContactTrackingGoal(*args))

    def setExternalLoadsFile(self, extLoadsFile: "std::string const &") -> "void":
        r"""
        Set the ExternalLoads as an XML file. This clears the ExternalLoads
        provided as an object, if one exists.
        """
        return _moco.MocoContactTrackingGoal_setExternalLoadsFile(self, extLoadsFile)

    def setExternalLoads(self, extLoads: "ExternalLoads") -> "void":
        r"""
        Set the ExternalLoads as an object. This clears the ExternalLoads
        XML file, if provided.
        """
        return _moco.MocoContactTrackingGoal_setExternalLoads(self, extLoads)

    def addContactGroup(self, *args) -> "void":
        r"""
        *Overload 1:*
        Add a group of contact forces whose sum should track the force data from
        a single ExternalForce. The externalForceName should be the name of an
        ExternalForce object in the ExternalLoads.

        |

        *Overload 2:*
        Add a group of contact forces whose sum should track the force data from
        a single ExternalForce.
        If the contact force elements associated with a single ExternalForce are
        distributed across multiple bodies use this function instead of the
        easier-to-use addContactGroup(), and set the group's
        alternative_frame_paths property accordingly. See
        MocoContactTrackingGoalGroup for more information.
        """
        return _moco.MocoContactTrackingGoal_addContactGroup(self, *args)

    def setProjection(self, projection: "std::string") -> "void":
        r"""
        Set if the force error should be projected onto either a vector or
        plane. Possible values: "none" (default), "vector", and "plane".
        """
        return _moco.MocoContactTrackingGoal_setProjection(self, projection)

    def getProjection(self) -> "std::string":
        return _moco.MocoContactTrackingGoal_getProjection(self)

    def setProjectionVector(self, normal: "Vec3") -> "void":
        r"""
        Set the vector to use for projecting the force error.
        If the projection type is "vector", the force error is projected onto
        the vector provided here. If the projection type is "plane", the force
        error is projected onto the plane perpendicular to this vector.
        """
        return _moco.MocoContactTrackingGoal_setProjectionVector(self, normal)

    def clearProjectionVector(self) -> "void":
        r""" Unset the projection vector."""
        return _moco.MocoContactTrackingGoal_clearProjectionVector(self)

    def getProjectionVector(self) -> "SimTK::Vec3":
        return _moco.MocoContactTrackingGoal_getProjectionVector(self)

    def addScaleFactor(self, name: "std::string const &", externalForceName: "std::string const &", index: "int", bounds: "MocoBounds") -> "void":
        r"""
        Add a MocoParameter to the problem that will scale the tracking reference
        data associated with a contact force group. Scale factors are applied
        to the tracking error calculations based on the following equation:

            error = modelValue - scaleFactor * referenceValue

        In other words, the scale factor is applied when computing the tracking
        error for each contact force group, not to the reference data directly.
        You must specify both the external force name associated with the contact
        force group and the index corresponding to the direction (i.e., X = 0,
        Y = 1, Z = 2) of the scaled force value. The direction is applied in
        whatever frame the reference data is expressed in based on the provided
        ExternalLoads in each contact group.
        """

        if not type(bounds) is MocoBounds:
            bounds = self._convert(MocoBounds, bounds)


        return _moco.MocoContactTrackingGoal_addScaleFactor(self, name, externalForceName, index, bounds)


    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)

    __swig_destroy__ = _moco.delete_MocoContactTrackingGoal

# Register MocoContactTrackingGoal in _moco:
_moco.MocoContactTrackingGoal_swigregister(MocoContactTrackingGoal)

def MocoContactTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoContactTrackingGoal *":
    return _moco.MocoContactTrackingGoal_safeDownCast(obj)

def MocoContactTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoContactTrackingGoal_getClassName()

class MocoInitialActivationGoal(MocoGoal):
    r"""
     For all muscles with activation dynamics, the initial activation and initial
    excitation should be the same.
    Without this goal, muscle activation may undesirably start at its maximum
    possible value in inverse/tracking problems which penalize only excitations
    (such activation is "free").
    This is an endpoint constraint goal by default.
    Credit for using this goal to address excessive initial activation goes to
    Jessica Allen.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialActivationGoal *":
        return _moco.MocoInitialActivationGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInitialActivationGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInitialActivationGoal_getClassName()

    def clone(self) -> "OpenSim::MocoInitialActivationGoal *":
        return _moco.MocoInitialActivationGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInitialActivationGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoInitialActivationGoal_swiginit(self, _moco.new_MocoInitialActivationGoal(*args))
    __swig_destroy__ = _moco.delete_MocoInitialActivationGoal

# Register MocoInitialActivationGoal in _moco:
_moco.MocoInitialActivationGoal_swigregister(MocoInitialActivationGoal)

def MocoInitialActivationGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialActivationGoal *":
    return _moco.MocoInitialActivationGoal_safeDownCast(obj)

def MocoInitialActivationGoal_getClassName() -> "std::string const &":
    return _moco.MocoInitialActivationGoal_getClassName()

class MocoJointReactionGoal(MocoGoal):
    r"""
     Minimize the sum of squares of specified reaction moment and force
    measures for a given joint, integrated over the phase. If the magnitude of
    the gravity acceleration vector (Model::get_gravity()) is non-zero, then the
    goal is normalized by the model's weight; otherwise, the goal is normalized
    by the model's mass. We assume the system's mass is constant (that is,
    MocoParameters do not affect mass).

    In addition to specifying the joint and reaction measures, the user may
    also specify the frame the loads are computed from ("parent" or "child"),
    and the frame the loads are expressed in (any valid frame in the model).

    Minimizing the y-direction reaction force on the child frame of the right
    knee joint expressed in the right tibia frame:

    .. code-block:: c++

        auto* cost = problem.addGoal<MocoJointReactionCost>();
        cost->setName("tibiofemoral_compressive_force");
        cost->setJointPath("/jointset/knee_r");
        cost->setLoadsFrame("child");
        cost->setExpressedInFramePath("/bodyset/tibia_r");
        cost->setReactionMeasures({"force-y"});

    This cost requires realizing to the Acceleration stage.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoJointReactionGoal *":
        return _moco.MocoJointReactionGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoJointReactionGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoJointReactionGoal_getClassName()

    def clone(self) -> "OpenSim::MocoJointReactionGoal *":
        return _moco.MocoJointReactionGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoJointReactionGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoJointReactionGoal_swiginit(self, _moco.new_MocoJointReactionGoal(*args))

    def setJointPath(self, jointPath: "std::string const &") -> "void":
        r"""
        Set the model path to the joint whose reaction load(s) will be
           minimized.
        """
        return _moco.MocoJointReactionGoal_setJointPath(self, jointPath)

    def setLoadsFrame(self, frame: "std::string const &") -> "void":
        r"""
        Set the frame from which the reaction loads are computed. Options:
           "parent" or "child" (default: "parent").
        """
        return _moco.MocoJointReactionGoal_setLoadsFrame(self, frame)

    def setExpressedInFramePath(self, framePath: "std::string const &") -> "void":
        r"""
        Set the frame in which the minimized reaction load is expressed. By
           default, it is set to the parent or child frame depending on the
           'loads_frame' property value.
        """
        return _moco.MocoJointReactionGoal_setExpressedInFramePath(self, framePath)

    def setReactionMeasures(self, measures: "StdVectorString") -> "void":
        r"""
        Set a specific set of reaction measures to be minimized. Options:
           "moment-x", "moment-y", "moment-z", "force-x", "force-y", and "force-z".
           All reaction measures are minimized by default.
           Replaces the reaction measure set if it already exists.
        """
        return _moco.MocoJointReactionGoal_setReactionMeasures(self, measures)

    def setWeight(self, stateName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual reaction measure. If a weight is
           already set for the requested measure, then the provided weight
           replaces the previous weight. An exception is thrown during
           initialization if a weight for an unknown measure is provided.
        """
        return _moco.MocoJointReactionGoal_setWeight(self, stateName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight the reaction measures in the cost.
           Replaces the weight set if it already exists.
        """
        return _moco.MocoJointReactionGoal_setWeightSet(self, weightSet)
    __swig_destroy__ = _moco.delete_MocoJointReactionGoal

# Register MocoJointReactionGoal in _moco:
_moco.MocoJointReactionGoal_swigregister(MocoJointReactionGoal)

def MocoJointReactionGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoJointReactionGoal *":
    return _moco.MocoJointReactionGoal_safeDownCast(obj)

def MocoJointReactionGoal_getClassName() -> "std::string const &":
    return _moco.MocoJointReactionGoal_getClassName()

class MocoSumSquaredStateGoal(MocoGoal):
    r"""
     Minimize the sum of squared states, integrated over the phase. For example,
    this can be used to minimize muscle activations, as is done in MocoInverse.

    This goal is computed as follows:

    .. math::

        \int_{t_i}^{t_f} \sum_{s \in S} w_s y_s(t)^2 ~dt
    We use the following notation:
    - :math:`t_i`: the initial time of this phase.
    - :math:`t_f`: the final time of this phase.
    - :math:`S`: the set of state variables selected for this goal.
    - :math:`w_s`: the weight for state variable :math:`s`.
    - :math:`y_s(t)`: state variable :math:`s`.

    Select which states to minimize by using
    a regex pattern with `setPattern()`. Provide weights for each
    state through `setWeightSet()` or `setWeightForState()`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoSumSquaredStateGoal *":
        return _moco.MocoSumSquaredStateGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoSumSquaredStateGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoSumSquaredStateGoal_getClassName()

    def clone(self) -> "OpenSim::MocoSumSquaredStateGoal *":
        return _moco.MocoSumSquaredStateGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoSumSquaredStateGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoSumSquaredStateGoal_swiginit(self, _moco.new_MocoSumSquaredStateGoal(*args))

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight the state variables in the cost.
           Replaces the weight set if it already exists.
        """
        return _moco.MocoSumSquaredStateGoal_setWeightSet(self, weightSet)

    def setWeightForState(self, stateName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual state variable. If a weight is
           already set for the requested state, then the provided weight
           replaces the previous weight. An exception is thrown if a weight
           for an unknown state is provided.
        """
        return _moco.MocoSumSquaredStateGoal_setWeightForState(self, stateName, weight)

    def setPattern(self, pattern: "std::string") -> "void":
        r"""
        Only state paths matching the regular expression are included. The
           regular expression must match the entire state path for a state path to
           be included (that is, we use std::regex_match, not std::regex_search).
           To include only generalized coordinates, use `.*value$`.
           To include generalized coordinates and speeds, use `.*(value|speed)$`.
           To include only activations, use `.*activation$`.
        """
        return _moco.MocoSumSquaredStateGoal_setPattern(self, pattern)

    def clearPattern(self) -> "void":
        r""" Unset the pattern, which causes all states to be matched."""
        return _moco.MocoSumSquaredStateGoal_clearPattern(self)

    def getPattern(self) -> "std::string":
        return _moco.MocoSumSquaredStateGoal_getPattern(self)
    __swig_destroy__ = _moco.delete_MocoSumSquaredStateGoal

# Register MocoSumSquaredStateGoal in _moco:
_moco.MocoSumSquaredStateGoal_swigregister(MocoSumSquaredStateGoal)

def MocoSumSquaredStateGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoSumSquaredStateGoal *":
    return _moco.MocoSumSquaredStateGoal_safeDownCast(obj)

def MocoSumSquaredStateGoal_getClassName() -> "std::string const &":
    return _moco.MocoSumSquaredStateGoal_getClassName()

class MocoOrientationTrackingGoal(MocoGoal):
    r"""
     The squared difference between a model frame's orientation and a reference
    orientation value, summed over the frames for which a reference is provided,
    and integrated over the phase. This can be used to track orientation
    quantities in the model that don't correspond to model degrees of freedom.
    The reference can be provided as a trajectory of SimTK::Quaternion%s
    representing the orientation reference data, or as a states trajectory from
    which the tracked rotation reference is computed. Both rotation and states
    references can be provided as a file name to a STO or CSV file (or other
    file types for which there is a FileAdapter), or programmatically as a
    TimeSeriesTable_<SimTK::Quaternion> (for the rotation reference) or as a
    scalar TimeSeriesTable (for the states reference).

    This cost requires realization to SimTK::Stage::Position. The cost is
    computed by creating a SimTK::Rotation between the model frame and the
    reference data, and then converting the rotation to an angle-axis
    representation and minimizing the angle value. The angle value is
    equivalent to the orientation error between the model frame and the
    reference data, so we only need to minimize this single scalar value per
    tracked frame, compared to other more complicated approaches which could
    require multiple minimized error values (e.g. Euler angle errors, etc).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOrientationTrackingGoal *":
        return _moco.MocoOrientationTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOrientationTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOrientationTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoOrientationTrackingGoal *":
        return _moco.MocoOrientationTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOrientationTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoOrientationTrackingGoal_swiginit(self, _moco.new_MocoOrientationTrackingGoal(*args))

    def setRotationReferenceFile(self, filepath: "std::string const &") -> "void":
        r"""
        Set the rotations of individual frames in ground to be tracked
           in the cost. The column labels of the provided reference must
           be paths to frames in the model, e.g. `/bodyset/torso`. If the
           frame_paths property is empty, all frames with data in this reference
           will be tracked. Otherwise, only the frames specified via
           setFramePaths() will be tracked. Calling this function clears the values
           provided via setStatesReference(), setRotationReference(), or the
           `states_reference_file` property, if any.
        """
        return _moco.MocoOrientationTrackingGoal_setRotationReferenceFile(self, filepath)

    def setRotationReference(self, *args) -> "void":
        r"""
        *Overload 1:*
        Each column label must be the path of a valid frame path (see
           setRotationReferenceFile()). Calling this function clears the
           `states_reference_file` and `rotation_reference_file` properties or the
           table provided via setStatesReference(), if any.

        |

        *Overload 2:*
         TimeSeriesTable_<SimTK::Rotation>& ref)
        """
        return _moco.MocoOrientationTrackingGoal_setRotationReference(self, *args)

    def setStatesReference(self, ref: "TableProcessor") -> "void":
        r"""
        Provide a table containing values of model state variables. These data
           are used to create a StatesTrajectory internally, from which the
           rotation data for the frames specified in setFramePaths() are computed.
           Each column label in the reference must be the path of a state variable,
           e.g., `/jointset/ankle_angle_r/value`. Calling this function clears the
           table provided via setRotationReference(), or the
           `rotation_reference_file` property, if any. The table is not loaded
           until the MocoProblem is initialized.
        """
        return _moco.MocoOrientationTrackingGoal_setStatesReference(self, ref)

    def setFramePaths(self, paths: "StdVectorString") -> "void":
        r"""
        Set the paths to frames in the model that this cost term will track. The
           names set here must correspond to OpenSim::Component%s that derive from
           OpenSim::Frame, which includes SimTK::Rotation as an output.
           Replaces the frame path set if it already exists.
        """
        return _moco.MocoOrientationTrackingGoal_setFramePaths(self, paths)

    def setWeightForFrame(self, frameName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual frame's rotation tracking. If a weight
           is already set for the requested frame, then the provided weight
           replaces the previous weight. An exception is thrown if a weight
           for an unknown frame is provided.
        """
        return _moco.MocoOrientationTrackingGoal_setWeightForFrame(self, frameName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight frame rotation tracking in the cost.
           Replaces the weight set if it already exists.
        """
        return _moco.MocoOrientationTrackingGoal_setWeightSet(self, weightSet)

    def getStatesReference(self) -> "OpenSim::TableProcessor const &":
        r"""
        If no states reference has been provided, this returns an empty
           processor.
        """
        return _moco.MocoOrientationTrackingGoal_getStatesReference(self)

    def getRotationReferenceFile(self) -> "std::string":
        r"""
        If no rotation reference file has been provided, this returns an empty
           string.
        """
        return _moco.MocoOrientationTrackingGoal_getRotationReferenceFile(self)
    __swig_destroy__ = _moco.delete_MocoOrientationTrackingGoal

# Register MocoOrientationTrackingGoal in _moco:
_moco.MocoOrientationTrackingGoal_swigregister(MocoOrientationTrackingGoal)

def MocoOrientationTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOrientationTrackingGoal *":
    return _moco.MocoOrientationTrackingGoal_safeDownCast(obj)

def MocoOrientationTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoOrientationTrackingGoal_getClassName()

class MocoTranslationTrackingGoal(MocoGoal):
    r"""
     The squared difference between a model frame's origin position and a
    reference position value, summed over the frames for which a reference is
    provided, and integrated over the phase. This can be used to track position
    quantities in the model that don't correspond to model degrees of freedom.
    The reference can be provided as a trajectory of SimTK::Vec3%s
    representing the translation reference data, or as a states trajectory from
    which the tracked translation reference is computed. Both translation and
    states references can be provided as a file name to a STO or CSV file (or
    other file types for which there is a FileAdapter), or programmatically as
    a TimeSeriesTableVec3 (for the translation reference) or as a scalar
    TimeSeriesTable (for the states reference).

    Technically, a cost function with the same effect could be achieved with the
    MocoMarkerTrackingCost class. However, this class avoids the need for adding
    markers to the frame origins and provides the convenient
    setStatesReference() and setStatesReferenceFile() methods which let the user
    set up a tracking cost given only a states trajectory.

    This cost requires realization to SimTK::Stage::Position.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTranslationTrackingGoal *":
        return _moco.MocoTranslationTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoTranslationTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoTranslationTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoTranslationTrackingGoal *":
        return _moco.MocoTranslationTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoTranslationTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoTranslationTrackingGoal_swiginit(self, _moco.new_MocoTranslationTrackingGoal(*args))

    def setTranslationReferenceFile(self, filepath: "std::string const &") -> "void":
        r"""
        Set the translation of individual frames in ground to be
           tracked in the cost. The column labels of the provided reference must
           be paths to frames in the model, e.g. `/bodyset/torso`. If the
           frame_paths property is empty, all frames with data in this reference
           will be tracked. Otherwise, only the frames specified via
           setFramePaths() will be tracked. Calling this function clears the values
           provided via setStatesReference(), setTranslationReference(), or the
           `states_reference_file` property, if any.
        """
        return _moco.MocoTranslationTrackingGoal_setTranslationReferenceFile(self, filepath)

    def setTranslationReference(self, ref: "TimeSeriesTableVec3") -> "void":
        r"""
        Each column label must be the path of a valid frame path (see
           setTranslationReferenceFile()). Calling this function clears the
           `states_reference_file` and `translation_reference_file` properties or
           the table provided via setStatesReference(), if any.
        """
        return _moco.MocoTranslationTrackingGoal_setTranslationReference(self, ref)

    def setStatesReference(self, ref: "TableProcessor") -> "void":
        r"""
        Provide a table containing values of model state
           variables. These data are used to create a StatesTrajectory internally,
           from which the translation data for the frames specified in
           setFramePaths() are computed. Each column label in the reference must be
           the path of a state variable, e.g., `/jointset/ankle_angle_r/value`.
           Calling this function clears the table provided via
           setTranslationReference(), or the
           `translation_reference_file` property, if any. The table is not loaded
           until the MocoProblem is initialized.
        """
        return _moco.MocoTranslationTrackingGoal_setStatesReference(self, ref)

    def setFramePaths(self, paths: "StdVectorString") -> "void":
        r"""
        Set the paths to frames in the model that this cost term will track. The
           names set here must correspond to OpenSim::Component%s that derive from
           OpenSim::Frame, which includes 'position' (SimTK::Vec3) as an output.
           Replaces the frame path set if it already exists.
        """
        return _moco.MocoTranslationTrackingGoal_setFramePaths(self, paths)

    def setWeightForFrame(self, frameName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual frame's translation tracking. If a
           weight is already set for the requested frame, then the provided weight
           replaces the previous weight. An exception is thrown if a weight
           for an unknown frame is provided.
        """
        return _moco.MocoTranslationTrackingGoal_setWeightForFrame(self, frameName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight frame translation tracking in the
           cost. Replaces the weight set if it already exists.
        """
        return _moco.MocoTranslationTrackingGoal_setWeightSet(self, weightSet)

    def getStatesReference(self) -> "OpenSim::TableProcessor const &":
        r"""
        If no states reference has been provided, this returns an empty
           processor.
        """
        return _moco.MocoTranslationTrackingGoal_getStatesReference(self)

    def getTranslationReferenceFile(self) -> "std::string":
        r"""
        If no translation reference file has been provided, this returns an
           empty string.
        """
        return _moco.MocoTranslationTrackingGoal_getTranslationReferenceFile(self)
    __swig_destroy__ = _moco.delete_MocoTranslationTrackingGoal

# Register MocoTranslationTrackingGoal in _moco:
_moco.MocoTranslationTrackingGoal_swigregister(MocoTranslationTrackingGoal)

def MocoTranslationTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTranslationTrackingGoal *":
    return _moco.MocoTranslationTrackingGoal_safeDownCast(obj)

def MocoTranslationTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoTranslationTrackingGoal_getClassName()

class MocoAccelerationTrackingGoal(MocoGoal):
    r"""
     The squared difference between a model frame origin's linear acceleration
    and a reference acceleration value, summed over the frames for which a
    reference is provided, and integrated over the phase. The reference is
    a trajectory of SimTK::Vec3%s representing the acceleration reference data.
    You must provide either a file name to a STO or CSV file (or other file
    types for which there is a FileAdapter) using setAccelerationReferenceFile() or
    a TimeSeriesTableVec3 directly using setAccelerationReference(). The model frames
    that track the acceleration reference data, or "tracking" frames, are specified
    using setFramePaths().




    By default, errors for this cost are computed assuming that the provided
    reference acceleration data is the derivative of a position vector with respect
    to the ground frame and expressed in the ground frame.



    If using this cost for tracking acceleration signals from an inertial measurement
    unit (IMU), you must subtract the gravity vector from the model accelerations and
    express them in the tracking frames using setGravityOffset() and
    setExpressAccelerationsInTrackingFrames(). In addition, the tracking frames for
    each IMU must be in the same location and orientation in the model as in your
    experiment. Therefore, it is recommended to add new frames to your model that
    represent the experimental IMU sensors when using these settings.

    This cost requires realization to SimTK::Stage::Acceleration.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAccelerationTrackingGoal *":
        return _moco.MocoAccelerationTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoAccelerationTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoAccelerationTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoAccelerationTrackingGoal *":
        return _moco.MocoAccelerationTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoAccelerationTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoAccelerationTrackingGoal_swiginit(self, _moco.new_MocoAccelerationTrackingGoal(*args))

    def setAccelerationReferenceFile(self, filepath: "std::string const &") -> "void":
        r"""
        Set the acceleration of individual frames in ground to be tracked in the
           cost. The column labels of the provided reference must be paths to
           frames in the model, e.g. `/bodyset/torso`. If the frame_paths property
           is empty, all frames with data in this reference will be tracked.
           Otherwise, only the frames specified via setFramePaths() will be
           tracked. Calling this function clears the table set by
           setAccelerationReference() if it exists.
        """
        return _moco.MocoAccelerationTrackingGoal_setAccelerationReferenceFile(self, filepath)

    def setAccelerationReference(self, ref: "TimeSeriesTableVec3") -> "void":
        r"""
        Each column label must be the path of a valid frame path (see
           setAccelerationReferenceFile()). Calling this function clears the
           `acceleration_reference_file` property.
        """
        return _moco.MocoAccelerationTrackingGoal_setAccelerationReference(self, ref)

    def setFramePaths(self, paths: "StdVectorString") -> "void":
        r"""
        Set the paths to frames in the model that this cost term will track. The
           names set here must correspond to OpenSim::Component%s that derive from
           OpenSim::Frame, which includes 'linear_acceleration' (SimTK::Vec3) as an
           output. Replaces the frame path set if it already exists.
        """
        return _moco.MocoAccelerationTrackingGoal_setFramePaths(self, paths)

    def setWeightForFrame(self, frameName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual frame's acceleration tracking. If a
           weight is already set for the requested frame, then the provided weight
           replaces the previous weight. An exception is thrown if a weight
           for an unknown frame is provided.
        """
        return _moco.MocoAccelerationTrackingGoal_setWeightForFrame(self, frameName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight frame acceleration tracking in the
           cost. Replaces the weight set if it already exists.
        """
        return _moco.MocoAccelerationTrackingGoal_setWeightSet(self, weightSet)

    def getAccelerationReferenceFile(self) -> "std::string":
        r"""
        If no acceleration reference file has been provided, this returns an
           empty string.
        """
        return _moco.MocoAccelerationTrackingGoal_getAccelerationReferenceFile(self)

    def setGravityOffset(self, tf: "bool") -> "void":
        r"""
        Subtract the model's gravity vector from the model-generated
           accelerations. This offset is performed while the model accelerations are
           expressed in the ground frame, before the accelerations are expressed in the
           tracking frames when setExpressAccelerationsInTrackingFrames() is set to
           true. This setting is useful when tracking accelerations recorded from
           inertial measurement units.
        """
        return _moco.MocoAccelerationTrackingGoal_setGravityOffset(self, tf)

    def getGravityOffset(self) -> "bool":
        return _moco.MocoAccelerationTrackingGoal_getGravityOffset(self)

    def setExpressAccelerationsInTrackingFrames(self, tf: "bool") -> "void":
        r"""
        Express the model-generated accelerations in the individual model
           tracking frames specified by the 'frame_paths' property. Accelerations are
           expressed after the gravity offset is applied when setGravityOffset() is set
           to true. This setting is useful when tracking accelerations recorded from
           inertial measurement units.
        """
        return _moco.MocoAccelerationTrackingGoal_setExpressAccelerationsInTrackingFrames(self, tf)

    def getExpressAccelerationsInTrackingFrames(self) -> "bool":
        return _moco.MocoAccelerationTrackingGoal_getExpressAccelerationsInTrackingFrames(self)
    __swig_destroy__ = _moco.delete_MocoAccelerationTrackingGoal

# Register MocoAccelerationTrackingGoal in _moco:
_moco.MocoAccelerationTrackingGoal_swigregister(MocoAccelerationTrackingGoal)

def MocoAccelerationTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAccelerationTrackingGoal *":
    return _moco.MocoAccelerationTrackingGoal_safeDownCast(obj)

def MocoAccelerationTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoAccelerationTrackingGoal_getClassName()

class MocoAngularVelocityTrackingGoal(MocoGoal):
    r"""
     The squared difference between a model frame's angular velocity and a
    reference angular velocity value, summed over the frames for which a
    reference is provided, and integrated over the phase. This can be used to
    track angular velocity quantities in the model that don't correspond to
    model degrees of freedom. The reference can be provided as a trajectory of
    SimTK::Vec3%s representing the angular velocity reference data, or as a
    states trajectory from which the tracked angular velocity reference is
    computed. Both angular velocity and states references can be provided as a
    file name to a STO or CSV file (or other file types for which there is a
    FileAdapter), or programmatically as a TimeSeriesTableVec3 (for the angular
    velocity reference) or as a scalar TimeSeriesTable (for the states
    reference).

    Errors for this cost are computed assuming that the provided reference
    angular velocity data is expressed in the ground frame. If you are using
    this cost to track raw signals from an inertial measurement unit (IMU), make
    sure that the frame you're tracking produces angular velocity values that
    correspond to the real-world placement of your IMU.

    This cost requires realization to SimTK::Stage::Velocity.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAngularVelocityTrackingGoal *":
        return _moco.MocoAngularVelocityTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoAngularVelocityTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoAngularVelocityTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoAngularVelocityTrackingGoal *":
        return _moco.MocoAngularVelocityTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoAngularVelocityTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoAngularVelocityTrackingGoal_swiginit(self, _moco.new_MocoAngularVelocityTrackingGoal(*args))

    def setAngularVelocityReferenceFile(self, filepath: "std::string const &") -> "void":
        r"""
        Set directly the angular velocities of individual frames in ground to be
           tracked in the cost. The column labels of the provided reference must
           be paths to frames in the model, e.g. `/bodyset/torso`. If the
           frame_paths property is empty, all frames with data in this reference
           will be tracked. Otherwise, only the frames specified via
           setFramePaths() will be tracked. Calling this function clears the values
           provided via setStatesReference(), setAngularVelocityReference(), or the
           `states_reference_file` property, if any.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setAngularVelocityReferenceFile(self, filepath)

    def setAngularVelocityReference(self, ref: "TimeSeriesTableVec3") -> "void":
        r"""
        Each column label must be the path of a valid frame path (see
           setAngularVelocityReferenceFile()). Calling this function clears the
           `states_reference_file` and `angular_velocity_reference_file` properties
           or the table provided via setStatesReference(), if any.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setAngularVelocityReference(self, ref)

    def setStatesReference(self, ref: "TableProcessor") -> "void":
        r"""
        Provide a table containing values of model state
           variables. These data are used to create a StatesTrajectory internally,
           from which the angular velocity data for the frames specified in
           setFramePaths() are computed. Each column label in the reference must be
           the path of a state variable, e.g., `/jointset/ankle_angle_r/value`.
           Calling this function clears the table provided via
           setAngularVelocityReference(), or the
           `angular_velocity_reference_file` property, if any. The table is not
           loaded until the MocoProblem is initialized.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setStatesReference(self, ref)

    def setFramePaths(self, paths: "StdVectorString") -> "void":
        r"""
        Set the paths to frames in the model that this cost term will track. The
           names set here must correspond to OpenSim::Component%s that derive from
           OpenSim::Frame, which includes 'angular_velocity' (SimTK::Vec3) as an
           output. Replaces the frame path set if it already exists.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setFramePaths(self, paths)

    def setWeightForFrame(self, frameName: "std::string const &", weight: "double const &") -> "void":
        r"""
        Set the weight for an individual frame's angular velocity tracking. If a
           weight is already set for the requested frame, then the provided weight
           replaces the previous weight. An exception is thrown if a weight
           for an unknown frame is provided.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setWeightForFrame(self, frameName, weight)

    def setWeightSet(self, weightSet: "MocoWeightSet") -> "void":
        r"""
        Provide a MocoWeightSet to weight frame angular velocity tracking in the
           cost. Replaces the weight set if it already exists.
        """
        return _moco.MocoAngularVelocityTrackingGoal_setWeightSet(self, weightSet)

    def getStatesReference(self) -> "OpenSim::TableProcessor const &":
        r"""
        If no states reference has been provided, this returns an empty
           processor.
        """
        return _moco.MocoAngularVelocityTrackingGoal_getStatesReference(self)

    def getAngularVelocityReferenceFile(self) -> "std::string":
        r"""
        If no angular velocity reference file has been provided, this returns an
           empty string.
        """
        return _moco.MocoAngularVelocityTrackingGoal_getAngularVelocityReferenceFile(self)
    __swig_destroy__ = _moco.delete_MocoAngularVelocityTrackingGoal

# Register MocoAngularVelocityTrackingGoal in _moco:
_moco.MocoAngularVelocityTrackingGoal_swigregister(MocoAngularVelocityTrackingGoal)

def MocoAngularVelocityTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoAngularVelocityTrackingGoal *":
    return _moco.MocoAngularVelocityTrackingGoal_safeDownCast(obj)

def MocoAngularVelocityTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoAngularVelocityTrackingGoal_getClassName()

class MocoOutputBase(MocoGoal):
    r"""
     This abstract base class provides convenience methods and common interfaces
    for all Output-related MocoGoal's. All MocoGoal's deriving from this class
    include the 'setOutputPath()', 'setOutputIndex()', and 'setExponent()' methods
    and their corresponding Object properties. The convenience method
    'initializeOnModelBase()' should be called at the top of
    'initializeOnModelImpl()' within each derived class. Similarly,
    'calcOutputValue()' can be used to retrieve the Output value with
    'calcGoalImpl()' and/or 'calcIntegrandImpl()', as needed for each derived class.
    The method 'getDependsOnStage()' returns the SimTK::Stage that should be realized
    to to calculate Output values. The method 'setValueToExponent()' can be used to
    raise a value to the exponent provided via 'setExponent()'.

    We support the following Output types:
    - double
    - SimTK::Vec3
    - SimTK::SpatialVec

    When using vector types, 'setOutputIndex()' may be used to select a specific
    element of the Output vector. If not specified, the norm of the vector is
    returned when calling 'calcOutputValue()'.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputBase *":
        return _moco.MocoOutputBase_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOutputBase_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOutputBase_getClassName()

    def clone(self) -> "OpenSim::MocoOutputBase *":
        return _moco.MocoOutputBase_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOutputBase_getConcreteClassName(self)

    def setOutputPath(self, path: "std::string") -> "void":
        r"""
        Set the absolute path to the output in the model to use as the integrand
           for this goal. The format is "/path/to/component|output_name".
        """
        return _moco.MocoOutputBase_setOutputPath(self, path)

    def getOutputPath(self) -> "std::string const &":
        return _moco.MocoOutputBase_getOutputPath(self)

    def setExponent(self, exponent: "int") -> "void":
        r"""
        Set the exponent applied to the output value in the integrand. This
           exponent is applied when minimizing the norm of a vector type output.
        """
        return _moco.MocoOutputBase_setExponent(self, exponent)

    def getExponent(self) -> "int":
        return _moco.MocoOutputBase_getExponent(self)

    def setOutputIndex(self, index: "int") -> "void":
        r"""
        Set the index to the value to be minimized when a vector type Output is
           specified. For SpatialVec Outputs, indices 0, 1, and 2 refer to the
           rotational components and indices 3, 4, and 5 refer to the translational
           components. A value of -1 indicates to minimize the vector norm (which is the
           default setting). If an index for a type double Output is provided, an
           exception is thrown.
        """
        return _moco.MocoOutputBase_setOutputIndex(self, index)

    def getOutputIndex(self) -> "int":
        return _moco.MocoOutputBase_getOutputIndex(self)
    __swig_destroy__ = _moco.delete_MocoOutputBase

# Register MocoOutputBase in _moco:
_moco.MocoOutputBase_swigregister(MocoOutputBase)

def MocoOutputBase_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputBase *":
    return _moco.MocoOutputBase_safeDownCast(obj)

def MocoOutputBase_getClassName() -> "std::string const &":
    return _moco.MocoOutputBase_getClassName()

class MocoOutputGoal(MocoOutputBase):
    r"""
     This goal allows you to use model Outputs of type double, SimTK::Vec3, and
    SimTK::SpatialVec in the integrand of a goal. By default, when using vector type
    Outputs, the norm of the vector is minimized, but you can also minimize a
    specific element of a vector Output via `setOutputIndex()`. You can also specify
    the exponent of the value in the integrand via `setExponent()`.

    This goal supports both "Cost" (default) and "EndpointConstraint" modes. In
    "EndpointConstraint" mode, the integral of the Output value is constrained
    between user-specified bounds. By default, these bounds constrain the integral to
    zero; use 'updConstraintInfo()' to set custom bounds.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputGoal *":
        return _moco.MocoOutputGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOutputGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOutputGoal_getClassName()

    def clone(self) -> "OpenSim::MocoOutputGoal *":
        return _moco.MocoOutputGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOutputGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoOutputGoal_swiginit(self, _moco.new_MocoOutputGoal(*args))

    def setDivideByDisplacement(self, tf: "bool") -> "void":
        r"""
        Set if the goal should be divided by the displacement of the system's
           center of mass over the phase.
        """
        return _moco.MocoOutputGoal_setDivideByDisplacement(self, tf)

    def getDivideByDisplacement(self) -> "bool":
        return _moco.MocoOutputGoal_getDivideByDisplacement(self)

    def setDivideByMass(self, tf: "bool") -> "void":
        r""" Set if the goal should be divided by the total mass of the model."""
        return _moco.MocoOutputGoal_setDivideByMass(self, tf)

    def getDivideByMass(self) -> "bool":
        return _moco.MocoOutputGoal_getDivideByMass(self)
    __swig_destroy__ = _moco.delete_MocoOutputGoal

# Register MocoOutputGoal in _moco:
_moco.MocoOutputGoal_swigregister(MocoOutputGoal)

def MocoOutputGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputGoal *":
    return _moco.MocoOutputGoal_safeDownCast(obj)

def MocoOutputGoal_getClassName() -> "std::string const &":
    return _moco.MocoOutputGoal_getClassName()

class MocoInitialOutputGoal(MocoOutputBase):
    r"""
     This goal allows you to minimize or constrain a Model Output value at the
    beginning of a trajectory. Outputs of type double, SimTK::Vec3, and
    SimTK::SpatialVec are supported. By default, when using vector type Outputs, the
    norm of the vector is minimized, but you can also minimize a specific element of
    a vector Output via `setOutputIndex()`. You can also specify the exponent of the
    value in the integrand via `setExponent()`.

    This goal supports both "Cost" (default) and "EndpointConstraint" modes. In
    "EndpointConstraint" mode, the Output value is constrained between user-specified
    bounds. By default, these bounds constrain the initial value to zero; use
    'updConstraintInfo()' to set custom bounds.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialOutputGoal *":
        return _moco.MocoInitialOutputGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInitialOutputGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInitialOutputGoal_getClassName()

    def clone(self) -> "OpenSim::MocoInitialOutputGoal *":
        return _moco.MocoInitialOutputGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInitialOutputGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoInitialOutputGoal_swiginit(self, _moco.new_MocoInitialOutputGoal(*args))
    __swig_destroy__ = _moco.delete_MocoInitialOutputGoal

# Register MocoInitialOutputGoal in _moco:
_moco.MocoInitialOutputGoal_swigregister(MocoInitialOutputGoal)

def MocoInitialOutputGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialOutputGoal *":
    return _moco.MocoInitialOutputGoal_safeDownCast(obj)

def MocoInitialOutputGoal_getClassName() -> "std::string const &":
    return _moco.MocoInitialOutputGoal_getClassName()

class MocoFinalOutputGoal(MocoOutputBase):
    r"""
     This goal allows you to minimize or constrain a Model Output value at the
    end of a trajectory. Outputs of type double, SimTK::Vec3, and SimTK::SpatialVec
    are supported. By default, when using vector type Outputs, the norm of the vector
    is minimized, but you can also minimize a specific element of a vector Output via
    `setOutputIndex()`. You can also specify the exponent of the value in the
    integrand via `setExponent()`.

    This goal supports both "Cost" (default) and "EndpointConstraint" modes. In
    "EndpointConstraint" mode, the Output value is constrained between user-specified
    bounds. By default, these bounds constrain the final value to zero; use
    'updConstraintInfo()' to set custom bounds.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalOutputGoal *":
        return _moco.MocoFinalOutputGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoFinalOutputGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoFinalOutputGoal_getClassName()

    def clone(self) -> "OpenSim::MocoFinalOutputGoal *":
        return _moco.MocoFinalOutputGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoFinalOutputGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoFinalOutputGoal_swiginit(self, _moco.new_MocoFinalOutputGoal(*args))
    __swig_destroy__ = _moco.delete_MocoFinalOutputGoal

# Register MocoFinalOutputGoal in _moco:
_moco.MocoFinalOutputGoal_swigregister(MocoFinalOutputGoal)

def MocoFinalOutputGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFinalOutputGoal *":
    return _moco.MocoFinalOutputGoal_safeDownCast(obj)

def MocoFinalOutputGoal_getClassName() -> "std::string const &":
    return _moco.MocoFinalOutputGoal_getClassName()

class MocoOutputPeriodicityGoal(MocoOutputBase):
    r"""
     This goal allows you to minimize or constrain the difference of values from
    a Model Output from the beginning and end of a trajectory. Outputs of type
    double, SimTK::Vec3, and SimTK::SpatialVec are supported. By default, when using
    vector type Outputs, the norm of the vector is minimized, but you can also
    minimize a specific element of a vector Output via `setOutputIndex()`. You can
    also specify the exponent of the value in the integrand via `setExponent()`.

    This goal supports both "Cost" (default) and "EndpointConstraint" modes. In
    "EndpointConstraint" mode, the difference in Output values is constrained between
    user-specified bounds. By default, these bounds constrain the final value to
    zero; use 'updConstraintInfo()' to set custom bounds.

    Notes: The exponent provided via 'setExponent()' is applied to the difference
          between final and initial Output values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputPeriodicityGoal *":
        return _moco.MocoOutputPeriodicityGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOutputPeriodicityGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOutputPeriodicityGoal_getClassName()

    def clone(self) -> "OpenSim::MocoOutputPeriodicityGoal *":
        return _moco.MocoOutputPeriodicityGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOutputPeriodicityGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoOutputPeriodicityGoal_swiginit(self, _moco.new_MocoOutputPeriodicityGoal(*args))
    __swig_destroy__ = _moco.delete_MocoOutputPeriodicityGoal

# Register MocoOutputPeriodicityGoal in _moco:
_moco.MocoOutputPeriodicityGoal_swigregister(MocoOutputPeriodicityGoal)

def MocoOutputPeriodicityGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputPeriodicityGoal *":
    return _moco.MocoOutputPeriodicityGoal_safeDownCast(obj)

def MocoOutputPeriodicityGoal_getClassName() -> "std::string const &":
    return _moco.MocoOutputPeriodicityGoal_getClassName()

class MocoOutputTrackingGoal(MocoOutputBase):
    r"""
     This goal allows you to minimize the squared difference between a Model
    Output value and a user-defined function. Outputs of type double, SimTK::Vec3,
    and SimTK::SpatialVec are supported. By default, when using vector type Outputs,
    the norm of the vector is tracked, but you can also track a specific element of a
    vector Output via `setOutputIndex()`.
    Notes: The exponent provided via 'setExponent()' is applied to the difference
          between Output value and the tracking function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputTrackingGoal *":
        return _moco.MocoOutputTrackingGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOutputTrackingGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOutputTrackingGoal_getClassName()

    def clone(self) -> "OpenSim::MocoOutputTrackingGoal *":
        return _moco.MocoOutputTrackingGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOutputTrackingGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoOutputTrackingGoal_swiginit(self, _moco.new_MocoOutputTrackingGoal(*args))

    def setTrackingFunction(self, f: "Function") -> "void":
        r""" The function of time that the Output value will track in the integrand."""
        return _moco.MocoOutputTrackingGoal_setTrackingFunction(self, f)

    def getTrackingFunction(self) -> "OpenSim::Function const &":
        return _moco.MocoOutputTrackingGoal_getTrackingFunction(self)
    __swig_destroy__ = _moco.delete_MocoOutputTrackingGoal

# Register MocoOutputTrackingGoal in _moco:
_moco.MocoOutputTrackingGoal_swigregister(MocoOutputTrackingGoal)

def MocoOutputTrackingGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputTrackingGoal *":
    return _moco.MocoOutputTrackingGoal_safeDownCast(obj)

def MocoOutputTrackingGoal_getClassName() -> "std::string const &":
    return _moco.MocoOutputTrackingGoal_getClassName()

class MocoPeriodicityGoalPair(opensim.common.OpenSimObject):
    r""" Create pair of variables for use with a MocoPeriodicityGoal."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPeriodicityGoalPair *":
        return _moco.MocoPeriodicityGoalPair_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoPeriodicityGoalPair_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoPeriodicityGoalPair_getClassName()

    def clone(self) -> "OpenSim::MocoPeriodicityGoalPair *":
        return _moco.MocoPeriodicityGoalPair_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoPeriodicityGoalPair_getConcreteClassName(self)

    def copyProperty_initial_variable(self, source: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoalPair_copyProperty_initial_variable(self, source)

    def append_initial_variable(self, value: "std::string const &") -> "int":
        return _moco.MocoPeriodicityGoalPair_append_initial_variable(self, value)

    def constructProperty_initial_variable(self, initValue: "std::string const &") -> "void":
        return _moco.MocoPeriodicityGoalPair_constructProperty_initial_variable(self, initValue)

    def get_initial_variable(self, *args) -> "std::string const &":
        return _moco.MocoPeriodicityGoalPair_get_initial_variable(self, *args)

    def upd_initial_variable(self, *args) -> "std::string &":
        return _moco.MocoPeriodicityGoalPair_upd_initial_variable(self, *args)

    def set_initial_variable(self, *args) -> "void":
        return _moco.MocoPeriodicityGoalPair_set_initial_variable(self, *args)

    def copyProperty_final_variable(self, source: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoalPair_copyProperty_final_variable(self, source)

    def append_final_variable(self, value: "std::string const &") -> "int":
        return _moco.MocoPeriodicityGoalPair_append_final_variable(self, value)

    def constructProperty_final_variable(self, initValue: "std::string const &") -> "void":
        return _moco.MocoPeriodicityGoalPair_constructProperty_final_variable(self, initValue)

    def get_final_variable(self, *args) -> "std::string const &":
        return _moco.MocoPeriodicityGoalPair_get_final_variable(self, *args)

    def upd_final_variable(self, *args) -> "std::string &":
        return _moco.MocoPeriodicityGoalPair_upd_final_variable(self, *args)

    def set_final_variable(self, *args) -> "void":
        return _moco.MocoPeriodicityGoalPair_set_final_variable(self, *args)

    def copyProperty_negate(self, source: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoalPair_copyProperty_negate(self, source)

    def append_negate(self, value: "bool const &") -> "int":
        return _moco.MocoPeriodicityGoalPair_append_negate(self, value)

    def constructProperty_negate(self, initValue: "bool const &") -> "void":
        return _moco.MocoPeriodicityGoalPair_constructProperty_negate(self, initValue)

    def get_negate(self, *args) -> "bool const &":
        return _moco.MocoPeriodicityGoalPair_get_negate(self, *args)

    def upd_negate(self, *args) -> "bool &":
        return _moco.MocoPeriodicityGoalPair_upd_negate(self, *args)

    def set_negate(self, *args) -> "void":
        return _moco.MocoPeriodicityGoalPair_set_negate(self, *args)

    def __init__(self, *args):
        _moco.MocoPeriodicityGoalPair_swiginit(self, _moco.new_MocoPeriodicityGoalPair(*args))
    __swig_destroy__ = _moco.delete_MocoPeriodicityGoalPair

# Register MocoPeriodicityGoalPair in _moco:
_moco.MocoPeriodicityGoalPair_swigregister(MocoPeriodicityGoalPair)

def MocoPeriodicityGoalPair_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPeriodicityGoalPair *":
    return _moco.MocoPeriodicityGoalPair_safeDownCast(obj)

def MocoPeriodicityGoalPair_getClassName() -> "std::string const &":
    return _moco.MocoPeriodicityGoalPair_getClassName()

class MocoPeriodicityGoal(MocoGoal):
    r"""
     This goal enforces equality between initial and final variable values in
    the optimal control problem. The initial and final values can belong to
    separate continuous variables or the same continuous variable, as long as
    they are the same type of variable (e.g., state or control). Value pairs
    are specified via a MocoPeriodicityGoalPair, where the initial variable of
    the pair indicates the initial state/control variable and the final
    variable indicates the final state/control variable. Set the initial and
    final variables to the same variable to enforce periodicity on a single
    continuous variable. Only state and control continuous variable pairs are
    supported, and are specified via the 'state_pairs' and 'control_pairs'
    properties.

    To handle initial and final variable values that are equal in absolute value
    but differ in sign (e.g. a pelvis rotation in walking), use
    addNegatedStatePair or addNegatedControlPair.

    To impose bilateral symmetry in a walking simulation,
    we can simulate over half a gait cycle and impose periodic constraints. For
    bilateral variables (e.g., hip flexion speeds and hamstrings controls), the
    constraints should enforce that right and left values, and inversely, should
    be the same at the beginning and half of the gait cycle, respectively. For
    the other variables (e.g., pelvis tilt values), the constraints should
    enforce that the values should be the same at the beginning and half of the
    gait cycle. The example code below illustrates how to enforce the
    aforementioned constraints with different constructors.

    .. code-block:: c++

        periodicGoal = problem.addGoal<MocoPeriodicityGoal>("periodicGoal");
    Periodic contraint for the pelvis tilt values:

    .. code-block:: c++

        periodicGoal->addStatePair({ "/jointset/ground_pelvis/pelvis_tilt/value"});
    Periodic contraints for the hip flexion speeds:

    .. code-block:: c++

        periodicGoal->addStatePair({"/jointset/hip_l/hip_flexion_l/speed",
                "/jointset/hip_r/hip_flexion_r/speed"});
        periodicGoal->addStatePair({"/jointset/hip_r/hip_flexion_r/speed",
                "/jointset/hip_l/hip_flexion_l/speed"});
    Periodic contraints for the hamstrings controls:

    .. code-block:: c++

        MocoPeriodicityGoalPair pair_hamstrings1;
        pair_hamstrings1.set_initial_variable("/hamstrings_r");
        pair_hamstrings1.set_final_variable("/hamstrings_l");
        periodicGoal->append_control_pairs(pair_hamstrings1);
        MocoPeriodicityGoalPair pair_hamstrings2;
        pair_hamstrings2.set_initial_variable("/hamstrings_l");
        pair_hamstrings2.set_final_variable("/hamstrings_r");
        periodicGoal->append_control_pairs(pair_hamstrings2);
    This is an endpoint constraint goal by default.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPeriodicityGoal *":
        return _moco.MocoPeriodicityGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoPeriodicityGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoPeriodicityGoal_getClassName()

    def clone(self) -> "OpenSim::MocoPeriodicityGoal *":
        return _moco.MocoPeriodicityGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoPeriodicityGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoPeriodicityGoal_swiginit(self, _moco.new_MocoPeriodicityGoal(*args))

    def addStatePair(self, pair: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoal_addStatePair(self, pair)

    def addNegatedStatePair(self, pair: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoal_addNegatedStatePair(self, pair)

    def addControlPair(self, pair: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoal_addControlPair(self, pair)

    def addNegatedControlPair(self, pair: "MocoPeriodicityGoalPair") -> "void":
        return _moco.MocoPeriodicityGoal_addNegatedControlPair(self, pair)
    __swig_destroy__ = _moco.delete_MocoPeriodicityGoal

# Register MocoPeriodicityGoal in _moco:
_moco.MocoPeriodicityGoal_swigregister(MocoPeriodicityGoal)

def MocoPeriodicityGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPeriodicityGoal *":
    return _moco.MocoPeriodicityGoal_safeDownCast(obj)

def MocoPeriodicityGoal_getClassName() -> "std::string const &":
    return _moco.MocoPeriodicityGoal_getClassName()

class MocoInitialForceEquilibriumDGFGoal(MocoGoal):
    r"""
     For all DeGrooteFregly2016Muscle%s with explicit tendon compliance dynamics,
    constrain (or minimize) the error computed from the muscle-tendon force
    equilibrium equation.
    This goal ensures that the initial normalized tendon force state variable
    is chosen such that equilibrium is satisfied; otherwise, the initial state
    may not be valid.
    This is an endpoint constraint goal by default.
    Notes: This goal only applies to DeGrooteFregly2016Muscle%s since it relies on
        the method calcEquilibriumResidual() provided by that class. Calls to
        calcEquilibriumResidual() set the normalized tendon force derivative
        argument to zero.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialForceEquilibriumDGFGoal *":
        return _moco.MocoInitialForceEquilibriumDGFGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInitialForceEquilibriumDGFGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInitialForceEquilibriumDGFGoal_getClassName()

    def clone(self) -> "OpenSim::MocoInitialForceEquilibriumDGFGoal *":
        return _moco.MocoInitialForceEquilibriumDGFGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInitialForceEquilibriumDGFGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoInitialForceEquilibriumDGFGoal_swiginit(self, _moco.new_MocoInitialForceEquilibriumDGFGoal(*args))
    __swig_destroy__ = _moco.delete_MocoInitialForceEquilibriumDGFGoal

# Register MocoInitialForceEquilibriumDGFGoal in _moco:
_moco.MocoInitialForceEquilibriumDGFGoal_swigregister(MocoInitialForceEquilibriumDGFGoal)

def MocoInitialForceEquilibriumDGFGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialForceEquilibriumDGFGoal *":
    return _moco.MocoInitialForceEquilibriumDGFGoal_safeDownCast(obj)

def MocoInitialForceEquilibriumDGFGoal_getClassName() -> "std::string const &":
    return _moco.MocoInitialForceEquilibriumDGFGoal_getClassName()

class MocoInitialVelocityEquilibriumDGFGoal(MocoGoal):
    r"""
     For DeGrooteFregly2016Muscle components with implicit tendon compliance
    dynamics, the initial tendon and fiber velocities are determined based the
    derivative of the linearized muscle-tendon equilibrium equation described
    in Millard et al. 2013 (Appendix, equation A6).
    Without this goal, the derivative of normalized tendon force, which is a
    control variable in implicit tendon compliance dynamics, may undesirably
    start at a very large value if not constrained or minimized (which it is
    not by default).
    This is an endpoint constraint goal by default.
    Notes: This goal only applies to DeGrooteFregly2016Muscles.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialVelocityEquilibriumDGFGoal *":
        return _moco.MocoInitialVelocityEquilibriumDGFGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInitialVelocityEquilibriumDGFGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInitialVelocityEquilibriumDGFGoal_getClassName()

    def clone(self) -> "OpenSim::MocoInitialVelocityEquilibriumDGFGoal *":
        return _moco.MocoInitialVelocityEquilibriumDGFGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInitialVelocityEquilibriumDGFGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoInitialVelocityEquilibriumDGFGoal_swiginit(self, _moco.new_MocoInitialVelocityEquilibriumDGFGoal(*args))
    __swig_destroy__ = _moco.delete_MocoInitialVelocityEquilibriumDGFGoal

# Register MocoInitialVelocityEquilibriumDGFGoal in _moco:
_moco.MocoInitialVelocityEquilibriumDGFGoal_swigregister(MocoInitialVelocityEquilibriumDGFGoal)

def MocoInitialVelocityEquilibriumDGFGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInitialVelocityEquilibriumDGFGoal *":
    return _moco.MocoInitialVelocityEquilibriumDGFGoal_safeDownCast(obj)

def MocoInitialVelocityEquilibriumDGFGoal_getClassName() -> "std::string const &":
    return _moco.MocoInitialVelocityEquilibriumDGFGoal_getClassName()

class MocoStepTimeAsymmetryGoalGroup(opensim.common.OpenSimObject):
    r"""
     A contact group includes a list of contact force component paths in the
    model. One of these force elements is designated to locate the position of the
    foot (via the 'foot_position_contact_force_path' property) which is necessary to
    compute step time asymmetry. The MocoStepTimeAsymmetryGoal determines when a foot
    is in contact with the ground when the total contact force from the sum of the
    elements in this group exceeds a user provided threshold.

    See also: MocoStepTimeAsymmetryGoal
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepTimeAsymmetryGoalGroup *":
        return _moco.MocoStepTimeAsymmetryGoalGroup_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_getClassName()

    def clone(self) -> "OpenSim::MocoStepTimeAsymmetryGoalGroup *":
        return _moco.MocoStepTimeAsymmetryGoalGroup_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_getConcreteClassName(self)

    def copyProperty_contact_force_paths(self, source: "MocoStepTimeAsymmetryGoalGroup") -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_copyProperty_contact_force_paths(self, source)

    def get_contact_force_paths(self, i: "int") -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_get_contact_force_paths(self, i)

    def upd_contact_force_paths(self, i: "int") -> "std::string &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_upd_contact_force_paths(self, i)

    def set_contact_force_paths(self, i: "int", value: "std::string const &") -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_set_contact_force_paths(self, i, value)

    def append_contact_force_paths(self, value: "std::string const &") -> "int":
        return _moco.MocoStepTimeAsymmetryGoalGroup_append_contact_force_paths(self, value)

    def constructProperty_contact_force_paths(self) -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_constructProperty_contact_force_paths(self)

    def copyProperty_foot_position_contact_force_path(self, source: "MocoStepTimeAsymmetryGoalGroup") -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_copyProperty_foot_position_contact_force_path(self, source)

    def append_foot_position_contact_force_path(self, value: "std::string const &") -> "int":
        return _moco.MocoStepTimeAsymmetryGoalGroup_append_foot_position_contact_force_path(self, value)

    def constructProperty_foot_position_contact_force_path(self, initValue: "std::string const &") -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_constructProperty_foot_position_contact_force_path(self, initValue)

    def get_foot_position_contact_force_path(self, *args) -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_get_foot_position_contact_force_path(self, *args)

    def upd_foot_position_contact_force_path(self, *args) -> "std::string &":
        return _moco.MocoStepTimeAsymmetryGoalGroup_upd_foot_position_contact_force_path(self, *args)

    def set_foot_position_contact_force_path(self, *args) -> "void":
        return _moco.MocoStepTimeAsymmetryGoalGroup_set_foot_position_contact_force_path(self, *args)

    def __init__(self, *args):
        _moco.MocoStepTimeAsymmetryGoalGroup_swiginit(self, _moco.new_MocoStepTimeAsymmetryGoalGroup(*args))
    __swig_destroy__ = _moco.delete_MocoStepTimeAsymmetryGoalGroup

# Register MocoStepTimeAsymmetryGoalGroup in _moco:
_moco.MocoStepTimeAsymmetryGoalGroup_swigregister(MocoStepTimeAsymmetryGoalGroup)

def MocoStepTimeAsymmetryGoalGroup_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepTimeAsymmetryGoalGroup *":
    return _moco.MocoStepTimeAsymmetryGoalGroup_safeDownCast(obj)

def MocoStepTimeAsymmetryGoalGroup_getClassName() -> "std::string const &":
    return _moco.MocoStepTimeAsymmetryGoalGroup_getClassName()

class MocoStepTimeAsymmetryGoal(MocoGoal):
    r"""
     Minimize the error between a model's step time asymmetry and a specified
    target asymmetry value over a gait cycle.

    Step time is defined as the time between consecutive foot strikes. Step Time
    Asymmetry (STA) is a ratio and is calculated as follows:
     - Right Step Time (RST) = Time from left foot-strike to right foot-strike
     - Left Step Time (LST)  = Time from right foot-strike to left foot-strike
     - STA = (RST - LST) / (RST + LST)

    In this goal, the step time asymmetry is computed by "counting" the number of
    nodes that each foot is in  contact with the ground (with respect to a specified
    contact force threshold). Since, in walking, there are double support phases
    where both feet are on the ground, the goal also detects which foot is in front
    and assigns the step time to the leading foot. Altogether, it estimates the time
    between consecutive heel strikes in order to infer the left and right step times.

    The contact elements for each foot must specified via 'setLeftContactGroup()'
    and 'setRightContactGroup()'. The force element and force threshold used to
    determine when a foot is in contact is set via 'setContactForceDirection()' and
    'setContactForceThreshold()'.

    Users must provide the target asymmetry value via 'setTargetAsymmetry()'.
    Asymmetry values ranges from -1.0 to 1.0. For example, 0.20 is 20% positive
    step time asymmetry with greater right step times than left step times. A
    symmetric step times solution can be achieved by setting this property to zero.
    This goal can be used only in 'cost' mode, where the error between the target
    asymmetry and model asymmetry is squared. To make this goal suitable for
    gradient-based optimization, step time values are assigned via smoothing
    functions which can be controlled via 'setAsymmetrySmoothing()' and
    'setContactDetectionSmoothing()'.

    Notes: This goal is designed for simulations of bipedal gait.

    The only contact element supported is SmoothSphereHalfSpaceForce.

    Since this goal approximates step time asymmetry, users should calculate
    the true asymmetry value after running an optimization.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepTimeAsymmetryGoal *":
        return _moco.MocoStepTimeAsymmetryGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoStepTimeAsymmetryGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoal_getClassName()

    def clone(self) -> "OpenSim::MocoStepTimeAsymmetryGoal *":
        return _moco.MocoStepTimeAsymmetryGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoStepTimeAsymmetryGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoStepTimeAsymmetryGoal_swiginit(self, _moco.new_MocoStepTimeAsymmetryGoal(*args))

    def setLeftContactGroup(self, contactForcePaths: "StdVectorString", footPositionForcePath: "std::string const &") -> "void":
        r"""
        Add the group of contact forces that determine the position of the left
        foot and when it is in contact with the ground.
        """
        return _moco.MocoStepTimeAsymmetryGoal_setLeftContactGroup(self, contactForcePaths, footPositionForcePath)

    def setRightContactGroup(self, contactForcePaths: "StdVectorString", footPositionForcePath: "std::string const &") -> "void":
        r"""
        Add the group of contact forces that determine the position of the right
        foot and when it is in contact with the ground.
        """
        return _moco.MocoStepTimeAsymmetryGoal_setRightContactGroup(self, contactForcePaths, footPositionForcePath)

    def setTargetAsymmetry(self, asymmetry: "double") -> "void":
        r"""
        Set the asymmetry value targeted by this goal. If using 'cost' mode, the
        error between the target asymmetry and the model asymmetry is squared.
        """
        return _moco.MocoStepTimeAsymmetryGoal_setTargetAsymmetry(self, asymmetry)

    def getTargetAsymmetry(self) -> "double":
        return _moco.MocoStepTimeAsymmetryGoal_getTargetAsymmetry(self)

    def setContactForceThreshold(self, threshold: "double") -> "void":
        r"""
        Set the threshold force value used to detect is a foot is in contact with
        the ground.
        """
        return _moco.MocoStepTimeAsymmetryGoal_setContactForceThreshold(self, threshold)

    def getContactForceThreshold(self) -> "double":
        return _moco.MocoStepTimeAsymmetryGoal_getContactForceThreshold(self)

    def setContactForceDirection(self, direction: "std::string const &") -> "void":
        r"""
        Set the direction in ground of the total contact force component used to
        detect foot contact. When the contact force component for a foot exceeds
        the force set by the 'contact_force_threshold' property, we register that
        foot as in contact with the ground. Acceptable direction values include
        "positive-x", "positive-y", "positive-z", "negative-x", "negative-y", and
        "negative-z". Default: "positive-y".
        """
        return _moco.MocoStepTimeAsymmetryGoal_setContactForceDirection(self, direction)

    def getContactForceDirection(self) -> "std::string":
        return _moco.MocoStepTimeAsymmetryGoal_getContactForceDirection(self)

    def setWalkingDirection(self, direction: "std::string const &") -> "void":
        r"""
        Set the walking direction of the model in the ground frame, which is used
        to determine the leading foot during double support. Acceptable direction
        values include "positive-x", "positive-y", "positive-z", "negative-x",
        "negative-y", and "negative-z". Default: "positive-x".
        """
        return _moco.MocoStepTimeAsymmetryGoal_setWalkingDirection(self, direction)

    def getWalkingDirection(self) -> "std::string":
        return _moco.MocoStepTimeAsymmetryGoal_getWalkingDirection(self)

    def setAsymmetrySmoothing(self, smoothing: "double") -> "void":
        r"""
        Set the values that determines the smoothing of the asymmetry
        computation. This term is necessary since this computation is non-smooth
        (i.e., either the left foot or right foot is in contact).
        """
        return _moco.MocoStepTimeAsymmetryGoal_setAsymmetrySmoothing(self, smoothing)

    def getAsymmetrySmoothing(self) -> "double":
        return _moco.MocoStepTimeAsymmetryGoal_getAsymmetrySmoothing(self)

    def setContactDetectionSmoothing(self, smoothing: "double") -> "void":
        r"""
        Set the value that determins the smoothing of the contact force
        detection. This term in necessary since foot contact is non-smooth,
        (i.e., ether the foot is in contact or not).
        """
        return _moco.MocoStepTimeAsymmetryGoal_setContactDetectionSmoothing(self, smoothing)

    def getContactDetectionSmoothing(self) -> "double":
        return _moco.MocoStepTimeAsymmetryGoal_getContactDetectionSmoothing(self)
    __swig_destroy__ = _moco.delete_MocoStepTimeAsymmetryGoal

# Register MocoStepTimeAsymmetryGoal in _moco:
_moco.MocoStepTimeAsymmetryGoal_swigregister(MocoStepTimeAsymmetryGoal)

def MocoStepTimeAsymmetryGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepTimeAsymmetryGoal *":
    return _moco.MocoStepTimeAsymmetryGoal_safeDownCast(obj)

def MocoStepTimeAsymmetryGoal_getClassName() -> "std::string const &":
    return _moco.MocoStepTimeAsymmetryGoal_getClassName()

class MocoStepLengthAsymmetryGoal(MocoGoal):
    r"""
     Minimize the error between a model's step time asymmetry and a specified
    target asymmetry value over a gait cycle.

    Step Length Asymmetry (SLA) is a ratio and is calculated as follows:
    The Right Step Length (RSL) is the distance between feet at right foot strike
    The Left Step Length (LSL) is the distance between feet at left foot strike
    Step Length Asymmetry = (RSL - LSL) / (RSL + LSL)

    In this goal, the distance between feet, or "foot frames", is limited throughout
    the gait cycle. The goal calculates the distance between the left foot and right
    foot, then limits the distance between feet to not pass beyond minimum (negative)
    or maximum (positive) bounds. There are two limits used: one that limits the
    distance between feet when the right foot is in front, and one that limits the
    distance between feet when the left foot is in front.

    Users must provide the target asymmetry value via 'setTargetAsymmetry()'.
    Asymmetry values ranges from -1.0 to 1.0. For example, 0.20 is 20% positive
    step length asymmetry with greater right step length than left step length. A
    symmetric step length solution can be achieved by setting this property to zero.
    This goal can be used only in 'cost' mode. To make this goal suitable for
    gradient-based optimization, step length values are assigned via a smoothing
    function which can be controlled via 'setAsymmetrySmoothing()'.

    Users must also prescribe the stride length via 'setStrideLength()'. The goal
    then calculates the minimum and maximum bounds on the distance between right
    and left foot. Users must ensure that this stride length is met via problem
    bounds or other goals; the value provided to MocoStepLengthAsymmetryGoal is
    only used to compute the model's asymmetry in the cost function.

    Notes: This goal is designed for simulations of bipedal gait.

    Since this goal approximates step length asymmetry, users should calculate
    the true asymmetry value after running an optimization.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepLengthAsymmetryGoal *":
        return _moco.MocoStepLengthAsymmetryGoal_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoStepLengthAsymmetryGoal_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoStepLengthAsymmetryGoal_getClassName()

    def clone(self) -> "OpenSim::MocoStepLengthAsymmetryGoal *":
        return _moco.MocoStepLengthAsymmetryGoal_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoStepLengthAsymmetryGoal_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoStepLengthAsymmetryGoal_swiginit(self, _moco.new_MocoStepLengthAsymmetryGoal(*args))

    def setLeftFootFrame(self, frame: "std::string const &") -> "void":
        r""" Set the body frame associated with the left foot."""
        return _moco.MocoStepLengthAsymmetryGoal_setLeftFootFrame(self, frame)

    def getLeftFootFrame(self) -> "std::string":
        return _moco.MocoStepLengthAsymmetryGoal_getLeftFootFrame(self)

    def setRightFootFrame(self, frame: "std::string const &") -> "void":
        r""" Set the body frame associated with the right foot."""
        return _moco.MocoStepLengthAsymmetryGoal_setRightFootFrame(self, frame)

    def getRightFootFrame(self) -> "std::string":
        return _moco.MocoStepLengthAsymmetryGoal_getRightFootFrame(self)

    def setTargetAsymmetry(self, asymmetry: "double") -> "void":
        r"""
        Set the asymmetry value targeted by this goal. The error between the
        target asymmetry and the model asymmetry is squared in the integrand.
        """
        return _moco.MocoStepLengthAsymmetryGoal_setTargetAsymmetry(self, asymmetry)

    def getTargetAsymmetry(self) -> "double":
        return _moco.MocoStepLengthAsymmetryGoal_getTargetAsymmetry(self)

    def setStrideLength(self, length: "double") -> "void":
        r"""
        Set the known stride length of your walking simulation. This value is
        necessary to compute step length asymmetry.
        """
        return _moco.MocoStepLengthAsymmetryGoal_setStrideLength(self, length)

    def getStrideLength(self) -> "double":
        return _moco.MocoStepLengthAsymmetryGoal_getStrideLength(self)

    def setWalkingDirection(self, direction: "std::string const &") -> "void":
        r"""
        Set the walking direction of the model in the ground frame, which is used
        to compute step lengths. Acceptable direction values include
        "positive-x", "positive-y", "positive-z", "negative-x", "negative-y", and
        "negative-z". Default: "positive-x".
        """
        return _moco.MocoStepLengthAsymmetryGoal_setWalkingDirection(self, direction)

    def getWalkingDirection(self) -> "std::string":
        return _moco.MocoStepLengthAsymmetryGoal_getWalkingDirection(self)

    def setAsymmetrySmoothing(self, smoothing: "double") -> "void":
        r"""
        Set the values that determines the smoothing of the asymmetry
        computation. This term is necessary since this computation is non-smooth.
        Larger smoothing values mean that larger step length errors are required
        for a given step to be counted towards the total asymmetry error
        minimized in the cost.
        """
        return _moco.MocoStepLengthAsymmetryGoal_setAsymmetrySmoothing(self, smoothing)

    def getAsymmetrySmoothing(self) -> "double":
        return _moco.MocoStepLengthAsymmetryGoal_getAsymmetrySmoothing(self)
    __swig_destroy__ = _moco.delete_MocoStepLengthAsymmetryGoal

# Register MocoStepLengthAsymmetryGoal in _moco:
_moco.MocoStepLengthAsymmetryGoal_swigregister(MocoStepLengthAsymmetryGoal)

def MocoStepLengthAsymmetryGoal_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStepLengthAsymmetryGoal *":
    return _moco.MocoStepLengthAsymmetryGoal_safeDownCast(obj)

def MocoStepLengthAsymmetryGoal_getClassName() -> "std::string const &":
    return _moco.MocoStepLengthAsymmetryGoal_getClassName()

class MocoKinematicConstraint(object):
    r"""
    A model kinematic constraint to be enforced in the optimal control problem.
    Objects of this class can only be instantiated by a MocoPhase, since
    information from each constraint in the model is required to ensure that
    the correct values are assigned to internal variables during construction.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getConstraintInfo(self) -> "MocoConstraintInfo const &":
        return _moco.MocoKinematicConstraint_getConstraintInfo(self)

    def setConstraintInfo(self, cInfo: "MocoConstraintInfo const &") -> "void":
        return _moco.MocoKinematicConstraint_setConstraintInfo(self, cInfo)

    def getSimbodyConstraintIndex(self) -> "SimTK::ConstraintIndex":
        r"""
        Get the SimTK::ConstraintIndex associated with this
        MocoKinematicConstraint. Note that a SimTK::ConstraintIndex is different
        from what is returned from MocoPathConstraint::getPathConstraintIndex():
        the former is an index to a model constraint, whereas the latter is an
        index to the path constraint errors vector in a MocoProblem.
        """
        return _moco.MocoKinematicConstraint_getSimbodyConstraintIndex(self)

    def getNumPositionEquations(self) -> "int":
        r"""
         Get the number of scalar constraint equations at each kinematic level.
         Note that the total number of scalar constraint equations enforced is
        NOT* equal to the sum of each of these values -- you must include the
         first and second derivatives of the position equations and the first
         derivatives of the velocity equations into that count as well (this
         value can be obtained by calling getNumEquations()).
        """
        return _moco.MocoKinematicConstraint_getNumPositionEquations(self)

    def getNumVelocityEquations(self) -> "int":
        return _moco.MocoKinematicConstraint_getNumVelocityEquations(self)

    def getNumAccelerationEquations(self) -> "int":
        return _moco.MocoKinematicConstraint_getNumAccelerationEquations(self)

    def getKinematicLevels(self) -> "std::vector< KinematicLevel,std::allocator< KinematicLevel > >":
        r"""
        Get a vector of enums specifying the kinematic level of each scalar
        constraint equation in the associated model constraint, as each equation
        may need to be treated differently in a solver (e.g. don't add Lagrange
        multipliers for derivatives of position or velocity constraint equations
        when looping through all scalar
        constraint equations).
        """
        return _moco.MocoKinematicConstraint_getKinematicLevels(self)

    def calcKinematicConstraintErrors(self, model: "Model", state: "State", errors: "Vector") -> "void":
        r"""
        Convenience method for calculating constraint errors given a
        SimTK::State object. This may not be the most efficient solution for
        solvers, but could be useful for a quick implementation or for
        debugging model constraints causing issues in an optimal control
        problem.
        The errors vector passed must be consistent with the
        number of scalar constraint equations associated with this
        MocoKinematicConstraint.
        """
        return _moco.MocoKinematicConstraint_calcKinematicConstraintErrors(self, model, state, errors)
    __swig_destroy__ = _moco.delete_MocoKinematicConstraint

# Register MocoKinematicConstraint in _moco:
_moco.MocoKinematicConstraint_swigregister(MocoKinematicConstraint)

class MocoPathConstraint(opensim.common.OpenSimObject):
    r"""
     A path constraint to be enforced in the optimal control problem.
    The use of 'path' here is unrelated to muscle paths, GeometryPath,
    or file system paths (e.g., Path).
    Title: For developers
    Every time the problem is solved, a copy of this constraint is used. An
    individual instance of a constraint is only ever used in a single problem.
    Therefore, there is no need to clear cache variables that you create in
    initializeImpl(). Also, information stored in this constraint does not
    persist across multiple solves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPathConstraint *":
        return _moco.MocoPathConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoPathConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoPathConstraint_getClassName()

    def clone(self) -> "OpenSim::MocoPathConstraint *":
        return _moco.MocoPathConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoPathConstraint_getConcreteClassName(self)

    def getConstraintInfo(self) -> "MocoConstraintInfo const &":
        return _moco.MocoPathConstraint_getConstraintInfo(self)

    def updConstraintInfo(self) -> "MocoConstraintInfo &":
        return _moco.MocoPathConstraint_updConstraintInfo(self)

    def setConstraintInfo(self, cInfo: "MocoConstraintInfo const &") -> "void":
        return _moco.MocoPathConstraint_setConstraintInfo(self, cInfo)

    def getPathConstraintIndex(self) -> "int":
        r"""
        For use by solvers. This index is the location of this
           MocoPathConstraint's first error in the MocoProblem's full path
           constraint errors vector. Since it is set by the MocoProblem, it is only
           available after initialization.
        """
        return _moco.MocoPathConstraint_getPathConstraintIndex(self)

    def calcPathConstraintErrors(self, state: "State", errors: "Vector") -> "void":
        r"""
        Calculate errors in the path constraint equations. The *errors* argument
           represents the error vector for this MocoPathConstraint. The errors vector
           is passed to calcPathConstraintErrorsImpl(), which is defined by derived
           classes.
           initializeOnModel() has been invoked.
        """
        return _moco.MocoPathConstraint_calcPathConstraintErrors(self, state, errors)

    def calcPathConstraintErrorsView(self, state: "State", errors: "Vector") -> "void":
        r"""
        Calculate errors in the path constraint equations. The *errors* argument
           represents the concatenated error vector for all path constraints in the
           MocoProblem. This method creates a view into *errors* to access the
           elements for this MocoPathConstraint and passes this view to
           calcPathConstraintErrorsImpl().
           initializeOnModel() has been invoked.
        """
        return _moco.MocoPathConstraint_calcPathConstraintErrorsView(self, state, errors)

    def initializeOnModel(self, model: "Model", arg3: "OpenSim::MocoProblemInfo const &", pathConstraintIndex: "int const &") -> "void":
        r"""
        Perform error checks on user input for this constraint, and cache
           quantities needed when computing the constraint errors.
           to efficiently evaluate the constraint.
           This function must be invoked before invoking
           calcPathConstraintErrors().
        """
        return _moco.MocoPathConstraint_initializeOnModel(self, model, arg3, pathConstraintIndex)

    def printDescription(self) -> "void":
        r""" Print the description for this path constraint."""
        return _moco.MocoPathConstraint_printDescription(self)
    __swig_destroy__ = _moco.delete_MocoPathConstraint

# Register MocoPathConstraint in _moco:
_moco.MocoPathConstraint_swigregister(MocoPathConstraint)

def MocoPathConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPathConstraint *":
    return _moco.MocoPathConstraint_safeDownCast(obj)

def MocoPathConstraint_getClassName() -> "std::string const &":
    return _moco.MocoPathConstraint_getClassName()

class MocoControlBoundConstraint(MocoPathConstraint):
    r"""
     This class constrains any number of control signals from ScalarActautor%s to
    be between two time-based functions. It is possible to constrain the control
    signal to be exactly to a provided function; see the equality_with_lower
    property.

    If a function is a GCVSpline, we ensure that the spline covers the entire
    possible time range in the problem (using the problem's time bounds). We do
    not perform such a check for other types of functions.

    Notes: If you omit the lower and upper bounds, then this class will not
    constrain any control signals, even if you have provided control paths.

    This class can only constrain control signals for ScalarActuator%s.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlBoundConstraint *":
        return _moco.MocoControlBoundConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoControlBoundConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoControlBoundConstraint_getClassName()

    def clone(self) -> "OpenSim::MocoControlBoundConstraint *":
        return _moco.MocoControlBoundConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoControlBoundConstraint_getConcreteClassName(self)

    def __init__(self):
        _moco.MocoControlBoundConstraint_swiginit(self, _moco.new_MocoControlBoundConstraint())

    def addControlPath(self, controlPath: "std::string") -> "void":
        r"""
        Set the control paths (absolute paths to actuators in the model)
        constrained by this class.
        """
        return _moco.MocoControlBoundConstraint_addControlPath(self, controlPath)

    def setControlPaths(self, controlPaths: "StdVectorString") -> "void":
        return _moco.MocoControlBoundConstraint_setControlPaths(self, controlPaths)

    def clearControlPaths(self) -> "void":
        return _moco.MocoControlBoundConstraint_clearControlPaths(self)

    def getControlPaths(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoControlBoundConstraint_getControlPaths(self)

    def setLowerBound(self, f: "Function") -> "void":
        
        return _moco.MocoControlBoundConstraint_setLowerBound(self, f)

    def clearLowerBound(self) -> "void":
        return _moco.MocoControlBoundConstraint_clearLowerBound(self)

    def hasLowerBound(self) -> "bool":
        return _moco.MocoControlBoundConstraint_hasLowerBound(self)

    def getLowerBound(self) -> "OpenSim::Function const &":
        return _moco.MocoControlBoundConstraint_getLowerBound(self)

    def setUpperBound(self, f: "Function") -> "void":
        return _moco.MocoControlBoundConstraint_setUpperBound(self, f)

    def clearUpperBound(self) -> "void":
        return _moco.MocoControlBoundConstraint_clearUpperBound(self)

    def hasUpperBound(self) -> "bool":
        return _moco.MocoControlBoundConstraint_hasUpperBound(self)

    def getUpperBound(self) -> "OpenSim::Function const &":
        return _moco.MocoControlBoundConstraint_getUpperBound(self)

    def setEqualityWithLower(self, v: "bool") -> "void":
        r"""
        Should the control be constrained to be equal to the lower bound (rather
        than an inequality constraint)? In this case, the upper bound must be
        unspecified.
        """
        return _moco.MocoControlBoundConstraint_setEqualityWithLower(self, v)

    def getEqualityWithLower(self) -> "bool":
        return _moco.MocoControlBoundConstraint_getEqualityWithLower(self)
    __swig_destroy__ = _moco.delete_MocoControlBoundConstraint

# Register MocoControlBoundConstraint in _moco:
_moco.MocoControlBoundConstraint_swigregister(MocoControlBoundConstraint)

def MocoControlBoundConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoControlBoundConstraint *":
    return _moco.MocoControlBoundConstraint_safeDownCast(obj)

def MocoControlBoundConstraint_getClassName() -> "std::string const &":
    return _moco.MocoControlBoundConstraint_getClassName()

class MocoFrameDistanceConstraintPair(opensim.common.OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFrameDistanceConstraintPair *":
        return _moco.MocoFrameDistanceConstraintPair_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoFrameDistanceConstraintPair_getClassName()

    def clone(self) -> "OpenSim::MocoFrameDistanceConstraintPair *":
        return _moco.MocoFrameDistanceConstraintPair_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoFrameDistanceConstraintPair_getConcreteClassName(self)

    def copyProperty_frame1_path(self, source: "MocoFrameDistanceConstraintPair") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_copyProperty_frame1_path(self, source)

    def append_frame1_path(self, value: "std::string const &") -> "int":
        return _moco.MocoFrameDistanceConstraintPair_append_frame1_path(self, value)

    def constructProperty_frame1_path(self, initValue: "std::string const &") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_constructProperty_frame1_path(self, initValue)

    def get_frame1_path(self, *args) -> "std::string const &":
        return _moco.MocoFrameDistanceConstraintPair_get_frame1_path(self, *args)

    def upd_frame1_path(self, *args) -> "std::string &":
        return _moco.MocoFrameDistanceConstraintPair_upd_frame1_path(self, *args)

    def set_frame1_path(self, *args) -> "void":
        return _moco.MocoFrameDistanceConstraintPair_set_frame1_path(self, *args)

    def copyProperty_frame2_path(self, source: "MocoFrameDistanceConstraintPair") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_copyProperty_frame2_path(self, source)

    def append_frame2_path(self, value: "std::string const &") -> "int":
        return _moco.MocoFrameDistanceConstraintPair_append_frame2_path(self, value)

    def constructProperty_frame2_path(self, initValue: "std::string const &") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_constructProperty_frame2_path(self, initValue)

    def get_frame2_path(self, *args) -> "std::string const &":
        return _moco.MocoFrameDistanceConstraintPair_get_frame2_path(self, *args)

    def upd_frame2_path(self, *args) -> "std::string &":
        return _moco.MocoFrameDistanceConstraintPair_upd_frame2_path(self, *args)

    def set_frame2_path(self, *args) -> "void":
        return _moco.MocoFrameDistanceConstraintPair_set_frame2_path(self, *args)

    def copyProperty_minimum_distance(self, source: "MocoFrameDistanceConstraintPair") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_copyProperty_minimum_distance(self, source)

    def append_minimum_distance(self, value: "double const &") -> "int":
        return _moco.MocoFrameDistanceConstraintPair_append_minimum_distance(self, value)

    def constructProperty_minimum_distance(self, initValue: "double const &") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_constructProperty_minimum_distance(self, initValue)

    def get_minimum_distance(self, *args) -> "double const &":
        return _moco.MocoFrameDistanceConstraintPair_get_minimum_distance(self, *args)

    def upd_minimum_distance(self, *args) -> "double &":
        return _moco.MocoFrameDistanceConstraintPair_upd_minimum_distance(self, *args)

    def set_minimum_distance(self, *args) -> "void":
        return _moco.MocoFrameDistanceConstraintPair_set_minimum_distance(self, *args)

    def copyProperty_maximum_distance(self, source: "MocoFrameDistanceConstraintPair") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_copyProperty_maximum_distance(self, source)

    def append_maximum_distance(self, value: "double const &") -> "int":
        return _moco.MocoFrameDistanceConstraintPair_append_maximum_distance(self, value)

    def constructProperty_maximum_distance(self, initValue: "double const &") -> "void":
        return _moco.MocoFrameDistanceConstraintPair_constructProperty_maximum_distance(self, initValue)

    def get_maximum_distance(self, *args) -> "double const &":
        return _moco.MocoFrameDistanceConstraintPair_get_maximum_distance(self, *args)

    def upd_maximum_distance(self, *args) -> "double &":
        return _moco.MocoFrameDistanceConstraintPair_upd_maximum_distance(self, *args)

    def set_maximum_distance(self, *args) -> "void":
        return _moco.MocoFrameDistanceConstraintPair_set_maximum_distance(self, *args)

    def __init__(self, *args):
        _moco.MocoFrameDistanceConstraintPair_swiginit(self, _moco.new_MocoFrameDistanceConstraintPair(*args))
    __swig_destroy__ = _moco.delete_MocoFrameDistanceConstraintPair

# Register MocoFrameDistanceConstraintPair in _moco:
_moco.MocoFrameDistanceConstraintPair_swigregister(MocoFrameDistanceConstraintPair)

def MocoFrameDistanceConstraintPair_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFrameDistanceConstraintPair *":
    return _moco.MocoFrameDistanceConstraintPair_safeDownCast(obj)

def MocoFrameDistanceConstraintPair_getClassName() -> "std::string const &":
    return _moco.MocoFrameDistanceConstraintPair_getClassName()

class MocoFrameDistanceConstraint(MocoPathConstraint):
    r"""
     This path constraint enforces that the distance between the origins of pairs
    of model frames is kept between minimum and maximum bounds. Frame pairs and
    their bounds are specified via a MocoFrameDistancConstraintPair.
    Any model component derived from Frame is valid to be included in a frame
    pair, and any number of frame pairs may be append to this constraint via
    addFramePair().

    This constraint can be used as a simple method for preventing bodies in your
    model from intersecting during an optimization. For example, the
    following prevents feet from intersecting during a walking optimization:

    .. code-block:: c++

        distance = problem.addPathConstraint<MocoFrameDistanceConstraint>();
        distance.setName("minimum_distance");
        SimTK::Real inf = SimTK::Infinity;
        distance.addFramePair('/bodyset/calcn_l', '/bodyset/calcn_r', 0.1, inf);
        distance.addFramePair('/bodyset/toes_l', '/bodyset/toes_r', 0.1, inf);
        distance.addFramePair('/bodyset/calcn_l', '/bodyset/toes_r', 0.1, inf);
        distance.addFramePair('/bodyset/toes_l', '/bodyset/calcn_r', 0.1, inf);

    To project the frame distance onto a vector or plane before ensuring its
    within the provided bounds, use setProjection() and setProjectionVector().

    Notes: This class represents a path constraint, *not* a model kinematic
    constraint. Therefore, there are no Lagrange multipliers or constraint
    forces associated with this constraint. The model's force elements
    (including actuators) must generate the forces necessary for satisfying this
    constraint.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFrameDistanceConstraint *":
        return _moco.MocoFrameDistanceConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoFrameDistanceConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoFrameDistanceConstraint_getClassName()

    def clone(self) -> "OpenSim::MocoFrameDistanceConstraint *":
        return _moco.MocoFrameDistanceConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoFrameDistanceConstraint_getConcreteClassName(self)

    def __init__(self):
        _moco.MocoFrameDistanceConstraint_swiginit(self, _moco.new_MocoFrameDistanceConstraint())

    def addFramePair(self, *args) -> "void":
        return _moco.MocoFrameDistanceConstraint_addFramePair(self, *args)

    def setProjection(self, projection: "std::string") -> "void":
        r"""
        Set if each distance should be projected onto either a vector or
        plane. Possible values: "none" (default), "vector", and "plane".
        """
        return _moco.MocoFrameDistanceConstraint_setProjection(self, projection)

    def getProjection(self) -> "std::string":
        return _moco.MocoFrameDistanceConstraint_getProjection(self)

    def setProjectionVector(self, vector: "Vec3") -> "void":
        r"""
        Set the vector to use for projecting each distance.
        If the projection type is "vector", the distance is projected onto
        the vector provided here. If the projection type is "plane", the
        distance is projected onto the plane perpendicular to this vector.
        """
        return _moco.MocoFrameDistanceConstraint_setProjectionVector(self, vector)

    def clearProjectionVector(self) -> "void":
        r""" Unset the projection vector."""
        return _moco.MocoFrameDistanceConstraint_clearProjectionVector(self)

    def getProjectionVector(self) -> "SimTK::Vec3":
        return _moco.MocoFrameDistanceConstraint_getProjectionVector(self)
    __swig_destroy__ = _moco.delete_MocoFrameDistanceConstraint

# Register MocoFrameDistanceConstraint in _moco:
_moco.MocoFrameDistanceConstraint_swigregister(MocoFrameDistanceConstraint)

def MocoFrameDistanceConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoFrameDistanceConstraint *":
    return _moco.MocoFrameDistanceConstraint_safeDownCast(obj)

def MocoFrameDistanceConstraint_getClassName() -> "std::string const &":
    return _moco.MocoFrameDistanceConstraint_getClassName()

class MocoOutputConstraint(MocoPathConstraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputConstraint *":
        return _moco.MocoOutputConstraint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoOutputConstraint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoOutputConstraint_getClassName()

    def clone(self) -> "OpenSim::MocoOutputConstraint *":
        return _moco.MocoOutputConstraint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoOutputConstraint_getConcreteClassName(self)

    def __init__(self):
        _moco.MocoOutputConstraint_swiginit(self, _moco.new_MocoOutputConstraint())

    def setOutputPath(self, path: "std::string") -> "void":
        r"""
        Set the absolute path to the output in the model to be used in this path
           constraint. The format is "/path/to/component|output_name".
        """
        return _moco.MocoOutputConstraint_setOutputPath(self, path)

    def getOutputPath(self) -> "std::string const &":
        return _moco.MocoOutputConstraint_getOutputPath(self)

    def setExponent(self, exponent: "int") -> "void":
        r"""
        Set the exponent applied to the output value in the constraint. This
           exponent is applied when minimizing the norm of a vector type output.
        """
        return _moco.MocoOutputConstraint_setExponent(self, exponent)

    def getExponent(self) -> "int":
        return _moco.MocoOutputConstraint_getExponent(self)

    def setOutputIndex(self, index: "int") -> "void":
        r"""
        Set the index to the value to be constrained when a vector type Output is
           specified. For SpatialVec Outputs, indices 0, 1, and 2 refer to the
           rotational components and indices 3, 4, and 5 refer to the translational
           components. A value of -1 indicates to constrain the vector norm (which is
           the default setting). If an index for a type double Output is provided, an
           exception is thrown.
        """
        return _moco.MocoOutputConstraint_setOutputIndex(self, index)

    def getOutputIndex(self) -> "int":
        return _moco.MocoOutputConstraint_getOutputIndex(self)
    __swig_destroy__ = _moco.delete_MocoOutputConstraint

# Register MocoOutputConstraint in _moco:
_moco.MocoOutputConstraint_swigregister(MocoOutputConstraint)

def MocoOutputConstraint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoOutputConstraint *":
    return _moco.MocoOutputConstraint_safeDownCast(obj)

def MocoOutputConstraint_getClassName() -> "std::string const &":
    return _moco.MocoOutputConstraint_getClassName()

class MocoProblemRep(object):
    r"""
    The primary intent of this class is for use by MocoSolver%s, but users
    can also use this class to apply parameter values to the model
    and evaluate cost terms.
    This class also checks the MocoProblem for various errors.
    To get an instance of this class, use MocoProblem::createRep().
    This interface currently supports only single-phase problems.
    This class stores a reference (not a copy) to the original MocoProblem
    from which it was created.

    Title: ModelBase and ModelDisabledConstraints
    This class provides access to two models: ModelBase is obtained by
    processing the ModelProcessor that the user gives to MocoProblem.
    ModelDisabledConstraints is a copy of ModelBase in which all kinematic
    constraints are disabled.
    ModelDisabledConstraints contains a DiscreteForces component, which
    is used to apply constraint forces computed using ModelBase.
    If kinematics are not prescribed (with PositionMotion),
    ModelDisabledConstraints also contains an AccelerationMotion component,
    which is used by solvers that rely on implicit multibody dynamics.
    The initialize() function adds a DiscreteController
    to both models; this controller is used by a solver to set the control
    signals for actuators to use.
    To learn the need for and use of these two models, see 'impldiverse'.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _moco.MocoProblemRep_swiginit(self, _moco.new_MocoProblemRep(*args))

    def getName(self) -> "std::string const &":
        return _moco.MocoProblemRep_getName(self)

    def getModelBase(self) -> "OpenSim::Model const &":
        r"""
        Get a reference to the copy of the model being used by this
        MocoProblemRep. This model is obtained by processing the ModelProcessor
        the user gives to MocoProblem. This model is *not* the model given to
        MocoGoal or MocoPathConstraint, but can be used within solvers to
        compute constraint forces and constraint errors (see
        getModelDisabledConstraints() for more details). Any parameter updates
        via a MocoParameter added to the problem will be applied to this model.
        """
        return _moco.MocoProblemRep_getModelBase(self)

    def updStateBase(self) -> "SimTK::State &":
        r""" This is a state object that solvers can use along with ModelBase."""
        return _moco.MocoProblemRep_updStateBase(self)

    def getDiscreteControllerBase(self) -> "OpenSim::DiscreteController const &":
        r"""
        This is a component inside ModelBase that you can use to
        set the value of control signals.
        """
        return _moco.MocoProblemRep_getDiscreteControllerBase(self)

    def getModelDisabledConstraints(self) -> "OpenSim::Model const &":
        r"""
        Get a reference to a copy of the model being used by this
        MocoProblemRep, but with all constraints disabled and an additional
        DiscreteForces component. This new component can be used to apply
        constraint forces computed from the base model to this model, which
        updates the discrete variables in the state associated with these
        forces. You should use this model to compute accelerations via
        getModelDisabledConstraints().realizeAccleration(state), making sure to
        add any constraint forces to the model preceding the realization. This
        model is the same instance as that given to MocoGoal and
        MocoPathConstraint, ensuring that realizing to Stage::Acceleration
        in these classes produces the same accelerations computed by the solver.
        Any parameter updates via a MocoParameter added to the problem
        will be applied to this model.
        """
        return _moco.MocoProblemRep_getModelDisabledConstraints(self)

    def updStateDisabledConstraints(self, index: "int"=0) -> "SimTK::State &":
        r"""
        This is a state object that solvers can use with
        ModelDisabledConstraints. Some solvers may need to use 2 state objects
        at once; you can supply an index of 1 to get a second state object.
        """
        return _moco.MocoProblemRep_updStateDisabledConstraints(self, index)

    def getDiscreteControllerDisabledConstraints(self) -> "OpenSim::DiscreteController const &":
        r"""
        This is a component inside ModelDisabledConstraints that you can use to
        set the value of control signals.
        """
        return _moco.MocoProblemRep_getDiscreteControllerDisabledConstraints(self)

    def getConstraintForces(self) -> "OpenSim::DiscreteForces const &":
        r"""
        This is a component inside ModelDisabledConstraints that you can use
        to set the value of discrete forces, intended to hold the constraint
        forces obtained from ModelBase.
        """
        return _moco.MocoProblemRep_getConstraintForces(self)

    def getAccelerationMotion(self) -> "OpenSim::AccelerationMotion const &":
        r"""
        This is a component inside ModelDisabledConstraints that you can use
        to set the value of generalized accelerations UDot, for use in
        implicit dynamics formulations. The motion is not necessarily enabled.
        """
        return _moco.MocoProblemRep_getAccelerationMotion(self)

    def getNumStates(self) -> "int":
        return _moco.MocoProblemRep_getNumStates(self)

    def getNumControls(self) -> "int":
        return _moco.MocoProblemRep_getNumControls(self)

    def getNumParameters(self) -> "int":
        return _moco.MocoProblemRep_getNumParameters(self)

    def getNumCosts(self) -> "int":
        r""" Get the number of goals in cost mode."""
        return _moco.MocoProblemRep_getNumCosts(self)

    def getNumEndpointConstraints(self) -> "int":
        r""" Get the number of goals in endpoint constraint mode."""
        return _moco.MocoProblemRep_getNumEndpointConstraints(self)

    def getNumKinematicConstraints(self) -> "int":
        return _moco.MocoProblemRep_getNumKinematicConstraints(self)

    def isPrescribedKinematics(self) -> "bool":
        r"""
        Does the model contain a PositionMotion to prescribe all generalized
        coordinates, speeds, and accelerations?
        """
        return _moco.MocoProblemRep_isPrescribedKinematics(self)

    def getNumImplicitAuxiliaryResiduals(self) -> "int":
        return _moco.MocoProblemRep_getNumImplicitAuxiliaryResiduals(self)

    def createStateVariableNamesInSystemOrder(self, yIndexMap: "std::unordered_map< int,int > &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        This excludes generalized coordinate and speed states if
        isPrescribedKinematics() is true.
        """
        return _moco.MocoProblemRep_createStateVariableNamesInSystemOrder(self, yIndexMap)

    def createStateInfoNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the state names of all the state infos."""
        return _moco.MocoProblemRep_createStateInfoNames(self)

    def createControlInfoNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the control names of all the control infos."""
        return _moco.MocoProblemRep_createControlInfoNames(self)

    def createParameterNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the names of all the parameters."""
        return _moco.MocoProblemRep_createParameterNames(self)

    def createCostNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the names of all the goals in cost mode."""
        return _moco.MocoProblemRep_createCostNames(self)

    def createEndpointConstraintNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the names of all the goals in endpoint constraint mode."""
        return _moco.MocoProblemRep_createEndpointConstraintNames(self)

    def createPathConstraintNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the names of all the MocoPathConstraint%s."""
        return _moco.MocoProblemRep_createPathConstraintNames(self)

    def createMultiplierInfoNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get the names of all the Lagrange multiplier infos."""
        return _moco.MocoProblemRep_createMultiplierInfoNames(self)

    def createKinematicConstraintNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the constraint names of all the kinematic constraints. Note: this
        should only be called after initialize().
        """
        return _moco.MocoProblemRep_createKinematicConstraintNames(self)

    def getKinematicConstraintEquationNames(self, includeDerivatives: "bool") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get a vector of names for all kinematic constraint equations.
        Kinematic constraint equations are ordered as so:
        - position-level constraints
        - velocity-level constraints
        - acceleration-level constraints
        If includeDerivatives is true, the ordering is:
        - position-level constraints
        - first derivative of position-level constraints (denoted by suffix "d")
        - velocity-level constraints
        - second derivative of position-level constraints (suffix "dd")
        - first derivative of velocity-level constraints (suffix "d")
        - acceleration-level constraints
        """
        return _moco.MocoProblemRep_getKinematicConstraintEquationNames(self, includeDerivatives)

    def getTimeInitialBounds(self) -> "OpenSim::MocoInitialBounds":
        r"""
        Note: the return value is constructed fresh on every call from
        the internal property. Avoid repeated calls to this function.
        """
        return _moco.MocoProblemRep_getTimeInitialBounds(self)

    def getTimeFinalBounds(self) -> "OpenSim::MocoFinalBounds":
        
        return _moco.MocoProblemRep_getTimeFinalBounds(self)

    def getStateInfo(self, name: "std::string const &") -> "OpenSim::MocoVariableInfo const &":
        r""" Get information for state variables. See MocoPhase::setStateInfo()."""
        return _moco.MocoProblemRep_getStateInfo(self, name)

    def getControlInfo(self, name: "std::string const &") -> "OpenSim::MocoVariableInfo const &":
        r"""
        Get information for actuator controls.
        If the control is associated with a non-scalar actuator (i.e. uses
        multiple control variables), then the control name will be the actuator
        path appended by the control index (e.g. "/actuator_0");
        See MocoPhase::setControlInfo().
        """
        return _moco.MocoProblemRep_getControlInfo(self, name)

    def getParameter(self, name: "std::string const &") -> "OpenSim::MocoParameter const &":
        return _moco.MocoProblemRep_getParameter(self, name)

    def getCost(self, name: "std::string const &") -> "OpenSim::MocoGoal const &":
        r""" Get a cost by name. This returns a MocoGoal in cost mode."""
        return _moco.MocoProblemRep_getCost(self, name)

    def getCostByIndex(self, index: "int") -> "OpenSim::MocoGoal const &":
        r"""
        Get a cost by index. The order is the same as in getCostNames().
        Note: this does not perform a bounds check.
        """
        return _moco.MocoProblemRep_getCostByIndex(self, index)

    def getEndpointConstraint(self, name: "std::string const &") -> "OpenSim::MocoGoal const &":
        r"""
        Get an endpoint constraint by name. This returns a MocoGoal in endpoint
        constraint mode.
        """
        return _moco.MocoProblemRep_getEndpointConstraint(self, name)

    def getEndpointConstraintByIndex(self, index: "int") -> "OpenSim::MocoGoal const &":
        r"""
        Get an endpoint constraint by index.
        The order is the same as in getEndpointConstraintNames().
        Note: this does not perform a bounds check.
        """
        return _moco.MocoProblemRep_getEndpointConstraintByIndex(self, index)

    def getPathConstraint(self, name: "std::string const &") -> "OpenSim::MocoPathConstraint const &":
        r"""
        Get a MocoPathConstraint. Note: this does not
        include MocoKinematicConstraints, use getKinematicConstraint() instead.
        """
        return _moco.MocoProblemRep_getPathConstraint(self, name)

    def getPathConstraintByIndex(self, index: "int") -> "OpenSim::MocoPathConstraint const &":
        r"""
        Get a path constraint by index. The order is the same as
        in getPathConstraintNames(). Note: this does not perform a bounds check.
        """
        return _moco.MocoProblemRep_getPathConstraintByIndex(self, index)

    def getNumPathConstraintEquations(self) -> "int":
        r"""
        Get the number of scalar path constraints in the MocoProblem. This does
        not include kinematic constraints equations.
        """
        return _moco.MocoProblemRep_getNumPathConstraintEquations(self)

    def getKinematicConstraint(self, name: "std::string const &") -> "OpenSim::MocoKinematicConstraint const &":
        r"""
        Get a MocoKinematicConstraint from this MocoPhase. Note: this does not
        include MocoPathConstraints, use getPathConstraint() instead.
        """
        return _moco.MocoProblemRep_getKinematicConstraint(self, name)

    def getNumKinematicConstraintEquations(self) -> "int":
        r"""
        Get the number of scalar kinematic constraints in the MocoProblem. This
        does not include path constraints equations.
        """
        return _moco.MocoProblemRep_getNumKinematicConstraintEquations(self)

    def printDescription(self) -> "void":
        r"""
        Print a description of this problem, including costs and variable
        bounds. Printing is done using OpenSim::log_cout().
        """
        return _moco.MocoProblemRep_printDescription(self)

    def calcPathConstraintErrors(self, state: "State", errors: "Vector") -> "void":
        r"""
        These functions are for use by MocoSolver%s, but can also be called
        by users for debugging.

        Calculate the errors in all the scalar path constraint equations in this
        phase.
        """
        return _moco.MocoProblemRep_calcPathConstraintErrors(self, state, errors)

    def calcKinematicConstraintErrors(self, state: "State") -> "SimTK::Vector":
        r"""
        Calculate the errors in all the scalar kinematic constraint equations in
        this phase. This may not be the most efficient solution for solvers, but
        is rather intended as a convenience method for a quick implementation or
        for debugging model constraints causing issues in an optimal control
        problem.
        """
        return _moco.MocoProblemRep_calcKinematicConstraintErrors(self, state)

    def applyParametersToModelProperties(self, parameterValues: "Vector", initSystemAndDisableConstraints: "bool"=False) -> "void":
        r"""
        Apply paramater values to the models created from the model passed to
        initialize() within the current MocoProblem. Values must be consistent
        with the order of parameters returned from createParameterNames().

        Note: initSystem() must be called on each model after calls to this
        method in order for provided parameter values to be applied to the
        model. You can pass `true` to have initSystem() called for you, and to
        also re-disable any constraints re-enabled by the initSystem() call
        (see getModelDisabledConstraints()).
        """
        return _moco.MocoProblemRep_applyParametersToModelProperties(self, parameterValues, initSystemAndDisableConstraints)

    def getImplicitResidualReferencePtrs(self) -> "std::vector< SimTK::ReferencePtr< OpenSim::Output< double > const >,std::allocator< SimTK::ReferencePtr< OpenSim::Output< double > const > > > const &":
        r"""
        Get a vector of reference pointers to model outputs that return residual
        values for any components with dynamics in implicit forms. The
        references returned are from the model returned by
        getModelDisabledConstraints().
        """
        return _moco.MocoProblemRep_getImplicitResidualReferencePtrs(self)

    def getImplicitComponentReferencePtrs(self) -> "std::vector< std::pair< std::string,SimTK::ReferencePtr< OpenSim::Component const > >,std::allocator< std::pair< std::string,SimTK::ReferencePtr< OpenSim::Component const > > > > const &":
        r"""
        Get reference pointers to components that enforce dynamics in implicit
        form. This returns a vector of pairs including the name of the discrete
        derivative variable and the component reference pointer.
        """
        return _moco.MocoProblemRep_getImplicitComponentReferencePtrs(self)
    __swig_destroy__ = _moco.delete_MocoProblemRep

# Register MocoProblemRep in _moco:
_moco.MocoProblemRep_swigregister(MocoProblemRep)

class MocoPhase(opensim.common.OpenSimObject):
    r"""
     The states, controls, dynamics, parameters, goals, and constraints for a
    phase of the problem.
    The dynamics are provided by the %OpenSim Model.

    This class allows you to define your problem, but does not let you do
    anything with your problem (this class only contains user input).
    Use MocoProblem::createRep() to create an instance of MocoProblemRep,
    which provides additional functionality.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPhase *":
        return _moco.MocoPhase_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoPhase_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoPhase_getClassName()

    def clone(self) -> "OpenSim::MocoPhase *":
        return _moco.MocoPhase_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoPhase_getConcreteClassName(self)

    def __init__(self):
        _moco.MocoPhase_swiginit(self, _moco.new_MocoPhase())

    def setModelAsCopy(self, model: "Model") -> "OpenSim::Model *":
        r"""
        The model is copied into the MocoPhase; further changes made to the
        passed-in model will have no effect on this MocoPhase.
        This function returns a pointer to the model stored in the phase
        (the copy).
        """
        return _moco.MocoPhase_setModelAsCopy(self, model)

    def setModelProcessor(self, model: "ModelProcessor") -> "void":
        r"""
        Set a model processor for creating the model for this phase. Use this
        to provide a model as a .osim file.
        """
        return _moco.MocoPhase_setModelProcessor(self, model)

    def updModelProcessor(self) -> "OpenSim::ModelProcessor &":
        r"""
        Get a mutable reference to the internal ModelProcessor. Use this to
        set the processor's base model or to add operators to the processor.
        """
        return _moco.MocoPhase_updModelProcessor(self)

    def setTimeBounds(self, arg2: "MocoInitialBounds", arg3: "MocoFinalBounds") -> "void":
        r"""
        Set the bounds on the initial and final time for this phase.
        If you want to constrain the initial time to a single value, pass
        that value to the constructor of MocoInitialBounds. If you want the
        initial time to fall within a range, pass the lower and upper bounds
        to the constructor of MocoInitialBounds. Likewise for MocoFinalBounds.
        This will overwrite bounds that were set previously, if any.
        """

        if not type(arg2) is MocoInitialBounds:
            arg2 = self._convert(MocoInitialBounds, arg2)
        if not type(arg3) is MocoFinalBounds:
            arg3 = self._convert(MocoFinalBounds, arg3)


        return _moco.MocoPhase_setTimeBounds(self, arg2, arg3)


    def printStateNamesWithSubstring(self, name: "std::string const &") -> "void":
        r""" Find and print the names of all state variables containing a substring."""
        return _moco.MocoPhase_printStateNamesWithSubstring(self, name)

    def setStateInfo(self, *args) -> "void":
        r"""
        Set information about a single state variable in this phase.
        :type name: string
        :param name:
                The name must match the path of a state variable in the
                model (e.g., `/hip/flexion/value` or `/hip/flexion/speed`).
        :type bounds: :py:class:`MocoBounds`
        :param bounds:
                The bounds on this state variable over the entire phase. If
                default-constructed (`{}`), then either the variable is
                unconstrained or default bounds are used (see below).
        :type init: :py:class:`MocoInitialBounds`, optional
        :param init:
                The bounds on this state variable at the start of the phase.
                By default, there are no additional bounds on the initial value
                (though the `bounds` over the entire phase still apply to the
                initial value).
        :param final:
                Similar to `init` but for the value at the end of the phase.

        For all bounds arguments: if you want to constrain to a single value,
        pass that single value. If you want to constrain to a range, pass
        the lower and upper bounds to the constructor as two arguments.

        Default bounds
        1. Coordinate values: the Coordinate's range is used (regardless of
            whether the coordinate is clamped).
        2. Coordinate speeds: this class's default_speed_bounds property.
        3. All other states: if a component has a SimTK::Vec2 output named
           `statebounds_<state-name>`, then this output is used to set default
           bounds for the state variable `<state-name>` for that component.
           The first element of the Vec2 is the lower bound and the second is
           the upper bound.

        These defaults are also used if you completely omit state info for a
        state variable.

        For states with default bounds, if you actually want a variable to
        be unconstrained, pass in MocoBounds::unconstrained().

        Examples
        Set bounds over the entire phase, but do not specify additional
        bounds on the value at the start and end of the phase.

        .. code-block:: c++

            phase.setStateInfo("/knee/flexion/value", {-1.5*SimTK::Pi, 0});

        Allow any value throughout the phase (within the coordinate's range),
        but the initial value is 5.

        .. code-block:: c++

            phase.setStateInfo("/ankle/flexion/value", {}, 5);

        Constrain the initial and final state to a single value of 0, but
        use default speed bounds elsewhere.

        .. code-block:: c++

            phase.setStateInfo("/ankle/flexion/speed", {}, 0, 0);

        Make a coordinate value unconstrained.

        .. code-block:: c++

            phase.setStateInfo("/ankle/flexion/value", MocoBounds::unconstrained());

        This function will overwrite any info that has previously been set for
        this state variable.
        """

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoPhase_setStateInfo(self, *args)


    def setStateInfoPattern(self, *args) -> "void":
        r"""
        Set information for state variables whose names match the provided
        regular expression. You can use this to set bounds for all muscle
        activations, etc. Infos provided via setStateInfoPattern() take
        precedence over the default values from the model. Infos provided via
        setStateInfo() take precedence over infos provided with
        setStateInfoPattern().  If a state variable name matches multiple
        patterns, the info provided with the last pattern is used for that state
        variable.
        """

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoPhase_setStateInfoPattern(self, *args)


    def printControlNamesWithSubstring(self, name: "std::string const &") -> "void":
        r""" Find and print the names of all control variables containing a substring."""
        return _moco.MocoPhase_printControlNamesWithSubstring(self, name)

    def setControlInfo(self, *args) -> "void":
        r"""
        Set information about a single control variable in this phase.
        Similar to setStateInfo(). The name for a control is the path to the
        associated actuator (e.g., "/forceset/soleus_r"). If setting a control
        info for an actuator with multiple controls, the name should be the
        actuator path appended by the control index (e.g. "/actuator_0");
        If info is not specified for a ScalarActuator (or if only the initial
        and/or final bounds are provided), the actuator's min and max control
        are used for the bounds over the phase. By default, non-ScalarActuators
        are unconstrained.
        """

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoPhase_setControlInfo(self, *args)


    def setDefaultSpeedBounds(self, bounds: "MocoBounds") -> "void":
        r"""
        Set the bounds on generalized speed state variables
        for which explicit bounds are not set.
        """
        return _moco.MocoPhase_setDefaultSpeedBounds(self, bounds)

    def setControlInfoPattern(self, *args) -> "void":
        r"""
        Set information for control variables whose names match the provided
        regular expression. You can use this to set bounds for all muscle
        activations, etc. Infos provided via setControlInfoPattern() take
        precedence over the default values from the model. Infos provided via
        setControlInfo() take precedence over infos provided with
        setControlInfoPattern().  If a state variable name matches multiple
        patterns, the info provided with the last pattern is used for that
        control variable.
        """

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoPhase_setControlInfoPattern(self, *args)


    def setBoundActivationFromExcitation(self, tf: "bool") -> "void":
        r"""
        For muscles without explicit activation bounds, set the bounds for
        muscle activation (if activation dynamics are enabled) from the bounds
        for muscle control (excitation), using min/max control if explicit
        control bounds are not provided. Default: true.
        """
        return _moco.MocoPhase_setBoundActivationFromExcitation(self, tf)

    def setKinematicConstraintBounds(self, bounds: "MocoBounds") -> "void":
        r"""
        Set the bounds on *all* of the kinematic constraint equations in this
        phase. When creating a MocoProblemRep, these bounds are used to create
        MocoConstraintInfo's for each kinematic constraint equation in the
        phase.
        """
        return _moco.MocoPhase_setKinematicConstraintBounds(self, bounds)

    def setMultiplierBounds(self, bounds: "MocoBounds") -> "void":
        r"""
        Set the bounds on *all* of the Lagrange multipliers in this phase.
        When creating a MocoProblemRep, these bounds are used to create
        MocoVariableInfo%s for each Lagrange multiplier in the phase.
        """
        return _moco.MocoPhase_setMultiplierBounds(self, bounds)

    def getModel(self) -> "OpenSim::Model const &":
        r"""
        Get the base model in the internal ModelProcessor. This throws an
        exception if the ModelProcessor does not have a base model. By default,
        the model is an empty model.
        """
        return _moco.MocoPhase_getModel(self)

    def updModel(self) -> "OpenSim::Model &":
        r"""
        Get a mutable reference to the base model in the internal
        ModelProcessor. This throws an exception if the ModelProcessor does not
        have a base model. By default, the model is an empty model.
        """
        return _moco.MocoPhase_updModel(self)

    def getModelProcessor(self) -> "OpenSim::ModelProcessor const &":
        r""" Get the ModelProcessor."""
        return _moco.MocoPhase_getModelProcessor(self)

    def getTimeInitialBounds(self) -> "OpenSim::MocoInitialBounds":
        r"""
        Note: the return value is constructed fresh on every call from
        the internal property. Avoid repeated calls to this function.
        """
        return _moco.MocoPhase_getTimeInitialBounds(self)

    def getTimeFinalBounds(self) -> "OpenSim::MocoFinalBounds":
        
        return _moco.MocoPhase_getTimeFinalBounds(self)

    def getStateInfo(self, name: "std::string const &") -> "OpenSim::MocoVariableInfo const &":
        r"""
        Access explicit state infos provided to this phase. For some state
        variables, default bounds are obtained from the model.
        This function does *not* provide such automatically-populated bounds
        from the model. For that, use see MocoProblemRep::getStateInfo().
        """
        return _moco.MocoPhase_getStateInfo(self, name)

    def getControlInfo(self, name: "std::string const &") -> "OpenSim::MocoVariableInfo const &":
        r"""
        Access explicit control infos provided to this phase.
        Default bounds are obtained from the model.
        This function does *not* provide such automatically-populated bounds
        from the model. For that, use see MocoProblemRep::getControlInfo().
        """
        return _moco.MocoPhase_getControlInfo(self, name)

    def getDefaultSpeedBounds(self) -> "OpenSim::MocoBounds const &":
        return _moco.MocoPhase_getDefaultSpeedBounds(self)

    def getBoundActivationFromExcitation(self) -> "bool":
        return _moco.MocoPhase_getBoundActivationFromExcitation(self)

    def getKinematicConstraintBounds(self) -> "OpenSim::MocoBounds const &":
        return _moco.MocoPhase_getKinematicConstraintBounds(self)

    def getMultiplierBounds(self) -> "OpenSim::MocoBounds const &":
        return _moco.MocoPhase_getMultiplierBounds(self)

    def getParameter(self, name: "std::string const &") -> "OpenSim::MocoParameter const &":
        return _moco.MocoPhase_getParameter(self, name)

    def updParameter(self, name: "std::string const &") -> "OpenSim::MocoParameter &":
        return _moco.MocoPhase_updParameter(self, name)

    def getGoal(self, name: "std::string const &") -> "OpenSim::MocoGoal const &":
        return _moco.MocoPhase_getGoal(self, name)

    def updGoal(self, name: "std::string const &") -> "OpenSim::MocoGoal &":
        return _moco.MocoPhase_updGoal(self, name)

    def getPathConstraint(self, name: "std::string const &") -> "OpenSim::MocoPathConstraint const &":
        r"""
        Get a MocoPathConstraint from this MocoPhase. Note: this does not
        include MocoKinematicConstraints, use getKinematicConstraint() instead.
        """
        return _moco.MocoPhase_getPathConstraint(self, name)

    def updPathConstraint(self, name: "std::string const &") -> "OpenSim::MocoPathConstraint &":
        return _moco.MocoPhase_updPathConstraint(self, name)

    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)


    def setModel(self, model: "Model") -> "void":
        val = _moco.MocoPhase_setModel(self, model)

        model._markAdopted()


        return val


    def addParameter(self, ptr: "MocoParameter") -> "void":
        val = _moco.MocoPhase_addParameter(self, ptr)

        ptr._markAdopted()


        return val


    def addGoal(self, ptr: "MocoGoal") -> "void":
        val = _moco.MocoPhase_addGoal(self, ptr)

        ptr._markAdopted()


        return val


    def addPathConstraint(self, ptr: "MocoPathConstraint") -> "void":
        val = _moco.MocoPhase_addPathConstraint(self, ptr)

        ptr._markAdopted()


        return val

    __swig_destroy__ = _moco.delete_MocoPhase

# Register MocoPhase in _moco:
_moco.MocoPhase_swigregister(MocoPhase)

def MocoPhase_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoPhase *":
    return _moco.MocoPhase_safeDownCast(obj)

def MocoPhase_getClassName() -> "std::string const &":
    return _moco.MocoPhase_getClassName()

class MocoProblem(opensim.common.OpenSimObject):
    r"""
     A description of an optimal control problem, backed by %OpenSim Model%s.
    A MocoProblem is a series of phases, each of which contains the following:
      - OpenSim Model
      - state and control variable info (e.g., bounds)
      - parameter variables (model properties)
      - goals (costs and endpoint constraints)
      - path constraints

    Currently, only single-phase problems are supported.
    This class has convenience methods to configure the first (0-th) phase.

    This class allows you to define your problem, but does not let you do
    anything with your problem (this class only contains user input).
    Use createRep() to create an instance of MocoProblemRep,
    which provides additional functionality.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoProblem *":
        return _moco.MocoProblem_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoProblem_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoProblem_getClassName()

    def clone(self) -> "OpenSim::MocoProblem *":
        return _moco.MocoProblem_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoProblem_getConcreteClassName(self)

    def __init__(self):
        _moco.MocoProblem_swiginit(self, _moco.new_MocoProblem())

    def setModelAsCopy(self, model: "Model") -> "OpenSim::Model *":
        r"""
        Set the model to use for phase 0.
        See also: MocoPhase::setModelAsCopy().
        """
        return _moco.MocoProblem_setModelAsCopy(self, model)

    def updModel(self) -> "OpenSim::Model &":
        r""" Update the model in phase 0."""
        return _moco.MocoProblem_updModel(self)

    def setModelProcessor(self, model: "ModelProcessor") -> "void":
        r"""
        Set a model processor for phase 0.
        See also: MocoPhase::setModelProcessor().
        """
        return _moco.MocoProblem_setModelProcessor(self, model)

    def setTimeBounds(self, arg2: "MocoInitialBounds", arg3: "MocoFinalBounds") -> "void":
        r""" Set time bounds for phase 0."""

        if not type(arg2) is MocoInitialBounds:
            arg2 = self._convert(MocoInitialBounds, arg2)
        if not type(arg3) is MocoFinalBounds:
            arg3 = self._convert(MocoFinalBounds, arg3)


        return _moco.MocoProblem_setTimeBounds(self, arg2, arg3)


    def printStateNamesWithSubstring(self, name: "std::string const &") -> "void":
        r""" Find and print the names of all state variables containing a substring."""
        return _moco.MocoProblem_printStateNamesWithSubstring(self, name)

    def setStateInfo(self, *args) -> "void":
        r""" Set bounds for a state variable for phase 0."""

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoProblem_setStateInfo(self, *args)


    def setStateInfoPattern(self, *args) -> "void":
        r"""
        Set bounds for all state variables for phase 0 whose path matches
        the provided pattern.
        """

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoProblem_setStateInfoPattern(self, *args)


    def printControlNamesWithSubstring(self, name: "std::string const &") -> "void":
        r""" Find and print the names of all state variables containing a substring."""
        return _moco.MocoProblem_printControlNamesWithSubstring(self, name)

    def setControlInfo(self, *args) -> "void":
        r""" Set bounds for a control variable for phase 0."""

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoProblem_setControlInfo(self, *args)


    def setControlInfoPattern(self, *args) -> "void":
        r""" Set bounds for a control variable using a regular expression."""

        args = list(args)
        if len(args) >= 2 and not type(args[1]) is MocoBounds:
            args[1] = self._convert(MocoBounds, args[1])
        if len(args) >= 3 and not type(args[2]) is MocoInitialBounds:
            args[2] = self._convert(MocoInitialBounds, args[2])
        if len(args) >= 4 and not type(args[3]) is MocoFinalBounds:
            args[3] = self._convert(MocoFinalBounds, args[3])


        return _moco.MocoProblem_setControlInfoPattern(self, *args)


    def setKinematicConstraintBounds(self, bounds: "MocoBounds") -> "void":
        r""" Set bounds for the kinematic constraints in phase 0."""
        return _moco.MocoProblem_setKinematicConstraintBounds(self, bounds)

    def setMultiplierBounds(self, bounds: "MocoBounds") -> "void":
        r""" Set bounds for the Lagrange multipliers in phase 0."""
        return _moco.MocoProblem_setMultiplierBounds(self, bounds)

    def updGoal(self, name: "std::string const &") -> "OpenSim::MocoGoal &":
        r""" Returns a reference to the goal with name "name" in phase 0."""
        return _moco.MocoProblem_updGoal(self, name)

    def updPhase(self, index: "int"=0) -> "OpenSim::MocoPhase &":
        r"""
        Get a modifiable phase of the problem by index (starting index of 0).
        This accesses the internal phases property.
        """
        return _moco.MocoProblem_updPhase(self, index)

    def getPhase(self, index: "int"=0) -> "OpenSim::MocoPhase const &":
        r"""
        Get a modifiable phase of the problem by index (starting index of 0).
        This accesses the internal phases property.
        """
        return _moco.MocoProblem_getPhase(self, index)

    def createRep(self) -> "std::unique_ptr< OpenSim::MocoProblemRep >":
        r"""
        Use this variant of createRep() if you require the MocoProblemRep to be
        dynamically-allocated MocoProblemRep.
        """
        return _moco.MocoProblem_createRep(self)

    def _convert(self, cls, v):
        if hasattr(v, '__len__'):
            if len(v) > 2:
                raise Exception("Bounds cannot have more than 2 elements.")
            elif len(v) == 0:
                return cls()
            elif len(v) == 1:
                return cls(v[0])
            elif len(v) == 2:
                return cls(v[0], v[1])
            else:
                return cls()
        else:
            return cls(v)


    def setModel(self, model: "Model") -> "void":
        val = _moco.MocoProblem_setModel(self, model)

        model._markAdopted()


        return val


    def addParameter(self, ptr: "MocoParameter") -> "void":
        val = _moco.MocoProblem_addParameter(self, ptr)

        ptr._markAdopted()


        return val


    def addGoal(self, ptr: "MocoGoal") -> "void":
        val = _moco.MocoProblem_addGoal(self, ptr)

        ptr._markAdopted()


        return val


    def addPathConstraint(self, ptr: "MocoPathConstraint") -> "void":
        val = _moco.MocoProblem_addPathConstraint(self, ptr)

        ptr._markAdopted()


        return val

    __swig_destroy__ = _moco.delete_MocoProblem

# Register MocoProblem in _moco:
_moco.MocoProblem_swigregister(MocoProblem)

def MocoProblem_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoProblem *":
    return _moco.MocoProblem_safeDownCast(obj)

def MocoProblem_getClassName() -> "std::string const &":
    return _moco.MocoProblem_getClassName()

class MocoParameter(opensim.common.OpenSimObject):
    r"""
     A MocoParameter allows you to optimize property values in an OpenSim Model.
    To describe this parameter, you must provide the name of the property you
    want to optimize and the path to the component in the model where the
    property exists. If the property is not a scalar, then you must also provide
    the element index of the property you want to optimize. To optimize multiple
    elements of a non-scalar property, use multiple MocoParameters.
    By specifying multiple component paths, you can optimize the same property
    in multiple components (each property will have the same value, as
    determined by this parameter).
    The following property types are currently supported:
     - double
     - Vec3
     - Vec6

    List properties are not currently supported.

    The name you give to a MocoParameter does not need to match the
    name of its model property.

    The default initial guess for a parameter depends on the solver you use. Most
    likely, the default initial guess is the midpoint of the bounds on the
    parameter (NOT the value of the property in the model).

    Create a MocoParameter from a property in the model:

    .. code-block:: c++

        MocoParameter p0;
        p0.setName("torso_mass");
        p0.appendComponentPath("torso");
        p0.setParameterName("mass");
        MocoBounds massBounds(60, 80);
        p0.setBounds(massBounds);

    Using the convenience constructor:

    .. code-block:: c++

        MocoParameter p0("torso_mass", "torso", "mass", MocoBounds(60, 80));

    Here is a Matlab example of optimizing the optimal fiber length of a muscle:

    .. code-block:: c++

        study = MocoStudy();
        problem = study.updProblem();
        param = MocoParameter('my_param_name', '/forceset/soleus_r', ...
                'optimal_fiber_length', MocoBounds(0.04, 0.06));
        problem.addParameter(param);

    The generic constructor can be used for more complex MocoParameter
    assignments. Here, we create a MocoParameter for the y-position of the mass
    center of three different rigid bodies in the model:

    .. code-block:: c++

        int propertyElt = 1; // y-position is the second element of the mass_center
        std::vector<std::string> componentPaths = {
            "/bodyset/pelvis",
            "/bodyset/thigh",
            "/bodyset/shank"
        };
        MocoParameter y_com("y_com", componentPaths, "mass_center",
                MocoBounds(-0.05, 0.05), propertyElt);
    Title: For developers
    Every time the problem is solved, a copy of this parameter is used.
    An individual instance of a parameter is only ever used in a single problem.
    Therefore, there is no need to clear cache variables that you create in
    initializeImpl(). Also, information stored in this parameter does not
    persist across multiple solves. Lastly, a MocoParameter may be applied to
    multiple models at once, as long as the value described in the MocoParameter
    exists and initializeOnModel() is called on all models of interest.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoParameter *":
        return _moco.MocoParameter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoParameter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoParameter_getClassName()

    def clone(self) -> "OpenSim::MocoParameter *":
        return _moco.MocoParameter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoParameter_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.MocoParameter_swiginit(self, _moco.new_MocoParameter(*args))

    def getBounds(self) -> "OpenSim::MocoBounds":
        return _moco.MocoParameter_getBounds(self)

    def getPropertyName(self) -> "std::string":
        return _moco.MocoParameter_getPropertyName(self)

    def getComponentPaths(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoParameter_getComponentPaths(self)

    def setBounds(self, bounds: "MocoBounds") -> "void":
        return _moco.MocoParameter_setBounds(self, bounds)

    def setPropertyName(self, propertyName: "std::string const &") -> "void":
        return _moco.MocoParameter_setPropertyName(self, propertyName)

    def appendComponentPath(self, componentPath: "std::string const &") -> "void":
        return _moco.MocoParameter_appendComponentPath(self, componentPath)

    def initializeOnModel(self, model: "Model") -> "void":
        r"""
        For use by solvers. This performs error checks and caches information
           about the model that is useful during the optimization.
           This method takes a non-const reference to the model because parameters
           need to be able to alter the model.
           If it is desired to apply this MocoParameter to multiple models, this
           should be called on all models of interest. The property references from
           each model will be appended to this MocoParameter's internal property
           reference list.
        """
        return _moco.MocoParameter_initializeOnModel(self, model)

    def applyParameterToModelProperties(self, value: "double const &") -> "void":
        r"""
        Set the value of the stored model properties, which may include
           properties from multiple models.
        """
        return _moco.MocoParameter_applyParameterToModelProperties(self, value)

    def printDescription(self) -> "void":
        r"""
        Print the name, property name, component paths, property element (if it
           exists), and bounds for this parameter.
        """
        return _moco.MocoParameter_printDescription(self)
    __swig_destroy__ = _moco.delete_MocoParameter

# Register MocoParameter in _moco:
_moco.MocoParameter_swigregister(MocoParameter)

def MocoParameter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoParameter *":
    return _moco.MocoParameter_safeDownCast(obj)

def MocoParameter_getClassName() -> "std::string const &":
    return _moco.MocoParameter_getClassName()

class MocoTrajectoryIsSealed(opensim.common.OpenSimException):
    r"""
    This exception is thrown if you try to invoke most methods on MocoTrajectory
    while the trajectory is sealed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _moco.MocoTrajectoryIsSealed_swiginit(self, _moco.new_MocoTrajectoryIsSealed(file, line, func))
    __swig_destroy__ = _moco.delete_MocoTrajectoryIsSealed

# Register MocoTrajectoryIsSealed in _moco:
_moco.MocoTrajectoryIsSealed_swigregister(MocoTrajectoryIsSealed)

class MocoTrajectory(object):
    r"""
     The values of the variables in an optimal control problem.
    This can be used for specifying an initial guess, or holding the solution
    returned by a solver.

    A MocoTrajectory can be written to and read from an STO (".sto") file. The file
    format is comprised of a file header followed by a row of column names and the
    stored data. The file header contains the number of states, controls, Lagrange
    multipliers (for kinematic constraints), derivatives (non-zero if the dynamics
    mode is implicit), slacks (for special solver implementations), and parameters
    (order does not matter). Order does matter for the column names and
    corresponding data columns. The columns *must* follow this order: time, states,
    controls, multipliers, derivatives, slacks, parameters.
    Notes: Slack columns may contain real number or NaN values, depending on their
    use. For example, values for velocity correction variables used in problems
    with model kinematic constraints are defined only at the midpoint of a Hermite-
    Simpson mesh interval. The non-midpoint variables are returned as NaN in the
    slack variable data structure.
    For parameter columns, the value of the parameter is stored in
    the first row of the column, while the rest of the rows are filled with
    NaNs.

    num_controls=<number-of-control-variables>
    num_derivatives=<number-of-derivative-variables>
    num_multipliers=<number-of-multiplier-variables>
    num_parameters=<number-of-parameter-variables>
    num_slacks=<number-of-slack-variables>
    num_states=<number-of-state-variables>
    time,<state-0-name>,...,<control-0-name>,...,<multiplier-0-name>,...,
            <derivative-0-name>,...,<slack-0-name>,...,<parameter-0-name>,...
    <#>,<#>,...,<#>,...,<#>,...,<#>,...,<#-or-NaN>,...,<#>  ,...
    <#>,<#>,...,<#>,...,<#>,...,<#>,...,<#-or-NaN>,...,<NaN>,...
     : , : ,..., : ,..., : ,..., : ,...,    :     ,...,  :  ,...
    <#>,<#>,...,<#>,...,<#>,...,<#>,...,<#-or-NaN>,...,<NaN>,...


    Column labels starting with "lambda" are Lagrange multipliers, and columns
    starting with "gamma" are slack variables (probably velocity corrections at
    certain collocation points).

    Title: Matlab and Python
    Many of the functions in this class have variants ending with "Mat" that
    provide convenient access to the data directly in Matlab or Python (NumPy).
    In Python, the constructors can also accept NumPy matrices in addition to
    arguments of type SimTK::Matrix.

    .. code-block:: c++

        trajectory.getStateMat("<state-name>")
        trajectory.getStatesTrajectoryMat()

    Title: Implicit dynamics model
    If the solver uses an implicit dynamics mode, then there are "control"
    variables ("adjunct" variables in tropter's terminology) for the generalized
    accelerations. These are stored in the trajectory as derivative variables.

    Title: Sealed trajectories
    If the trajectory is obtained as the failed solution to a problem,
    the trajectory will be sealed (MocoTrajectory::isSealed()), which means
    that you cannot do anything with the trajectory (read, edit, or write) until you
    call MocoTrajectory::unseal(). The sealing forces you to acknowledge that the
    solver failed.

    Title: Convenience accessors
    The accessors getValuesTrajectory() and getSpeedsTrajectory() (and related
    methods (e.g., getValueNames()) are available to obtain only the coordinate
    values or coordinate speeds, which are part of the states trajectory. Note that
    these accessors create fresh data structures from the existing member variables,
    so repeated calls should be avoided. Similarly, the accessors
    getAccelerationsTrajectory() and getDerivativesWithoutAccelerationsTrajectory()
    are available to access subcomponents of the derivatives trajectory.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _moco.delete_MocoTrajectory

    def clone(self) -> "OpenSim::MocoTrajectory *":
        r"""
        Returns a dynamically-allocated copy of this trajectory. You must manage
        the memory for return value.
        Notes: This works even if the trajectory is sealed.
        """
        return _moco.MocoTrajectory_clone(self)

    def empty(self) -> "bool":
        return _moco.MocoTrajectory_empty(self)

    def hasCoordinateStates(self) -> "bool":
        return _moco.MocoTrajectory_hasCoordinateStates(self)

    def setNumTimes(self, numTimes: "int") -> "void":
        r"""
        Resize the time vector and the time dimension of the states, controls,
        multipliers, and derivatives trajectories, and set all times, states,
        controls, multipliers, and derivatives to NaN.
        Notes: Parameters are NOT set to NaN.
        """
        return _moco.MocoTrajectory_setNumTimes(self, numTimes)

    def resampleWithNumTimes(self, numTimes: "int") -> "double":
        r"""
        Uniformly resample (interpolate) the trajectory so that it retains the
        same initial and final times but now has the provided number of time
        points.
        Resampling is done by creating a 5-th degree GCV spline of the states
        and controls and evaluating the spline at the `numTimes` time points.
        The degree is reduced as necessary if getNumTimes() < 6, and
        resampling is not possible if getNumTimes() < 2.
        :rtype: float
        :return: the resulting time interval between time points.
        """
        return _moco.MocoTrajectory_resampleWithNumTimes(self, numTimes)

    def resampleWithInterval(self, desiredTimeInterval: "double") -> "double":
        r"""
        Uniformly resample (interpolate) the trajectory to try to achieve the
        provided time interval between mesh points, while preserving the
        initial and final times. The resulting time interval may be shorter
        than what you request (in order to preserve initial and
        final times), and is returned by this function.
        Resampling is done by creating a 5-th degree GCV spline of the states
        and controls and evaluating the spline at the new time points.
        The degree is reduced as necessary if getNumTimes() < 6, and
        resampling is not possible if getNumTimes() < 2.
        """
        return _moco.MocoTrajectory_resampleWithInterval(self, desiredTimeInterval)

    def resampleWithFrequency(self, desiredNumTimePointsPerSecond: "double") -> "double":
        r"""
        Uniformly resample (interpolate) the trajectory to try to achieve the
        provided frequency of time points per second of the trajectory, while
        preserving the initial and final times. The resulting frequency may be
        higher than what you request (in order to preserve initial and final
        times), and is returned by this function.
        Resampling is done by creating a 5-th degree GCV spline of the states
        and controls and evaluating the spline at the new time points.
        The degree is reduced as necessary if getNumTimes() < 6, and
        resampling is not possible if getNumTimes() < 2.
        """
        return _moco.MocoTrajectory_resampleWithFrequency(self, desiredNumTimePointsPerSecond)

    def resample(self, newTime: "Vector") -> "void":
        r"""
        Resample (interpolate) the data in this trajectory at the provided
        times. If all times have the same value (e.g., 0.0), then the value of
        each variable for all time is its previous value at the initial time.
        :raises: Exception if new times are not within existing initial and final
            times, if the new times are decreasing, or if getNumTimes() < 2.
        """
        return _moco.MocoTrajectory_resample(self, newTime)

    def setParameter(self, name: "std::string const &", value: "SimTK::Real const &") -> "void":
        r"""
        Set the value of a single parameter variable. This value is invariant
        across time.
        """
        return _moco.MocoTrajectory_setParameter(self, name, value)

    def setStatesTrajectory(self, states: "TimeSeriesTable", allowMissingColumns: "bool"=False, allowExtraColumns: "bool"=False) -> "void":
        r"""
        Set the states trajectory. The provided data is interpolated at the
        times contained within this trajectory. The controls trajectory is not
        altered. If the table only contains a subset of the states in the
        trajectory (and allowMissingColumns is true), the unspecified states
        preserve their pre-existing values.

        This function might be helpful if you generate a guess using a
        forward simulation; you can access the forward simulation's states
        trajectory using Manager::getStateStorage() or
        Manager::getStatesTable().

        :type states: :py:class:`TimeSeriesTable`
        :param states:
                The column labels of the table should match the state
                names (see getStateNames()). By default, the table must provide all
                state variables. Any data outside the time range of this guess's
                times are ignored.
        :type allowMissingColumns: boolean, optional
        :param allowMissingColumns:
                If false, an exception is thrown if there are states in the
                trajectory that are not in the table.
        :type allowExtraColumns: boolean, optional
        :param allowExtraColumns:
                If false, an exception is thrown if there are states in the
                table that are not in the trajectory.
        See also: createFromStatesControlsTables.
        """
        return _moco.MocoTrajectory_setStatesTrajectory(self, states, allowMissingColumns, allowExtraColumns)

    def insertStatesTrajectory(self, subsetOfStates: "TimeSeriesTable", overwrite: "bool"=False) -> "void":
        r"""
        Add additional state columns. The provided data are interpolated using
        GCV splines to match the times in this trajectory. By default, we do not
        overwrite data for states that already exist in the trajectory; you can
        change this behavior with `overwrite`.
        """
        return _moco.MocoTrajectory_insertStatesTrajectory(self, subsetOfStates, overwrite)

    def insertControlsTrajectory(self, subsetOfControls: "TimeSeriesTable", overwrite: "bool"=False) -> "void":
        r"""
        Add additional control columns. The provided data are interpolated using
        GCV splines to match the times in this trajectory. By default, we do not
        overwrite data for controls that already exist in the trajectory; you
        can change this behavior with `overwrite`.
        """
        return _moco.MocoTrajectory_insertControlsTrajectory(self, subsetOfControls, overwrite)

    def generateSpeedsFromValues(self) -> "void":
        r"""
        Compute coordinate speeds based on coordinate position values and append
        to the trajectory. Coordinate values must exist in the original
        trajectory.
        Notes: Overrides any existing speed values in the trajectory.
        """
        return _moco.MocoTrajectory_generateSpeedsFromValues(self)

    def generateAccelerationsFromValues(self) -> "void":
        r"""
        Compute coordinate accelerations based on coordinate position values and
        append to the trajectory. Coordinate values must exist in the original
        trajectory.
        Notes: Overrides any existing acceleration values in the trajectory.
        """
        return _moco.MocoTrajectory_generateAccelerationsFromValues(self)

    def generateAccelerationsFromSpeeds(self) -> "void":
        r"""
        Compute coordinate accelerations based on coordinate speeds and append
        to the trajectory. Coordinate speeds must exist in the original
        trajectory.
        Notes: Overrides any existing acceleration values in the trajectory.
        """
        return _moco.MocoTrajectory_generateAccelerationsFromSpeeds(self)

    def getNumTimes(self) -> "int":
        
        return _moco.MocoTrajectory_getNumTimes(self)

    def getTime(self) -> "SimTK::Vector const &":
        return _moco.MocoTrajectory_getTime(self)

    def getInitialTime(self) -> "double":
        r"""
        The first time in the time vector.
        :raises: Exception If numTimes is 0.
        """
        return _moco.MocoTrajectory_getInitialTime(self)

    def getFinalTime(self) -> "double":
        r"""
        The last time in the time vector.
        :raises: Exception If numTimes is 0.
        """
        return _moco.MocoTrajectory_getFinalTime(self)

    def getNumStates(self) -> "int":
        return _moco.MocoTrajectory_getNumStates(self)

    def getNumControls(self) -> "int":
        return _moco.MocoTrajectory_getNumControls(self)

    def getNumMultipliers(self) -> "int":
        return _moco.MocoTrajectory_getNumMultipliers(self)

    def getNumDerivatives(self) -> "int":
        return _moco.MocoTrajectory_getNumDerivatives(self)

    def getNumValues(self) -> "int":
        return _moco.MocoTrajectory_getNumValues(self)

    def getNumSpeeds(self) -> "int":
        return _moco.MocoTrajectory_getNumSpeeds(self)

    def getNumAccelerations(self) -> "int":
        return _moco.MocoTrajectory_getNumAccelerations(self)

    def getNumDerivativesWithoutAccelerations(self) -> "int":
        return _moco.MocoTrajectory_getNumDerivativesWithoutAccelerations(self)

    def getNumParameters(self) -> "int":
        return _moco.MocoTrajectory_getNumParameters(self)

    def getStateNames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _moco.MocoTrajectory_getStateNames(self)

    def getControlNames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _moco.MocoTrajectory_getControlNames(self)

    def getMultiplierNames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _moco.MocoTrajectory_getMultiplierNames(self)

    def getDerivativeNames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _moco.MocoTrajectory_getDerivativeNames(self)

    def getValueNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoTrajectory_getValueNames(self)

    def getSpeedNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoTrajectory_getSpeedNames(self)

    def getAccelerationNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoTrajectory_getAccelerationNames(self)

    def getDerivativeNamesWithoutAccelerations(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _moco.MocoTrajectory_getDerivativeNamesWithoutAccelerations(self)

    def getParameterNames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        return _moco.MocoTrajectory_getParameterNames(self)

    def getState(self, name: "std::string const &") -> "SimTK::VectorView_< double >":
        return _moco.MocoTrajectory_getState(self, name)

    def getControl(self, name: "std::string const &") -> "SimTK::VectorView_< double >":
        return _moco.MocoTrajectory_getControl(self, name)

    def getMultiplier(self, name: "std::string const &") -> "SimTK::VectorView_< double >":
        return _moco.MocoTrajectory_getMultiplier(self, name)

    def getDerivative(self, name: "std::string const &") -> "SimTK::VectorView_< double >":
        return _moco.MocoTrajectory_getDerivative(self, name)

    def getParameter(self, name: "std::string const &") -> "SimTK::Real const &":
        return _moco.MocoTrajectory_getParameter(self, name)

    def getStatesTrajectory(self) -> "SimTK::Matrix const &":
        return _moco.MocoTrajectory_getStatesTrajectory(self)

    def getControlsTrajectory(self) -> "SimTK::Matrix const &":
        return _moco.MocoTrajectory_getControlsTrajectory(self)

    def getMultipliersTrajectory(self) -> "SimTK::Matrix const &":
        return _moco.MocoTrajectory_getMultipliersTrajectory(self)

    def getDerivativesTrajectory(self) -> "SimTK::Matrix const &":
        return _moco.MocoTrajectory_getDerivativesTrajectory(self)

    def getValuesTrajectory(self) -> "SimTK::Matrix":
        return _moco.MocoTrajectory_getValuesTrajectory(self)

    def getSpeedsTrajectory(self) -> "SimTK::Matrix":
        return _moco.MocoTrajectory_getSpeedsTrajectory(self)

    def getAccelerationsTrajectory(self) -> "SimTK::Matrix":
        return _moco.MocoTrajectory_getAccelerationsTrajectory(self)

    def getDerivativesWithoutAccelerationsTrajectory(self) -> "SimTK::Matrix":
        return _moco.MocoTrajectory_getDerivativesWithoutAccelerationsTrajectory(self)

    def getParameters(self) -> "SimTK::RowVector const &":
        return _moco.MocoTrajectory_getParameters(self)

    def isCompatible(self, arg2: "MocoProblemRep", requireAccelerations: "bool"=False, throwOnError: "bool"=False) -> "bool":
        r"""
        Do the state, control, multiplier, derivative, and parameter names in
        this trajectory match those in the problem? This may not catch all
        possible incompatibilities. If the trajectory should have generalized
        accelerations (for implicit multibody dynamics mode), set
        requireAccelerations to true.
        To throw an exception with a detailed message if the problem is not
        compatible, pass throwOnError as true. To get the detailed message
        without an exception, set the Logger level to Debug or a more verbose
        setting (e.g., `Logger::setLevel(Logger::Level::Debug)` in C++, and
        `Logger.setLevel(Logger.Level_Debug)` in MATLAB/Python).
        """
        return _moco.MocoTrajectory_isCompatible(self, arg2, requireAccelerations, throwOnError)

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        Check if this trajectory is numerically equal to another trajectory.
        This uses SimTK::Test::numericallyEqual() internally.
        Accordingly, the tolerance is both a relative and absolute tolerance
        (depending on the magnitude of quantities being compared).
        """
        return _moco.MocoTrajectory_isNumericallyEqual(self, *args)

    def compareContinuousVariablesRMS(self, *args) -> "double":
        r"""
        Compute the root-mean-square error between the continuous variables of
        this trajectory and another. The RMS is computed by numerically
        integrating the sum of squared error across
        states,
        controls,
        Lagrange multipliers, and
        derivatives and dividing by the number of columns and the time duration.
        The calculation can be expressed as follows:

        .. math::

            \epsilon_{\textrm{RMS}} =
                 \sqrt{\frac{1}{N(t_f - t_i)} \int_{t_i}^{t_f} \left(
                     \sum_{ i \in \textrm{states} } \epsilon_i(t)^2 +
                     \sum_{ i \in \textrm{controls} } \epsilon_i(t)^2 +
                     \sum_{ i \in \textrm{mult} } \epsilon_i(t)^2 +
                     \sum_{ i \in \textrm{deriv} } \epsilon_i(t)^2
                 \right) dt  },
        where :math:`N` is the number of columns, :math:`t_i` is the minimum of
        the two initial times, :math:`t_f` is the maximum of the two final
        times, and :math:`\epsilon` indicates an error.

        When the two trajectories do not cover the same time range, we assume
        values of 0 for the trajectory with "missing" time (we do NOT assume
        that the error is 0 over the non-overlapping time range).

        First, the trajectories are splined and sampled. The number of sampling
        points is taken to be the number of times in the trajectory with the
        greater number of times. Numerical integration is performed on the
        sampled points using the trapezoidal rule.

        By default, all states, controls, and multipliers are
        compared, and it is expected that both trajectories have the same
        states, controls, and multipliers. Alternatively, you can specify the
        specific
        states,
        controls,
        multipliers, and
        derivatives to compare as keys for `columnsToUse`.
        Values are an empty vector to compare all columns for that key,
        `{"none"}` (single-entry vector with value "none") to compare none of
        the columns for that key, or a vector of column labels to compare
        for that key. Leaving out a key means no columns for that
        key are compared.
        Both trajectories must have at least 6 time nodes.
        If the number of columns to compare is 0, this returns 0.
        """
        return _moco.MocoTrajectory_compareContinuousVariablesRMS(self, *args)

    def compareContinuousVariablesRMSPattern(self, other: "MocoTrajectory", columnType: "std::string", pattern: "std::string") -> "double":
        r"""
        This is an alternative interface for compareContinuousVariablesRMS()
        that uses regular expression patterns to select columns. The parameter
        columnType is "states", "controls", "multipliers", or "derivatives".
        All columns for the provided column type whose entire name matches the
        provided regular expression are included in the root-mean-square.
        """
        return _moco.MocoTrajectory_compareContinuousVariablesRMSPattern(self, other, columnType, pattern)

    def compareParametersRMS(self, *args) -> "double":
        r"""
        Compute the root-mean-square error between the parameters in this
        trajectory and another. The RMS is computed by dividing the sum of
        the squared errors between corresponding parameters and then dividing by
        the number of parameters compared.
        By default, all parameters are compared, and it is expected that both
        trajectories have the same parameters. Alternatively, you can specify
        the specific parameters to compare.
        """
        return _moco.MocoTrajectory_compareParametersRMS(self, *args)

    def write(self, filepath: "std::string const &") -> "void":
        r""" Save the trajectory to a STO file. Use the ."sto" file extension."""
        return _moco.MocoTrajectory_write(self, filepath)

    def exportToStatesTable(self) -> "OpenSim::TimeSeriesTable":
        r"""
        This table can be saved as a Storage file that can be used in the
        OpenSim GUI to visualize a motion, or as input to OpenSim's conventional
        tools (e.g., AnalyzeTool).

        Controls are not carried over to the states storage.
        """
        return _moco.MocoTrajectory_exportToStatesTable(self)

    def exportToControlsTable(self) -> "OpenSim::TimeSeriesTable":
        r""" Export the controls trajectory to a TimeSeriesTable."""
        return _moco.MocoTrajectory_exportToControlsTable(self)

    def exportToMultipliersTable(self) -> "OpenSim::TimeSeriesTable":
        r""" Export the multipliers trajectory to a TimeSeriesTable."""
        return _moco.MocoTrajectory_exportToMultipliersTable(self)

    def exportToDerivativesTable(self) -> "OpenSim::TimeSeriesTable":
        r""" Export the derivatives trajectory to a TimeSeriesTable."""
        return _moco.MocoTrajectory_exportToDerivativesTable(self)

    def exportToValuesTable(self) -> "OpenSim::TimeSeriesTable":
        r"""
        Export the coordinate values from the states trajectory to a
        TimeSeriesTable.
        """
        return _moco.MocoTrajectory_exportToValuesTable(self)

    def exportToSpeedsTable(self) -> "OpenSim::TimeSeriesTable":
        r"""
        Export the coordinate speeds from the states trajectory to a
        TimeSeriesTable.
        """
        return _moco.MocoTrajectory_exportToSpeedsTable(self)

    def exportToAccelerationsTable(self) -> "OpenSim::TimeSeriesTable":
        r"""
        Export the coordinate accelerations from the derivatives trajectory to a
        TimeSeriesTable.
        """
        return _moco.MocoTrajectory_exportToAccelerationsTable(self)

    def exportToDerivativesWithoutAccelerationsTable(self) -> "OpenSim::TimeSeriesTable":
        r"""
        Export the derivatives trajectory without coordinate accelerations to a
        TimeSeriesTable.
        """
        return _moco.MocoTrajectory_exportToDerivativesWithoutAccelerationsTable(self)

    def exportToStatesTrajectory(self, *args) -> "OpenSim::StatesTrajectory":
        r"""
        *Overload 1:*
        Controls are not carried over to the StatesTrajectory.
        The MocoProblem is necessary because we need the underlying Model to
        order the state variables correctly.

        |

        *Overload 2:*
        This is similar to the above function but requires only a model, not
        a MocoProblem.
        """
        return _moco.MocoTrajectory_exportToStatesTrajectory(self, *args)

    def randomizeReplace(self, *args) -> "void":
        r"""
        Randomize all data except time using the provided random number
        generator. All data is replaced with the random numbers. Use this to
        create a completely (pseudo-)random trajectory, probably for a
        MocoSolver guess.
        The default random number generator samples uniformly within [-0.1,
        0.1].
        """
        return _moco.MocoTrajectory_randomizeReplace(self, *args)

    def randomizeAdd(self, *args) -> "void":
        r"""
        Randomize all data except time using the provided random number
        generator. The random numbers are added to the existing data. Use this
        to perturb an existing solution, probably for a MocoSolver guess.
        The default random number generator samples uniformly within [-0.1,
        0.1].
        """
        return _moco.MocoTrajectory_randomizeAdd(self, *args)

    @staticmethod
    def createFromStatesControlsTables(arg1: "MocoProblemRep", statesTrajectory: "TimeSeriesTable", controlsTrajectory: "TimeSeriesTable") -> "OpenSim::MocoTrajectory":
        r"""
        (Experimental) Create a trajectory from a states trajectory and controls
        trajectory (i.e, from Manager::getStatesTable() and
        Model::getControlsTable()). The time columns from the two tables must
        match exactly. The times in the trajectory will be those from the
        tables. This does not (yet) handle parameters.
        """
        return _moco.MocoTrajectory_createFromStatesControlsTables(arg1, statesTrajectory, controlsTrajectory)

    def __init__(self, *args):
        _moco.MocoTrajectory_swiginit(self, _moco.new_MocoTrajectory(*args))

    def setTime(self, *args) -> "void":
        return _moco.MocoTrajectory_setTime(self, *args)

    def setState(self, *args) -> "void":
        return _moco.MocoTrajectory_setState(self, *args)

    def setControl(self, *args) -> "void":
        return _moco.MocoTrajectory_setControl(self, *args)

    def setMultiplier(self, *args) -> "void":
        return _moco.MocoTrajectory_setMultiplier(self, *args)

    def setDerivative(self, *args) -> "void":
        return _moco.MocoTrajectory_setDerivative(self, *args)

    def _getTimeMat(self, n: "int") -> "void":
        return _moco.MocoTrajectory__getTimeMat(self, n)

    def _getStateMat(self, name: "std::string", n: "int") -> "void":
        return _moco.MocoTrajectory__getStateMat(self, name, n)

    def _getControlMat(self, name: "std::string", n: "int") -> "void":
        return _moco.MocoTrajectory__getControlMat(self, name, n)

    def _getMultiplierMat(self, name: "std::string", n: "int") -> "void":
        return _moco.MocoTrajectory__getMultiplierMat(self, name, n)

    def _getDerivativeMat(self, name: "std::string", n: "int") -> "void":
        return _moco.MocoTrajectory__getDerivativeMat(self, name, n)

    def _getParametersMat(self, n: "int") -> "void":
        return _moco.MocoTrajectory__getParametersMat(self, n)

    def _getStatesTrajectoryMat(self, nrow: "int") -> "void":
        return _moco.MocoTrajectory__getStatesTrajectoryMat(self, nrow)

    def _getControlsTrajectoryMat(self, nrow: "int") -> "void":
        return _moco.MocoTrajectory__getControlsTrajectoryMat(self, nrow)

    def _getMultipliersTrajectoryMat(self, nrow: "int") -> "void":
        return _moco.MocoTrajectory__getMultipliersTrajectoryMat(self, nrow)

    def _getDerivativesTrajectoryMat(self, nrow: "int") -> "void":
        return _moco.MocoTrajectory__getDerivativesTrajectoryMat(self, nrow)

    def getTimeMat(self):
        return self._getTimeMat(self.getNumTimes())
    def getStateMat(self, name):
        return self._getStateMat(name, self.getNumTimes())
    def getControlMat(self, name):
        return self._getControlMat(name, self.getNumTimes())
    def getMultiplierMat(self, name):
        return self._getMultiplierMat(name, self.getNumTimes())
    def getDerivativeMat(self, name):
        return self._getDerivativeMat(name, self.getNumTimes())
    def getParametersMat(self):
        return self._getParametersMat(len(self.getParameterNames()))

    def getStatesTrajectoryMat(self):
        import numpy as np
        mat = np.empty([self.getNumTimes(), len(self.getStateNames())])
        self._getStatesTrajectoryMat(mat)
        return mat
    def getControlsTrajectoryMat(self):
        import numpy as np
        mat = np.empty([self.getNumTimes(), len(self.getControlNames())])
        self._getControlsTrajectoryMat(mat)
        return mat
    def getMultipliersTrajectoryMat(self):
        import numpy as np
        mat = np.empty([self.getNumTimes(), len(self.getMultiplierNames())])
        self._getMultipliersTrajectoryMat(mat)
        return mat
    def getDerivativesTrajectoryMat(self):
        import numpy as np
        mat = np.empty([self.getNumTimes(), len(self.getDerivativeNames())])
        self._getDerivativesTrajectoryMat(mat)
        return mat



# Register MocoTrajectory in _moco:
_moco.MocoTrajectory_swigregister(MocoTrajectory)

def MocoTrajectory_createFromStatesControlsTables(arg1: "MocoProblemRep", statesTrajectory: "TimeSeriesTable", controlsTrajectory: "TimeSeriesTable") -> "OpenSim::MocoTrajectory":
    r"""
    (Experimental) Create a trajectory from a states trajectory and controls
    trajectory (i.e, from Manager::getStatesTable() and
    Model::getControlsTable()). The time columns from the two tables must
    match exactly. The times in the trajectory will be those from the
    tables. This does not (yet) handle parameters.
    """
    return _moco.MocoTrajectory_createFromStatesControlsTables(arg1, statesTrajectory, controlsTrajectory)

class MocoSolution(MocoTrajectory):
    r"""
    Return type for MocoStudy::solve(). Use success() to check if the solver
    succeeded. You can also use this object as a boolean in an if-statement:

    .. code-block:: c++

        auto solution = study.solve();
        if (solution) {
            std::cout << solution.getStatus() << std::endl;
        }
    You can use getStatus() to get more details about the return status of
    the optimizer.
    If the solver was not successful, then this object is "sealed", which
    means you cannot do anything with it until calling `unseal()`. This
    prevents you from silently proceeding with a failed solution.
    In the file written by write(), the header contains solver success, the
    objective, the individual terms in the objective (including the weight),
    the breakdown of the objective, and other quantities.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clone(self) -> "OpenSim::MocoSolution *":
        r"""
        Returns a dynamically-allocated copy of this solution. You must manage
        the memory for return value.
        Notes: This works even if the trajectory is sealed.
        """
        return _moco.MocoSolution_clone(self)

    def success(self) -> "bool":
        r"""
        Was the problem solved successfully? If not, then you cannot access
        the solution until you call unlock().
        """
        return _moco.MocoSolution_success(self)

    def getObjective(self) -> "double":
        return _moco.MocoSolution_getObjective(self)

    def __nonzero__(self):
        return _moco.MocoSolution___nonzero__(self)
    __bool__ = __nonzero__



    def getStatus(self) -> "std::string const &":
        r"""
        Obtain a solver-dependent string describing the return status of the
        optimization.
        """
        return _moco.MocoSolution_getStatus(self)

    def getNumIterations(self) -> "int":
        r"""
        Number of solver iterations at which this solution was obtained
        (-1 if not set).
        """
        return _moco.MocoSolution_getNumIterations(self)

    def getSolverDuration(self) -> "double":
        r"""
        Get the amount of time (clock time, not CPU time) spent within solve().
        Units: seconds.
        """
        return _moco.MocoSolution_getSolverDuration(self)

    def getNumObjectiveTerms(self) -> "int":
        r"""
        Some solvers provide a breakdown of the terms in the objective. Use
        these functions to access this breakdown. Some terms may come from
        MocoGoals in the problem, while other terms may be added by the solver.

        Returns the number of terms in the objective. If the solver did not
        provide this breakdown, then this returns 0.
        """
        return _moco.MocoSolution_getNumObjectiveTerms(self)

    def getObjectiveTermNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the names of all terms in the objective (either from MocoGoals in
        the problem or added by the solver). Terms from MocoGoals are named with
        the name of the associated MocoGoal. If the solver did not provide this
        breakdown, then this returns an empty vector.
        """
        return _moco.MocoSolution_getObjectiveTermNames(self)

    def getObjectiveTerm(self, name: "std::string const &") -> "double":
        r"""
        Get the value of a term in the objective by name. See
        getObjectiveTermNames().
        The value includes the weight on the term.
        """
        return _moco.MocoSolution_getObjectiveTerm(self, name)

    def getObjectiveTermByIndex(self, index: "int") -> "double":
        r"""
        Get the value of a term in the objective, using an index. The order of
        terms is the same as in getObjectiveTermNames().
        The value includes the weight on the term.
        """
        return _moco.MocoSolution_getObjectiveTermByIndex(self, index)

    def printObjectiveBreakdown(self) -> "void":
        r""" Print to the console the terms in the objective and their values."""
        return _moco.MocoSolution_printObjectiveBreakdown(self)

    def unseal(self) -> "OpenSim::MocoSolution &":
        r"""
        If the solver did not succeed, call this to enable read and write
        access to the (failed) solution. If the solver succeeded, then the
        solution is already unsealed.
        Notes: In Python, you must invoke this function on a separate line:

        .. code-block:: c++

            solution = moco.solve()
            solution.unseal()
        Otherwise, Moco will cause a crash.
        """
        return _moco.MocoSolution_unseal(self)

    def seal(self) -> "OpenSim::MocoSolution &":
        return _moco.MocoSolution_seal(self)

    def isSealed(self) -> "bool":
        return _moco.MocoSolution_isSealed(self)

    def __init__(self):
        _moco.MocoSolution_swiginit(self, _moco.new_MocoSolution())
    __swig_destroy__ = _moco.delete_MocoSolution

# Register MocoSolution in _moco:
_moco.MocoSolution_swigregister(MocoSolution)

class MocoSolver(opensim.common.OpenSimObject):
    r"""
     Once the solver is created, you should not make any edits to the
    MocoProblem. If you do, you must call resetProblem(const MocoProblem
    problem).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoSolver *":
        return _moco.MocoSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoSolver_getClassName()

    def clone(self) -> "OpenSim::MocoSolver *":
        return _moco.MocoSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoSolver_getConcreteClassName(self)
    __swig_destroy__ = _moco.delete_MocoSolver

    def resetProblem(self, problem: "MocoProblem") -> "void":
        r"""
        Call this to prepare the solver for use on the provided problem.
        The solver creates and stores a MocoProblemRep using the provided
        problem.
        """
        return _moco.MocoSolver_resetProblem(self, problem)

    def createGuessTimeStepping(self) -> "OpenSim::MocoTrajectory":
        r"""
        (Experimental) Run a forward simulation (using the OpenSim Manager,
        which uses a SimTK::Integrator), using the default controls for
        actuators and the default states as the initial states, to create a
        guess that is dynamically consistent (constraint errors should be
        small). The time range for the simulation is the upper bound on the
        initial time and the lower bound on the final time. The initial state
        values are the default state values unless:
         - initial bounds are an equality constraint: use the bound value
         - default value is not within the initial bounds: use midpoint of
           initial bounds.

        The number of times in the trajectory is the number of successful
        integration steps.

        Notes: This function does not yet support problems with parameters.

        This function assumes all actuators are in the model's ForceSet.

        :raises: Exception If the lower bound on the final time is less than or
            equal to the upper bound on the initial time. This situation is okay in
            general; it's just that this function doesn't support it.

        You must have called resetProblem().
        """
        return _moco.MocoSolver_createGuessTimeStepping(self)

# Register MocoSolver in _moco:
_moco.MocoSolver_swigregister(MocoSolver)

def MocoSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoSolver *":
    return _moco.MocoSolver_safeDownCast(obj)

def MocoSolver_getClassName() -> "std::string const &":
    return _moco.MocoSolver_getClassName()

class MocoDirectCollocationSolver(MocoSolver):
    r"""
     This is a base class for solvers that use direct collocation to convert
    an optimal control problem into a generic nonlinear programming problem.
    The best resource for learning about direct collocation is the Betts
    textbook:

    Betts, John T. Practical methods for optimal control and estimation using
    nonlinear programming. Vol. 19. Siam, 2010.

    MocoDirectCollocationSolver
    ===========================
    Transcription scheme
    --------------------
    The `transcription_scheme` setting allows you to choose between
    'trapezoidal' and 'hermite-simpson' transcription schemes. The 'trapezoidal'
    option replaces the dynamics differential constraints with finite
    differences based on trapezoidal rule integration. The 'hermite-simpson'
    option uses a Hermite interpolant and Simpson integration to construct the
    finite differences. The 'hermite-simpson' option uses the separated
    Hermite-Simpson transcription approach, which allows control values at mesh
    interval midpoints to be free variables (see Betts textbook for more
    details). The setting `interpolate_control_midpoints` constrains control
    midpoint variables to be linearly interpolated from the mesh interval
    endpoint values (default and recommended setting). If solving problems
    including model kinematic constraints, the 'hermite-simpson' option is
    required (see Kinematic constraints section below).

    Path constraints on controls with Hermite-Simpson transcription
    ---------------------------------------------------------------
    For Hermite-Simpson transcription, the direct collocation solvers enforce
    the path constraints (e.g., MocoPathConstraint) at only the mesh interval
    endpoints (not midpoints), but control signal variables exist at both mesh
    interval endpoints and midpoints. Keep this in mind when using path
    constraints on controls (e.g., MocoControlBoundConstraint). If
    `interpolate_control_midpoints` is false, the values of a control at
    midpoints may differ greatly from the values at mesh interval endpoints.

    Multibody dynamics mode
    -----------------------
    The `multibody_dynamics_mode` setting allows you to choose between
    expressing multibody dynamics as explicit differential equations (e.g., :math:`\dot{y} = f(y)`) or implicit differential equations (e.g., :math:`0 = f(y,\dot{y})`, or inverse dynamics). Whether auxiliary dynamics (e.g.,
    muscle fiber and activation dynamics) are implicit or explicit depends on
    the model component implementing those dynamics.

    Kinematic constraints
    ---------------------
    All holonomic kinematic constraints included as OpenSim model constraints are
    supported. Both the 'trapezoidal' and 'hermite-simpson' transcription schemes
    support kinematic constraints, but the 'hermite-transcription' scheme handles
    kinematic constraints much more robustly; in practice, the 'trapezoidal' scheme
    is not used for models with kinematic constraints. Kinematic constraints are
    automatically detected if present in the model and are converted to path
    constraints in the optimal control problem based on the method presented in Posa
    et al. 2016, 'Optimization and stabilization of trajectories for constrained
    dynamical systems'; see 'implkincon'. The `minimize_lagrange_multipliers` and
    `lagrange_multiplier_weight` settings allow you to enable and set the weight for
    the minimization of all Lagrange multipliers associated with kinematic
    constraints in the problem. The `velocity_correction_bounds` setting allows you
    to set the bounds on the velocity correction variables that project state
    variables onto the constraint manifold when necessary to properly enforce defect
    constraints (see Posa et al. 2016 for details).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoDirectCollocationSolver *":
        return _moco.MocoDirectCollocationSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoDirectCollocationSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_getClassName()

    def clone(self) -> "OpenSim::MocoDirectCollocationSolver *":
        return _moco.MocoDirectCollocationSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_getConcreteClassName(self)

    def copyProperty_num_mesh_intervals(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_num_mesh_intervals(self, source)

    def append_num_mesh_intervals(self, value: "int const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_num_mesh_intervals(self, value)

    def constructProperty_num_mesh_intervals(self, initValue: "int const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_num_mesh_intervals(self, initValue)

    def get_num_mesh_intervals(self, *args) -> "int const &":
        return _moco.MocoDirectCollocationSolver_get_num_mesh_intervals(self, *args)

    def upd_num_mesh_intervals(self, *args) -> "int &":
        return _moco.MocoDirectCollocationSolver_upd_num_mesh_intervals(self, *args)

    def set_num_mesh_intervals(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_num_mesh_intervals(self, *args)

    def copyProperty_verbosity(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_verbosity(self, source)

    def append_verbosity(self, value: "int const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_verbosity(self, value)

    def constructProperty_verbosity(self, initValue: "int const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_verbosity(self, initValue)

    def get_verbosity(self, *args) -> "int const &":
        return _moco.MocoDirectCollocationSolver_get_verbosity(self, *args)

    def upd_verbosity(self, *args) -> "int &":
        return _moco.MocoDirectCollocationSolver_upd_verbosity(self, *args)

    def set_verbosity(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_verbosity(self, *args)

    def copyProperty_transcription_scheme(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_transcription_scheme(self, source)

    def append_transcription_scheme(self, value: "std::string const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_transcription_scheme(self, value)

    def constructProperty_transcription_scheme(self, initValue: "std::string const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_transcription_scheme(self, initValue)

    def get_transcription_scheme(self, *args) -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_get_transcription_scheme(self, *args)

    def upd_transcription_scheme(self, *args) -> "std::string &":
        return _moco.MocoDirectCollocationSolver_upd_transcription_scheme(self, *args)

    def set_transcription_scheme(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_transcription_scheme(self, *args)

    def copyProperty_interpolate_control_midpoints(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_interpolate_control_midpoints(self, source)

    def append_interpolate_control_midpoints(self, value: "bool const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_interpolate_control_midpoints(self, value)

    def constructProperty_interpolate_control_midpoints(self, initValue: "bool const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_interpolate_control_midpoints(self, initValue)

    def get_interpolate_control_midpoints(self, *args) -> "bool const &":
        return _moco.MocoDirectCollocationSolver_get_interpolate_control_midpoints(self, *args)

    def upd_interpolate_control_midpoints(self, *args) -> "bool &":
        return _moco.MocoDirectCollocationSolver_upd_interpolate_control_midpoints(self, *args)

    def set_interpolate_control_midpoints(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_interpolate_control_midpoints(self, *args)

    def copyProperty_multibody_dynamics_mode(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_multibody_dynamics_mode(self, source)

    def append_multibody_dynamics_mode(self, value: "std::string const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_multibody_dynamics_mode(self, value)

    def constructProperty_multibody_dynamics_mode(self, initValue: "std::string const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_multibody_dynamics_mode(self, initValue)

    def get_multibody_dynamics_mode(self, *args) -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_get_multibody_dynamics_mode(self, *args)

    def upd_multibody_dynamics_mode(self, *args) -> "std::string &":
        return _moco.MocoDirectCollocationSolver_upd_multibody_dynamics_mode(self, *args)

    def set_multibody_dynamics_mode(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_multibody_dynamics_mode(self, *args)

    def copyProperty_optim_solver(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_solver(self, source)

    def append_optim_solver(self, value: "std::string const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_solver(self, value)

    def constructProperty_optim_solver(self, initValue: "std::string const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_solver(self, initValue)

    def get_optim_solver(self, *args) -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_get_optim_solver(self, *args)

    def upd_optim_solver(self, *args) -> "std::string &":
        return _moco.MocoDirectCollocationSolver_upd_optim_solver(self, *args)

    def set_optim_solver(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_solver(self, *args)

    def copyProperty_optim_max_iterations(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_max_iterations(self, source)

    def append_optim_max_iterations(self, value: "int const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_max_iterations(self, value)

    def constructProperty_optim_max_iterations(self, initValue: "int const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_max_iterations(self, initValue)

    def get_optim_max_iterations(self, *args) -> "int const &":
        return _moco.MocoDirectCollocationSolver_get_optim_max_iterations(self, *args)

    def upd_optim_max_iterations(self, *args) -> "int &":
        return _moco.MocoDirectCollocationSolver_upd_optim_max_iterations(self, *args)

    def set_optim_max_iterations(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_max_iterations(self, *args)

    def copyProperty_optim_convergence_tolerance(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_convergence_tolerance(self, source)

    def append_optim_convergence_tolerance(self, value: "double const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_convergence_tolerance(self, value)

    def constructProperty_optim_convergence_tolerance(self, initValue: "double const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_convergence_tolerance(self, initValue)

    def get_optim_convergence_tolerance(self, *args) -> "double const &":
        return _moco.MocoDirectCollocationSolver_get_optim_convergence_tolerance(self, *args)

    def upd_optim_convergence_tolerance(self, *args) -> "double &":
        return _moco.MocoDirectCollocationSolver_upd_optim_convergence_tolerance(self, *args)

    def set_optim_convergence_tolerance(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_convergence_tolerance(self, *args)

    def copyProperty_optim_constraint_tolerance(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_constraint_tolerance(self, source)

    def append_optim_constraint_tolerance(self, value: "double const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_constraint_tolerance(self, value)

    def constructProperty_optim_constraint_tolerance(self, initValue: "double const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_constraint_tolerance(self, initValue)

    def get_optim_constraint_tolerance(self, *args) -> "double const &":
        return _moco.MocoDirectCollocationSolver_get_optim_constraint_tolerance(self, *args)

    def upd_optim_constraint_tolerance(self, *args) -> "double &":
        return _moco.MocoDirectCollocationSolver_upd_optim_constraint_tolerance(self, *args)

    def set_optim_constraint_tolerance(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_constraint_tolerance(self, *args)

    def copyProperty_optim_hessian_approximation(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_hessian_approximation(self, source)

    def append_optim_hessian_approximation(self, value: "std::string const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_hessian_approximation(self, value)

    def constructProperty_optim_hessian_approximation(self, initValue: "std::string const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_hessian_approximation(self, initValue)

    def get_optim_hessian_approximation(self, *args) -> "std::string const &":
        return _moco.MocoDirectCollocationSolver_get_optim_hessian_approximation(self, *args)

    def upd_optim_hessian_approximation(self, *args) -> "std::string &":
        return _moco.MocoDirectCollocationSolver_upd_optim_hessian_approximation(self, *args)

    def set_optim_hessian_approximation(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_hessian_approximation(self, *args)

    def copyProperty_optim_ipopt_print_level(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_optim_ipopt_print_level(self, source)

    def append_optim_ipopt_print_level(self, value: "int const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_optim_ipopt_print_level(self, value)

    def constructProperty_optim_ipopt_print_level(self, initValue: "int const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_optim_ipopt_print_level(self, initValue)

    def get_optim_ipopt_print_level(self, *args) -> "int const &":
        return _moco.MocoDirectCollocationSolver_get_optim_ipopt_print_level(self, *args)

    def upd_optim_ipopt_print_level(self, *args) -> "int &":
        return _moco.MocoDirectCollocationSolver_upd_optim_ipopt_print_level(self, *args)

    def set_optim_ipopt_print_level(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_optim_ipopt_print_level(self, *args)

    def copyProperty_enforce_constraint_derivatives(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_enforce_constraint_derivatives(self, source)

    def append_enforce_constraint_derivatives(self, value: "bool const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_enforce_constraint_derivatives(self, value)

    def constructProperty_enforce_constraint_derivatives(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_enforce_constraint_derivatives(self, *args)

    def get_enforce_constraint_derivatives(self, *args) -> "bool const &":
        return _moco.MocoDirectCollocationSolver_get_enforce_constraint_derivatives(self, *args)

    def upd_enforce_constraint_derivatives(self, *args) -> "bool &":
        return _moco.MocoDirectCollocationSolver_upd_enforce_constraint_derivatives(self, *args)

    def set_enforce_constraint_derivatives(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_enforce_constraint_derivatives(self, *args)

    def copyProperty_minimize_lagrange_multipliers(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_minimize_lagrange_multipliers(self, source)

    def append_minimize_lagrange_multipliers(self, value: "bool const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_minimize_lagrange_multipliers(self, value)

    def constructProperty_minimize_lagrange_multipliers(self, initValue: "bool const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_minimize_lagrange_multipliers(self, initValue)

    def get_minimize_lagrange_multipliers(self, *args) -> "bool const &":
        return _moco.MocoDirectCollocationSolver_get_minimize_lagrange_multipliers(self, *args)

    def upd_minimize_lagrange_multipliers(self, *args) -> "bool &":
        return _moco.MocoDirectCollocationSolver_upd_minimize_lagrange_multipliers(self, *args)

    def set_minimize_lagrange_multipliers(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_minimize_lagrange_multipliers(self, *args)

    def copyProperty_lagrange_multiplier_weight(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_lagrange_multiplier_weight(self, source)

    def append_lagrange_multiplier_weight(self, value: "double const &") -> "int":
        return _moco.MocoDirectCollocationSolver_append_lagrange_multiplier_weight(self, value)

    def constructProperty_lagrange_multiplier_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_lagrange_multiplier_weight(self, initValue)

    def get_lagrange_multiplier_weight(self, *args) -> "double const &":
        return _moco.MocoDirectCollocationSolver_get_lagrange_multiplier_weight(self, *args)

    def upd_lagrange_multiplier_weight(self, *args) -> "double &":
        return _moco.MocoDirectCollocationSolver_upd_lagrange_multiplier_weight(self, *args)

    def set_lagrange_multiplier_weight(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_lagrange_multiplier_weight(self, *args)

    def copyProperty_velocity_correction_bounds(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_velocity_correction_bounds(self, source)

    def append_velocity_correction_bounds(self, value: "MocoBounds") -> "int":
        return _moco.MocoDirectCollocationSolver_append_velocity_correction_bounds(self, value)

    def constructProperty_velocity_correction_bounds(self, initValue: "MocoBounds") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_velocity_correction_bounds(self, initValue)

    def get_velocity_correction_bounds(self, *args) -> "OpenSim::MocoBounds const &":
        return _moco.MocoDirectCollocationSolver_get_velocity_correction_bounds(self, *args)

    def upd_velocity_correction_bounds(self, *args) -> "OpenSim::MocoBounds &":
        return _moco.MocoDirectCollocationSolver_upd_velocity_correction_bounds(self, *args)

    def set_velocity_correction_bounds(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_velocity_correction_bounds(self, *args)

    def copyProperty_implicit_multibody_acceleration_bounds(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_implicit_multibody_acceleration_bounds(self, source)

    def append_implicit_multibody_acceleration_bounds(self, value: "MocoBounds") -> "int":
        return _moco.MocoDirectCollocationSolver_append_implicit_multibody_acceleration_bounds(self, value)

    def constructProperty_implicit_multibody_acceleration_bounds(self, initValue: "MocoBounds") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_implicit_multibody_acceleration_bounds(self, initValue)

    def get_implicit_multibody_acceleration_bounds(self, *args) -> "OpenSim::MocoBounds const &":
        return _moco.MocoDirectCollocationSolver_get_implicit_multibody_acceleration_bounds(self, *args)

    def upd_implicit_multibody_acceleration_bounds(self, *args) -> "OpenSim::MocoBounds &":
        return _moco.MocoDirectCollocationSolver_upd_implicit_multibody_acceleration_bounds(self, *args)

    def set_implicit_multibody_acceleration_bounds(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_implicit_multibody_acceleration_bounds(self, *args)

    def copyProperty_implicit_auxiliary_derivative_bounds(self, source: "MocoDirectCollocationSolver") -> "void":
        return _moco.MocoDirectCollocationSolver_copyProperty_implicit_auxiliary_derivative_bounds(self, source)

    def append_implicit_auxiliary_derivative_bounds(self, value: "MocoBounds") -> "int":
        return _moco.MocoDirectCollocationSolver_append_implicit_auxiliary_derivative_bounds(self, value)

    def constructProperty_implicit_auxiliary_derivative_bounds(self, initValue: "MocoBounds") -> "void":
        return _moco.MocoDirectCollocationSolver_constructProperty_implicit_auxiliary_derivative_bounds(self, initValue)

    def get_implicit_auxiliary_derivative_bounds(self, *args) -> "OpenSim::MocoBounds const &":
        return _moco.MocoDirectCollocationSolver_get_implicit_auxiliary_derivative_bounds(self, *args)

    def upd_implicit_auxiliary_derivative_bounds(self, *args) -> "OpenSim::MocoBounds &":
        return _moco.MocoDirectCollocationSolver_upd_implicit_auxiliary_derivative_bounds(self, *args)

    def set_implicit_auxiliary_derivative_bounds(self, *args) -> "void":
        return _moco.MocoDirectCollocationSolver_set_implicit_auxiliary_derivative_bounds(self, *args)

    def setMesh(self, mesh: "StdVectorDouble") -> "void":
        r"""
         %Set the mesh to a user-defined list of mesh points to sample. This
        takes precedence over the uniform mesh that would be specified with
        num_mesh_intervals. The user-defined mesh must start with 0, be strictly
        increasing (no duplicate entries), and end with 1.
        """
        return _moco.MocoDirectCollocationSolver_setMesh(self, mesh)
    __swig_destroy__ = _moco.delete_MocoDirectCollocationSolver

# Register MocoDirectCollocationSolver in _moco:
_moco.MocoDirectCollocationSolver_swigregister(MocoDirectCollocationSolver)

def MocoDirectCollocationSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoDirectCollocationSolver *":
    return _moco.MocoDirectCollocationSolver_safeDownCast(obj)

def MocoDirectCollocationSolver_getClassName() -> "std::string const &":
    return _moco.MocoDirectCollocationSolver_getClassName()

class MocoTropterSolverNotAvailable(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "int", func: "std::string const &"):
        _moco.MocoTropterSolverNotAvailable_swiginit(self, _moco.new_MocoTropterSolverNotAvailable(file, line, func))
    __swig_destroy__ = _moco.delete_MocoTropterSolverNotAvailable

# Register MocoTropterSolverNotAvailable in _moco:
_moco.MocoTropterSolverNotAvailable_swigregister(MocoTropterSolverNotAvailable)

class MocoTropterSolver(MocoDirectCollocationSolver):
    r"""
     Solve the MocoProblem using the **tropter** direct collocation library.
    tropter** is a free and open-source C++ library that supports computing
    the Jacobian and Hessian via either automatic differentiation or finite
    differences, and uses IPOPT for solving the nonlinear optimization problem.

    This class allows you to configure tropter's settings.

    Supported optimization solvers
    ==============================
    The following optimization solvers can be specified for the optim_solver
    property:
    - ipopt
    - snopt

    Using this solver in C++ requires that a tropter shared library is
    available, but tropter header files are not required. No tropter symbols
    are exposed in Moco's interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTropterSolver *":
        return _moco.MocoTropterSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoTropterSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoTropterSolver_getClassName()

    def clone(self) -> "OpenSim::MocoTropterSolver *":
        return _moco.MocoTropterSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoTropterSolver_getConcreteClassName(self)

    def copyProperty_optim_jacobian_approximation(self, source: "MocoTropterSolver") -> "void":
        return _moco.MocoTropterSolver_copyProperty_optim_jacobian_approximation(self, source)

    def append_optim_jacobian_approximation(self, value: "std::string const &") -> "int":
        return _moco.MocoTropterSolver_append_optim_jacobian_approximation(self, value)

    def constructProperty_optim_jacobian_approximation(self, initValue: "std::string const &") -> "void":
        return _moco.MocoTropterSolver_constructProperty_optim_jacobian_approximation(self, initValue)

    def get_optim_jacobian_approximation(self, *args) -> "std::string const &":
        return _moco.MocoTropterSolver_get_optim_jacobian_approximation(self, *args)

    def upd_optim_jacobian_approximation(self, *args) -> "std::string &":
        return _moco.MocoTropterSolver_upd_optim_jacobian_approximation(self, *args)

    def set_optim_jacobian_approximation(self, *args) -> "void":
        return _moco.MocoTropterSolver_set_optim_jacobian_approximation(self, *args)

    def copyProperty_optim_sparsity_detection(self, source: "MocoTropterSolver") -> "void":
        return _moco.MocoTropterSolver_copyProperty_optim_sparsity_detection(self, source)

    def append_optim_sparsity_detection(self, value: "std::string const &") -> "int":
        return _moco.MocoTropterSolver_append_optim_sparsity_detection(self, value)

    def constructProperty_optim_sparsity_detection(self, initValue: "std::string const &") -> "void":
        return _moco.MocoTropterSolver_constructProperty_optim_sparsity_detection(self, initValue)

    def get_optim_sparsity_detection(self, *args) -> "std::string const &":
        return _moco.MocoTropterSolver_get_optim_sparsity_detection(self, *args)

    def upd_optim_sparsity_detection(self, *args) -> "std::string &":
        return _moco.MocoTropterSolver_upd_optim_sparsity_detection(self, *args)

    def set_optim_sparsity_detection(self, *args) -> "void":
        return _moco.MocoTropterSolver_set_optim_sparsity_detection(self, *args)

    def copyProperty_exact_hessian_block_sparsity_mode(self, source: "MocoTropterSolver") -> "void":
        return _moco.MocoTropterSolver_copyProperty_exact_hessian_block_sparsity_mode(self, source)

    def append_exact_hessian_block_sparsity_mode(self, value: "std::string const &") -> "int":
        return _moco.MocoTropterSolver_append_exact_hessian_block_sparsity_mode(self, value)

    def constructProperty_exact_hessian_block_sparsity_mode(self, *args) -> "void":
        return _moco.MocoTropterSolver_constructProperty_exact_hessian_block_sparsity_mode(self, *args)

    def get_exact_hessian_block_sparsity_mode(self, *args) -> "std::string const &":
        return _moco.MocoTropterSolver_get_exact_hessian_block_sparsity_mode(self, *args)

    def upd_exact_hessian_block_sparsity_mode(self, *args) -> "std::string &":
        return _moco.MocoTropterSolver_upd_exact_hessian_block_sparsity_mode(self, *args)

    def set_exact_hessian_block_sparsity_mode(self, *args) -> "void":
        return _moco.MocoTropterSolver_set_exact_hessian_block_sparsity_mode(self, *args)

    def __init__(self):
        _moco.MocoTropterSolver_swiginit(self, _moco.new_MocoTropterSolver())

    @staticmethod
    def isAvailable() -> "bool":
        r"""
        Returns true if Moco was compiled with the Tropter library; returns
        false otherwise.
        """
        return _moco.MocoTropterSolver_isAvailable()

    def createGuess(self, *args) -> "OpenSim::MocoTrajectory":
        r"""
        Create a guess that you can edit and then set using setGuess().
        The types of guesses available are:
        - **bounds**: variable values are the midpoint between the variables'
          bounds (the value for variables with ony one bound is the specified
          bound). This is the default type.
        - **random**: values are randomly generated within the bounds.
        - **time-stepping**: see MocoSolver::createGuessTimeStepping().
        Notes: Calling this method does *not* set an initial guess to be used
        in the solver; you must call setGuess() or setGuessFile() for that.
        You must have called resetProblem().
        """
        return _moco.MocoTropterSolver_createGuess(self, *args)

    def setGuess(self, *args) -> "void":
        r"""
        *Overload 1:*
        The number of time points in the trajectory does *not* need to match
        `num_mesh_intervals`; the trajectory will be interpolated to the correct
        size.
        If you have updated the problem since the solver was initialized, you
        may need to invoke MocoSolver::resetProblem() for the provided guess to
        be recognized as compatible with the problem.
        This clears the `guess_file`, if one exists.

        |

        *Overload 2:*
        Use this convenience function if you want to choose the type of guess
        used, but do not want to modify it first.
        """
        return _moco.MocoTropterSolver_setGuess(self, *args)

    def setGuessFile(self, file: "std::string const &") -> "void":
        r"""
        This clears any previously-set guess, if any. The file is not loaded
        until solving or if you call getGuess().
        Set to an empty string to clear the guess file.
        """
        return _moco.MocoTropterSolver_setGuessFile(self, file)

    def clearGuess(self) -> "void":
        r""" Clear the stored guess and the `guess_file` if any."""
        return _moco.MocoTropterSolver_clearGuess(self)

    def getGuess(self) -> "OpenSim::MocoTrajectory const &":
        r"""
        Access the guess, loading it from the guess_file if necessary.
        This throws an exception if you have not set a guess (or guess file).
        If you have not set a guess (or guess file), this returns an empty
        guess, and when solving, we will generate a guess using bounds.
        """
        return _moco.MocoTropterSolver_getGuess(self)

    @staticmethod
    def printOptimizationSolverOptions(*args) -> "void":
        r""" Print the available options for the underlying optimization solver."""
        return _moco.MocoTropterSolver_printOptimizationSolverOptions(*args)
    __swig_destroy__ = _moco.delete_MocoTropterSolver

# Register MocoTropterSolver in _moco:
_moco.MocoTropterSolver_swigregister(MocoTropterSolver)

def MocoTropterSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTropterSolver *":
    return _moco.MocoTropterSolver_safeDownCast(obj)

def MocoTropterSolver_getClassName() -> "std::string const &":
    return _moco.MocoTropterSolver_getClassName()

def MocoTropterSolver_isAvailable() -> "bool":
    r"""
    Returns true if Moco was compiled with the Tropter library; returns
    false otherwise.
    """
    return _moco.MocoTropterSolver_isAvailable()

def MocoTropterSolver_printOptimizationSolverOptions(*args) -> "void":
    r""" Print the available options for the underlying optimization solver."""
    return _moco.MocoTropterSolver_printOptimizationSolverOptions(*args)

class MocoCasADiSolverNotAvailable(opensim.common.OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "int", func: "std::string const &"):
        _moco.MocoCasADiSolverNotAvailable_swiginit(self, _moco.new_MocoCasADiSolverNotAvailable(file, line, func))
    __swig_destroy__ = _moco.delete_MocoCasADiSolverNotAvailable

# Register MocoCasADiSolverNotAvailable in _moco:
_moco.MocoCasADiSolverNotAvailable_swigregister(MocoCasADiSolverNotAvailable)

class MocoCasADiSolver(MocoDirectCollocationSolver):
    r"""
     This solver uses the CasADi library (https://casadi.org) to convert the
    MocoProblem into a generic nonlinear programming problem. CasADi efficiently
    calculcates the derivatives required to solve MocoProblem%s, and may
    solve your MocoProblem more quickly that MocoTropterSolver. In general,
    we hope that the feature sets of MocoCasADiSolver and MocoTropterSolver
    are the same.
    Note, however, that parameter optimization problems are implemented much
    less efficiently in this solver; for parameter optimization, first try
    MocoTropterSolver.

    Sparsity
    ========
    Direct collocation is fast because the derivative matrices (Jacobian and
    Hessian) in the optimization problem are extremely sparse. By default,
    CasADi determines the sparsity pattern of these matrices to be block
    patterns: the individual functions that invoke OpenSim are treated as dense,
    but this dense pattern is repeated in a sparse way. This is conservative
    because we ensure that no "nonzeros" are accidentally treated as "zeros."
    However, the problem may solve faster if we discover more "zeros."

    See the optim_sparsity_detection setting for more information. In the case
    of "random", we use 3 random trajectories and combine the resulting sparsity
    patterns. The seed used for these 3 random trajectories is always exactly
    the same, ensuring that the sparsity pattern is deterministic.

    To explore the sparsity pattern for your problem, set optim_write_sparsity
    and run the resulting files with the plot_casadi_sparsity.py Python script.

    Finite difference scheme
    ========================
    The "central" finite difference is more accurate but can be 2 times
    slower than "forward" (tested on exampleSlidingMass). Sometimes, problems
    may struggle to converge with "forward".

    Parallelization
    ===============
    By default, CasADi evaluate the integral cost integrand and the
    differential-algebraic equations in parallel.
    This should work fine for almost all models, but if you have custom model
    components, ensure they are threadsafe. Make sure that threads do not
    access shared resources like files or global variables at the same time.

    You can turn off or change the number of parallel jobs used for individual
    problems via either the OPENSIM_MOCO_PARALLEL environment variable (see
    getMocoParallelEnvironmentVariable()) or the `parallel` property of this
    class. For example, if you plan to solve two problems at the same time on
    a machine with 4 processor cores, you could set OPENSIM_MOCO_PARALLEL to 2 to
    use all 4 cores.

    Note that there is overhead in the parallelization; if you plan to solve
    many problems, it is better to turn off parallelization here and parallelize
    the solving of your multiple problems using your system (e.g., invoke Moco in
    multiple Terminals or Command Prompts).

    Note that the `parallel` property overrides the environment variable,
    allowing more granular control over parallelization. However, the
    parallelization setting does not logically belong as a property, as it does
    not affect the solution. We encourage you to use the environment variable
    instead, as this allows different users to solve the same problem with the
    parallelization they prefer.

    Parameter variables
    ===================
    By default, MocoCasADiSolver is much slower than MocoTroperSolver at
    handling problems with MocoParameters. Many parameters require invoking
    Model::initSystem() to take effect, and this function is expensive (for
    CasADi, we must invoke this function for every time point, while in Tropter,
    we can invoke the function only once for every NLP iterate). However, if you
    know that all parameters in your problem do not require Model::initSystem(),
    you can substantially speed up your optimization by setting the
    parameters_require_initsystem property to false. Be careful, though: you
    will end up with incorrect results if your parameter does indeed require
    Model::initSystem(). To protect against this, ensure that you obtain the
    same results whether this setting is true or false.

    Notes: The software license of CasADi (LGPL) is more restrictive than that of
    the rest of Moco (Apache 2.0).
    This solver currently only supports systems for which :math:`\dot{q} = u` (e.g., no quaternions).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoCasADiSolver *":
        return _moco.MocoCasADiSolver_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoCasADiSolver_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoCasADiSolver_getClassName()

    def clone(self) -> "OpenSim::MocoCasADiSolver *":
        return _moco.MocoCasADiSolver_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoCasADiSolver_getConcreteClassName(self)

    def copyProperty_scale_variables_using_bounds(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_scale_variables_using_bounds(self, source)

    def append_scale_variables_using_bounds(self, value: "bool const &") -> "int":
        return _moco.MocoCasADiSolver_append_scale_variables_using_bounds(self, value)

    def constructProperty_scale_variables_using_bounds(self, initValue: "bool const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_scale_variables_using_bounds(self, initValue)

    def get_scale_variables_using_bounds(self, *args) -> "bool const &":
        return _moco.MocoCasADiSolver_get_scale_variables_using_bounds(self, *args)

    def upd_scale_variables_using_bounds(self, *args) -> "bool &":
        return _moco.MocoCasADiSolver_upd_scale_variables_using_bounds(self, *args)

    def set_scale_variables_using_bounds(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_scale_variables_using_bounds(self, *args)

    def copyProperty_parameters_require_initsystem(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_parameters_require_initsystem(self, source)

    def append_parameters_require_initsystem(self, value: "bool const &") -> "int":
        return _moco.MocoCasADiSolver_append_parameters_require_initsystem(self, value)

    def constructProperty_parameters_require_initsystem(self, initValue: "bool const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_parameters_require_initsystem(self, initValue)

    def get_parameters_require_initsystem(self, *args) -> "bool const &":
        return _moco.MocoCasADiSolver_get_parameters_require_initsystem(self, *args)

    def upd_parameters_require_initsystem(self, *args) -> "bool &":
        return _moco.MocoCasADiSolver_upd_parameters_require_initsystem(self, *args)

    def set_parameters_require_initsystem(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_parameters_require_initsystem(self, *args)

    def copyProperty_optim_sparsity_detection(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_optim_sparsity_detection(self, source)

    def append_optim_sparsity_detection(self, value: "std::string const &") -> "int":
        return _moco.MocoCasADiSolver_append_optim_sparsity_detection(self, value)

    def constructProperty_optim_sparsity_detection(self, initValue: "std::string const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_optim_sparsity_detection(self, initValue)

    def get_optim_sparsity_detection(self, *args) -> "std::string const &":
        return _moco.MocoCasADiSolver_get_optim_sparsity_detection(self, *args)

    def upd_optim_sparsity_detection(self, *args) -> "std::string &":
        return _moco.MocoCasADiSolver_upd_optim_sparsity_detection(self, *args)

    def set_optim_sparsity_detection(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_optim_sparsity_detection(self, *args)

    def copyProperty_optim_write_sparsity(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_optim_write_sparsity(self, source)

    def append_optim_write_sparsity(self, value: "std::string const &") -> "int":
        return _moco.MocoCasADiSolver_append_optim_write_sparsity(self, value)

    def constructProperty_optim_write_sparsity(self, initValue: "std::string const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_optim_write_sparsity(self, initValue)

    def get_optim_write_sparsity(self, *args) -> "std::string const &":
        return _moco.MocoCasADiSolver_get_optim_write_sparsity(self, *args)

    def upd_optim_write_sparsity(self, *args) -> "std::string &":
        return _moco.MocoCasADiSolver_upd_optim_write_sparsity(self, *args)

    def set_optim_write_sparsity(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_optim_write_sparsity(self, *args)

    def copyProperty_optim_finite_difference_scheme(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_optim_finite_difference_scheme(self, source)

    def append_optim_finite_difference_scheme(self, value: "std::string const &") -> "int":
        return _moco.MocoCasADiSolver_append_optim_finite_difference_scheme(self, value)

    def constructProperty_optim_finite_difference_scheme(self, initValue: "std::string const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_optim_finite_difference_scheme(self, initValue)

    def get_optim_finite_difference_scheme(self, *args) -> "std::string const &":
        return _moco.MocoCasADiSolver_get_optim_finite_difference_scheme(self, *args)

    def upd_optim_finite_difference_scheme(self, *args) -> "std::string &":
        return _moco.MocoCasADiSolver_upd_optim_finite_difference_scheme(self, *args)

    def set_optim_finite_difference_scheme(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_optim_finite_difference_scheme(self, *args)

    def copyProperty_parallel(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_parallel(self, source)

    def append_parallel(self, value: "int const &") -> "int":
        return _moco.MocoCasADiSolver_append_parallel(self, value)

    def constructProperty_parallel(self, *args) -> "void":
        return _moco.MocoCasADiSolver_constructProperty_parallel(self, *args)

    def get_parallel(self, *args) -> "int const &":
        return _moco.MocoCasADiSolver_get_parallel(self, *args)

    def upd_parallel(self, *args) -> "int &":
        return _moco.MocoCasADiSolver_upd_parallel(self, *args)

    def set_parallel(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_parallel(self, *args)

    def copyProperty_output_interval(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_output_interval(self, source)

    def append_output_interval(self, value: "int const &") -> "int":
        return _moco.MocoCasADiSolver_append_output_interval(self, value)

    def constructProperty_output_interval(self, initValue: "int const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_output_interval(self, initValue)

    def get_output_interval(self, *args) -> "int const &":
        return _moco.MocoCasADiSolver_get_output_interval(self, *args)

    def upd_output_interval(self, *args) -> "int &":
        return _moco.MocoCasADiSolver_upd_output_interval(self, *args)

    def set_output_interval(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_output_interval(self, *args)

    def copyProperty_minimize_implicit_multibody_accelerations(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_minimize_implicit_multibody_accelerations(self, source)

    def append_minimize_implicit_multibody_accelerations(self, value: "bool const &") -> "int":
        return _moco.MocoCasADiSolver_append_minimize_implicit_multibody_accelerations(self, value)

    def constructProperty_minimize_implicit_multibody_accelerations(self, initValue: "bool const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_minimize_implicit_multibody_accelerations(self, initValue)

    def get_minimize_implicit_multibody_accelerations(self, *args) -> "bool const &":
        return _moco.MocoCasADiSolver_get_minimize_implicit_multibody_accelerations(self, *args)

    def upd_minimize_implicit_multibody_accelerations(self, *args) -> "bool &":
        return _moco.MocoCasADiSolver_upd_minimize_implicit_multibody_accelerations(self, *args)

    def set_minimize_implicit_multibody_accelerations(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_minimize_implicit_multibody_accelerations(self, *args)

    def copyProperty_implicit_multibody_accelerations_weight(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_implicit_multibody_accelerations_weight(self, source)

    def append_implicit_multibody_accelerations_weight(self, value: "double const &") -> "int":
        return _moco.MocoCasADiSolver_append_implicit_multibody_accelerations_weight(self, value)

    def constructProperty_implicit_multibody_accelerations_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_implicit_multibody_accelerations_weight(self, initValue)

    def get_implicit_multibody_accelerations_weight(self, *args) -> "double const &":
        return _moco.MocoCasADiSolver_get_implicit_multibody_accelerations_weight(self, *args)

    def upd_implicit_multibody_accelerations_weight(self, *args) -> "double &":
        return _moco.MocoCasADiSolver_upd_implicit_multibody_accelerations_weight(self, *args)

    def set_implicit_multibody_accelerations_weight(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_implicit_multibody_accelerations_weight(self, *args)

    def copyProperty_minimize_implicit_auxiliary_derivatives(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_minimize_implicit_auxiliary_derivatives(self, source)

    def append_minimize_implicit_auxiliary_derivatives(self, value: "bool const &") -> "int":
        return _moco.MocoCasADiSolver_append_minimize_implicit_auxiliary_derivatives(self, value)

    def constructProperty_minimize_implicit_auxiliary_derivatives(self, initValue: "bool const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_minimize_implicit_auxiliary_derivatives(self, initValue)

    def get_minimize_implicit_auxiliary_derivatives(self, *args) -> "bool const &":
        return _moco.MocoCasADiSolver_get_minimize_implicit_auxiliary_derivatives(self, *args)

    def upd_minimize_implicit_auxiliary_derivatives(self, *args) -> "bool &":
        return _moco.MocoCasADiSolver_upd_minimize_implicit_auxiliary_derivatives(self, *args)

    def set_minimize_implicit_auxiliary_derivatives(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_minimize_implicit_auxiliary_derivatives(self, *args)

    def copyProperty_implicit_auxiliary_derivatives_weight(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_implicit_auxiliary_derivatives_weight(self, source)

    def append_implicit_auxiliary_derivatives_weight(self, value: "double const &") -> "int":
        return _moco.MocoCasADiSolver_append_implicit_auxiliary_derivatives_weight(self, value)

    def constructProperty_implicit_auxiliary_derivatives_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_implicit_auxiliary_derivatives_weight(self, initValue)

    def get_implicit_auxiliary_derivatives_weight(self, *args) -> "double const &":
        return _moco.MocoCasADiSolver_get_implicit_auxiliary_derivatives_weight(self, *args)

    def upd_implicit_auxiliary_derivatives_weight(self, *args) -> "double &":
        return _moco.MocoCasADiSolver_upd_implicit_auxiliary_derivatives_weight(self, *args)

    def set_implicit_auxiliary_derivatives_weight(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_implicit_auxiliary_derivatives_weight(self, *args)

    def copyProperty_enforce_path_constraint_midpoints(self, source: "MocoCasADiSolver") -> "void":
        return _moco.MocoCasADiSolver_copyProperty_enforce_path_constraint_midpoints(self, source)

    def append_enforce_path_constraint_midpoints(self, value: "bool const &") -> "int":
        return _moco.MocoCasADiSolver_append_enforce_path_constraint_midpoints(self, value)

    def constructProperty_enforce_path_constraint_midpoints(self, initValue: "bool const &") -> "void":
        return _moco.MocoCasADiSolver_constructProperty_enforce_path_constraint_midpoints(self, initValue)

    def get_enforce_path_constraint_midpoints(self, *args) -> "bool const &":
        return _moco.MocoCasADiSolver_get_enforce_path_constraint_midpoints(self, *args)

    def upd_enforce_path_constraint_midpoints(self, *args) -> "bool &":
        return _moco.MocoCasADiSolver_upd_enforce_path_constraint_midpoints(self, *args)

    def set_enforce_path_constraint_midpoints(self, *args) -> "void":
        return _moco.MocoCasADiSolver_set_enforce_path_constraint_midpoints(self, *args)

    def __init__(self):
        _moco.MocoCasADiSolver_swiginit(self, _moco.new_MocoCasADiSolver())

    @staticmethod
    def isAvailable() -> "bool":
        r"""
        Returns true if Moco was compiled with the CasADi library; returns false
        otherwise.
        """
        return _moco.MocoCasADiSolver_isAvailable()

    def createGuess(self, *args) -> "OpenSim::MocoTrajectory":
        r"""
        Create a guess that you can edit and then set using setGuess().
        The types of guesses available are:
        - **bounds**: variable values are the midpoint between the variables'
          bounds (the value for variables with ony one bound is the specified
          bound). This is the default type.
        - **random**: values are randomly generated within the bounds.
        - **time-stepping**: see MocoSolver::createGuessTimeStepping().
          NOTE: This option does not yet work well for this solver.
        Notes: Calling this method does *not* set an initial guess to be used
        in the solver; you must call setGuess() or setGuessFile() for that.
        You must have called resetProblem().
        """
        return _moco.MocoCasADiSolver_createGuess(self, *args)

    def setGuess(self, *args) -> "void":
        r"""
        *Overload 1:*
        The number of time points in the trajectory does *not* need to match
        `num_mesh_intervals`; the trajectory will be interpolated to the correct
        size.
        If you have updated the problem since the solver was initialized, you
        may need to invoke MocoSolver::resetProblem() for the provided guess to
        be recognized as compatible with the problem.
        This clears the `guess_file`, if one exists.

        |

        *Overload 2:*
        Use this convenience function if you want to choose the type of guess
        used, but do not want to modify it first.
        """
        return _moco.MocoCasADiSolver_setGuess(self, *args)

    def setGuessFile(self, file: "std::string const &") -> "void":
        r"""
        This clears any previously-set guess, if any. The file is not loaded
        until solving or if you call getGuess().
        Set to an empty string to clear the guess file.
        """
        return _moco.MocoCasADiSolver_setGuessFile(self, file)

    def clearGuess(self) -> "void":
        r""" Clear the stored guess and the `guess_file` if any."""
        return _moco.MocoCasADiSolver_clearGuess(self)

    def getGuess(self) -> "OpenSim::MocoTrajectory const &":
        r"""
        Access the guess, loading it from the guess_file if necessary.
        This throws an exception if you have not set a guess (or guess file).
        If you have not set a guess (or guess file), this returns an empty
        guess, and when solving, we will generate a guess using bounds.
        """
        return _moco.MocoCasADiSolver_getGuess(self)
    __swig_destroy__ = _moco.delete_MocoCasADiSolver

# Register MocoCasADiSolver in _moco:
_moco.MocoCasADiSolver_swigregister(MocoCasADiSolver)

def MocoCasADiSolver_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoCasADiSolver *":
    return _moco.MocoCasADiSolver_safeDownCast(obj)

def MocoCasADiSolver_getClassName() -> "std::string const &":
    return _moco.MocoCasADiSolver_getClassName()

def MocoCasADiSolver_isAvailable() -> "bool":
    r"""
    Returns true if Moco was compiled with the CasADi library; returns false
    otherwise.
    """
    return _moco.MocoCasADiSolver_isAvailable()

class MocoStudy(opensim.common.OpenSimObject):
    r"""
     The top-level class for solving a custom optimal control problem.

    This class consists of a MocoProblem, which describes the optimal control
    problem, and a MocoSolver, which describes the numerical method for
    solving the problem.

    Workflow
    ========
    When building a MocoStudy programmatically (e.g., in C++), the workflow is
    as follows:

    1. Build the MocoProblem (set the model, constraints, etc.).
    2. Call MocoStudy::initSolver(), which returns a reference to the
    MocoSolver.
       After this, you cannot edit the MocoProblem.
    3. Edit the settings of the MocoSolver (returned by initSolver()).
    4. Call MocoStudy::solve(). This returns the MocoSolution.
    5. (Optional) Postprocess the solution, perhaps using
    MocoStudy::visualize().

    After calling solve(), you can edit the MocoProblem and/or the MocoSolver.
    You can then call solve() again, if you wish.

    Obtaining the solution
    ----------------------
    The most common way to obtain the MocoStudy is in code, using the MocoSolution
    object returned by solve(). This norm differs from the behavior of OpenSim's
    other tools, which do not make their results available in code and instead write
    their results to file. If you want MocoStudy to write the solution to file at
    the end of solve(), use set_write_solution() and set_results_directory(). The
    name of the solution file is "<study-name>_solution.sto" or
    "MocoStudy_solution.sto" if the MocoStudy object has no name. Alternatively, you
    can write the solution to file yourself:

    .. code-block:: c++

        MocoSolution solution = study.solve();
        solution.write("solution.sto");

    Saving the study setup to a file
    --------------------------------
    You can save the MocoStudy to a file by calling MocoStudy::print(), and you
    can load the setup using MocoStudy(const std::string& omocoFile).
    MocoStudy setup files have a `.omoco` extension.

    Solver
    ------
    The default solver, MocoCasADiSolver, uses the **CasADi** automatic
    differentiation and optimization library. Moco also provides the
    MocoTropterSolver, which uses the **tropter** optimal control library that is
    part of the OpenSim project. If you want to use MocoTropterSolver instead of
    MocoCasADiSolver, call initTropterSolver() before solve(). We would like to
    support users plugging in their own solvers, but there is no timeline for this.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStudy *":
        return _moco.MocoStudy_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoStudy_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoStudy_getClassName()

    def clone(self) -> "OpenSim::MocoStudy *":
        return _moco.MocoStudy_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoStudy_getConcreteClassName(self)

    def copyProperty_write_solution(self, source: "MocoStudy") -> "void":
        return _moco.MocoStudy_copyProperty_write_solution(self, source)

    def append_write_solution(self, value: "bool const &") -> "int":
        return _moco.MocoStudy_append_write_solution(self, value)

    def constructProperty_write_solution(self, initValue: "bool const &") -> "void":
        return _moco.MocoStudy_constructProperty_write_solution(self, initValue)

    def get_write_solution(self, *args) -> "bool const &":
        return _moco.MocoStudy_get_write_solution(self, *args)

    def upd_write_solution(self, *args) -> "bool &":
        return _moco.MocoStudy_upd_write_solution(self, *args)

    def set_write_solution(self, *args) -> "void":
        return _moco.MocoStudy_set_write_solution(self, *args)

    def copyProperty_results_directory(self, source: "MocoStudy") -> "void":
        return _moco.MocoStudy_copyProperty_results_directory(self, source)

    def append_results_directory(self, value: "std::string const &") -> "int":
        return _moco.MocoStudy_append_results_directory(self, value)

    def constructProperty_results_directory(self, initValue: "std::string const &") -> "void":
        return _moco.MocoStudy_constructProperty_results_directory(self, initValue)

    def get_results_directory(self, *args) -> "std::string const &":
        return _moco.MocoStudy_get_results_directory(self, *args)

    def upd_results_directory(self, *args) -> "std::string &":
        return _moco.MocoStudy_upd_results_directory(self, *args)

    def set_results_directory(self, *args) -> "void":
        return _moco.MocoStudy_set_results_directory(self, *args)

    def __init__(self, *args):
        r""" Load a MocoStudy setup file."""
        _moco.MocoStudy_swiginit(self, _moco.new_MocoStudy(*args))

    def getProblem(self) -> "OpenSim::MocoProblem const &":
        r""" Access the MocoProblem within this study."""
        return _moco.MocoStudy_getProblem(self)

    def updProblem(self) -> "OpenSim::MocoProblem &":
        r"""
        Access the MocoProblem within this study. This function allows you to
        modify the MocoProblem.
        If using this method in C++, make sure to include the "&" in the
        return type; otherwise, you'll make a copy of the problem, and the copy
        will have no effect on this MocoStudy. See this example:

        .. code-block:: c++

            MocoProblem& problem = study.updProblem();
        """
        return _moco.MocoStudy_updProblem(self)

    def initCasADiSolver(self) -> "OpenSim::MocoCasADiSolver &":
        r"""
        Call this method once you have finished setting up your MocoProblem.
        This returns a reference to the MocoSolver, which you can then edit.
        If using this method in C++, make sure to include the "&" in the
        return type; otherwise, you'll make a copy of the solver, and the copy
        will have no effect on this MocoStudy.
        This deletes the previous solver if one exists.
        """
        return _moco.MocoStudy_initCasADiSolver(self)

    def initTropterSolver(self) -> "OpenSim::MocoTropterSolver &":
        r"""
        Call this method once you have finished setting up your MocoProblem.
        This returns a reference to the MocoSolver, which you can then edit.
        If using this method in C++, make sure to include the "&" in the
        return type; otherwise, you'll make a copy of the solver, and the copy
        will have no effect on this MocoStudy.
        This deletes the previous solver if one exists.
        """
        return _moco.MocoStudy_initTropterSolver(self)

    def updSolver(self) -> "OpenSim::MocoSolver &":
        r"""
        Access the solver. Make sure to call `initSolver()` beforehand.
        If using this method in C++, make sure to include the "&" in the
        return type; otherwise, you'll make a copy of the solver, and the copy
        will have no effect on this MocoStudy.
        """
        return _moco.MocoStudy_updSolver(self)

    def solve(self) -> "OpenSim::MocoSolution":
        r"""
        Solve the provided MocoProblem using the provided MocoSolver, and obtain
        the solution to the problem. If the write_solution property is true,
        then the solution is also written to disk in the directory specified in
        the results_directory property.

            You must have finished setting up both the problem and solver.
        This reinitializes the solver so that any changes you have made will
        hold.

        Use MocoSolution::success() on the returned solution to detect if the
        solver succeeded. If the solver did not succeed the solution will be
        sealed: you will not be able to use the failed solution
        until you acknowledge the failure by invoking MocoSolution::unseal().
        """
        return _moco.MocoStudy_solve(self)

    def visualize(self, it: "MocoTrajectory") -> "void":
        r"""
        Interactively visualize a trajectory using the simbody-visualizer. The
        trajectory could be an initial guess, a solution, etc.

            The MocoProblem must contain the model corresponding to
            the provided trajectory.
        """
        return _moco.MocoStudy_visualize(self, it)

    def analyze(self, it: "MocoTrajectory", outputPaths: "StdVectorString") -> "OpenSim::TimeSeriesTable":
        r"""
        Calculate the requested outputs using the model in the problem and the
        states and controls in the MocoTrajectory.
        The output paths can be regular expressions. For example,
        ".*activation" gives the activation of all muscles.
        Constraints are not enforced but prescribed motion (e.g.,
        PositionMotion) is.
        See also: OpenSim::analyze()
        Notes: Parameters in the MocoTrajectory are **not** applied to the model.
        """
        return _moco.MocoStudy_analyze(self, it, outputPaths)
    __swig_destroy__ = _moco.delete_MocoStudy

# Register MocoStudy in _moco:
_moco.MocoStudy_swigregister(MocoStudy)

def MocoStudy_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoStudy *":
    return _moco.MocoStudy_safeDownCast(obj)

def MocoStudy_getClassName() -> "std::string const &":
    return _moco.MocoStudy_getClassName()

class MocoStudyFactory(object):
    r""" This class creates MocoStudies of common interest."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createLinearTangentSteeringStudy(acceleration: "double", finalTime: "double", finalHeight: "double") -> "OpenSim::MocoStudy":
        r"""
        In the "linear tangent steering" problem, we control the direction to
        apply a constant thrust to a point mass to move the mass a given
        vertical distance and maximize its final horizontal speed.
        This function defines internal classes: a DirectionActuator, and a
        LinearTangentFinalSpeed. This function is intended for use in testing.
        This problem has an analytical solution, and
        is described in Section 2.4 of Bryson and Ho [1]. Bryson, A. E., Ho,
        Y.C., Applied Optimal Control, Optimization, Estimation, and Control.
        New York London Sydney Toronto. John Wiley & Sons. 1975.
        """
        return _moco.MocoStudyFactory_createLinearTangentSteeringStudy(acceleration, finalTime, finalHeight)

    def __init__(self):
        _moco.MocoStudyFactory_swiginit(self, _moco.new_MocoStudyFactory())
    __swig_destroy__ = _moco.delete_MocoStudyFactory

# Register MocoStudyFactory in _moco:
_moco.MocoStudyFactory_swigregister(MocoStudyFactory)

def MocoStudyFactory_createLinearTangentSteeringStudy(acceleration: "double", finalTime: "double", finalHeight: "double") -> "OpenSim::MocoStudy":
    r"""
    In the "linear tangent steering" problem, we control the direction to
    apply a constant thrust to a point mass to move the mass a given
    vertical distance and maximize its final horizontal speed.
    This function defines internal classes: a DirectionActuator, and a
    LinearTangentFinalSpeed. This function is intended for use in testing.
    This problem has an analytical solution, and
    is described in Section 2.4 of Bryson and Ho [1]. Bryson, A. E., Ho,
    Y.C., Applied Optimal Control, Optimization, Estimation, and Control.
    New York London Sydney Toronto. John Wiley & Sons. 1975.
    """
    return _moco.MocoStudyFactory_createLinearTangentSteeringStudy(acceleration, finalTime, finalHeight)

class MocoTool(opensim.common.OpenSimObject):
    r"""
     This is a base class for solving problems that depend on an observed motion
    using Moco's optimal control methods.
    MocoTool Properties
    ===================
    Mesh interval
    -------------
    A smaller mesh interval increases the convergence time, but is necessary
    for fast motions or problems with stiff differential equations (e.g.,
    stiff tendons).
    For gait, consider using a mesh interval between 0.01 and 0.05 seconds.
    Try solving your problem with decreasing mesh intervals and choose a mesh
    interval at which the solution stops changing noticeably.

    Reserve actuators
    -----------------
    Sometimes it is not possible to achieve the desired motion using
    muscles alone. There are multiple possible causes for this:
      - the muscles are not strong enough to achieve the required
        net joint moments,
      - the net joint moments change more rapidly than activation and
        deactivation time constants allow,
      - the filtering of the data causes unrealistic desired net joint moments.
    You may want to add "reserve" actuators to your model.
    This can be done with the ModOpAddReserves model operator.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTool *":
        return _moco.MocoTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoTool_getClassName()

    def clone(self) -> "OpenSim::MocoTool *":
        return _moco.MocoTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoTool_getConcreteClassName(self)

    def copyProperty_initial_time(self, source: "MocoTool") -> "void":
        return _moco.MocoTool_copyProperty_initial_time(self, source)

    def append_initial_time(self, value: "double const &") -> "int":
        return _moco.MocoTool_append_initial_time(self, value)

    def constructProperty_initial_time(self, *args) -> "void":
        return _moco.MocoTool_constructProperty_initial_time(self, *args)

    def get_initial_time(self, *args) -> "double const &":
        return _moco.MocoTool_get_initial_time(self, *args)

    def upd_initial_time(self, *args) -> "double &":
        return _moco.MocoTool_upd_initial_time(self, *args)

    def set_initial_time(self, *args) -> "void":
        return _moco.MocoTool_set_initial_time(self, *args)

    def copyProperty_final_time(self, source: "MocoTool") -> "void":
        return _moco.MocoTool_copyProperty_final_time(self, source)

    def append_final_time(self, value: "double const &") -> "int":
        return _moco.MocoTool_append_final_time(self, value)

    def constructProperty_final_time(self, *args) -> "void":
        return _moco.MocoTool_constructProperty_final_time(self, *args)

    def get_final_time(self, *args) -> "double const &":
        return _moco.MocoTool_get_final_time(self, *args)

    def upd_final_time(self, *args) -> "double &":
        return _moco.MocoTool_upd_final_time(self, *args)

    def set_final_time(self, *args) -> "void":
        return _moco.MocoTool_set_final_time(self, *args)

    def copyProperty_mesh_interval(self, source: "MocoTool") -> "void":
        return _moco.MocoTool_copyProperty_mesh_interval(self, source)

    def append_mesh_interval(self, value: "double const &") -> "int":
        return _moco.MocoTool_append_mesh_interval(self, value)

    def constructProperty_mesh_interval(self, initValue: "double const &") -> "void":
        return _moco.MocoTool_constructProperty_mesh_interval(self, initValue)

    def get_mesh_interval(self, *args) -> "double const &":
        return _moco.MocoTool_get_mesh_interval(self, *args)

    def upd_mesh_interval(self, *args) -> "double &":
        return _moco.MocoTool_upd_mesh_interval(self, *args)

    def set_mesh_interval(self, *args) -> "void":
        return _moco.MocoTool_set_mesh_interval(self, *args)

    def copyProperty_clip_time_range(self, source: "MocoTool") -> "void":
        return _moco.MocoTool_copyProperty_clip_time_range(self, source)

    def append_clip_time_range(self, value: "bool const &") -> "int":
        return _moco.MocoTool_append_clip_time_range(self, value)

    def constructProperty_clip_time_range(self, initValue: "bool const &") -> "void":
        return _moco.MocoTool_constructProperty_clip_time_range(self, initValue)

    def get_clip_time_range(self, *args) -> "bool const &":
        return _moco.MocoTool_get_clip_time_range(self, *args)

    def upd_clip_time_range(self, *args) -> "bool &":
        return _moco.MocoTool_upd_clip_time_range(self, *args)

    def set_clip_time_range(self, *args) -> "void":
        return _moco.MocoTool_set_clip_time_range(self, *args)

    def copyProperty_model(self, source: "MocoTool") -> "void":
        return _moco.MocoTool_copyProperty_model(self, source)

    def append_model(self, value: "ModelProcessor") -> "int":
        return _moco.MocoTool_append_model(self, value)

    def constructProperty_model(self, initValue: "ModelProcessor") -> "void":
        return _moco.MocoTool_constructProperty_model(self, initValue)

    def get_model(self, *args) -> "OpenSim::ModelProcessor const &":
        return _moco.MocoTool_get_model(self, *args)

    def upd_model(self, *args) -> "OpenSim::ModelProcessor &":
        return _moco.MocoTool_upd_model(self, *args)

    def set_model(self, *args) -> "void":
        return _moco.MocoTool_set_model(self, *args)

    def setModel(self, model: "ModelProcessor") -> "void":
        return _moco.MocoTool_setModel(self, model)
    __swig_destroy__ = _moco.delete_MocoTool

# Register MocoTool in _moco:
_moco.MocoTool_swigregister(MocoTool)

def MocoTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTool *":
    return _moco.MocoTool_safeDownCast(obj)

def MocoTool_getClassName() -> "std::string const &":
    return _moco.MocoTool_getClassName()

class MocoInverseSolution(object):
    r""" This class holds the solution from MocoInverse."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getMocoSolution(self) -> "OpenSim::MocoSolution const &":
        return _moco.MocoInverseSolution_getMocoSolution(self)

    def getOutputs(self) -> "OpenSim::TimeSeriesTable const &":
        return _moco.MocoInverseSolution_getOutputs(self)

    def __init__(self):
        _moco.MocoInverseSolution_swiginit(self, _moco.new_MocoInverseSolution())
    __swig_destroy__ = _moco.delete_MocoInverseSolution

# Register MocoInverseSolution in _moco:
_moco.MocoInverseSolution_swigregister(MocoInverseSolution)

class MocoInverse(MocoTool):
    r"""
     This tool solves problems in which the kinematics are prescribed and you
    seek the actuator (e.g., muscle) behavior that may have given rise to the
    provided kinematics. The term "inverse" describes methods that estimate
    quantities from an observation; on the other hand, "forward" methods attempt
    to predict (unobserved) behavior. In this case, "inverse" refers to the
    multibody systems. This class can still be used to simulate muscles in a
    "forward" or predictive sense.

    The kinematics file must provide values for all coordinates (even those
    labeled as dependent in a CoordinateCouplerConstraint); missing coordinates
    are set to NaN.

    The provided trajectory is altered to satisfy any enabled kinematic
    constraints in the model.

    # Cost
    By default, MocoInverse minimizes the sum of squared controls and
    constrains initial activation to be equal to initial excitation (to avoid
    initial activation spikes). To customize the cost, invoke initialize(), add
    costs manually, and solve the problem using the solver directly. Note,
    however, that kinematic states are not included in the solution if you use
    the solver directly.

    # Default solver settings
    - solver: MocoCasADiSolver
    - multibody_dynamics_mode: implicit
    - interpolate_control_midpoints: false
    - minimize_implicit_auxiliary_derivatives: true
    - implicit_auxiliary_derivatives_weight: 0.01
    - optim_convergence_tolerance: 1e-3
    - optim_constraint_tolerance: 1e-3
    - optim_sparsity_detection: random
    - optim_finite_difference_scheme: forward

    If you would like to use settings other than these defaults, see "Customizing
    a problem" below.

    MocoInverse minimizes the sum of squared controls and, optionally, the sum
    of squared activations. As MocoInverse becomes more mature and general, the
    costs will become more flexible.

    # Mesh interval
    A smaller mesh interval increases the convergence time, but is necessary
    for fast motions or problems with stiff differential equations (e.g.,
    stiff tendons).
    For gait, consider using a mesh interval between 0.01 and 0.05 seconds.
    Try solving your problem with decreasing mesh intervals and choose a mesh
    interval at which the solution stops changing noticeably.

    # Basic example

    This example shows how to use MocoInverse in C++:

    .. code-block:: c++

        MocoInverse inverse;
        inverse.setName("prescribed_motion");
        inverse.setModel(ModelProcessor("model_file.osim") |
                         ModOpAddExternalLoads("external_loads.xml") |
                         ModOpAddReserves());
        inverse.setKinematics(TableProcessor("states_reference_file.sto"));
        inverse.set_mesh_interval(0.02);
        MocoInverseSolution solution = inverse.solve();
        solution.getMocoSolution().write("MocoInverse_solution.sto");

    Customizing the tool
    --------------------
    The example below shows how you can customize the MocoInverse tool by obtaining
    the underlying MocoStudy. You can change the "Default solver settings" above
    and add additional goals.

    .. code-block:: c++

        MocoInverse inverse;
        inverse.setName("prescribed_motion");
        inverse.setModel(ModelProcessor("model_file.osim") |
                         ModOpAddExternalLoads("external_loads.xml") |
                         ModOpAddReserves(1));
        inverse.setKinematics(TableProcessor("states_reference_file.sto"));
        inverse.set_mesh_interval(0.02);
        MocoStudy study = inverse.initialize();
        MocoProblem& problem = study.updProblem();
        auto* emg_tracking = problem.addGoal<MocoControlTrackingGoal>("emg_tracking");
        emg_tracking->setReference(TimeSeriesTable("electromyography.sto"));
        auto& solver = study.updSolver<MocoCasADiSolver>();
        solver.set_optim_convergence_tolerance(1e-4);
        MocoSolution solution = study.solve();
        solution.write("MocoInverse_solution.sto");

    Do NOT change the multibody_dynamics_mode solver setting, as setting this to
    "implicit" is vital to how MocoInverse works.

    # Path constraints
    If adding a MocoPathConstraint to a custom MocoInverse problem, you may want
    to enable the solver setting 'enforce_path_constraint_midpoints':

    .. code-block:: c++

        solver.set_enforce_path_constraint_midpoints(true);

    This is because we do not enforce MocoPathConstraints at mesh interval
    midpoints by default with Hermite-Simpson collocation, and the property
    'interpolate_control_midpoints' is set to false with MocoInverse to ensure
    the problem does not become over-constrained.

    For example, if using a MocoControlBoundConstraint with MocoInverse,
    the constraint will be ignored at mesh interval midpoints if
    'enforce_path_constraint_midpoints' is set to false.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInverse *":
        return _moco.MocoInverse_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoInverse_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoInverse_getClassName()

    def clone(self) -> "OpenSim::MocoInverse *":
        return _moco.MocoInverse_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoInverse_getConcreteClassName(self)

    def copyProperty_kinematics(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_kinematics(self, source)

    def append_kinematics(self, value: "TableProcessor") -> "int":
        return _moco.MocoInverse_append_kinematics(self, value)

    def constructProperty_kinematics(self, initValue: "TableProcessor") -> "void":
        return _moco.MocoInverse_constructProperty_kinematics(self, initValue)

    def get_kinematics(self, *args) -> "OpenSim::TableProcessor const &":
        return _moco.MocoInverse_get_kinematics(self, *args)

    def upd_kinematics(self, *args) -> "OpenSim::TableProcessor &":
        return _moco.MocoInverse_upd_kinematics(self, *args)

    def set_kinematics(self, *args) -> "void":
        return _moco.MocoInverse_set_kinematics(self, *args)

    def copyProperty_kinematics_allow_extra_columns(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_kinematics_allow_extra_columns(self, source)

    def append_kinematics_allow_extra_columns(self, value: "bool const &") -> "int":
        return _moco.MocoInverse_append_kinematics_allow_extra_columns(self, value)

    def constructProperty_kinematics_allow_extra_columns(self, initValue: "bool const &") -> "void":
        return _moco.MocoInverse_constructProperty_kinematics_allow_extra_columns(self, initValue)

    def get_kinematics_allow_extra_columns(self, *args) -> "bool const &":
        return _moco.MocoInverse_get_kinematics_allow_extra_columns(self, *args)

    def upd_kinematics_allow_extra_columns(self, *args) -> "bool &":
        return _moco.MocoInverse_upd_kinematics_allow_extra_columns(self, *args)

    def set_kinematics_allow_extra_columns(self, *args) -> "void":
        return _moco.MocoInverse_set_kinematics_allow_extra_columns(self, *args)

    def copyProperty_minimize_sum_squared_activations(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_minimize_sum_squared_activations(self, source)

    def append_minimize_sum_squared_activations(self, value: "bool const &") -> "int":
        return _moco.MocoInverse_append_minimize_sum_squared_activations(self, value)

    def constructProperty_minimize_sum_squared_activations(self, initValue: "bool const &") -> "void":
        return _moco.MocoInverse_constructProperty_minimize_sum_squared_activations(self, initValue)

    def get_minimize_sum_squared_activations(self, *args) -> "bool const &":
        return _moco.MocoInverse_get_minimize_sum_squared_activations(self, *args)

    def upd_minimize_sum_squared_activations(self, *args) -> "bool &":
        return _moco.MocoInverse_upd_minimize_sum_squared_activations(self, *args)

    def set_minimize_sum_squared_activations(self, *args) -> "void":
        return _moco.MocoInverse_set_minimize_sum_squared_activations(self, *args)

    def copyProperty_max_iterations(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_max_iterations(self, source)

    def append_max_iterations(self, value: "int const &") -> "int":
        return _moco.MocoInverse_append_max_iterations(self, value)

    def constructProperty_max_iterations(self, *args) -> "void":
        return _moco.MocoInverse_constructProperty_max_iterations(self, *args)

    def get_max_iterations(self, *args) -> "int const &":
        return _moco.MocoInverse_get_max_iterations(self, *args)

    def upd_max_iterations(self, *args) -> "int &":
        return _moco.MocoInverse_upd_max_iterations(self, *args)

    def set_max_iterations(self, *args) -> "void":
        return _moco.MocoInverse_set_max_iterations(self, *args)

    def copyProperty_convergence_tolerance(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_convergence_tolerance(self, source)

    def append_convergence_tolerance(self, value: "double const &") -> "int":
        return _moco.MocoInverse_append_convergence_tolerance(self, value)

    def constructProperty_convergence_tolerance(self, initValue: "double const &") -> "void":
        return _moco.MocoInverse_constructProperty_convergence_tolerance(self, initValue)

    def get_convergence_tolerance(self, *args) -> "double const &":
        return _moco.MocoInverse_get_convergence_tolerance(self, *args)

    def upd_convergence_tolerance(self, *args) -> "double &":
        return _moco.MocoInverse_upd_convergence_tolerance(self, *args)

    def set_convergence_tolerance(self, *args) -> "void":
        return _moco.MocoInverse_set_convergence_tolerance(self, *args)

    def copyProperty_constraint_tolerance(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_constraint_tolerance(self, source)

    def append_constraint_tolerance(self, value: "double const &") -> "int":
        return _moco.MocoInverse_append_constraint_tolerance(self, value)

    def constructProperty_constraint_tolerance(self, initValue: "double const &") -> "void":
        return _moco.MocoInverse_constructProperty_constraint_tolerance(self, initValue)

    def get_constraint_tolerance(self, *args) -> "double const &":
        return _moco.MocoInverse_get_constraint_tolerance(self, *args)

    def upd_constraint_tolerance(self, *args) -> "double &":
        return _moco.MocoInverse_upd_constraint_tolerance(self, *args)

    def set_constraint_tolerance(self, *args) -> "void":
        return _moco.MocoInverse_set_constraint_tolerance(self, *args)

    def copyProperty_output_paths(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_output_paths(self, source)

    def get_output_paths(self, i: "int") -> "std::string const &":
        return _moco.MocoInverse_get_output_paths(self, i)

    def upd_output_paths(self, i: "int") -> "std::string &":
        return _moco.MocoInverse_upd_output_paths(self, i)

    def set_output_paths(self, i: "int", value: "std::string const &") -> "void":
        return _moco.MocoInverse_set_output_paths(self, i, value)

    def append_output_paths(self, value: "std::string const &") -> "int":
        return _moco.MocoInverse_append_output_paths(self, value)

    def constructProperty_output_paths(self) -> "void":
        return _moco.MocoInverse_constructProperty_output_paths(self)

    def copyProperty_reserves_weight(self, source: "MocoInverse") -> "void":
        return _moco.MocoInverse_copyProperty_reserves_weight(self, source)

    def append_reserves_weight(self, value: "double const &") -> "int":
        return _moco.MocoInverse_append_reserves_weight(self, value)

    def constructProperty_reserves_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoInverse_constructProperty_reserves_weight(self, initValue)

    def get_reserves_weight(self, *args) -> "double const &":
        return _moco.MocoInverse_get_reserves_weight(self, *args)

    def upd_reserves_weight(self, *args) -> "double &":
        return _moco.MocoInverse_upd_reserves_weight(self, *args)

    def set_reserves_weight(self, *args) -> "void":
        return _moco.MocoInverse_set_reserves_weight(self, *args)

    def __init__(self):
        _moco.MocoInverse_swiginit(self, _moco.new_MocoInverse())

    def setKinematics(self, kinematics: "TableProcessor") -> "void":
        return _moco.MocoInverse_setKinematics(self, kinematics)

    def initialize(self) -> "OpenSim::MocoStudy":
        return _moco.MocoInverse_initialize(self)

    def solve(self) -> "OpenSim::MocoInverseSolution":
        r"""
        Solve the problem returned by initialize() and compute the outputs
        listed in output_paths.
        """
        return _moco.MocoInverse_solve(self)
    __swig_destroy__ = _moco.delete_MocoInverse

# Register MocoInverse in _moco:
_moco.MocoInverse_swigregister(MocoInverse)

def MocoInverse_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoInverse *":
    return _moco.MocoInverse_safeDownCast(obj)

def MocoInverse_getClassName() -> "std::string const &":
    return _moco.MocoInverse_getClassName()

class MocoTrack(MocoTool):
    r"""
    This tool constructs problems in which state and/or marker trajectory data
    are tracked while solving for model kinematics and actuator controls.
    "Tracking" refers to cost terms that minimize the error between provided
    reference data and the associated model quantities (joint angles, joint
    velocities, marker positions, etc).

    State and marker tracking
    -------------------------
    State reference data (joint angles and velocities), marker reference data
    (x/y/z marker motion capture trajectories), or both may be provided via the
    `states_reference` and `markers_reference` properties. For each set of
    reference data provided, a tracking cost term is added to the internal
    MocoProblem.

    setMarkersReference() only accepts a scalar TimeSeriesTable (either
    directly or via a TableProcessor) containing x/y/z marker position values.
    A TimeSeriesTableVec3 of markers is not accepted, but you may use the
    flatten() method to convert to a scalar TimeSeriesTable:

    .. code-block:: c++

        MocoTrack track;

        TimeSeriesTableVec3 markers = TRCFileAdapter("marker_trajectories.trc");
        TimeSeriesTable markersFlat(markers.flatten());
        track.setMarkersReference(TableProcessor(markersFlat));

    If you wish to set the markers reference directly from a TRC file, use
    setMarkersReferenceFromTRC().

    The `states_global_tracking_weight` and `markers_global_tracking_weight`
    properties apply a cost function weight to all tracking error associated
    provided reference data. The `states_weight_set` and `markers_weight_set`
    properties give you finer control over the tracking costs, letting you set
    weights for individual reference data tracking errors.

    Control effort minimization
    ---------------------------
    By default, a MocoControlCost term is added to the underlying problem with
    a weight of 0.001. Control effort terms often help smooth the problem
    solution controls, and minimally affect the states tracking solution with a
    sufficiently low weight. Use the `minimize_control_effort` and
    `control_effort_weight` properties to customize these settings.

    Problem configuration options
    -----------------------------
    A time range that is compatible with all reference data may be provided.
    If no time range is set, the widest time range that is compatible with all
    reference data will be used.

    If you would like to track joint velocities but only have joint angles in
    your states reference, enable the `track_reference_position_derivatives`
    property. When enabled, the provided position-level states reference data
    will be splined in order to compute derivatives. If some velocity-level
    information exists in the reference, this option will fill in the missing
    data with position derivatives and leave the existing velocity data intact.
    This is not enabled by default, but is recommended for improving tracking
    performance and reducing convergence times.

    Since the data in the provided references may be altered by TableProcessor
    operations or appended to by `track_reference_position_derivatives`, the
    tracked data is printed to file in addition to the problem solution. The
    tracked data files have the following format
    "<tool_name>_tracked_<data_type>.sto" (e.g. "MocoTool_tracked_states.sto").

    Default solver settings
    -----------------------
    - solver: MocoCasADiSolver
    - multibody_dynamics_mode: explicit
    - transcription_scheme: Hermite-Simpson
    - optim_convergence_tolerance: 1e-2
    - optim_constraint_tolerance: 1e-2
    - optim_sparsity_detection: random
    - optim_finite_difference_scheme: 'forward'

    If you would like to use settings other than these defaults, see
    "Customizing a tracking problem" below.

    Basic example
    -------------
    Construct a tracking problem by setting property values and calling solve():

    .. code-block:: c++

        MocoTrack track;
        track.setName("states_tracking_with_reserves");
        track.setModel(ModelProcessor("model_file.osim") |
                       ModOpAddExternalLoads("external_loads.xml") |
                       ModOpAddReserves());
        track.setStatesReference("states_reference_file.sto");
        track.set_track_reference_position_derivatives(true);
        track.set_control_effort_weight(0.1);
        MocoSolution solution = track.solve();

    Customizing a tracking problem
    ------------------------------
    If you wish to further customize the underlying MocoProblem before solving,
    instead of calling solve(), call initialize() which returns a pre-configured
    MocoStudy object:

    .. code-block:: c++

        MocoTrack track;
        track.setName("track_and_minimize_hip_compressive_force");
        track.setModel(ModelProcessor("model_file.xml") |
                       ModOpAddExternalLoads());
        track.setStatesReference("states_reference_file.sto");

        MocoStudy study = track.initialize();

        auto& problem = study.updProblem();
        auto* hipForceCost = problem.addGoal<MocoJointReactionCost>("hip_force");
        hipForceCost->set_weight(10);
        hipForceCost->setJointPath("/jointset/hip_r");
        hipForceCost->setReactionMeasures({"force-y"});

        auto& solver = study.updSolver<MocoCasADiSolver>();
        solver.set_multibody_dynamics_mode("implicit");

        MocoSolution solution = study.solve();

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTrack *":
        return _moco.MocoTrack_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.MocoTrack_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.MocoTrack_getClassName()

    def clone(self) -> "OpenSim::MocoTrack *":
        return _moco.MocoTrack_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.MocoTrack_getConcreteClassName(self)

    def copyProperty_states_reference(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_states_reference(self, source)

    def append_states_reference(self, value: "TableProcessor") -> "int":
        return _moco.MocoTrack_append_states_reference(self, value)

    def constructProperty_states_reference(self, initValue: "TableProcessor") -> "void":
        return _moco.MocoTrack_constructProperty_states_reference(self, initValue)

    def get_states_reference(self, *args) -> "OpenSim::TableProcessor const &":
        return _moco.MocoTrack_get_states_reference(self, *args)

    def upd_states_reference(self, *args) -> "OpenSim::TableProcessor &":
        return _moco.MocoTrack_upd_states_reference(self, *args)

    def set_states_reference(self, *args) -> "void":
        return _moco.MocoTrack_set_states_reference(self, *args)

    def copyProperty_states_global_tracking_weight(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_states_global_tracking_weight(self, source)

    def append_states_global_tracking_weight(self, value: "double const &") -> "int":
        return _moco.MocoTrack_append_states_global_tracking_weight(self, value)

    def constructProperty_states_global_tracking_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoTrack_constructProperty_states_global_tracking_weight(self, initValue)

    def get_states_global_tracking_weight(self, *args) -> "double const &":
        return _moco.MocoTrack_get_states_global_tracking_weight(self, *args)

    def upd_states_global_tracking_weight(self, *args) -> "double &":
        return _moco.MocoTrack_upd_states_global_tracking_weight(self, *args)

    def set_states_global_tracking_weight(self, *args) -> "void":
        return _moco.MocoTrack_set_states_global_tracking_weight(self, *args)

    def copyProperty_states_weight_set(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_states_weight_set(self, source)

    def append_states_weight_set(self, value: "MocoWeightSet") -> "int":
        return _moco.MocoTrack_append_states_weight_set(self, value)

    def constructProperty_states_weight_set(self, initValue: "MocoWeightSet") -> "void":
        return _moco.MocoTrack_constructProperty_states_weight_set(self, initValue)

    def get_states_weight_set(self, *args) -> "OpenSim::MocoWeightSet const &":
        return _moco.MocoTrack_get_states_weight_set(self, *args)

    def upd_states_weight_set(self, *args) -> "OpenSim::MocoWeightSet &":
        return _moco.MocoTrack_upd_states_weight_set(self, *args)

    def set_states_weight_set(self, *args) -> "void":
        return _moco.MocoTrack_set_states_weight_set(self, *args)

    def copyProperty_scale_state_weights_with_range(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_scale_state_weights_with_range(self, source)

    def append_scale_state_weights_with_range(self, value: "bool const &") -> "int":
        return _moco.MocoTrack_append_scale_state_weights_with_range(self, value)

    def constructProperty_scale_state_weights_with_range(self, initValue: "bool const &") -> "void":
        return _moco.MocoTrack_constructProperty_scale_state_weights_with_range(self, initValue)

    def get_scale_state_weights_with_range(self, *args) -> "bool const &":
        return _moco.MocoTrack_get_scale_state_weights_with_range(self, *args)

    def upd_scale_state_weights_with_range(self, *args) -> "bool &":
        return _moco.MocoTrack_upd_scale_state_weights_with_range(self, *args)

    def set_scale_state_weights_with_range(self, *args) -> "void":
        return _moco.MocoTrack_set_scale_state_weights_with_range(self, *args)

    def copyProperty_track_reference_position_derivatives(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_track_reference_position_derivatives(self, source)

    def append_track_reference_position_derivatives(self, value: "bool const &") -> "int":
        return _moco.MocoTrack_append_track_reference_position_derivatives(self, value)

    def constructProperty_track_reference_position_derivatives(self, initValue: "bool const &") -> "void":
        return _moco.MocoTrack_constructProperty_track_reference_position_derivatives(self, initValue)

    def get_track_reference_position_derivatives(self, *args) -> "bool const &":
        return _moco.MocoTrack_get_track_reference_position_derivatives(self, *args)

    def upd_track_reference_position_derivatives(self, *args) -> "bool &":
        return _moco.MocoTrack_upd_track_reference_position_derivatives(self, *args)

    def set_track_reference_position_derivatives(self, *args) -> "void":
        return _moco.MocoTrack_set_track_reference_position_derivatives(self, *args)

    def copyProperty_markers_reference(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_markers_reference(self, source)

    def append_markers_reference(self, value: "TableProcessor") -> "int":
        return _moco.MocoTrack_append_markers_reference(self, value)

    def constructProperty_markers_reference(self, initValue: "TableProcessor") -> "void":
        return _moco.MocoTrack_constructProperty_markers_reference(self, initValue)

    def get_markers_reference(self, *args) -> "OpenSim::TableProcessor const &":
        return _moco.MocoTrack_get_markers_reference(self, *args)

    def upd_markers_reference(self, *args) -> "OpenSim::TableProcessor &":
        return _moco.MocoTrack_upd_markers_reference(self, *args)

    def set_markers_reference(self, *args) -> "void":
        return _moco.MocoTrack_set_markers_reference(self, *args)

    def copyProperty_markers_global_tracking_weight(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_markers_global_tracking_weight(self, source)

    def append_markers_global_tracking_weight(self, value: "double const &") -> "int":
        return _moco.MocoTrack_append_markers_global_tracking_weight(self, value)

    def constructProperty_markers_global_tracking_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoTrack_constructProperty_markers_global_tracking_weight(self, initValue)

    def get_markers_global_tracking_weight(self, *args) -> "double const &":
        return _moco.MocoTrack_get_markers_global_tracking_weight(self, *args)

    def upd_markers_global_tracking_weight(self, *args) -> "double &":
        return _moco.MocoTrack_upd_markers_global_tracking_weight(self, *args)

    def set_markers_global_tracking_weight(self, *args) -> "void":
        return _moco.MocoTrack_set_markers_global_tracking_weight(self, *args)

    def copyProperty_markers_weight_set(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_markers_weight_set(self, source)

    def append_markers_weight_set(self, value: "MocoWeightSet") -> "int":
        return _moco.MocoTrack_append_markers_weight_set(self, value)

    def constructProperty_markers_weight_set(self, initValue: "MocoWeightSet") -> "void":
        return _moco.MocoTrack_constructProperty_markers_weight_set(self, initValue)

    def get_markers_weight_set(self, *args) -> "OpenSim::MocoWeightSet const &":
        return _moco.MocoTrack_get_markers_weight_set(self, *args)

    def upd_markers_weight_set(self, *args) -> "OpenSim::MocoWeightSet &":
        return _moco.MocoTrack_upd_markers_weight_set(self, *args)

    def set_markers_weight_set(self, *args) -> "void":
        return _moco.MocoTrack_set_markers_weight_set(self, *args)

    def copyProperty_allow_unused_references(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_allow_unused_references(self, source)

    def append_allow_unused_references(self, value: "bool const &") -> "int":
        return _moco.MocoTrack_append_allow_unused_references(self, value)

    def constructProperty_allow_unused_references(self, initValue: "bool const &") -> "void":
        return _moco.MocoTrack_constructProperty_allow_unused_references(self, initValue)

    def get_allow_unused_references(self, *args) -> "bool const &":
        return _moco.MocoTrack_get_allow_unused_references(self, *args)

    def upd_allow_unused_references(self, *args) -> "bool &":
        return _moco.MocoTrack_upd_allow_unused_references(self, *args)

    def set_allow_unused_references(self, *args) -> "void":
        return _moco.MocoTrack_set_allow_unused_references(self, *args)

    def copyProperty_guess_file(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_guess_file(self, source)

    def append_guess_file(self, value: "std::string const &") -> "int":
        return _moco.MocoTrack_append_guess_file(self, value)

    def constructProperty_guess_file(self, initValue: "std::string const &") -> "void":
        return _moco.MocoTrack_constructProperty_guess_file(self, initValue)

    def get_guess_file(self, *args) -> "std::string const &":
        return _moco.MocoTrack_get_guess_file(self, *args)

    def upd_guess_file(self, *args) -> "std::string &":
        return _moco.MocoTrack_upd_guess_file(self, *args)

    def set_guess_file(self, *args) -> "void":
        return _moco.MocoTrack_set_guess_file(self, *args)

    def copyProperty_apply_tracked_states_to_guess(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_apply_tracked_states_to_guess(self, source)

    def append_apply_tracked_states_to_guess(self, value: "bool const &") -> "int":
        return _moco.MocoTrack_append_apply_tracked_states_to_guess(self, value)

    def constructProperty_apply_tracked_states_to_guess(self, initValue: "bool const &") -> "void":
        return _moco.MocoTrack_constructProperty_apply_tracked_states_to_guess(self, initValue)

    def get_apply_tracked_states_to_guess(self, *args) -> "bool const &":
        return _moco.MocoTrack_get_apply_tracked_states_to_guess(self, *args)

    def upd_apply_tracked_states_to_guess(self, *args) -> "bool &":
        return _moco.MocoTrack_upd_apply_tracked_states_to_guess(self, *args)

    def set_apply_tracked_states_to_guess(self, *args) -> "void":
        return _moco.MocoTrack_set_apply_tracked_states_to_guess(self, *args)

    def copyProperty_minimize_control_effort(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_minimize_control_effort(self, source)

    def append_minimize_control_effort(self, value: "bool const &") -> "int":
        return _moco.MocoTrack_append_minimize_control_effort(self, value)

    def constructProperty_minimize_control_effort(self, initValue: "bool const &") -> "void":
        return _moco.MocoTrack_constructProperty_minimize_control_effort(self, initValue)

    def get_minimize_control_effort(self, *args) -> "bool const &":
        return _moco.MocoTrack_get_minimize_control_effort(self, *args)

    def upd_minimize_control_effort(self, *args) -> "bool &":
        return _moco.MocoTrack_upd_minimize_control_effort(self, *args)

    def set_minimize_control_effort(self, *args) -> "void":
        return _moco.MocoTrack_set_minimize_control_effort(self, *args)

    def copyProperty_control_effort_weight(self, source: "MocoTrack") -> "void":
        return _moco.MocoTrack_copyProperty_control_effort_weight(self, source)

    def append_control_effort_weight(self, value: "double const &") -> "int":
        return _moco.MocoTrack_append_control_effort_weight(self, value)

    def constructProperty_control_effort_weight(self, initValue: "double const &") -> "void":
        return _moco.MocoTrack_constructProperty_control_effort_weight(self, initValue)

    def get_control_effort_weight(self, *args) -> "double const &":
        return _moco.MocoTrack_get_control_effort_weight(self, *args)

    def upd_control_effort_weight(self, *args) -> "double &":
        return _moco.MocoTrack_upd_control_effort_weight(self, *args)

    def set_control_effort_weight(self, *args) -> "void":
        return _moco.MocoTrack_set_control_effort_weight(self, *args)

    def __init__(self):
        _moco.MocoTrack_swiginit(self, _moco.new_MocoTrack())

    def setStatesReference(self, states: "TableProcessor") -> "void":
        r"""
        Set the states reference TableProcessor.
        Notes: Overrides any existing TableProcessor for 'states_reference'.
        """
        return _moco.MocoTrack_setStatesReference(self, states)

    def setMarkersReference(self, markers: "TableProcessor") -> "void":
        r"""
        Set the markers reference TableProcessor.
        Notes: Overrides any existing TableProcessor for 'markers_reference'.
        """
        return _moco.MocoTrack_setMarkersReference(self, markers)

    def setMarkersReferenceFromTRC(self, filename: "std::string const &", lowpassFilterFreq: "double"=6.0) -> "void":
        r"""
        Set the markers reference directly from a TRC file. By default, the
        marker data is low-pass filtered with a 6 Hz cutoff frequency, but you
        may set any frequency using the optional argument.
        Notes: Overrides any existing TableProcessor for 'markers_reference'.
        """
        return _moco.MocoTrack_setMarkersReferenceFromTRC(self, filename, lowpassFilterFreq)

    def initialize(self) -> "OpenSim::MocoStudy":
        return _moco.MocoTrack_initialize(self)

    def solve(self) -> "OpenSim::MocoSolution":
        r""" Solve the MocoTrack problem and obtain the solution."""
        return _moco.MocoTrack_solve(self)

    def solveAndVisualize(self) -> "OpenSim::MocoSolution":
        r"""
        Solve the MocoTrack problem, visualize the solution, then obtain the
        solution.
        """
        return _moco.MocoTrack_solveAndVisualize(self)
    __swig_destroy__ = _moco.delete_MocoTrack

# Register MocoTrack in _moco:
_moco.MocoTrack_swigregister(MocoTrack)

def MocoTrack_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MocoTrack *":
    return _moco.MocoTrack_safeDownCast(obj)

def MocoTrack_getClassName() -> "std::string const &":
    return _moco.MocoTrack_getClassName()


def prescribeControlsToModel(*args) -> "void":
    r"""
    Given a MocoTrajectory and the associated OpenSim model, return the model
    with a prescribed controller appended that will compute the control values
    from the MocoTrajectory. This can be useful when computing state-dependent
    model quantities that require realization to the Dynamics stage or later.
    The function used to fit the controls can either be GCVSpline or
    PiecewiseLinearFunction.
    """
    return _moco.prescribeControlsToModel(*args)

def simulateTrajectoryWithTimeStepping(*args) -> "OpenSim::MocoTrajectory":
    r"""
    Use the controls and initial state in the provided trajectory to simulate
    the model using an ODE time stepping integrator (OpenSim::Manager), and
    return the resulting states and controls. We return a MocoTrajectory (rather
    than a StatesTrajectory) to facilitate comparing optimal control solutions
    with time stepping. Use integratorAccuracy to override the default setting.

    Notes: This function expects all Actuator%s in the model to be in the Model's
    ForceSet.
    """
    return _moco.simulateTrajectoryWithTimeStepping(*args)

def createPeriodicTrajectory(*args) -> "OpenSim::MocoTrajectory":
    r"""
    Convert a trajectory covering half the period of a symmetric motion into a
    trajectory over the full period. This is useful for simulations of half a
    gait cycle.
    This converts time, states, controls, and derivatives; all other quantities
    from the input trajectory are ignored.
    If a column in the trajectory does not match addPatterns, negatePatterns,
    negateAndShiftPatterns, or symmetryPatterns, then the second half of the
    period contains the same data as the first half.

    :type halfPeriodTrajectory: :py:class:`MocoTrajectory`
    :param halfPeriodTrajectory: The input trajectory covering half a period.
    :type addPatterns: std::vector< std::string,std::allocator< std::string > >, optional
    :param addPatterns: If a column label matches an addPattern, then the second
        half of the period for that column is (first_half_trajectory +
        half_period_value - initial_value).
    :type negatePatterns: std::vector< std::string,std::allocator< std::string > >, optional
    :param negatePatterns: If a column label matches a negatePattern, then the
        second half of the period for that column is (-first_half_trajectory).
        This is usually relevant for only 3D models.
    :type negateAndShiftPatterns: std::vector< std::string,std::allocator< std::string > >, optional
    :param negateAndShiftPatterns: If a column label matches a
        negateAndShiftPattern, then the second half of the period for that column is
        (-first_half_trajectory + 2 * half_period_value). This is usually relevant
        for only 3D models.
    :type symmetryPatterns: std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >, optional
    :param symmetryPatterns: This argument is a list of pairs, where the first
        element of the pair is a pattern to match, and the second is a substitution
        to convert the column label into the opposite column label of the symmetric
        pair. If a column label matches a symmetryPattern, then its first
        half-period is copied into the second half of the period for the column
        identified by the substitution.

    The default values for the patterns are intended to handle the column labels
    for typical 2D or 3D OpenSim gait models.
    The default values for negatePatterns, negateAndShiftPatterns, and
    symmetryPatterns warrant an explanation. The string pattern before the
    regex "(?!/value)" is followed by
    anything except "/value" since it is contained in the negative lookahead
    "(?!...)".  R"()" is a string literal that permits us to not escape
    backslash characters. The regex "_r(\/|_|$)" matches "_r" followed by either
    a forward slash (which is escaped), an underscore, OR the end of the string
    ($). Since the forward slash and end of the string are within parentheses,
    whatever matches this is captured and is available in the substitution (the
    second element of the pair) as $1. The default symmetry patterns cause the
    following replacements:
    - "/jointset/hip_r/hip_flexion_r/value" becomes "/jointset/hip_l/hip_flexion_l/value"
    - "/forceset/soleus_r" becomes "/forceset/soleus_l"
    """
    return _moco.createPeriodicTrajectory(*args)

def getMocoParallelEnvironmentVariable() -> "int":
    r"""
    This obtains the value of the OPENSIM_MOCO_PARALLEL environment variable.
    The value has the following meanings:
    - 0: run in series (not parallel).
    - 1: run in parallel using all cores.
    - greater than 1: run in parallel with this number of parallel jobs.
    If the environment variable is not set, this function returns -1.

    This variable does not indicate which calculations are parallelized
    or how the parallelization is achieved. Moco may even ignore or override
    the setting from the environment variable. See documentation elsewhere
    (e.g., from a specific MocoSolver) for more information.
    """
    return _moco.getMocoParallelEnvironmentVariable()
class FileDeletionThrowerException(opensim.common.OpenSimException):
    r""" Thrown by FileDeletionThrower::throwIfDeleted()."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", deletedFile: "std::string const &"):
        _moco.FileDeletionThrowerException_swiginit(self, _moco.new_FileDeletionThrowerException(file, line, func, deletedFile))
    __swig_destroy__ = _moco.delete_FileDeletionThrowerException

# Register FileDeletionThrowerException in _moco:
_moco.FileDeletionThrowerException_swigregister(FileDeletionThrowerException)

class FileDeletionThrower(object):
    r"""
    This class helps a user cause an exception within the code. The constructor
    writes a file, and the destructor deletes the file. The programmer can call
    throwIfDeleted() to throw the FileDeletionThrowerException exception if the
    file is deleted (by a user) before the object is destructed. If the file
    could not be written by the constructor, then throwIfDeleted() does not
    throw an exception.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _moco.FileDeletionThrower_swiginit(self, _moco.new_FileDeletionThrower(*args))
    __swig_destroy__ = _moco.delete_FileDeletionThrower

    def throwIfDeleted(self) -> "void":
        return _moco.FileDeletionThrower_throwIfDeleted(self)

# Register FileDeletionThrower in _moco:
_moco.FileDeletionThrower_swigregister(FileDeletionThrower)


def createExternalLoadsTableForGait(*args) -> "OpenSim::TimeSeriesTable":
    r"""
    *Overload 1:*
    Obtain the ground reaction forces, centers of pressure, and torques
    resulting from Force elements (e.g., SmoothSphereHalfSpaceForce), using a
    model and states trajectory. Forces and torques are expressed in the ground
    frame with respect to the ground origin. Hence, the centers of pressure are
    at the origin. Paths to Force elements should be provided separately for
    elements of the right and left feet. The output is a table formatted for use
    with OpenSim tools; the labels of the columns distinguish between right
    ("<>_r") and left ("<>_l") forces, centers of pressure, and torques. The
    forces and torques used are taken from the first six outputs of
    getRecordValues(); this order is of use for, for example, the
    SmoothSphereHalfSpaceForce contact model but might have a different meaning
    for different contact models.


    |

    *Overload 2:*
    Same as above, but with a MocoTrajectory instead of a StatesTrajectory.
    """
    return _moco.createExternalLoadsTableForGait(*args)

def analyzeMocoTrajectory(model: "Model", trajectory: "MocoTrajectory", outputPaths: "StdVectorString") -> "OpenSim::TimeSeriesTable_< double >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided StatesTrajectory and controls table.
    The controls table is used to set the model's controls vector.
    We assume the StatesTrajectory and controls table contain the same time
    points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.

    Parameters and Lagrange multipliers in the MocoTrajectory are **not**
          applied to the model.
    """
    return _moco.analyzeMocoTrajectory(model, trajectory, outputPaths)

def analyzeMocoTrajectoryVec3(model: "Model", trajectory: "MocoTrajectory", outputPaths: "StdVectorString") -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided StatesTrajectory and controls table.
    The controls table is used to set the model's controls vector.
    We assume the StatesTrajectory and controls table contain the same time
    points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.

    Parameters and Lagrange multipliers in the MocoTrajectory are **not**
          applied to the model.
    """
    return _moco.analyzeMocoTrajectoryVec3(model, trajectory, outputPaths)

def analyzeMocoTrajectorySpatialVec(model: "Model", trajectory: "MocoTrajectory", outputPaths: "StdVectorString") -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec3,1 > >":
    r"""
    Calculate the requested outputs using the model in the problem and the
    provided StatesTrajectory and controls table.
    The controls table is used to set the model's controls vector.
    We assume the StatesTrajectory and controls table contain the same time
    points.
    The output paths can be regular expressions. For example,
    ".*activation" gives the activation of all muscles.

    The output paths must correspond to outputs that match the type provided in
    the template argument, otherwise they are not included in the report.

    Notes: The provided trajectory is not modified to satisfy kinematic
    constraints, but SimTK::Motions in the Model (e.g., PositionMotion) are
    applied. Therefore, this function expects that you've provided a trajectory
    that already satisfies kinematic constraints. If your provided trajectory
    does not satisfy kinematic constraints, many outputs will be incorrect.
    For example, in a model with a patella whose location is determined by a
    CoordinateCouplerConstraint, the length of a muscle that crosses the patella
    will be incorrect.

    Parameters and Lagrange multipliers in the MocoTrajectory are **not**
          applied to the model.
    """
    return _moco.analyzeMocoTrajectorySpatialVec(model, trajectory, outputPaths)
class ModOpReplaceMusclesWithDeGrooteFregly2016(opensim.actuators.ModelOperator):
    r""" Invoke DeGrooteFregly2016Muscle::replaceMuscles() on the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpReplaceMusclesWithDeGrooteFregly2016 *":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_getClassName()

    def clone(self) -> "OpenSim::ModOpReplaceMusclesWithDeGrooteFregly2016 *":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_operate(self, model, arg3)

    def __init__(self):
        _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_swiginit(self, _moco.new_ModOpReplaceMusclesWithDeGrooteFregly2016())
    __swig_destroy__ = _moco.delete_ModOpReplaceMusclesWithDeGrooteFregly2016

# Register ModOpReplaceMusclesWithDeGrooteFregly2016 in _moco:
_moco.ModOpReplaceMusclesWithDeGrooteFregly2016_swigregister(ModOpReplaceMusclesWithDeGrooteFregly2016)

def ModOpReplaceMusclesWithDeGrooteFregly2016_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpReplaceMusclesWithDeGrooteFregly2016 *":
    return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_safeDownCast(obj)

def ModOpReplaceMusclesWithDeGrooteFregly2016_getClassName() -> "std::string const &":
    return _moco.ModOpReplaceMusclesWithDeGrooteFregly2016_getClassName()

class ModOpTendonComplianceDynamicsModeDGF(opensim.actuators.ModelOperator):
    r"""
     For DeGrooteFregly2016Muscle muscles whose 'ignore_tendon_compliance'
    property is false, set the tendon compliance dynamics mode to either
    'explicit' or 'implicit'.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpTendonComplianceDynamicsModeDGF *":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpTendonComplianceDynamicsModeDGF *":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.ModOpTendonComplianceDynamicsModeDGF_swiginit(self, _moco.new_ModOpTendonComplianceDynamicsModeDGF(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpTendonComplianceDynamicsModeDGF_operate(self, model, arg3)
    __swig_destroy__ = _moco.delete_ModOpTendonComplianceDynamicsModeDGF

# Register ModOpTendonComplianceDynamicsModeDGF in _moco:
_moco.ModOpTendonComplianceDynamicsModeDGF_swigregister(ModOpTendonComplianceDynamicsModeDGF)

def ModOpTendonComplianceDynamicsModeDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpTendonComplianceDynamicsModeDGF *":
    return _moco.ModOpTendonComplianceDynamicsModeDGF_safeDownCast(obj)

def ModOpTendonComplianceDynamicsModeDGF_getClassName() -> "std::string const &":
    return _moco.ModOpTendonComplianceDynamicsModeDGF_getClassName()

class ModOpUseImplicitTendonComplianceDynamicsDGF(opensim.actuators.ModelOperator):
    r"""
     Set the tendon compliance dynamics mode to "implicit" for all
    DeGrooteFregly2016Muscle%s in the model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpUseImplicitTendonComplianceDynamicsDGF *":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpUseImplicitTendonComplianceDynamicsDGF *":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_operate(self, model, arg3)

    def __init__(self):
        _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_swiginit(self, _moco.new_ModOpUseImplicitTendonComplianceDynamicsDGF())
    __swig_destroy__ = _moco.delete_ModOpUseImplicitTendonComplianceDynamicsDGF

# Register ModOpUseImplicitTendonComplianceDynamicsDGF in _moco:
_moco.ModOpUseImplicitTendonComplianceDynamicsDGF_swigregister(ModOpUseImplicitTendonComplianceDynamicsDGF)

def ModOpUseImplicitTendonComplianceDynamicsDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpUseImplicitTendonComplianceDynamicsDGF *":
    return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_safeDownCast(obj)

def ModOpUseImplicitTendonComplianceDynamicsDGF_getClassName() -> "std::string const &":
    return _moco.ModOpUseImplicitTendonComplianceDynamicsDGF_getClassName()

class ModOpIgnorePassiveFiberForcesDGF(opensim.actuators.ModelOperator):
    r"""
     Turn off passive fiber forces for all DeGrooteFregly2016Muscle%s in the
    model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnorePassiveFiberForcesDGF *":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpIgnorePassiveFiberForcesDGF *":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpIgnorePassiveFiberForcesDGF_operate(self, model, arg3)

    def __init__(self):
        _moco.ModOpIgnorePassiveFiberForcesDGF_swiginit(self, _moco.new_ModOpIgnorePassiveFiberForcesDGF())
    __swig_destroy__ = _moco.delete_ModOpIgnorePassiveFiberForcesDGF

# Register ModOpIgnorePassiveFiberForcesDGF in _moco:
_moco.ModOpIgnorePassiveFiberForcesDGF_swigregister(ModOpIgnorePassiveFiberForcesDGF)

def ModOpIgnorePassiveFiberForcesDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnorePassiveFiberForcesDGF *":
    return _moco.ModOpIgnorePassiveFiberForcesDGF_safeDownCast(obj)

def ModOpIgnorePassiveFiberForcesDGF_getClassName() -> "std::string const &":
    return _moco.ModOpIgnorePassiveFiberForcesDGF_getClassName()

class ModOpPassiveFiberStrainAtOneNormForceDGF(opensim.actuators.ModelOperator):
    r"""
     Set passive fiber stiffness for all DeGrooteFregly2016Muscle%s in the
    model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpPassiveFiberStrainAtOneNormForceDGF *":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpPassiveFiberStrainAtOneNormForceDGF *":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_swiginit(self, _moco.new_ModOpPassiveFiberStrainAtOneNormForceDGF(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_operate(self, model, arg3)
    __swig_destroy__ = _moco.delete_ModOpPassiveFiberStrainAtOneNormForceDGF

# Register ModOpPassiveFiberStrainAtOneNormForceDGF in _moco:
_moco.ModOpPassiveFiberStrainAtOneNormForceDGF_swigregister(ModOpPassiveFiberStrainAtOneNormForceDGF)

def ModOpPassiveFiberStrainAtOneNormForceDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpPassiveFiberStrainAtOneNormForceDGF *":
    return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_safeDownCast(obj)

def ModOpPassiveFiberStrainAtOneNormForceDGF_getClassName() -> "std::string const &":
    return _moco.ModOpPassiveFiberStrainAtOneNormForceDGF_getClassName()

class ModOpScaleActiveFiberForceCurveWidthDGF(opensim.actuators.ModelOperator):
    r"""
     Scale the active fiber force curve width for all DeGrooteFregly2016Muscle%s
    in the model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpScaleActiveFiberForceCurveWidthDGF *":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpScaleActiveFiberForceCurveWidthDGF *":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.ModOpScaleActiveFiberForceCurveWidthDGF_swiginit(self, _moco.new_ModOpScaleActiveFiberForceCurveWidthDGF(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_operate(self, model, arg3)
    __swig_destroy__ = _moco.delete_ModOpScaleActiveFiberForceCurveWidthDGF

# Register ModOpScaleActiveFiberForceCurveWidthDGF in _moco:
_moco.ModOpScaleActiveFiberForceCurveWidthDGF_swigregister(ModOpScaleActiveFiberForceCurveWidthDGF)

def ModOpScaleActiveFiberForceCurveWidthDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpScaleActiveFiberForceCurveWidthDGF *":
    return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_safeDownCast(obj)

def ModOpScaleActiveFiberForceCurveWidthDGF_getClassName() -> "std::string const &":
    return _moco.ModOpScaleActiveFiberForceCurveWidthDGF_getClassName()

class ModOpFiberDampingDGF(opensim.actuators.ModelOperator):
    r""" Set the fiber damping for all DeGrooteFregly2016Muscle%s in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpFiberDampingDGF *":
        return _moco.ModOpFiberDampingDGF_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _moco.ModOpFiberDampingDGF_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _moco.ModOpFiberDampingDGF_getClassName()

    def clone(self) -> "OpenSim::ModOpFiberDampingDGF *":
        return _moco.ModOpFiberDampingDGF_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _moco.ModOpFiberDampingDGF_getConcreteClassName(self)

    def __init__(self, *args):
        _moco.ModOpFiberDampingDGF_swiginit(self, _moco.new_ModOpFiberDampingDGF(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _moco.ModOpFiberDampingDGF_operate(self, model, arg3)
    __swig_destroy__ = _moco.delete_ModOpFiberDampingDGF

# Register ModOpFiberDampingDGF in _moco:
_moco.ModOpFiberDampingDGF_swigregister(ModOpFiberDampingDGF)

def ModOpFiberDampingDGF_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpFiberDampingDGF *":
    return _moco.ModOpFiberDampingDGF_safeDownCast(obj)

def ModOpFiberDampingDGF_getClassName() -> "std::string const &":
    return _moco.ModOpFiberDampingDGF_getClassName()



