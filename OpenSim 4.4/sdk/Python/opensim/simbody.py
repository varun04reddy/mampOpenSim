# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _simbody
else:
    import _simbody

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _simbody.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _simbody.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _simbody.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _simbody.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _simbody.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _simbody.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _simbody.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _simbody.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _simbody.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _simbody.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _simbody.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _simbody.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _simbody.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _simbody.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _simbody.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _simbody.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _simbody.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _simbody:
_simbody.SwigPyIterator_swigregister(SwigPyIterator)

class StdVectorUnsigned(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorUnsigned_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorUnsigned___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorUnsigned___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _simbody.StdVectorUnsigned___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _simbody.StdVectorUnsigned___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorUnsigned___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _simbody.StdVectorUnsigned___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorUnsigned___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _simbody.StdVectorUnsigned___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorUnsigned___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _simbody.StdVectorUnsigned_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _simbody.StdVectorUnsigned_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorUnsigned_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _simbody.StdVectorUnsigned_size(self)

    def swap(self, v: "StdVectorUnsigned") -> "void":
        return _simbody.StdVectorUnsigned_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _simbody.StdVectorUnsigned_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _simbody.StdVectorUnsigned_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _simbody.StdVectorUnsigned_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _simbody.StdVectorUnsigned_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorUnsigned_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _simbody.StdVectorUnsigned_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorUnsigned_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _simbody.StdVectorUnsigned_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorUnsigned_swiginit(self, _simbody.new_StdVectorUnsigned(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _simbody.StdVectorUnsigned_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _simbody.StdVectorUnsigned_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _simbody.StdVectorUnsigned_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _simbody.StdVectorUnsigned_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorUnsigned_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorUnsigned_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _simbody.StdVectorUnsigned_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _simbody.StdVectorUnsigned_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorUnsigned

# Register StdVectorUnsigned in _simbody:
_simbody.StdVectorUnsigned_swigregister(StdVectorUnsigned)

class StdVectorInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorInt___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorInt___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _simbody.StdVectorInt___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _simbody.StdVectorInt___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorInt___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _simbody.StdVectorInt___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorInt___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _simbody.StdVectorInt___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorInt___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _simbody.StdVectorInt_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _simbody.StdVectorInt_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorInt_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _simbody.StdVectorInt_size(self)

    def swap(self, v: "StdVectorInt") -> "void":
        return _simbody.StdVectorInt_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _simbody.StdVectorInt_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _simbody.StdVectorInt_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _simbody.StdVectorInt_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _simbody.StdVectorInt_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorInt_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _simbody.StdVectorInt_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorInt_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _simbody.StdVectorInt_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorInt_swiginit(self, _simbody.new_StdVectorInt(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _simbody.StdVectorInt_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _simbody.StdVectorInt_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _simbody.StdVectorInt_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _simbody.StdVectorInt_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorInt_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorInt_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _simbody.StdVectorInt_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _simbody.StdVectorInt_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorInt

# Register StdVectorInt in _simbody:
_simbody.StdVectorInt_swigregister(StdVectorInt)

class StdVectorDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorDouble___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _simbody.StdVectorDouble___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _simbody.StdVectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _simbody.StdVectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _simbody.StdVectorDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorDouble___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _simbody.StdVectorDouble_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _simbody.StdVectorDouble_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorDouble_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _simbody.StdVectorDouble_size(self)

    def swap(self, v: "StdVectorDouble") -> "void":
        return _simbody.StdVectorDouble_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _simbody.StdVectorDouble_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _simbody.StdVectorDouble_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _simbody.StdVectorDouble_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _simbody.StdVectorDouble_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorDouble_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _simbody.StdVectorDouble_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorDouble_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _simbody.StdVectorDouble_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorDouble_swiginit(self, _simbody.new_StdVectorDouble(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _simbody.StdVectorDouble_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _simbody.StdVectorDouble_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _simbody.StdVectorDouble_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _simbody.StdVectorDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorDouble_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _simbody.StdVectorDouble_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _simbody.StdVectorDouble_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorDouble

# Register StdVectorDouble in _simbody:
_simbody.StdVectorDouble_swigregister(StdVectorDouble)

class StdVectorString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorString___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _simbody.StdVectorString___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _simbody.StdVectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorString___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _simbody.StdVectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _simbody.StdVectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorString___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _simbody.StdVectorString_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _simbody.StdVectorString_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorString_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _simbody.StdVectorString_size(self)

    def swap(self, v: "StdVectorString") -> "void":
        return _simbody.StdVectorString_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _simbody.StdVectorString_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _simbody.StdVectorString_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _simbody.StdVectorString_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _simbody.StdVectorString_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorString_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _simbody.StdVectorString_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorString_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _simbody.StdVectorString_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorString_swiginit(self, _simbody.new_StdVectorString(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _simbody.StdVectorString_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _simbody.StdVectorString_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _simbody.StdVectorString_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _simbody.StdVectorString_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorString_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorString_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _simbody.StdVectorString_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _simbody.StdVectorString_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorString

# Register StdVectorString in _simbody:
_simbody.StdVectorString_swigregister(StdVectorString)

SHARED_PTR_DISOWN = _simbody.SHARED_PTR_DISOWN
SimTK_PI = _simbody.SimTK_PI
r"""
    There are two kinds of numerical constants predefined by %SimTK: (1) a set
    of typed, const, in-memory values in the SimTK namespace, at the default Real
    precision or with other specific types, and (2) a set of preprocessor
    (#define) macros containing extremely high-precision precalculated numerical
    values in long double precision.

    You should use the typed constants whenever possible in your code since they
    are very compact and well-behaved in C++. They have memory addresses so can
    be returned as references. Because they are filled in at startup, they can
    include machine- and precision-specific values like NaN, Infinity, machine
    roundoff error, number of digits in a float, etc. that are very useful for
    writing robust, precision-independent numerical algorithms.

    The macro values must be cast to the appropriate type before use, and are
    mostly useful as raw material for making *typed* constants. These macros
    contain **machine-independent** constants, including unitless mathematical
    constants like pi, as well as physical constants and unit conversion factors.
    These constants are provided at extremely high precision as compile-time
    macros in long double precision. By using very high precision we ensure
    sufficient accuracy for any IEEE long double precision implementation (they
    can be 64, 80, or 128 bits). These constants can be used as raw material for
    providing nicer templatized constants in appropriate precisions and unit
    systems.

    ## Naming conventions
    Note that the %SimTK convention for typed constants is to name them
    like ordinary variables except with an initial capital letter (like a
    class name). This is distinct from the widely-used convention for
    constants that are defined via the presprocessor as macros (that is,
    using #define). Those are written entirely in
    ``UPPER_CASE_WITH_UNDERSCORES``, after an initial ``SimTK_``. Typed constants
    are processed instead by the compiler itself and do not require any
    special treatment when used; they behave just like variables of the
    same type and value would behave so there is no need to shout when
    using them. *


    These are preprocessor (#define) macros providing constants values at very
    high precision.\ See the discussion under the main 'PredefinedConstants'
    module heading.

    ## Units
    Our most common unit systems are the "SI" (MKS) system, and the "MD" system
    used for molecular dynamics. SI units are meters, kg, seconds, coulombs
    (ampere-s), kelvins and moles. MD units are nanometers, atomic mass units
    (Daltons, g/mol), picoseconds, proton charge e, kelvins, and moles. Many
    molecular dynamicists and chemists prefer kcals for energy and angstroms for
    length. This does not constitute a consistent set of units, however, so
    we provide for it by conversion from the MD units, which are consistent.
    (By consistent, we mean that force units = mass-length/time^2, so f=ma!)


    Unit systems

               SI (MKS)           MD                     KCAL-ANGSTROM
    ---------  --------------  ------------------------  ------------------
    length     meter           nanometer                 angstrom (A)
    mass       kg              amu, dalton               amu, dalton
    time       second          picosecond                picosecond
    charge     coulomb         e, proton charge          e, proton charge
    temp.      kelvin          kelvin                    kelvin
    substance  mole            mole                      mole

    velocity   m/s             km/s (nm/ps)              100m/s (A/ps)

    energy     J (kg-m^2/s^2)  kJ/mol                    kcal/mol
                                 (Da-nm^2/ps^2)            (418.4 Da-A^2/ps^2)
    force      N (kg-m/s^2)    kJ/(mol-nm) = TN/mol      kcal/(mol-A)
                                 (Da-nm/ps^2) (T=10^12)    (418.4 Da-A/ps^2)



    We always keep angles in radians internally, which are unitless. However,
    most humans prefer degrees where 1 degree = Pi/180 radians so we provide
    convenient conversions. ** The ratio pi of a circle's circumference to its diameter in Euclidean geometry.
    Title: uncertainty
         approximation of an exact value
    """
SimTK_E = _simbody.SimTK_E
r"""
     e, or exp(1).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_LN2 = _simbody.SimTK_LN2
r"""
     The natural (base e) logarithm of 2.
    Title: uncertainty
         approximation of an exact value
    See also: SimTK_E
    """
SimTK_LN10 = _simbody.SimTK_LN10
r"""
     The natural (base e) logarithm of 10.
    Title: uncertainty
         approximation of an exact value
    See also: SimTK_E
    """
SimTK_LOG2E = _simbody.SimTK_LOG2E
r"""
     log2(e).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_LOG10E = _simbody.SimTK_LOG10E
r"""
     log10(e).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_SQRT2 = _simbody.SimTK_SQRT2
r"""
     The square root of 2.
    Title: uncertainty
         approximation of an exact value
    """
SimTK_OOSQRT2 = _simbody.SimTK_OOSQRT2
r"""
     One over the square root of 2; also half the square root of 2 since
    1/sqrt(2) == 2^(-1/2) == sqrt(2)/2.
    Title: uncertainty
         approximation of an exact value
    """
SimTK_CBRT2 = _simbody.SimTK_CBRT2
r"""
     The cube root of 2, 2^(1/3).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_OOCBRT2 = _simbody.SimTK_OOCBRT2
r"""
     One over the cube root of 2, 2^(-1/3).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_SIXRT2 = _simbody.SimTK_SIXRT2
r"""
     The sixth root of 2, 2^(1/6).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_OOSIXRT2 = _simbody.SimTK_OOSIXRT2
r"""
     One over the sixth root of 2, 2^(-1/6).
    Title: uncertainty
         approximation of an exact value
    """
SimTK_SQRT3 = _simbody.SimTK_SQRT3
r"""
     The square root of 3.
    Title: uncertainty
         approximation of an exact value
    """
SimTK_CBRT3 = _simbody.SimTK_CBRT3
r"""
     The cube root of 3.
    Title: uncertainty
         approximation of an exact value
    """
SimTK_AVOGADROS_NUMBER = _simbody.SimTK_AVOGADROS_NUMBER
r"""
    **
    Avogadro's number (NA) is defined as the number of atoms in 12g of pure Carbon-12 in
    its unbound, rest state. The number is 1 mole (mol).
    Title: uncertainty
         10e16
    """
SimTK_MASS_OF_PROTON_IN_MD = _simbody.SimTK_MASS_OF_PROTON_IN_MD
r"""
    Mass of a proton in MD units.

    The atomic mass unit u (or amu) is defined as 1/12 of the mass of a Carbon-12 atom,
    unbound and in its rest state. This definition matched to Avogadro's number's definition
    ensures that 1 mole of particles of mass 1u each has total mass exactly 1g. This is
    synonymous with the dalton (Da), with units of g/mole, so 1u = 1Dalton = 1g/mole.
    We will use Da for this mass unit, with kDa being a common mass measure for
    large biomolecules.

    Title: uncertainty
         13e-11
    See also: SimTK_AVOGADROS_NUMBER
    """
SimTK_MASS_OF_NEUTRON_IN_MD = _simbody.SimTK_MASS_OF_NEUTRON_IN_MD
r"""
    Mass of a neutron in MD units.
    Title: uncertainty
         55e-11
    See also: SimTK_MASS_OF_PROTON_IN_MD
    """
SimTK_MASS_OF_ELECTRON_IN_MD = _simbody.SimTK_MASS_OF_ELECTRON_IN_MD
r"""
    Mass of an electron in MD units.
    Title: uncertainty
         24e-14
    See also: SimTK_MASS_OF_PROTON_IN_MD
    """
SimTK_CHARGE_OF_PROTON_IN_SI = _simbody.SimTK_CHARGE_OF_PROTON_IN_SI
r"""
    Atomic charge unit e expressed in MKS unit of Coulombs.
    The charge on an electron is just the negative of this value.
    Title: uncertainty
         14e-27
    """
SimTK_CHARGE_OF_PROTON_IN_MD = _simbody.SimTK_CHARGE_OF_PROTON_IN_MD
r"""
    Atomic charge unit e expressed in MD units, which uses e as its charge unit!
    The charge on an electron is just the negative of this value.
    Title: uncertainty
         exact (duh!)
    """
SimTK_MOLAR_CHARGE_IN_SI = _simbody.SimTK_MOLAR_CHARGE_IN_SI
r"""
    The charge of 1 mole of protons, expressed in Coulombs.

       1.60217653(14)e-19 C/e * 6.0221415(10)e23 = 9.6485338(18)e+4

    Title: uncertainty
         18e-3
    """
SimTK_MOLAR_CHARGE_IN_MD = _simbody.SimTK_MOLAR_CHARGE_IN_MD
r"""
    The charge of 1 mole of protons, expressed in MD units where the unit
    of charge is just the charge on one proton. So in MD units this is just
    Avogadro's number.
    See also: SimTK_AVOGADROS_NUMBER
    """
SimTK_LIGHTSPEED_IN_SI = _simbody.SimTK_LIGHTSPEED_IN_SI
r"""
    Speed of light c is exact in MKS units of m/s.
    Title: uncertainty
         exact
    See also: SimTK_LIGHTSPEED_IN_MD
    """
SimTK_LIGHTSPEED_IN_MD = _simbody.SimTK_LIGHTSPEED_IN_MD
r"""
    Speed of light c is exact in MD units of nm/ps.
    Title: uncertainty
         exact
    See also: SimTK_LIGHTSPEED_IN_SI
    """
SimTK_GRAVITATIONAL_CONSTANT_IN_SI = _simbody.SimTK_GRAVITATIONAL_CONSTANT_IN_SI
r"""
    Newton's gravitational constant G in N-m^2/kg^2 = m^3 kg^-1 s^-2.
    The force between two point masses m1,m2 separated by a distance d is
         F = -G m1*m2/d^2
    (with the "-" indicating an attractive force).
    Title: uncertainty
         10e-15
    See also: SimTK_GRAVITATIONAL_CONSTANT_IN_MD
    """
SimTK_GRAVITATIONAL_CONSTANT_IN_MD = _simbody.SimTK_GRAVITATIONAL_CONSTANT_IN_MD
r"""
    Newton's gravitational constant G in (kJ/mol)-nm^2/u^2 = nm^3 u^-1 ps^-2.

    Conversion is (nm/m)^3 (u/kg)^-1 (ps/s)^-2
             = 1.66053886(28)e-24L     (uncertainty: 28e-32)

    This is why gravity doesn't matter in molecular systems. Don't try
    this in single precision -- you'll run out of exponent!
    Title: uncertainty
         17e-39
    See also: SimTK_GRAVITATIONAL_CONSTANT_IN_SI
    """
SimTK_MAGNETIC_PERMEABILITY_IN_SI = _simbody.SimTK_MAGNETIC_PERMEABILITY_IN_SI
r"""
    Free space magnetic permeability constant mu0 in SI units (exact).

      = 4*pi * 1e-7 exactly in N/A^2 (Newtons/Ampere^2) = kg-m/C^2

    Title: uncertainty
         approximation of an exact quantity
    See also: SimTK_ELECTRIC_PERMITTIVITY_IN_SI
    """
SimTK_MAGNETIC_PERMEABILITY_IN_MD = _simbody.SimTK_MAGNETIC_PERMEABILITY_IN_MD
r"""
    Free space magnetic permeability constant mu0 in MD units (not exact).

    Convert kg->g/mole, m->nm, C->e = (4*pi*1e5)*1.60217653e-19^2*6.0221415e23
         (exact in SI units, but not exact here)

    Title: uncertainty
         47e-16
    See also: SimTK_ELECTRIC_PERMITTIVITY_IN_MD
    """
SimTK_ELECTRIC_PERMITTIVITY_IN_SI = _simbody.SimTK_ELECTRIC_PERMITTIVITY_IN_SI
r"""
    Free space permittivity constant e0 = 1/(mu0*c^2) Farad/m = Coulomb^2/(N-m^2) (exact in SI units).
    Title: uncertainty
         approximation of an exact quantity
    See also: SimTK_MAGNETIC_PERMEABILITY_IN_SI
    """
SimTK_ELECTRIC_PERMITTIVITY_IN_MD = _simbody.SimTK_ELECTRIC_PERMITTIVITY_IN_MD
r"""
    Free space permittivity constant e0=1/(mu0*c^2) e^2/(kN-nm^2) using MD permeability and
    MD lightspeed.
    Title: uncertainty
         14e-11
    See also: SimTK_MAGNETIC_PERMEABILITY_IN_MD
    """
SimTK_COULOMB_CONSTANT_IN_SI = _simbody.SimTK_COULOMB_CONSTANT_IN_SI
r"""
    Coulomb's constant kappa = 1/(4pi*e0)=1e-7*c^2 N-m^2/Coulomb^2 (exact in SI units).
    This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.
    Title: uncertainty
         exact
    """
SimTK_COULOMB_CONSTANT_IN_MD = _simbody.SimTK_COULOMB_CONSTANT_IN_MD
r"""
    Coulomb's constant kappa = 1/(4*pi*e0) in MD units.
    This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.

    Coulomb's consant in MD units uses MD e0 & c:
      1/(4*pi*e0)=1e5*1.60217653e-19^2*6.0221415e23*c^2 kN-nm^2/e^2 (=kJ-nm/e^2)
        (exact in SI units but not exact in MD)

    Title: uncertainty
         33e-6
    """
SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM = _simbody.SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM
r"""
    Coulomb's constant kappa = 1/(4*pi*e0) in kcal-Angstroms/e^2.
    This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.
    This is an exact conversion from MD units (which are inexact).
    Title: uncertainty
         80e-6
    """
SimTK_MOLAR_GAS_CONSTANT_SI = _simbody.SimTK_MOLAR_GAS_CONSTANT_SI
r"""
    This is the gas constant R in (J/mol)/K.
    Title: uncertainty
         15e-6
    """
SimTK_MOLAR_GAS_CONSTANT_MD = _simbody.SimTK_MOLAR_GAS_CONSTANT_MD
r"""
    This is the gas constant R in (kJ/mol)/K.
    This is an exact conversion from SI units, differing only in the use of kJ
    here vs. J in SI.
    Title: uncertainty
         15e-9
    """
SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM = _simbody.SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM
r"""
    This is the gas constant R in (kcal/mol)/K.
    This is an exact conversion from MD units, differing only in the use of kcal
    here vs. kJ in MD.
    Title: uncertainty
         36e-10
    """
SimTK_BOLTZMANN_CONSTANT_SI = _simbody.SimTK_BOLTZMANN_CONSTANT_SI
r"""
    Boltzmann's constant in SI units of joules/kelvin; just divide R by NA.
    Title: uncertainty
         24e-30
    """
SimTK_BOLTZMANN_CONSTANT_MD = _simbody.SimTK_BOLTZMANN_CONSTANT_MD
r"""
    Boltzmann's constant in MD units of (kJ/mol)/kelvin; same as R.
    See also: SimTK_MOLAR_GAS_CONSTANT_MD
    """
SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM = _simbody.SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM
r"""
    Boltzmann's constant in Kcal-Angstrom units of (kcal/mol)/kelvin; same as R.
    See also: SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM
    """
SimTK_RADIAN_TO_DEGREE = _simbody.SimTK_RADIAN_TO_DEGREE
r"""
    **
    Convert radians to degrees.
    Title: uncertainty
          approximation of an exact quantity
    See also: SimTK_DEGREE_TO_RADIAN
    """
SimTK_DEGREE_TO_RADIAN = _simbody.SimTK_DEGREE_TO_RADIAN
r"""
    Convert degrees to radians.
    Title: uncertainty
          approximation of an exact quantity
    See also: SimTK_RADIAN_TO_DEGREE
    """
SimTK_NS_TO_S = _simbody.SimTK_NS_TO_S
r"""
    Convert nanoseconds to seconds.
    Title: uncertainty
             exact
    See also: SimTK_S_TO_NS
    """
SimTK_S_TO_NS = _simbody.SimTK_S_TO_NS
r"""
    Convert seconds to nanoseconds.
    Title: uncertainty
             exact
    See also: SimTK_NS_TO_S
    """
SimTK_KCAL_TO_KJOULE = _simbody.SimTK_KCAL_TO_KJOULE
r"""
    Convert Kcal to Kjoule (also Kcal/mol to Kjoule/mol).
    Title: uncertainty
            exact
    See also: SimTK_KJOULE_TO_KCAL
    """
SimTK_KJOULE_TO_KCAL = _simbody.SimTK_KJOULE_TO_KCAL
r"""
    Convert Kjoule to Kcal (also Kjoule/mol to Kcal/mol).
    Title: uncertainty
            approximation of an exact quantity
    See also: SimTK_KCAL_TO_KJOULE
    """
SimTK_DALTON_TO_GRAM = _simbody.SimTK_DALTON_TO_GRAM
r"""
    Convert atomic mass unit (amu, Dalton) to g. This is 1/NA (NA=avogadro's number).
    Title: uncertainty
            28e-32
    See also: SimTK_AVOGADROS_NUMBER
    """
SimTK_E_TO_COULOMB = _simbody.SimTK_E_TO_COULOMB
r"""
    Convert proton charge units to Coulombs. This is the same as the
    conversion from electron volts to Joules, and both are just the
    charge of a proton in SI units.
    See also: SimTK_CHARGE_OF_PROTON_IN_SI
    See also: SimTK_EV_TO_JOULE
    """
SimTK_EV_TO_JOULE = _simbody.SimTK_EV_TO_JOULE
r"""
    Convert electron volts to Joules. This is the same as the
    conversion from proton charge units to Coulombs, and both are just the
    charge of a proton in SI units.
    See also: SimTK_CHARGE_OF_PROTON_IN_SI
    See also: SimTK_E_TO_COULOMB
    """
class Vec2(object):
    r"""
     This is a fixed length column vector designed for no-overhead inline
    computation.

    :param M:       The number of rows in the vector.
    :param ELT:     The element type. Must be a composite numerical type (CNT).
                            The default is ELT=Real.
    :param STRIDE:  The spacing from one element to the next in memory, as an
                            integer number of elements of type ELT. The default is
                            STRIDE=1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r"""
        The number of elements in this Vec (note that stride does not
           affect this number.) *
        """
        return _simbody.Vec2_size()

    @staticmethod
    def nrow() -> "int":
        r""" The number of rows in a Vec is the number of elements. *"""
        return _simbody.Vec2_nrow()

    @staticmethod
    def ncol() -> "int":
        r""" The number of columns in a Vec is always 1. *"""
        return _simbody.Vec2_ncol()

    def __init__(self, *args):
        _simbody.Vec2_swiginit(self, _simbody.new_Vec2(*args))

    def setToNaN(self) -> "void":
        r"""
        Set every scalar in this %Vec to NaN; this is the default initial
           value in Debug builds, but not in Release. *
        """
        return _simbody.Vec2_setToNaN(self)

    def setToZero(self) -> "void":
        r""" Set every scalar in this %Vec to zero. *"""
        return _simbody.Vec2_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Vec contains a NaN anywhere. *"""
        return _simbody.Vec2_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Vec contains a +Infinity
           or -Infinity somewhere but no element contains a NaN anywhere. *
        """
        return _simbody.Vec2_isInf(self)

    def isFinite(self) -> "bool":
        r"""
        Return true if no element of this %Vec contains an Infinity or a NaN
           anywhere. *
        """
        return _simbody.Vec2_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a vector is
           the same as its elements' default tolerance. *
        """
        return _simbody.Vec2_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether every element of this vector is numerically equal to the given
           element, using either a specified tolerance or the vector's
           default tolerance (which is always the same or looser than the default
           tolerance for one of its elements). *
        """
        return _simbody.Vec2_isNumericallyEqual(self, *args)

    def toString(self) -> "std::string":
        r""" Print Vec into a string and return it.  Please refer to operator<< for details. *"""
        return _simbody.Vec2_toString(self)

    def set(self, i: "int", value: "SimTK::Vec< 2 >::E const &") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.Vec2_set(self, i, value)

    def get(self, i: "int") -> "SimTK::Vec< 2 >::E const &":
        r""" Variant of operator[] that's scripting friendly to get const reference to ith entry *"""
        return _simbody.Vec2_get(self, i)

    def __str__(self) -> "std::string":
        return _simbody.Vec2___str__(self)

    def __len__(self) -> "int":
        return _simbody.Vec2___len__(self)

    def scalarEq(self, ee: "double const &") -> "SimTK::Vec< 2 > &":
        return _simbody.Vec2_scalarEq(self, ee)

    def scalarPlusEq(self, ee: "double const &") -> "SimTK::Vec< 2 > &":
        return _simbody.Vec2_scalarPlusEq(self, ee)

    def scalarMinusEq(self, ee: "double const &") -> "SimTK::Vec< 2 > &":
        return _simbody.Vec2_scalarMinusEq(self, ee)

    def scalarTimesEq(self, ee: "double const &") -> "SimTK::Vec< 2 > &":
        return _simbody.Vec2_scalarTimesEq(self, ee)

    def scalarDivideEq(self, ee: "double const &") -> "SimTK::Vec< 2 > &":
        return _simbody.Vec2_scalarDivideEq(self, ee)
    __swig_destroy__ = _simbody.delete_Vec2

# Register Vec2 in _simbody:
_simbody.Vec2_swigregister(Vec2)

def Vec2_size() -> "int":
    r"""
    The number of elements in this Vec (note that stride does not
       affect this number.) *
    """
    return _simbody.Vec2_size()

def Vec2_nrow() -> "int":
    r""" The number of rows in a Vec is the number of elements. *"""
    return _simbody.Vec2_nrow()

def Vec2_ncol() -> "int":
    r""" The number of columns in a Vec is always 1. *"""
    return _simbody.Vec2_ncol()

def Vec2_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a vector is
       the same as its elements' default tolerance. *
    """
    return _simbody.Vec2_getDefaultTolerance()

class Vec3(object):
    r"""
     This is a fixed length column vector designed for no-overhead inline
    computation.

    :param M:       The number of rows in the vector.
    :param ELT:     The element type. Must be a composite numerical type (CNT).
                            The default is ELT=Real.
    :param STRIDE:  The spacing from one element to the next in memory, as an
                            integer number of elements of type ELT. The default is
                            STRIDE=1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r"""
        The number of elements in this Vec (note that stride does not
           affect this number.) *
        """
        return _simbody.Vec3_size()

    @staticmethod
    def nrow() -> "int":
        r""" The number of rows in a Vec is the number of elements. *"""
        return _simbody.Vec3_nrow()

    @staticmethod
    def ncol() -> "int":
        r""" The number of columns in a Vec is always 1. *"""
        return _simbody.Vec3_ncol()

    def setToNaN(self) -> "void":
        r"""
        Set every scalar in this %Vec to NaN; this is the default initial
           value in Debug builds, but not in Release. *
        """
        return _simbody.Vec3_setToNaN(self)

    def setToZero(self) -> "void":
        r""" Set every scalar in this %Vec to zero. *"""
        return _simbody.Vec3_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Vec contains a NaN anywhere. *"""
        return _simbody.Vec3_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Vec contains a +Infinity
           or -Infinity somewhere but no element contains a NaN anywhere. *
        """
        return _simbody.Vec3_isInf(self)

    def isFinite(self) -> "bool":
        r"""
        Return true if no element of this %Vec contains an Infinity or a NaN
           anywhere. *
        """
        return _simbody.Vec3_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a vector is
           the same as its elements' default tolerance. *
        """
        return _simbody.Vec3_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether every element of this vector is numerically equal to the given
           element, using either a specified tolerance or the vector's
           default tolerance (which is always the same or looser than the default
           tolerance for one of its elements). *
        """
        return _simbody.Vec3_isNumericallyEqual(self, *args)

    def toString(self) -> "std::string":
        r""" Print Vec into a string and return it.  Please refer to operator<< for details. *"""
        return _simbody.Vec3_toString(self)

    def set(self, i: "int", value: "SimTK::Vec< 3 >::E const &") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.Vec3_set(self, i, value)

    def get(self, i: "int") -> "SimTK::Vec< 3 >::E const &":
        r""" Variant of operator[] that's scripting friendly to get const reference to ith entry *"""
        return _simbody.Vec3_get(self, i)

    def __str__(self) -> "std::string":
        return _simbody.Vec3___str__(self)

    def __len__(self) -> "int":
        return _simbody.Vec3___len__(self)

    def scalarEq(self, ee: "double const &") -> "SimTK::Vec< 3 > &":
        return _simbody.Vec3_scalarEq(self, ee)

    def scalarPlusEq(self, ee: "double const &") -> "SimTK::Vec< 3 > &":
        return _simbody.Vec3_scalarPlusEq(self, ee)

    def scalarMinusEq(self, ee: "double const &") -> "SimTK::Vec< 3 > &":
        return _simbody.Vec3_scalarMinusEq(self, ee)

    def scalarTimesEq(self, ee: "double const &") -> "SimTK::Vec< 3 > &":
        return _simbody.Vec3_scalarTimesEq(self, ee)

    def scalarDivideEq(self, ee: "double const &") -> "SimTK::Vec< 3 > &":
        return _simbody.Vec3_scalarDivideEq(self, ee)

    def __init__(self, *args):
        _simbody.Vec3_swiginit(self, _simbody.new_Vec3(*args))

    @staticmethod
    def createFromMat(n: "int") -> "SimTK::Vec< 3 >":
        return _simbody.Vec3_createFromMat(n)

    def __getitem__(self, i: "int") -> "double":
        return _simbody.Vec3___getitem__(self, i)

    def __setitem__(self, i: "int", value: "double") -> "void":
        return _simbody.Vec3___setitem__(self, i, value)

    def _to_numpy(self, n: "int") -> "void":
        return _simbody.Vec3__to_numpy(self, n)

    def to_numpy(self):
        return self._to_numpy(self.size())

    __swig_destroy__ = _simbody.delete_Vec3

# Register Vec3 in _simbody:
_simbody.Vec3_swigregister(Vec3)

def Vec3_size() -> "int":
    r"""
    The number of elements in this Vec (note that stride does not
       affect this number.) *
    """
    return _simbody.Vec3_size()

def Vec3_nrow() -> "int":
    r""" The number of rows in a Vec is the number of elements. *"""
    return _simbody.Vec3_nrow()

def Vec3_ncol() -> "int":
    r""" The number of columns in a Vec is always 1. *"""
    return _simbody.Vec3_ncol()

def Vec3_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a vector is
       the same as its elements' default tolerance. *
    """
    return _simbody.Vec3_getDefaultTolerance()

def Vec3_createFromMat(n: "int") -> "SimTK::Vec< 3 >":
    return _simbody.Vec3_createFromMat(n)

class Vec4(object):
    r"""
     This is a fixed length column vector designed for no-overhead inline
    computation.

    :param M:       The number of rows in the vector.
    :param ELT:     The element type. Must be a composite numerical type (CNT).
                            The default is ELT=Real.
    :param STRIDE:  The spacing from one element to the next in memory, as an
                            integer number of elements of type ELT. The default is
                            STRIDE=1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r"""
        The number of elements in this Vec (note that stride does not
           affect this number.) *
        """
        return _simbody.Vec4_size()

    @staticmethod
    def nrow() -> "int":
        r""" The number of rows in a Vec is the number of elements. *"""
        return _simbody.Vec4_nrow()

    @staticmethod
    def ncol() -> "int":
        r""" The number of columns in a Vec is always 1. *"""
        return _simbody.Vec4_ncol()

    def __init__(self, *args):
        _simbody.Vec4_swiginit(self, _simbody.new_Vec4(*args))

    def setToNaN(self) -> "void":
        r"""
        Set every scalar in this %Vec to NaN; this is the default initial
           value in Debug builds, but not in Release. *
        """
        return _simbody.Vec4_setToNaN(self)

    def setToZero(self) -> "void":
        r""" Set every scalar in this %Vec to zero. *"""
        return _simbody.Vec4_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Vec contains a NaN anywhere. *"""
        return _simbody.Vec4_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Vec contains a +Infinity
           or -Infinity somewhere but no element contains a NaN anywhere. *
        """
        return _simbody.Vec4_isInf(self)

    def isFinite(self) -> "bool":
        r"""
        Return true if no element of this %Vec contains an Infinity or a NaN
           anywhere. *
        """
        return _simbody.Vec4_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a vector is
           the same as its elements' default tolerance. *
        """
        return _simbody.Vec4_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether every element of this vector is numerically equal to the given
           element, using either a specified tolerance or the vector's
           default tolerance (which is always the same or looser than the default
           tolerance for one of its elements). *
        """
        return _simbody.Vec4_isNumericallyEqual(self, *args)

    def toString(self) -> "std::string":
        r""" Print Vec into a string and return it.  Please refer to operator<< for details. *"""
        return _simbody.Vec4_toString(self)

    def set(self, i: "int", value: "SimTK::Vec< 4 >::E const &") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.Vec4_set(self, i, value)

    def get(self, i: "int") -> "SimTK::Vec< 4 >::E const &":
        r""" Variant of operator[] that's scripting friendly to get const reference to ith entry *"""
        return _simbody.Vec4_get(self, i)

    def __str__(self) -> "std::string":
        return _simbody.Vec4___str__(self)

    def __len__(self) -> "int":
        return _simbody.Vec4___len__(self)

    def scalarEq(self, ee: "double const &") -> "SimTK::Vec< 4 > &":
        return _simbody.Vec4_scalarEq(self, ee)

    def scalarPlusEq(self, ee: "double const &") -> "SimTK::Vec< 4 > &":
        return _simbody.Vec4_scalarPlusEq(self, ee)

    def scalarMinusEq(self, ee: "double const &") -> "SimTK::Vec< 4 > &":
        return _simbody.Vec4_scalarMinusEq(self, ee)

    def scalarTimesEq(self, ee: "double const &") -> "SimTK::Vec< 4 > &":
        return _simbody.Vec4_scalarTimesEq(self, ee)

    def scalarDivideEq(self, ee: "double const &") -> "SimTK::Vec< 4 > &":
        return _simbody.Vec4_scalarDivideEq(self, ee)
    __swig_destroy__ = _simbody.delete_Vec4

# Register Vec4 in _simbody:
_simbody.Vec4_swigregister(Vec4)

def Vec4_size() -> "int":
    r"""
    The number of elements in this Vec (note that stride does not
       affect this number.) *
    """
    return _simbody.Vec4_size()

def Vec4_nrow() -> "int":
    r""" The number of rows in a Vec is the number of elements. *"""
    return _simbody.Vec4_nrow()

def Vec4_ncol() -> "int":
    r""" The number of columns in a Vec is always 1. *"""
    return _simbody.Vec4_ncol()

def Vec4_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a vector is
       the same as its elements' default tolerance. *
    """
    return _simbody.Vec4_getDefaultTolerance()

class Vec6(object):
    r"""
     This is a fixed length column vector designed for no-overhead inline
    computation.

    :param M:       The number of rows in the vector.
    :param ELT:     The element type. Must be a composite numerical type (CNT).
                            The default is ELT=Real.
    :param STRIDE:  The spacing from one element to the next in memory, as an
                            integer number of elements of type ELT. The default is
                            STRIDE=1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r"""
        The number of elements in this Vec (note that stride does not
           affect this number.) *
        """
        return _simbody.Vec6_size()

    @staticmethod
    def nrow() -> "int":
        r""" The number of rows in a Vec is the number of elements. *"""
        return _simbody.Vec6_nrow()

    @staticmethod
    def ncol() -> "int":
        r""" The number of columns in a Vec is always 1. *"""
        return _simbody.Vec6_ncol()

    def __init__(self, *args):
        _simbody.Vec6_swiginit(self, _simbody.new_Vec6(*args))

    def setToNaN(self) -> "void":
        r"""
        Set every scalar in this %Vec to NaN; this is the default initial
           value in Debug builds, but not in Release. *
        """
        return _simbody.Vec6_setToNaN(self)

    def setToZero(self) -> "void":
        r""" Set every scalar in this %Vec to zero. *"""
        return _simbody.Vec6_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Vec contains a NaN anywhere. *"""
        return _simbody.Vec6_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Vec contains a +Infinity
           or -Infinity somewhere but no element contains a NaN anywhere. *
        """
        return _simbody.Vec6_isInf(self)

    def isFinite(self) -> "bool":
        r"""
        Return true if no element of this %Vec contains an Infinity or a NaN
           anywhere. *
        """
        return _simbody.Vec6_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a vector is
           the same as its elements' default tolerance. *
        """
        return _simbody.Vec6_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether every element of this vector is numerically equal to the given
           element, using either a specified tolerance or the vector's
           default tolerance (which is always the same or looser than the default
           tolerance for one of its elements). *
        """
        return _simbody.Vec6_isNumericallyEqual(self, *args)

    def toString(self) -> "std::string":
        r""" Print Vec into a string and return it.  Please refer to operator<< for details. *"""
        return _simbody.Vec6_toString(self)

    def set(self, i: "int", value: "SimTK::Vec< 6 >::E const &") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.Vec6_set(self, i, value)

    def get(self, i: "int") -> "SimTK::Vec< 6 >::E const &":
        r""" Variant of operator[] that's scripting friendly to get const reference to ith entry *"""
        return _simbody.Vec6_get(self, i)

    def __str__(self) -> "std::string":
        return _simbody.Vec6___str__(self)

    def __len__(self) -> "int":
        return _simbody.Vec6___len__(self)

    def scalarEq(self, ee: "double const &") -> "SimTK::Vec< 6 > &":
        return _simbody.Vec6_scalarEq(self, ee)

    def scalarPlusEq(self, ee: "double const &") -> "SimTK::Vec< 6 > &":
        return _simbody.Vec6_scalarPlusEq(self, ee)

    def scalarMinusEq(self, ee: "double const &") -> "SimTK::Vec< 6 > &":
        return _simbody.Vec6_scalarMinusEq(self, ee)

    def scalarTimesEq(self, ee: "double const &") -> "SimTK::Vec< 6 > &":
        return _simbody.Vec6_scalarTimesEq(self, ee)

    def scalarDivideEq(self, ee: "double const &") -> "SimTK::Vec< 6 > &":
        return _simbody.Vec6_scalarDivideEq(self, ee)
    __swig_destroy__ = _simbody.delete_Vec6

# Register Vec6 in _simbody:
_simbody.Vec6_swigregister(Vec6)

def Vec6_size() -> "int":
    r"""
    The number of elements in this Vec (note that stride does not
       affect this number.) *
    """
    return _simbody.Vec6_size()

def Vec6_nrow() -> "int":
    r""" The number of rows in a Vec is the number of elements. *"""
    return _simbody.Vec6_nrow()

def Vec6_ncol() -> "int":
    r""" The number of columns in a Vec is always 1. *"""
    return _simbody.Vec6_ncol()

def Vec6_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a vector is
       the same as its elements' default tolerance. *
    """
    return _simbody.Vec6_getDefaultTolerance()

class Mat33(object):
    r"""
     This class represents a small matrix whose size is known at compile time,
    containing elements of any Composite Numerical Type (CNT) and engineered to
    have no runtime overhead whatsoever. Memory layout defaults to packed,
    column ordered storage but can be specified to have any regular row and
    column spacing. A Mat object is itself a Composite Numerical Type and can thus
    be the element type for other matrix and vector types.

    :param M:   The number of rows in this matrix (no default).
    :param N:   The number of columns in this matrix (no default).
    :param ELT: The element type; default is Real.
    :param CS:  Column spacing in memory as a multiple of element size (default M).
    :param RS:  %Row spacing in memory as a multiple of element size (default 1).

    See also: Matrix_ for handling of large or variable-size matrices.
    See also: SymMat, Vec, Row
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r""" Return the total number of elements M*N contained in this Mat. *"""
        return _simbody.Mat33_size()

    @staticmethod
    def nrow() -> "int":
        r"""
        Return the number of rows in this Mat, echoing the value supplied
           for the template paramter *M*. *
        """
        return _simbody.Mat33_nrow()

    @staticmethod
    def ncol() -> "int":
        r"""
        Return the number of columns in this Mat, echoing the value supplied
           for the template paramter *N*. *
        """
        return _simbody.Mat33_ncol()

    def __init__(self, *args):
        _simbody.Mat33_swiginit(self, _simbody.new_Mat33(*args))

    def setToNaN(self) -> "void":
        return _simbody.Mat33_setToNaN(self)

    def setToZero(self) -> "void":
        return _simbody.Mat33_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Mat contains a NaN anywhere."""
        return _simbody.Mat33_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Mat contains a +Inf
        or -Inf somewhere but no element contains a NaN anywhere.
        """
        return _simbody.Mat33_isInf(self)

    def isFinite(self) -> "bool":
        r""" Return true if no element contains an Infinity or a NaN."""
        return _simbody.Mat33_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a matrix is
        its shortest dimension times its elements' default tolerance.
        """
        return _simbody.Mat33_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether this is numerically a "scalar" matrix, meaning that it is
        a diagonal matrix in which each diagonal element is numerically equal to
        the same scalar, using either a specified tolerance or the matrix's
        default tolerance (which is always the same or looser than the default
        tolerance for one of its elements).
        """
        return _simbody.Mat33_isNumericallyEqual(self, *args)

    def isNumericallySymmetric(self, *args) -> "bool":
        r"""
        A Matrix is symmetric (actually Hermitian) if it is square and each
        element (i,j) is the Hermitian transpose of element (j,i). Here we
        are testing for numerical symmetry, meaning that the symmetry condition
        is satisified to within a tolerance (supplied or default). This is
        a relatively expensive test since all elements must be examined but
        can be very useful in Debug mode to check assumptions.
        See also: isExactlySymmetric() for a rarely-used exact equality test
        """
        return _simbody.Mat33_isNumericallySymmetric(self, *args)

    def isExactlySymmetric(self) -> "bool":
        r"""
        A Matrix is symmetric (actually Hermitian) if it is square and each
        element (i,j) is the Hermitian (conjugate) transpose of element (j,i). This
        method tests for exact (bitwise) equality and is too stringent for most
        purposes; don't use it unless you know that the corresponding elements
        should be bitwise conjugates, typically because you put them there directly.
        See also: isNumericallySymmetric() for a more useful method
        """
        return _simbody.Mat33_isExactlySymmetric(self)

    def toString(self) -> "std::string":
        return _simbody.Mat33_toString(self)

    def get(self, i: "int", j: "int") -> "double const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.Mat33_get(self, i, j)

    def set(self, i: "int", j: "int", value: "double const &") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.Mat33_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_Mat33

# Register Mat33 in _simbody:
_simbody.Mat33_swigregister(Mat33)

def Mat33_size() -> "int":
    r""" Return the total number of elements M*N contained in this Mat. *"""
    return _simbody.Mat33_size()

def Mat33_nrow() -> "int":
    r"""
    Return the number of rows in this Mat, echoing the value supplied
       for the template paramter *M*. *
    """
    return _simbody.Mat33_nrow()

def Mat33_ncol() -> "int":
    r"""
    Return the number of columns in this Mat, echoing the value supplied
       for the template paramter *N*. *
    """
    return _simbody.Mat33_ncol()

def Mat33_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a matrix is
    its shortest dimension times its elements' default tolerance.
    """
    return _simbody.Mat33_getDefaultTolerance()

class CoordinateAxis(object):
    r"""
     This class, along with its sister class CoordinateDirection, provides
    convenient manipulation of the three coordinate axes via the definition of
    three constants XAxis, YAxis, and ZAxis each with a unique subtype and implicit
    conversion to the integers 0, 1, and 2 whenever necessary.\ Methods are
    provided to allow code to be written once that can be used to work with the
    axes in any order.

    There are also three CoordinateDirection constants NegXAxis, NegYAxis, and
    NegZAxis, also with unique types permitting efficient compile time
    manipulation. These do not correspond to integers, however. Instead, they are
    objects containing one of the CoordinateAxis objects combined with an integer
    that is 1 or -1 to indicate the direction along that axis. The unary negation
    operator is overloaded so that -XAxis is NegXAxis and -NegZAxis is ZAxis.
    There are implicit conversions to UnitVec3 for any CoordinateAxis or
    CoordinateDirection object, yielding the equivalent (normalized) unit vector
    corresponding to any of the six directions, without doing any computation
    (and in particular, without normalizing).
    See also: CoordinateDirection *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i: "int"):
        r"""
        Explicit construction of a CoordinateAxis from a calculated integer
           that must be 0, 1, or 2 representing XAxis, YAxis, or ZAxis. *
        """
        _simbody.CoordinateAxis_swiginit(self, _simbody.new_CoordinateAxis(i))

    def getNextAxis(self) -> "SimTK::CoordinateAxis":
        r"""
        Return the "next" coordinate axis after this one:
               - XAxis.getNextAxis()  returns YAxis
               - YAxis.getNextAxis()  returns ZAxis
               - ZAxis.getNextAxis()  returns XAxis *
        """
        return _simbody.CoordinateAxis_getNextAxis(self)

    def getPreviousAxis(self) -> "SimTK::CoordinateAxis":
        r"""
        Return the "previous" coordinate axis before this one:
               - XAxis.getPreviousAxis()  returns ZAxis
               - YAxis.getPreviousAxis()  returns XAxis
               - ZAxis.getPreviousAxis()  returns YAxis *
        """
        return _simbody.CoordinateAxis_getPreviousAxis(self)

    def getThirdAxis(self, axis2: "CoordinateAxis") -> "SimTK::CoordinateAxis":
        r"""
        Given this coordinate axis and one other, return the missing one:
               - XAxis.getThirdAxis(YAxis) returns ZAxis (and vice versa)
               - XAxis.getThirdAxis(ZAxis) returns YAxis (and vice versa)
               - YAxis.getThirdAxis(ZAxis) returns XAxis (and vice versa)
           :type axis2: :py:class:`CoordinateAxis`, in
           :param axis2:    A coordinate axis that must be distinct from the
                   current one; it is a fatal error to provide the same axis.
           :rtype: :py:class:`CoordinateAxis`
           :return: The unmentioned third axis. *
        """
        return _simbody.CoordinateAxis_getThirdAxis(self, axis2)

    def isXAxis(self) -> "bool":
        r""" Return true if this is the X axis. *"""
        return _simbody.CoordinateAxis_isXAxis(self)

    def isYAxis(self) -> "bool":
        r""" Return true if this is the Y axis. *"""
        return _simbody.CoordinateAxis_isYAxis(self)

    def isZAxis(self) -> "bool":
        r""" Return true if this is the Z axis. *"""
        return _simbody.CoordinateAxis_isZAxis(self)

    def isNextAxis(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is the one following this one as
           would be reported by getNextAxis(). *
        """
        return _simbody.CoordinateAxis_isNextAxis(self, axis2)

    def isPreviousAxis(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is the one preceding this one as
           would be reported by getPreviousAxis(). *
        """
        return _simbody.CoordinateAxis_isPreviousAxis(self, axis2)

    def isSameAxis(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is the same as this one.\ You
           can use operator==() to perform the same comparison. *
        """
        return _simbody.CoordinateAxis_isSameAxis(self, axis2)

    def areAllSameAxes(self, axis2: "CoordinateAxis", axis3: "CoordinateAxis") -> "bool":
        r""" Return true if both *axis2* and *axis3* are the same as this one. *"""
        return _simbody.CoordinateAxis_areAllSameAxes(self, axis2, axis3)

    def isDifferentAxis(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is not the same one as this
           one.\ You can use operator!=() to perform the same comparison.  *
        """
        return _simbody.CoordinateAxis_isDifferentAxis(self, axis2)

    def areAllDifferentAxes(self, axis2: "CoordinateAxis", axis3: "CoordinateAxis") -> "bool":
        r"""
        Return true if neither *axis2* nor *axis3* is the same as this
           axis nor each other; that is, (this,axis2,axis3) together cover all three
           axes. *
        """
        return _simbody.CoordinateAxis_areAllDifferentAxes(self, axis2, axis3)

    def isForwardCyclical(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is the one following this one in a
           forward cyclical direction, that is, if *axis2* is the one that would be
           reported by getNextAxis(). *
        """
        return _simbody.CoordinateAxis_isForwardCyclical(self, axis2)

    def isReverseCyclical(self, axis2: "CoordinateAxis") -> "bool":
        r"""
        Return true if the given *axis2* is the one following this one in a
           reverse cyclical direction, that is, if *axis2* is the one that would be
           reported by getPreviousAxis(). *
        """
        return _simbody.CoordinateAxis_isReverseCyclical(self, axis2)

    def dotProduct(self, axis2: "CoordinateAxis") -> "int":
        r"""
        Perform a specialized dot product between this axis and *axis2;*
           returning one if they are the same axis and zero otherwise, without
           performing any floating point operations. *
        """
        return _simbody.CoordinateAxis_dotProduct(self, axis2)

    def crossProductSign(self, axis2: "CoordinateAxis") -> "int":
        r"""
        Return the sign that would result from a cross product between this
           axis and *axis2*: zero if *axis2* is the same as this axis; one if the
           result would be in the positive direction along the third axis; -1 if it
           would be in the negative direction. No floating point computations are
           performed. See also: crossProductAxis() *
        """
        return _simbody.CoordinateAxis_crossProductSign(self, axis2)

    def crossProductAxis(self, axis2: "CoordinateAxis") -> "SimTK::CoordinateAxis":
        r"""
        Return the coordinate axis along which the cross product of this axis
           and *axis2* would lie: same as this if *axis2* is the same as this axis
           (doesn't matter because the sign would be zero); otherwise, the third
           axis that is neither this one nor *axis2*. But note that the actual
           result may be along that axis or in the negative direction along that
           axis.  No floating point computations are performed.
           See also: crossProductSign(). *
        """
        return _simbody.CoordinateAxis_crossProductAxis(self, axis2)

    def crossProduct(self, axis2: "CoordinateAxis", sign: "int &") -> "SimTK::CoordinateAxis":
        r"""
        Return the axis and sign along that axis that would result from a
           cross product between this axis and *axis2;* this combines the functions
           of both crossProductAxis() and crossProductSign(). Note that if *axis2* is
           the same as this axis we'll just return this as the axis but the sign is
           zero since the magnitude of the result would be zero. No floating point
           calculations are performed.
           See also: crossProductSign(), crossProductAxis() *
        """
        return _simbody.CoordinateAxis_crossProduct(self, axis2, sign)

    @staticmethod
    def getCoordinateAxis(i: "int") -> "SimTK::CoordinateAxis const &":
        r"""
        Return a reference to the CoordinateAxis constant XAxis, YAxis, or
           ZAxis corresponding to the given integer index which must be 0, 1, or 2. *
        """
        return _simbody.CoordinateAxis_getCoordinateAxis(i)

    @staticmethod
    def isIndexInRange(i: "int") -> "bool":
        r"""
        Return true if the given integer is suitable as a coordinate axis,
           meaning it is one of 0, 1, or 2 designating XAxis, YAxis, or ZAxis,
           respectively. *
        """
        return _simbody.CoordinateAxis_isIndexInRange(i)
    __swig_destroy__ = _simbody.delete_CoordinateAxis

# Register CoordinateAxis in _simbody:
_simbody.CoordinateAxis_swigregister(CoordinateAxis)

def CoordinateAxis_getCoordinateAxis(i: "int") -> "SimTK::CoordinateAxis const &":
    r"""
    Return a reference to the CoordinateAxis constant XAxis, YAxis, or
       ZAxis corresponding to the given integer index which must be 0, 1, or 2. *
    """
    return _simbody.CoordinateAxis_getCoordinateAxis(i)

def CoordinateAxis_isIndexInRange(i: "int") -> "bool":
    r"""
    Return true if the given integer is suitable as a coordinate axis,
       meaning it is one of 0, 1, or 2 designating XAxis, YAxis, or ZAxis,
       respectively. *
    """
    return _simbody.CoordinateAxis_isIndexInRange(i)


def __eq__(a1: "CoordinateAxis", a2: "CoordinateAxis") -> "bool":
    return _simbody.__eq__(a1, a2)

def __ne__(a1: "CoordinateAxis", a2: "CoordinateAxis") -> "bool":
    return _simbody.__ne__(a1, a2)
class CoordinateDirection(object):
    r"""
     A CoordinateDirection is a CoordinateAxis plus a direction indicating the
    positive or negative direction along that axis. There are only six possible
    values for a CoordinateDirection, and there are predefined constants available
    covering all of them:
      - XAxis, YAxis, ZAxis are the CoordinateAxis types; they will implicitly
        convert to positive axis directions.
      - NegXAxis, NegYAxis, NegZAxis are the negative directions.
      - The unary negation operator is overloaded so that -XAxis produces
        NegXAxis and -NegYAxis produces YAxis.
      - The unary plus operator is overloaded for the CoordinateAxis objects
        so that +XAxis and so on are the positive CoordinateDirection objects.
    You can also produce CoordinateDirections at compile time or run time from
    calculated axes and directions.
    See also: CoordinateAxis *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Implicit conversion of a CoordinateAxis to a positive
           CoordinateDirection along that axis. *

        |

        *Overload 2:*
        Explicit creation of a CoordinateDirection from a CoordinateAxis
           and a direction calculated at run time.
           :type axis: :py:class:`CoordinateAxis`, in
           :param axis:         XAxis, YAxis, or ZAxis
           :type direction: int, in
           :param direction:    Must be -1 or 1.
           Notes: Zero is not allowed for *direction*, meaning that
           you must not try to produce one of these from the "sign" result of one of
           the cross product methods, because there the sign can be -1, 0, or 1. *
        """
        _simbody.CoordinateDirection_swiginit(self, _simbody.new_CoordinateDirection(*args))

    def getAxis(self) -> "SimTK::CoordinateAxis":
        r"""
        This is the coordinate axis XAxis, YAxis, or ZAxis contained in this
           CoordinateDirection.\ Use getDirection() to determine whether this is the
           positive or negative direction. *
        """
        return _simbody.CoordinateDirection_getAxis(self)

    def getDirection(self) -> "int":
        r"""
        Returns 1 or -1 to indicate the direction along the coordinate
           axis returned by getAxis(). *
        """
        return _simbody.CoordinateDirection_getDirection(self)

    def hasSameAxis(self, dir2: "CoordinateDirection") -> "bool":
        r"""
        Return true if this direction and *dir2* are along the same axis,
           even if the direction along that axis is not the same. *
        """
        return _simbody.CoordinateDirection_hasSameAxis(self, dir2)

    def isSameAxisAndDirection(self, dir2: "CoordinateDirection") -> "bool":
        r"""
        Return true if this direction and *dir2* are along the same axis,
           and in the same direction along that axis.\ You can also
           use operator==() for this comparison. *
        """
        return _simbody.CoordinateDirection_isSameAxisAndDirection(self, dir2)

    def dotProduct(self, dir2: "CoordinateDirection") -> "int":
        r"""
        Perform a specialized dot product between this coordinate direction
           and *dir2;* returning 1 or -1 if they contain the same axis and 0
           otherwise, without performing any floating point operations. *
        """
        return _simbody.CoordinateDirection_dotProduct(self, dir2)

    def crossProductSign(self, dir2: "CoordinateDirection") -> "int":
        r"""
        Return the sign that would result from a cross product between this
           coordinate direction and *dir2*: 0 if they are along the same axis;
           1 if the result would be in the positive direction along the third axis;
           -1 if it would be in the negative direction. No floating point
           computations are performed. See also: crossProductAxis() *
        """
        return _simbody.CoordinateDirection_crossProductSign(self, dir2)

    def crossProductAxis(self, dir2: "CoordinateDirection") -> "SimTK::CoordinateAxis":
        r"""
        Return the coordinate axis along which the cross product of this
           coordinate direction and *dir2* would lie: same as this if both contain
           the same axis (doesn't matter because the sign would be zero); otherwise,
           the third axis that neither this one nor *dir2* contains. But note that
           the actual result may be along that axis or in the negative direction
           along that axis.  No floating point computations are performed.
           See also: crossProductSign(). *
        """
        return _simbody.CoordinateDirection_crossProductAxis(self, dir2)

    def crossProduct(self, dir2: "CoordinateDirection", sign: "int &") -> "SimTK::CoordinateAxis":
        r"""
        Return the axis and sign along that axis that would result from a
           cross product between this coordinate direction and *dir2;* this
           combines the functions of both crossProductAxis() and crossProductSign().
           Note that if *dir2* is along the same axis as this one, we'll just
           return this as the axis but the sign is zero since the magnitude of the
           result would be zero. No floating point calculations are
           performed. See also: crossProductSign(), crossProductAxis() *
        """
        return _simbody.CoordinateDirection_crossProduct(self, dir2, sign)
    __swig_destroy__ = _simbody.delete_CoordinateDirection

# Register CoordinateDirection in _simbody:
_simbody.CoordinateDirection_swigregister(CoordinateDirection)

class UnitVec3(Vec3):
    r"""
    This class is a Vec3 plus an ironclad guarantee either that:
         - the length is one (to within a very small tolerance), or
         - all components are NaN.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def asVec3(self) -> "SimTK::UnitVec< double,1 >::BaseVec const &":
        r""" Return a reference to the underlying Vec3 (no copying here)."""
        return _simbody.UnitVec3_asVec3(self)

    def negate(self) -> "SimTK::UnitVec< double,1 >":
        r"""
        Returns a new unit vector pointing in the opposite direction from this one;
        does *not* modify this UnitVec object. Cost is 3 flops.
        """
        return _simbody.UnitVec3_negate(self)

    def __neg__(self) -> "SimTK::UnitVec< double,1 >":
        r"""
        Returns a new unit vector pointing in the opposite direction from this one.
        Cost is 3 flops.
        """
        return _simbody.UnitVec3___neg__(self)

    def __invert__(self, *args) -> "SimTK::UnitVec< double,1 >::TransposeType &":
        r"""
        *Overload 1:*
        Return a const reference to this unit vector re-expressed as a unit row; no
        computational cost.

        |

        *Overload 2:*
        Return a writable reference to this unit vector re-expressed as a unit row; no
        computational cost.
        """
        return _simbody.UnitVec3___invert__(self, *args)

    def __call__(self, i: "int") -> "double const &":
        r"""
        Return one element of this unit vector as a const reference; there is no
        corresponding writable index function since changing a single element of
        a unit vector would violate the contract that it has unit length at all times.
        """
        return _simbody.UnitVec3___call__(self, i)

    def abs(self) -> "SimTK::UnitVec< double,1 >":
        r"""
        Return a new unit vector whose measure numbers are the absolute values
        of the ones here. This will still have unit length but will be
        a reflection of this unit vector into the first octant (+x,+y,+z).
        Note that we are returning the packed form of UnitVec regardless
        of our stride here.
        """
        return _simbody.UnitVec3_abs(self)

    def perp(self) -> "SimTK::UnitVec< double,1 >":
        r"""
        Return a new unit vector perpendicular to this one but otherwise
        arbitrary. Some care is taken to ensure good numerical conditioning
        for the result regardless of what goes in. Cost is about 50 flops.
        """
        return _simbody.UnitVec3_perp(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor initializes to all-NaN even in Release mode so that
        we maintain the above-promised contract.

        |

        *Overload 2:*
        Copy constructor does not require normalization since we know the
        source is a unit vector.

        |

        *Overload 3:*
        Explicit conversion from Vec to UnitVec, requiring expensive normalization.

        |

        *Overload 4:*
        Explicit conversion from Vec of any stride to this UnitVec, requiring
        expensive normalization.
        Create a unit vector in the direction of the vector (x,y,z) whose measure
        numbers are supplied -- this requires an expensive normalization since
        we don't know that the supplied vector is normalized.

        |

        *Overload 5:*
        Implicit conversion from a coordinate axis XAxis, YAxis, or ZAxis to
        a UnitVec3.\ Does not require any computation.

        |

        *Overload 6:*
        Implicit conversion from a coordinate axis direction to a
        UnitVec3.\ The axis direction is given by one of XAxis, YAxis, ZAxis
        or NegXAxis, NegYAxis, NegZAxis.\ Does not require any computation.

        |

        *Overload 7:*
        Construct a unit axis vector 100 010 001 given 0,1, or 2; this is not
        an implicit conversion.

        |

        *Overload 8:*
        (Advanced) This constructor is only for our friends whom we trust to
        give us an already-normalized vector which we simply accept as
        normalized without checking.
        """
        _simbody.UnitVec3_swiginit(self, _simbody.new_UnitVec3(*args))

    @staticmethod
    def getAs(p: "double const *") -> "SimTK::UnitVec< double,1 > const &":
        r"""
        (Advanced) Reinterpret a given memory location as a %UnitVec like
        this one, without checking -- don't use this if you aren't absolutely
        certain that the memory location actually *does* contain a unit vector,
        with the correct stride! This overrides the base Vec class method of the
        same name.
        """
        return _simbody.UnitVec3_getAs(p)
    __swig_destroy__ = _simbody.delete_UnitVec3

# Register UnitVec3 in _simbody:
_simbody.UnitVec3_swigregister(UnitVec3)

def UnitVec3_getAs(p: "double const *") -> "SimTK::UnitVec< double,1 > const &":
    r"""
    (Advanced) Reinterpret a given memory location as a %UnitVec like
    this one, without checking -- don't use this if you aren't absolutely
    certain that the memory location actually *does* contain a unit vector,
    with the correct stride! This overrides the base Vec class method of the
    same name.
    """
    return _simbody.UnitVec3_getAs(p)

class Quaternion(Vec4):
    r"""
    A Quaternion is a Vec4 with the following behavior:
      - its length is always 1 (or else it is all NaN)
      - it is equivalent to an angle/axis rotation for
        angle a, axis unit vector v, as:  q = [ cos(a/2) sin(a/2)*v ]
    A quaternion is in "canonical form" when its first element is nonnegative.
    This corresponds to rotation angles in the range -180 < a <= 180 degrees.
    Quaternions are not required to be in canonical form (e.g., during numerical
    integration). When appropriate, they are put in canonical form.

    Conversion from quaternion to (angle,axis) form is handled here also.
    (angle,axis) is in canonical form when -180 < angle <= 180 and |axis|=1.
    However, (angle,axis) is meaningful for any angle and for any axis where
    |axis| > 0.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def setQuaternionToZeroRotation(self) -> "void":
        r"""
        The ZeroRotation quaternion is [1 0 0 0]. Note: Default constructor
        is ZeroRotation (unlike Vec<4,P> which start as NaN in Debug mode).
        """
        return _simbody.Quaternion_setQuaternionToZeroRotation(self)

    def setQuaternionToNaN(self) -> "void":
        r"""
        Set quaternion to all-NaN. Note that this is not the same as produced
        by default construction, even in Debug mode -- default construction
        always produces an identity rotation of [1 0 0 0].
        """
        return _simbody.Quaternion_setQuaternionToNaN(self)

    def normalizeThis(self) -> "SimTK::Quaternion_< double > &":
        r"""
        Normalize an already constructed quaternion in place; but do you really
        need to do this? Quaternions should be kept normalized at all times.
        One of the advantages of using them is that you don't have to check if
        they are normalized or renormalize them. However, under some situations
        they do need renormalization, but it is costly if you don't actually
        need it. If the quaternion is *exactly* zero, set it to [1 0 0 0]. If
        its magnitude is 0 < magnitude < epsilon  (epsilon is machine
        tolerance), set it to NaN (treated as an error). Otherwise, normalize
        the quaternion which costs about 40 flops. The quaternion is NOT put
        in canonical form.
        """
        return _simbody.Quaternion_normalizeThis(self)

    def normalize(self) -> "SimTK::Quaternion_< double >":
        r"""
        Return a normalized copy of this quaternion; but do you really need to
        do this? Quaternions should be kept normalized at all times. One of
        the advantages of using them is that you don't have to check if they
        are normalized or renormalize them. However, under some situations they
        do need renormalization, but it is costly if you don't actually need it.
        See also: normalizeThis() for details.
        """
        return _simbody.Quaternion_normalize(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor produces the ZeroRotation quaternion [1 0 0 0]
        (not NaN - even in debug mode).

        |

        *Overload 2:*
        Zero-cost copy constructor just copies the source without conversion to
        canonical form or normalization.

        |

        *Overload 3:*
        Construct a quaternion from four scalars and normalize the result,
        which costs about 40 flops.

        |

        *Overload 4:*
        Construct a quaternion from a 4-vector and normalize the result,
        which costs about 40 flops.

        |

        *Overload 5:*
        Use this constructor only if you are *sure* v is normalized to 1.0.
        This zero cost method is faster than the Quaternion(Vec4) constructor
        which normalizes the Vec4. The second argument forces the compiler to
        call the fast constructor; it is otherwise ignored. By convention, set
        the second argument to "true".
        """
        _simbody.Quaternion_swiginit(self, _simbody.new_Quaternion(*args))
    __swig_destroy__ = _simbody.delete_Quaternion

# Register Quaternion in _simbody:
_simbody.Quaternion_swigregister(Quaternion)

class StdVectorVec3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorVec3_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorVec3___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorVec3___bool__(self)

    def __len__(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::size_type":
        return _simbody.StdVectorVec3___len__(self)

    def __getslice__(self, i: "std::vector< SimTK::Vec< 3,double,1 > >::difference_type", j: "std::vector< SimTK::Vec< 3,double,1 > >::difference_type") -> "std::vector< SimTK::Vec< 3,double,1 >,std::allocator< SimTK::Vec< 3,double,1 > > > *":
        return _simbody.StdVectorVec3___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorVec3___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SimTK::Vec< 3,double,1 > >::difference_type", j: "std::vector< SimTK::Vec< 3,double,1 > >::difference_type") -> "void":
        return _simbody.StdVectorVec3___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorVec3___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SimTK::Vec< 3,double,1 > >::value_type const &":
        return _simbody.StdVectorVec3___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorVec3___setitem__(self, *args)

    def pop(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::value_type":
        return _simbody.StdVectorVec3_pop(self)

    def append(self, x: "Vec3") -> "void":
        return _simbody.StdVectorVec3_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorVec3_empty(self)

    def size(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::size_type":
        return _simbody.StdVectorVec3_size(self)

    def swap(self, v: "StdVectorVec3") -> "void":
        return _simbody.StdVectorVec3_swap(self, v)

    def begin(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::iterator":
        return _simbody.StdVectorVec3_begin(self)

    def end(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::iterator":
        return _simbody.StdVectorVec3_end(self)

    def rbegin(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::reverse_iterator":
        return _simbody.StdVectorVec3_rbegin(self)

    def rend(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::reverse_iterator":
        return _simbody.StdVectorVec3_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorVec3_clear(self)

    def get_allocator(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::allocator_type":
        return _simbody.StdVectorVec3_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorVec3_pop_back(self)

    def erase(self, *args) -> "std::vector< SimTK::Vec< 3,double,1 > >::iterator":
        return _simbody.StdVectorVec3_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorVec3_swiginit(self, _simbody.new_StdVectorVec3(*args))

    def push_back(self, x: "Vec3") -> "void":
        return _simbody.StdVectorVec3_push_back(self, x)

    def front(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::value_type const &":
        return _simbody.StdVectorVec3_front(self)

    def back(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::value_type const &":
        return _simbody.StdVectorVec3_back(self)

    def assign(self, n: "std::vector< SimTK::Vec< 3,double,1 > >::size_type", x: "Vec3") -> "void":
        return _simbody.StdVectorVec3_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorVec3_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorVec3_insert(self, *args)

    def reserve(self, n: "std::vector< SimTK::Vec< 3,double,1 > >::size_type") -> "void":
        return _simbody.StdVectorVec3_reserve(self, n)

    def capacity(self) -> "std::vector< SimTK::Vec< 3,double,1 > >::size_type":
        return _simbody.StdVectorVec3_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorVec3

# Register StdVectorVec3 in _simbody:
_simbody.StdVectorVec3_swigregister(StdVectorVec3)

class MatrixBaseDouble(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseDouble_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseDouble_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseDouble_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseDouble_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseDouble_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseDouble_swiginit(self, _simbody.new_MatrixBaseDouble(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseDouble_clear(self)

    def setTo(self, t: "double const &") -> "SimTK::MatrixBase< double > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseDouble_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< double > &":
        return _simbody.MatrixBaseDouble_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< double > &":
        return _simbody.MatrixBaseDouble_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< double >":
        return _simbody.MatrixBaseDouble_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< double >":
        return _simbody.MatrixBaseDouble_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< double >":
        return _simbody.MatrixBaseDouble_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< double >":
        return _simbody.MatrixBaseDouble_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< double >":
        return _simbody.MatrixBaseDouble___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "double const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseDouble_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "double &":
        return _simbody.MatrixBaseDouble_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< double > &":
        return _simbody.MatrixBaseDouble_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< double > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseDouble_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< double > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseDouble_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseDouble_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseDouble_unlockShape(self)

    def _to_numpy(self, nrow: "int") -> "void":
        return _simbody.MatrixBaseDouble__to_numpy(self, nrow)

    def to_numpy(self):
        import numpy as np
        mat = np.empty([self.nrow(), self.ncol()])
        self._to_numpy(mat)
        return mat

    __swig_destroy__ = _simbody.delete_MatrixBaseDouble

# Register MatrixBaseDouble in _simbody:
_simbody.MatrixBaseDouble_swigregister(MatrixBaseDouble)

class MatrixView(MatrixBaseDouble):
    r"""
    This class is identical to a Matrix_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Matrix_ is recast to a MatrixView_.
    However, there are no owner constructors for MatrixView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "MatrixView"):
        _simbody.MatrixView_swiginit(self, _simbody.new_MatrixView(m))

    def __iadd__(self, r: "double const &") -> "SimTK::MatrixView_< double > &":
        return _simbody.MatrixView___iadd__(self, r)

    def __isub__(self, r: "double const &") -> "SimTK::MatrixView_< double > &":
        return _simbody.MatrixView___isub__(self, r)
    __swig_destroy__ = _simbody.delete_MatrixView

# Register MatrixView in _simbody:
_simbody.MatrixView_swigregister(MatrixView)

class Matrix(MatrixBaseDouble):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.Matrix_swiginit(self, _simbody.new_Matrix(*args))

    def toString(self) -> "std::string":
        return _simbody.Matrix_toString(self)

    def get(self, i: "int", j: "int") -> "double const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.Matrix_get(self, i, j)

    def set(self, i: "int", j: "int", value: "double const &") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.Matrix_set(self, i, j, value)

    @staticmethod
    def createFromMat(nrow: "int") -> "SimTK::Matrix_< double >":
        return _simbody.Matrix_createFromMat(nrow)
    __swig_destroy__ = _simbody.delete_Matrix

# Register Matrix in _simbody:
_simbody.Matrix_swigregister(Matrix)

def Matrix_createFromMat(nrow: "int") -> "SimTK::Matrix_< double >":
    return _simbody.Matrix_createFromMat(nrow)

class VectorBaseDouble(MatrixBaseDouble):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseDouble_swiginit(self, _simbody.new_VectorBaseDouble(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseDouble_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseDouble_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseDouble_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< double > &":
        return _simbody.VectorBaseDouble_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< double > &":
        return _simbody.VectorBaseDouble_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseDouble_clear(self)

    def sum(self) -> "double":
        return _simbody.VectorBaseDouble_sum(self)

    def __getitem__(self, i: "int") -> "double":
        return _simbody.VectorBaseDouble___getitem__(self, i)

    def __setitem__(self, i: "int", value: "double") -> "void":
        return _simbody.VectorBaseDouble___setitem__(self, i, value)

    def _to_numpy(self, n: "int") -> "void":
        return _simbody.VectorBaseDouble__to_numpy(self, n)

    def to_numpy(self):
        return self._to_numpy(self.size())

    __swig_destroy__ = _simbody.delete_VectorBaseDouble

# Register VectorBaseDouble in _simbody:
_simbody.VectorBaseDouble_swigregister(VectorBaseDouble)

class VectorView(VectorBaseDouble):
    r"""
    This class is identical to a Vector_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Vector_ is recast to a VectorView_.
    However, there are no owner constructors for VectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v: "VectorView"):
        _simbody.VectorView_swiginit(self, _simbody.new_VectorView(v))
    __swig_destroy__ = _simbody.delete_VectorView

# Register VectorView in _simbody:
_simbody.VectorView_swigregister(VectorView)

class Vector(VectorBaseDouble):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def toString(self) -> "std::string":
        return _simbody.Vector_toString(self)

    def get(self, i: "int") -> "double const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.Vector_get(self, i)

    def set(self, i: "int", value: "double const &") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.Vector_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.Vector___str__(self)

    def __len__(self) -> "int":
        return _simbody.Vector___len__(self)

    def __init__(self, *args):
        _simbody.Vector_swiginit(self, _simbody.new_Vector(*args))

    def transpose(self) -> "SimTK::RowVector_< double >":
        return _simbody.Vector_transpose(self)

    @staticmethod
    def createFromMat(n: "int") -> "SimTK::Vector_< double >":
        return _simbody.Vector_createFromMat(n)

    def __getitem__(self, i: "int") -> "double":
        return _simbody.Vector___getitem__(self, i)

    def __setitem__(self, i: "int", value: "double") -> "void":
        return _simbody.Vector___setitem__(self, i, value)
    __swig_destroy__ = _simbody.delete_Vector

# Register Vector in _simbody:
_simbody.Vector_swigregister(Vector)

def Vector_createFromMat(n: "int") -> "SimTK::Vector_< double >":
    return _simbody.Vector_createFromMat(n)

class RowVectorBaseDouble(MatrixBaseDouble):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseDouble_swiginit(self, _simbody.new_RowVectorBaseDouble(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseDouble_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseDouble_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseDouble_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseDouble_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< double >":
        return _simbody.RowVectorBaseDouble_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< double >":
        return _simbody.RowVectorBaseDouble_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< double >":
        return _simbody.RowVectorBaseDouble___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< double > const &":
        return _simbody.RowVectorBaseDouble___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< double > &":
        return _simbody.RowVectorBaseDouble_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< double > &":
        return _simbody.RowVectorBaseDouble_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseDouble_clear(self)

    def sum(self) -> "double":
        return _simbody.RowVectorBaseDouble_sum(self)

    def begin(self) -> "VectorIterator< double,SimTK::RowVectorBase< double > >":
        return _simbody.RowVectorBaseDouble_begin(self)

    def end(self) -> "VectorIterator< double,SimTK::RowVectorBase< double > >":
        return _simbody.RowVectorBaseDouble_end(self)

    def __getitem__(self, i: "int") -> "double":
        return _simbody.RowVectorBaseDouble___getitem__(self, i)

    def __setitem__(self, i: "int", value: "double") -> "void":
        return _simbody.RowVectorBaseDouble___setitem__(self, i, value)

    def _to_numpy(self, n: "int") -> "void":
        return _simbody.RowVectorBaseDouble__to_numpy(self, n)

    def to_numpy(self):
        return self._to_numpy(self.size())

    __swig_destroy__ = _simbody.delete_RowVectorBaseDouble

# Register RowVectorBaseDouble in _simbody:
_simbody.RowVectorBaseDouble_swigregister(RowVectorBaseDouble)

class RowVectorView(RowVectorBaseDouble):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorView"):
        _simbody.RowVectorView_swiginit(self, _simbody.new_RowVectorView(r))
    __swig_destroy__ = _simbody.delete_RowVectorView

# Register RowVectorView in _simbody:
_simbody.RowVectorView_swigregister(RowVectorView)

class RowVector(RowVectorBaseDouble):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVector_swiginit(self, _simbody.new_RowVector(*args))

    def transpose(self) -> "SimTK::Vector_< double >":
        return _simbody.RowVector_transpose(self)

    @staticmethod
    def createFromMat(n: "int") -> "SimTK::RowVector_< double >":
        return _simbody.RowVector_createFromMat(n)
    __swig_destroy__ = _simbody.delete_RowVector

# Register RowVector in _simbody:
_simbody.RowVector_swigregister(RowVector)

def RowVector_createFromMat(n: "int") -> "SimTK::RowVector_< double >":
    return _simbody.RowVector_createFromMat(n)

class MatrixBaseVec3(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseVec3_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseVec3_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseVec3_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseVec3_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseVec3_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseVec3_swiginit(self, _simbody.new_MatrixBaseVec3(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseVec3_clear(self)

    def setTo(self, t: "Vec3") -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseVec3_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        return _simbody.MatrixBaseVec3_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        return _simbody.MatrixBaseVec3_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.MatrixBaseVec3_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.MatrixBaseVec3_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.MatrixBaseVec3_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.MatrixBaseVec3_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.MatrixBaseVec3___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "SimTK::Vec< 3,double,1 > const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseVec3_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "SimTK::Vec< 3,double,1 > &":
        return _simbody.MatrixBaseVec3_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        return _simbody.MatrixBaseVec3_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseVec3_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Vec3 > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseVec3_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseVec3_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseVec3_unlockShape(self)
    __swig_destroy__ = _simbody.delete_MatrixBaseVec3

# Register MatrixBaseVec3 in _simbody:
_simbody.MatrixBaseVec3_swigregister(MatrixBaseVec3)

class MatrixViewVec3(MatrixBaseVec3):
    r"""
    This class is identical to a Matrix_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Matrix_ is recast to a MatrixView_.
    However, there are no owner constructors for MatrixView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "MatrixViewVec3"):
        _simbody.MatrixViewVec3_swiginit(self, _simbody.new_MatrixViewVec3(m))

    def __iadd__(self, r: "Vec3") -> "SimTK::MatrixView_< SimTK::Vec3 > &":
        return _simbody.MatrixViewVec3___iadd__(self, r)

    def __isub__(self, r: "Vec3") -> "SimTK::MatrixView_< SimTK::Vec3 > &":
        return _simbody.MatrixViewVec3___isub__(self, r)
    __swig_destroy__ = _simbody.delete_MatrixViewVec3

# Register MatrixViewVec3 in _simbody:
_simbody.MatrixViewVec3_swigregister(MatrixViewVec3)

class MatrixVec3(MatrixBaseVec3):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixVec3_swiginit(self, _simbody.new_MatrixVec3(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixVec3_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Vec< 3,double,1 > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixVec3_get(self, i, j)

    def set(self, i: "int", j: "int", value: "Vec3") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixVec3_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixVec3

# Register MatrixVec3 in _simbody:
_simbody.MatrixVec3_swigregister(MatrixVec3)

class VectorBaseVec3(MatrixBaseVec3):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseVec3_swiginit(self, _simbody.new_VectorBaseVec3(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseVec3_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseVec3_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseVec3_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< SimTK::Vec3 > &":
        return _simbody.VectorBaseVec3_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< SimTK::Vec3 > &":
        return _simbody.VectorBaseVec3_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseVec3_clear(self)

    def sum(self) -> "SimTK::Vec< 3,double,1 >":
        return _simbody.VectorBaseVec3_sum(self)

    def __getitem__(self, i: "int") -> "SimTK::Vec3":
        return _simbody.VectorBaseVec3___getitem__(self, i)

    def __setitem__(self, i: "int", value: "Vec3") -> "void":
        return _simbody.VectorBaseVec3___setitem__(self, i, value)
    __swig_destroy__ = _simbody.delete_VectorBaseVec3

# Register VectorBaseVec3 in _simbody:
_simbody.VectorBaseVec3_swigregister(VectorBaseVec3)

class VectorViewVec3(VectorBaseVec3):
    r"""
    This class is identical to a Vector_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Vector_ is recast to a VectorView_.
    However, there are no owner constructors for VectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v: "VectorViewVec3"):
        _simbody.VectorViewVec3_swiginit(self, _simbody.new_VectorViewVec3(v))
    __swig_destroy__ = _simbody.delete_VectorViewVec3

# Register VectorViewVec3 in _simbody:
_simbody.VectorViewVec3_swigregister(VectorViewVec3)

class VectorVec3(VectorBaseVec3):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def toString(self) -> "std::string":
        return _simbody.VectorVec3_toString(self)

    def get(self, i: "int") -> "SimTK::Vec< 3,double,1 > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorVec3_get(self, i)

    def set(self, i: "int", value: "Vec3") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorVec3_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorVec3___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorVec3___len__(self)

    def __init__(self, *args):
        _simbody.VectorVec3_swiginit(self, _simbody.new_VectorVec3(*args))

    def transpose(self) -> "SimTK::RowVector_< SimTK::Vec3 >":
        return _simbody.VectorVec3_transpose(self)
    __swig_destroy__ = _simbody.delete_VectorVec3

# Register VectorVec3 in _simbody:
_simbody.VectorVec3_swigregister(VectorVec3)

class RowVectorBaseVec3(MatrixBaseVec3):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseVec3_swiginit(self, _simbody.new_RowVectorBaseVec3(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseVec3_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseVec3_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseVec3_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseVec3_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.RowVectorBaseVec3_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.RowVectorBaseVec3_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< SimTK::Vec< 3,double,1 > >":
        return _simbody.RowVectorBaseVec3___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< SimTK::Vec3 > const &":
        return _simbody.RowVectorBaseVec3___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Vec3 > &":
        return _simbody.RowVectorBaseVec3_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Vec3 > &":
        return _simbody.RowVectorBaseVec3_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseVec3_clear(self)

    def sum(self) -> "SimTK::Vec< 3,double,1 >":
        return _simbody.RowVectorBaseVec3_sum(self)

    def begin(self) -> "VectorIterator< SimTK::Vec< 3,double,1 >,SimTK::RowVectorBase< SimTK::Vec< 3,double,1 > > >":
        return _simbody.RowVectorBaseVec3_begin(self)

    def end(self) -> "VectorIterator< SimTK::Vec< 3,double,1 >,SimTK::RowVectorBase< SimTK::Vec< 3,double,1 > > >":
        return _simbody.RowVectorBaseVec3_end(self)

    def __getitem__(self, i: "int") -> "SimTK::Vec3":
        return _simbody.RowVectorBaseVec3___getitem__(self, i)

    def __setitem__(self, i: "int", value: "Vec3") -> "void":
        return _simbody.RowVectorBaseVec3___setitem__(self, i, value)
    __swig_destroy__ = _simbody.delete_RowVectorBaseVec3

# Register RowVectorBaseVec3 in _simbody:
_simbody.RowVectorBaseVec3_swigregister(RowVectorBaseVec3)

class RowVectorViewVec3(RowVectorBaseVec3):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorViewVec3"):
        _simbody.RowVectorViewVec3_swiginit(self, _simbody.new_RowVectorViewVec3(r))
    __swig_destroy__ = _simbody.delete_RowVectorViewVec3

# Register RowVectorViewVec3 in _simbody:
_simbody.RowVectorViewVec3_swigregister(RowVectorViewVec3)

class RowVectorVec3(RowVectorBaseVec3):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVectorVec3_swiginit(self, _simbody.new_RowVectorVec3(*args))

    def transpose(self) -> "SimTK::Vector_< SimTK::Vec3 >":
        return _simbody.RowVectorVec3_transpose(self)
    __swig_destroy__ = _simbody.delete_RowVectorVec3

# Register RowVectorVec3 in _simbody:
_simbody.RowVectorVec3_swigregister(RowVectorVec3)

class MatrixBaseVec6(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseVec6_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseVec6_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseVec6_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseVec6_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseVec6_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseVec6_swiginit(self, _simbody.new_MatrixBaseVec6(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseVec6_clear(self)

    def setTo(self, t: "Vec6") -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseVec6_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        return _simbody.MatrixBaseVec6_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        return _simbody.MatrixBaseVec6_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.MatrixBaseVec6_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.MatrixBaseVec6_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.MatrixBaseVec6_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.MatrixBaseVec6_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.MatrixBaseVec6___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "SimTK::Vec< 6,double,1 > const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseVec6_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "SimTK::Vec< 6,double,1 > &":
        return _simbody.MatrixBaseVec6_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        return _simbody.MatrixBaseVec6_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseVec6_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Vec6 > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseVec6_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseVec6_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseVec6_unlockShape(self)
    __swig_destroy__ = _simbody.delete_MatrixBaseVec6

# Register MatrixBaseVec6 in _simbody:
_simbody.MatrixBaseVec6_swigregister(MatrixBaseVec6)

class MatrixViewVec6(MatrixBaseVec6):
    r"""
    This class is identical to a Matrix_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Matrix_ is recast to a MatrixView_.
    However, there are no owner constructors for MatrixView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "MatrixViewVec6"):
        _simbody.MatrixViewVec6_swiginit(self, _simbody.new_MatrixViewVec6(m))

    def __iadd__(self, r: "Vec6") -> "SimTK::MatrixView_< SimTK::Vec6 > &":
        return _simbody.MatrixViewVec6___iadd__(self, r)

    def __isub__(self, r: "Vec6") -> "SimTK::MatrixView_< SimTK::Vec6 > &":
        return _simbody.MatrixViewVec6___isub__(self, r)
    __swig_destroy__ = _simbody.delete_MatrixViewVec6

# Register MatrixViewVec6 in _simbody:
_simbody.MatrixViewVec6_swigregister(MatrixViewVec6)

class MatrixVec6(MatrixBaseVec6):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixVec6_swiginit(self, _simbody.new_MatrixVec6(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixVec6_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Vec< 6,double,1 > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixVec6_get(self, i, j)

    def set(self, i: "int", j: "int", value: "Vec6") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixVec6_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixVec6

# Register MatrixVec6 in _simbody:
_simbody.MatrixVec6_swigregister(MatrixVec6)

class VectorBaseVec6(MatrixBaseVec6):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseVec6_swiginit(self, _simbody.new_VectorBaseVec6(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseVec6_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseVec6_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseVec6_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< SimTK::Vec6 > &":
        return _simbody.VectorBaseVec6_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< SimTK::Vec6 > &":
        return _simbody.VectorBaseVec6_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseVec6_clear(self)

    def sum(self) -> "SimTK::Vec< 6,double,1 >":
        return _simbody.VectorBaseVec6_sum(self)
    __swig_destroy__ = _simbody.delete_VectorBaseVec6

# Register VectorBaseVec6 in _simbody:
_simbody.VectorBaseVec6_swigregister(VectorBaseVec6)

class VectorViewVec6(VectorBaseVec6):
    r"""
    This class is identical to a Vector_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Vector_ is recast to a VectorView_.
    However, there are no owner constructors for VectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v: "VectorViewVec6"):
        _simbody.VectorViewVec6_swiginit(self, _simbody.new_VectorViewVec6(v))
    __swig_destroy__ = _simbody.delete_VectorViewVec6

# Register VectorViewVec6 in _simbody:
_simbody.VectorViewVec6_swigregister(VectorViewVec6)

class VectorVec6(VectorBaseVec6):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.VectorVec6_swiginit(self, _simbody.new_VectorVec6(*args))

    def toString(self) -> "std::string":
        return _simbody.VectorVec6_toString(self)

    def get(self, i: "int") -> "SimTK::Vec< 6,double,1 > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorVec6_get(self, i)

    def set(self, i: "int", value: "Vec6") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorVec6_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorVec6___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorVec6___len__(self)
    __swig_destroy__ = _simbody.delete_VectorVec6

# Register VectorVec6 in _simbody:
_simbody.VectorVec6_swigregister(VectorVec6)

class RowVectorBaseVec6(MatrixBaseVec6):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseVec6_swiginit(self, _simbody.new_RowVectorBaseVec6(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseVec6_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseVec6_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseVec6_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseVec6_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.RowVectorBaseVec6_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.RowVectorBaseVec6_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< SimTK::Vec< 6,double,1 > >":
        return _simbody.RowVectorBaseVec6___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< SimTK::Vec6 > const &":
        return _simbody.RowVectorBaseVec6___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Vec6 > &":
        return _simbody.RowVectorBaseVec6_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Vec6 > &":
        return _simbody.RowVectorBaseVec6_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseVec6_clear(self)

    def sum(self) -> "SimTK::Vec< 6,double,1 >":
        return _simbody.RowVectorBaseVec6_sum(self)

    def begin(self) -> "VectorIterator< SimTK::Vec< 6,double,1 >,SimTK::RowVectorBase< SimTK::Vec< 6,double,1 > > >":
        return _simbody.RowVectorBaseVec6_begin(self)

    def end(self) -> "VectorIterator< SimTK::Vec< 6,double,1 >,SimTK::RowVectorBase< SimTK::Vec< 6,double,1 > > >":
        return _simbody.RowVectorBaseVec6_end(self)
    __swig_destroy__ = _simbody.delete_RowVectorBaseVec6

# Register RowVectorBaseVec6 in _simbody:
_simbody.RowVectorBaseVec6_swigregister(RowVectorBaseVec6)

class RowVectorViewVec6(RowVectorBaseVec6):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorViewVec6"):
        _simbody.RowVectorViewVec6_swiginit(self, _simbody.new_RowVectorViewVec6(r))
    __swig_destroy__ = _simbody.delete_RowVectorViewVec6

# Register RowVectorViewVec6 in _simbody:
_simbody.RowVectorViewVec6_swigregister(RowVectorViewVec6)

class RowVectorVec6(RowVectorBaseVec6):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVectorVec6_swiginit(self, _simbody.new_RowVectorVec6(*args))
    __swig_destroy__ = _simbody.delete_RowVectorVec6

# Register RowVectorVec6 in _simbody:
_simbody.RowVectorVec6_swigregister(RowVectorVec6)

class MatrixBaseQuaternion(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseQuaternion_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseQuaternion_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseQuaternion_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseQuaternion_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseQuaternion_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseQuaternion_swiginit(self, _simbody.new_MatrixBaseQuaternion(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseQuaternion_clear(self)

    def setTo(self, t: "Quaternion") -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseQuaternion_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        return _simbody.MatrixBaseQuaternion_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        return _simbody.MatrixBaseQuaternion_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Quaternion_< double > >":
        return _simbody.MatrixBaseQuaternion_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Quaternion_< double > >":
        return _simbody.MatrixBaseQuaternion_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< SimTK::Quaternion_< double > >":
        return _simbody.MatrixBaseQuaternion_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< SimTK::Quaternion_< double > >":
        return _simbody.MatrixBaseQuaternion_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< SimTK::Quaternion_< double > >":
        return _simbody.MatrixBaseQuaternion___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "SimTK::Quaternion_< double > const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseQuaternion_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "SimTK::Quaternion_< double > &":
        return _simbody.MatrixBaseQuaternion_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        return _simbody.MatrixBaseQuaternion_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseQuaternion_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Quaternion_< double > > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseQuaternion_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseQuaternion_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseQuaternion_unlockShape(self)
    __swig_destroy__ = _simbody.delete_MatrixBaseQuaternion

# Register MatrixBaseQuaternion in _simbody:
_simbody.MatrixBaseQuaternion_swigregister(MatrixBaseQuaternion)

class MatrixQuaternion(MatrixBaseQuaternion):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixQuaternion_swiginit(self, _simbody.new_MatrixQuaternion(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixQuaternion_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Quaternion_< double > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixQuaternion_get(self, i, j)

    def set(self, i: "int", j: "int", value: "Quaternion") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixQuaternion_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixQuaternion

# Register MatrixQuaternion in _simbody:
_simbody.MatrixQuaternion_swigregister(MatrixQuaternion)

class VectorBaseQuaternion(MatrixBaseQuaternion):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseQuaternion_swiginit(self, _simbody.new_VectorBaseQuaternion(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseQuaternion_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseQuaternion_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseQuaternion_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< SimTK::Quaternion_< double > > &":
        return _simbody.VectorBaseQuaternion_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< SimTK::Quaternion_< double > > &":
        return _simbody.VectorBaseQuaternion_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseQuaternion_clear(self)

    def sum(self) -> "SimTK::Quaternion_< double >":
        return _simbody.VectorBaseQuaternion_sum(self)
    __swig_destroy__ = _simbody.delete_VectorBaseQuaternion

# Register VectorBaseQuaternion in _simbody:
_simbody.VectorBaseQuaternion_swigregister(VectorBaseQuaternion)

class VectorQuaternion(VectorBaseQuaternion):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.VectorQuaternion_swiginit(self, _simbody.new_VectorQuaternion(*args))

    def toString(self) -> "std::string":
        return _simbody.VectorQuaternion_toString(self)

    def get(self, i: "int") -> "SimTK::Quaternion_< double > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorQuaternion_get(self, i)

    def set(self, i: "int", value: "Quaternion") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorQuaternion_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorQuaternion___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorQuaternion___len__(self)
    __swig_destroy__ = _simbody.delete_VectorQuaternion

# Register VectorQuaternion in _simbody:
_simbody.VectorQuaternion_swigregister(VectorQuaternion)

class RowVectorBaseQuaternion(MatrixBaseQuaternion):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseQuaternion_swiginit(self, _simbody.new_RowVectorBaseQuaternion(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseQuaternion_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseQuaternion_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseQuaternion_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseQuaternion_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Quaternion_< double > >":
        return _simbody.RowVectorBaseQuaternion_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Quaternion_< double > >":
        return _simbody.RowVectorBaseQuaternion_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< SimTK::Quaternion_< double > >":
        return _simbody.RowVectorBaseQuaternion___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< SimTK::Quaternion_< double > > const &":
        return _simbody.RowVectorBaseQuaternion___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Quaternion_< double > > &":
        return _simbody.RowVectorBaseQuaternion_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Quaternion_< double > > &":
        return _simbody.RowVectorBaseQuaternion_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseQuaternion_clear(self)

    def sum(self) -> "SimTK::Quaternion_< double >":
        return _simbody.RowVectorBaseQuaternion_sum(self)

    def begin(self) -> "VectorIterator< SimTK::Quaternion_< double >,SimTK::RowVectorBase< SimTK::Quaternion_< double > > >":
        return _simbody.RowVectorBaseQuaternion_begin(self)

    def end(self) -> "VectorIterator< SimTK::Quaternion_< double >,SimTK::RowVectorBase< SimTK::Quaternion_< double > > >":
        return _simbody.RowVectorBaseQuaternion_end(self)
    __swig_destroy__ = _simbody.delete_RowVectorBaseQuaternion

# Register RowVectorBaseQuaternion in _simbody:
_simbody.RowVectorBaseQuaternion_swigregister(RowVectorBaseQuaternion)

class RowVectorViewQuaternion(RowVectorBaseQuaternion):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorViewQuaternion"):
        _simbody.RowVectorViewQuaternion_swiginit(self, _simbody.new_RowVectorViewQuaternion(r))
    __swig_destroy__ = _simbody.delete_RowVectorViewQuaternion

# Register RowVectorViewQuaternion in _simbody:
_simbody.RowVectorViewQuaternion_swigregister(RowVectorViewQuaternion)

class RowVectorQuaternion(RowVectorBaseQuaternion):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVectorQuaternion_swiginit(self, _simbody.new_RowVectorQuaternion(*args))
    __swig_destroy__ = _simbody.delete_RowVectorQuaternion

# Register RowVectorQuaternion in _simbody:
_simbody.RowVectorQuaternion_swigregister(RowVectorQuaternion)


def findRelativeVelocity(X_FA: "Transform const &", V_FA: "SpatialVec", X_FB: "Transform const &", V_FB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.findRelativeVelocity(X_FA, V_FA, X_FB, V_FB)

def findRelativeVelocityInF(p_AB_F: "Vec3", V_FA: "SpatialVec", V_FB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.findRelativeVelocityInF(p_AB_F, V_FA, V_FB)

def findRelativeAcceleration(X_FA: "Transform const &", V_FA: "SpatialVec", A_FA: "SpatialVec", X_FB: "Transform const &", V_FB: "SpatialVec", A_FB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.findRelativeAcceleration(X_FA, V_FA, A_FA, X_FB, V_FB, A_FB)

def findRelativeAccelerationInF(p_AB_F: "Vec3", V_FA: "SpatialVec", A_FA: "SpatialVec", V_FB: "SpatialVec", A_FB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.findRelativeAccelerationInF(p_AB_F, V_FA, A_FA, V_FB, A_FB)

def reverseRelativeVelocity(X_AB: "Transform const &", V_AB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.reverseRelativeVelocity(X_AB, V_AB)

def reverseRelativeVelocityInA(X_AB: "Transform const &", V_AB: "SpatialVec") -> "SimTK::SpatialVec":
    return _simbody.reverseRelativeVelocityInA(X_AB, V_AB)

def shiftVelocityBy(V_AB: "SpatialVec", r_A: "Vec3") -> "SimTK::SpatialVec":
    return _simbody.shiftVelocityBy(V_AB, r_A)

def shiftVelocityFromTo(V_A_BP: "SpatialVec", fromP_A: "Vec3", toQ_A: "Vec3") -> "SimTK::SpatialVec":
    return _simbody.shiftVelocityFromTo(V_A_BP, fromP_A, toQ_A)

def shiftForceBy(F_AP: "SpatialVec", r_A: "Vec3") -> "SimTK::SpatialVec":
    return _simbody.shiftForceBy(F_AP, r_A)

def shiftForceFromTo(F_AP: "SpatialVec", fromP_A: "Vec3", toQ_A: "Vec3") -> "SimTK::SpatialVec":
    return _simbody.shiftForceFromTo(F_AP, fromP_A, toQ_A)

def shiftAccelerationBy(A_AB: "SpatialVec", w_AB: "Vec3", r_A: "Vec3") -> "SimTK::SpatialVec":
    r"""
     Shift a relative spatial acceleration measured at some point to that
    same relative spatial quantity but measured at a new point given by an offset
    from the old one.

    :type A_AB: :py:class:`SpatialVec`, in
    :param A_AB:
            The relative spatial acceleration of frame B in frame A, measured and
            expressed in frame A.
    :type w_AB: :py:class:`Vec3`, in
    :param w_AB:
            The relative angular velocity of frame B in frame A, expressed in frame A.
    :type r_A: :py:class:`Vec3`, in
    :param r_A:
            The vector offset, expressed in frame A, by which to change the point at
            which the translational component of the relative spatial acceleration is
            measured.
    :rtype: :py:class:`SpatialVec`
    :return: A_A_BQ, the relative acceleration of frame B in frame A, but measured at
            the point Q=Bo+r rather than at B's origin Bo.

    Given the spatial acceleration A_AB and angular velocity w_AB of frame B in A,
    measured at a point coincident with B's origin Bo, change it to the spatial
    acceleration A_A_BQ representing the same relationship but with the acceleration
    measured at a new point Q=Bo+r for some position vector r. All vectors are
    measured and expressed in frame A, including the vector r. Example:

    .. code-block:: c++

            SpatialVec A_AB;     // assume these are known from somewhere
            Vec3       w_AB;
            Vec3       offset_A; // Q = Bo + offset

            SpatialVec A_A_BQ = shiftAccelerationBy(A_AB, w_AB, offset_A);

    Notes: The shift in location leaves the relative angular acceleration b the same
    but results in the linear acceleration changing by b X r + w X (w X r).

    Cost is 33 flops. See also: shiftAccelerationFromTo() *
    """
    return _simbody.shiftAccelerationBy(A_AB, w_AB, r_A)

def shiftAccelerationFromTo(A_A_BP: "SpatialVec", w_AB: "Vec3", fromP_A: "Vec3", toQ_A: "Vec3") -> "SimTK::SpatialVec":
    r"""
     Shift a relative spatial acceleration measured at some point P to
    that same relative spatial quantity but measured at a new point Q given the
    points P and Q.

    :type A_A_BP: :py:class:`SpatialVec`, in
    :param A_A_BP:
            The relative spatial acceleration of frame B in frame A, measured and
            expressed in frame A, with the linear component measured at a point P.
    :type w_AB: :py:class:`Vec3`, in
    :param w_AB:
            The relative angular velocity of frame B in frame A, expressed in frame A.
    :type fromP_A: :py:class:`Vec3`, in
    :param fromP_A:
            The "from" point P at which the input linear acceleration was
            measured, given as a vector from A's origin Ao to the point P,
            expressed in A.
    :type toQ_A: :py:class:`Vec3`, in
    :param toQ_A:
            The "to" point Q at which we want to re-measure the linear acceleration,
            given as a vector from A's origin Ao to the point Q, expressed
            in A.
    :rtype: :py:class:`SpatialVec`
    :return: A_A_BQ, the relative acceleration of frame B in frame A, but measured at
            the point Q rather than at point P.

    Given the spatial acceleration A_A_BP of frame B in A, measured at a point P,
    change it to the spatial acceleration A_A_BQ representing the same relationship
    but with the acceleration measured at a new point Q. Example:

    .. code-block:: c++

        assume these are known from somewhere
            Transform  X_AB;    // contains the vector from Ao to Bo
            SpatialVec A_AB;    // linear acceleration is measured at origin Bo of B
            Vec3       w_AB;
            Vec3       p_AQ;    // vector from Ao to some other point Q, in A

            SpatialVec A_A_BQ = shiftAccelerationFromTo(A_AB, w_AB, X_AB.p(), p_AQ);

    Notes: There is no way to know whether the supplied acceleration was
    actually measured at P; this method really just shifts the relative
    acceleration by the vector r=(to-from). Use it carefully.

    Cost is 36 flops. See also: shiftAccelerationBy() *
    """
    return _simbody.shiftAccelerationFromTo(A_A_BP, w_AB, fromP_A, toQ_A)
class SpatialVec(object):
    r"""
     This is a fixed length column vector designed for no-overhead inline
    computation.

    :param M:       The number of rows in the vector.
    :param ELT:     The element type. Must be a composite numerical type (CNT).
                            The default is ELT=Real.
    :param STRIDE:  The spacing from one element to the next in memory, as an
                            integer number of elements of type ELT. The default is
                            STRIDE=1.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def size() -> "int":
        r"""
        The number of elements in this Vec (note that stride does not
           affect this number.) *
        """
        return _simbody.SpatialVec_size()

    @staticmethod
    def nrow() -> "int":
        r""" The number of rows in a Vec is the number of elements. *"""
        return _simbody.SpatialVec_nrow()

    @staticmethod
    def ncol() -> "int":
        r""" The number of columns in a Vec is always 1. *"""
        return _simbody.SpatialVec_ncol()

    def __init__(self, *args):
        _simbody.SpatialVec_swiginit(self, _simbody.new_SpatialVec(*args))

    def setToNaN(self) -> "void":
        r"""
        Set every scalar in this %Vec to NaN; this is the default initial
           value in Debug builds, but not in Release. *
        """
        return _simbody.SpatialVec_setToNaN(self)

    def setToZero(self) -> "void":
        r""" Set every scalar in this %Vec to zero. *"""
        return _simbody.SpatialVec_setToZero(self)

    def isNaN(self) -> "bool":
        r""" Return true if any element of this Vec contains a NaN anywhere. *"""
        return _simbody.SpatialVec_isNaN(self)

    def isInf(self) -> "bool":
        r"""
        Return true if any element of this Vec contains a +Infinity
           or -Infinity somewhere but no element contains a NaN anywhere. *
        """
        return _simbody.SpatialVec_isInf(self)

    def isFinite(self) -> "bool":
        r"""
        Return true if no element of this %Vec contains an Infinity or a NaN
           anywhere. *
        """
        return _simbody.SpatialVec_isFinite(self)

    @staticmethod
    def getDefaultTolerance() -> "double":
        r"""
        For approximate comparisions, the default tolerance to use for a vector is
           the same as its elements' default tolerance. *
        """
        return _simbody.SpatialVec_getDefaultTolerance()

    def isNumericallyEqual(self, *args) -> "bool":
        r"""
        %Test whether every element of this vector is numerically equal to the given
           element, using either a specified tolerance or the vector's
           default tolerance (which is always the same or looser than the default
           tolerance for one of its elements). *
        """
        return _simbody.SpatialVec_isNumericallyEqual(self, *args)

    def toString(self) -> "std::string":
        r""" Print Vec into a string and return it.  Please refer to operator<< for details. *"""
        return _simbody.SpatialVec_toString(self)

    def set(self, i: "int", value: "Vec3") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.SpatialVec_set(self, i, value)

    def get(self, i: "int") -> "SimTK::Vec< 2,SimTK::Vec< 3,double,1 > >::E const &":
        r""" Variant of operator[] that's scripting friendly to get const reference to ith entry *"""
        return _simbody.SpatialVec_get(self, i)

    def __str__(self) -> "std::string":
        return _simbody.SpatialVec___str__(self)

    def __len__(self) -> "int":
        return _simbody.SpatialVec___len__(self)
    __swig_destroy__ = _simbody.delete_SpatialVec

# Register SpatialVec in _simbody:
_simbody.SpatialVec_swigregister(SpatialVec)

def SpatialVec_size() -> "int":
    r"""
    The number of elements in this Vec (note that stride does not
       affect this number.) *
    """
    return _simbody.SpatialVec_size()

def SpatialVec_nrow() -> "int":
    r""" The number of rows in a Vec is the number of elements. *"""
    return _simbody.SpatialVec_nrow()

def SpatialVec_ncol() -> "int":
    r""" The number of columns in a Vec is always 1. *"""
    return _simbody.SpatialVec_ncol()

def SpatialVec_getDefaultTolerance() -> "double":
    r"""
    For approximate comparisions, the default tolerance to use for a vector is
       the same as its elements' default tolerance. *
    """
    return _simbody.SpatialVec_getDefaultTolerance()

class VectorOfSpatialVec(object):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.VectorOfSpatialVec_swiginit(self, _simbody.new_VectorOfSpatialVec(*args))

    def toString(self) -> "std::string":
        return _simbody.VectorOfSpatialVec_toString(self)

    def get(self, i: "int") -> "SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorOfSpatialVec_get(self, i)

    def set(self, i: "int", value: "SpatialVec") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorOfSpatialVec_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorOfSpatialVec___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorOfSpatialVec___len__(self)
    __swig_destroy__ = _simbody.delete_VectorOfSpatialVec

# Register VectorOfSpatialVec in _simbody:
_simbody.VectorOfSpatialVec_swigregister(VectorOfSpatialVec)

class MatrixOfSpatialVec(object):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixOfSpatialVec_swiginit(self, _simbody.new_MatrixOfSpatialVec(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixOfSpatialVec_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixOfSpatialVec_get(self, i, j)

    def set(self, i: "int", j: "int", value: "SpatialVec") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixOfSpatialVec_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixOfSpatialVec

# Register MatrixOfSpatialVec in _simbody:
_simbody.MatrixOfSpatialVec_swigregister(MatrixOfSpatialVec)

BodyRotationSequence = _simbody.BodyRotationSequence
SpaceRotationSequence = _simbody.SpaceRotationSequence
class Rotation(Mat33):
    r"""
    The Rotation class is a Mat33 that guarantees that the matrix is a legitimate
    3x3 array associated with the relative orientation of two right-handed,
    orthogonal, unit vector bases. The Rotation class takes advantage of
    known properties of orthogonal matrices. For example, multiplication by a
    rotation matrix preserves a vector's length so unit vectors are still unit
    vectors afterwards and don't need to be re-normalized.

    A rotation is an orthogonal matrix whose columns and rows are directions
    (that is, unit vectors) that are mutually orthogonal. Furthermore, if the
    columns (or rows) are labeled x,y,z it always holds that z = x X y (rather
    than -(x X y)) ensuring that this is a right-handed rotation matrix and not
    a reflection. This is equivalent to saying that the determinant of a rotation
    matrix is 1, not -1.

    Suppose there is a vector v_F expressed in terms of the right-handed,
    orthogonal unit vectors Fx, Fy, Fz and one would like to express v instead
    as v_G, in terms of a right-handed, orthogonal unit vectors Gx, Gy, Gz. To
    calculate it, we form a rotation matrix R_GF whose columns are the F unit
    vectors re-expressed in G:

                G F   (      |      |      )
         R_GF =  R  = ( Fx_G | Fy_G | Fz_G )
                      (      |      |      )
    where
         Fx_G = ~( ~Fx*Gx, ~Fx*Gy, ~Fx*Gz ), etc.

    (~Fx*Gx means dot(Fx,Gx)). Note that we use "monogram" notation R_GF in
    code to represent the more typographically demanding superscripted notation
    for rotation matrices. Now we can re-express the vector v from frame F to
    frame G via

         v_G = R_GF * v_F.

    Because a rotation is orthogonal, its transpose is its inverse. Hence
    R_FG = ~R_GF (where ~ is the SimTK "transpose" operator). This transpose
    matrix can be used to expressed v_G in terms of Fx, Fy, Fz as

         v_F = R_FG * v_G  or  v_F = ~R_GF * v_G

    In either direction, correct behavior can be obtained by using the
    recommended notation and then matching up the frame labels (after
    interpreting the "~" operator as reversing the labels).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def setRotationToIdentityMatrix(self) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationToIdentityMatrix(self)

    def setRotationToNaN(self) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationToNaN(self)

    def setRotationFromAngleAboutAxis(self, angle: "double", axis: "CoordinateAxis") -> "SimTK::Rotation_< double > &":
        r""" Set this Rotation_ object to a right-handed rotation by an angle (in radians) about a coordinate axis."""
        return _simbody.Rotation_setRotationFromAngleAboutAxis(self, angle, axis)

    def setRotationFromAngleAboutX(self, *args) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationFromAngleAboutX(self, *args)

    def setRotationFromAngleAboutY(self, *args) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationFromAngleAboutY(self, *args)

    def setRotationFromAngleAboutZ(self, *args) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationFromAngleAboutZ(self, *args)

    def setRotationFromAngleAboutNonUnitVector(self, angle: "double", nonUnitVector: "Vec3") -> "SimTK::Rotation_< double > &":
        r""" Set this Rotation_ object to a right-handed rotation of an angle (in radians) about an arbitrary vector."""
        return _simbody.Rotation_setRotationFromAngleAboutNonUnitVector(self, angle, nonUnitVector)

    def setRotationFromTwoAnglesTwoAxes(self, bodyOrSpace: "SimTK::BodyOrSpaceType", angle1: "double", axis1: "CoordinateAxis", angle2: "double", axis2: "CoordinateAxis") -> "SimTK::Rotation_< double > &":
        r""" Set this Rotation_ object to a two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians)"""
        return _simbody.Rotation_setRotationFromTwoAnglesTwoAxes(self, bodyOrSpace, angle1, axis1, angle2, axis2)

    def setRotationFromThreeAnglesThreeAxes(self, bodyOrSpace: "SimTK::BodyOrSpaceType", angle1: "double", axis1: "CoordinateAxis", angle2: "double", axis2: "CoordinateAxis", angle3: "double", axis3: "CoordinateAxis") -> "SimTK::Rotation_< double > &":
        r""" Set this Rotation_ object to a three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians)"""
        return _simbody.Rotation_setRotationFromThreeAnglesThreeAxes(self, bodyOrSpace, angle1, axis1, angle2, axis2, angle3, axis3)

    def setRotationToBodyFixedXY(self, v: "Vec2") -> "void":
        r"""
        Set this Rotation_ to represent a rotation characterized by subsequent rotations of:
        +v[0] about the body frame's X axis,      followed by a rotation of
        +v[1] about the body frame's NEW Y axis.  See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3.
        """
        return _simbody.Rotation_setRotationToBodyFixedXY(self, v)

    def setRotationFromQuaternion(self, q: "Quaternion") -> "SimTK::Rotation_< double > &":
        r""" Method for creating a rotation matrix from a quaternion."""
        return _simbody.Rotation_setRotationFromQuaternion(self, q)

    def setRotationFromApproximateMat33(self, m: "Mat33") -> "SimTK::Rotation_< double > &":
        r""" Set this Rotation_ object to an (hopefully nearby) orthogonal rotation matrix from a generic Mat33."""
        return _simbody.Rotation_setRotationFromApproximateMat33(self, m)

    def setRotationFromOneAxis(self, uvec: "UnitVec3", axis: "CoordinateAxis") -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationFromOneAxis(self, uvec, axis)

    def setRotationFromTwoAxes(self, uveci: "UnitVec3", axisi: "CoordinateAxis", vecjApprox: "Vec3", axisjApprox: "CoordinateAxis") -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation_setRotationFromTwoAxes(self, uveci, axisi, vecjApprox, axisjApprox)

    def convertOneAxisRotationToOneAngle(self, axis1: "CoordinateAxis") -> "double":
        r"""
        Converts rotation matrix to a single orientation angle.
        Note:  The result is most meaningful if the Rotation_ matrix is one that can be produced by such a sequence.
        """
        return _simbody.Rotation_convertOneAxisRotationToOneAngle(self, axis1)

    def convertTwoAxesRotationToTwoAngles(self, bodyOrSpace: "SimTK::BodyOrSpaceType", axis1: "CoordinateAxis", axis2: "CoordinateAxis") -> "SimTK::Vec2":
        r"""
        Converts rotation matrix to two orientation angles.
        Note:  The result is most meaningful if the Rotation_ matrix is one that can be produced by such a sequence.
        """
        return _simbody.Rotation_convertTwoAxesRotationToTwoAngles(self, bodyOrSpace, axis1, axis2)

    def convertThreeAxesRotationToThreeAngles(self, bodyOrSpace: "SimTK::BodyOrSpaceType", axis1: "CoordinateAxis", axis2: "CoordinateAxis", axis3: "CoordinateAxis") -> "SimTK::Vec3":
        r"""
        Converts rotation matrix to three orientation angles.
        Note:  The result is most meaningful if the Rotation_ matrix is one that can be produced by such a sequence.
        """
        return _simbody.Rotation_convertThreeAxesRotationToThreeAngles(self, bodyOrSpace, axis1, axis2, axis3)

    def convertRotationToQuaternion(self) -> "SimTK::Quaternion_< double >":
        r""" Converts rotation matrix to a quaternion."""
        return _simbody.Rotation_convertRotationToQuaternion(self)

    def convertRotationToAngleAxis(self) -> "SimTK::Vec4":
        r""" Converts rotation matrix to angle-axis form."""
        return _simbody.Rotation_convertRotationToAngleAxis(self)

    def convertRotationToBodyFixedXY(self) -> "SimTK::Vec2":
        r""" A convenient special case of convertTwoAxesRotationToTwoAngles()."""
        return _simbody.Rotation_convertRotationToBodyFixedXY(self)

    def convertRotationToBodyFixedXYZ(self) -> "SimTK::Vec3":
        r""" A convenient special case of convertThreeAxesRotationToThreeAngles()."""
        return _simbody.Rotation_convertRotationToBodyFixedXYZ(self)

    def isSameRotationToWithinAngle(self, R: "Rotation", okPointingAngleErrorRads: "double") -> "bool":
        r"""
        Perform an efficient transform of a symmetric matrix that must be re-expressed with
        a multiply from both left and right, such as an inertia matrix. Details: assuming
        this Rotation is R_AB, and given a symmetric dyadic matrix S_BB expressed in B,
        we can reexpress it in A using S_AA=R_AB*S_BB*R_BA. The matrix should be one that
        is formed as products of vectors expressed in A, such as inertia, gyration or
        covariance matrices. This can be done efficiently exploiting properties of R
        (orthogonal) and S (symmetric). Total cost is 57 flops.
        Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error
        """
        return _simbody.Rotation_isSameRotationToWithinAngle(self, R, okPointingAngleErrorRads)

    def isSameRotationToWithinAngleOfMachinePrecision(self, R: "Rotation") -> "bool":
        return _simbody.Rotation_isSameRotationToWithinAngleOfMachinePrecision(self, R)

    def getMaxAbsDifferenceInRotationElements(self, R: "Rotation") -> "double":
        return _simbody.Rotation_getMaxAbsDifferenceInRotationElements(self, R)

    def areAllRotationElementsSameToEpsilon(self, R: "Rotation", epsilon: "double") -> "bool":
        return _simbody.Rotation_areAllRotationElementsSameToEpsilon(self, R, epsilon)

    def areAllRotationElementsSameToMachinePrecision(self, R: "Rotation") -> "bool":
        return _simbody.Rotation_areAllRotationElementsSameToMachinePrecision(self, R)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.

        |

        *Overload 2:*
        Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector.

        |

        *Overload 3:*
        Constructor for two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians)

        |

        *Overload 4:*
        Constructor for three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians)

        |

        *Overload 5:*
        Constructor for creating a rotation matrix from a quaternion.

        |

        *Overload 6:*
        Construct a Rotation_ directly from a Mat33 (we trust that m is a valid Rotation_!)

        |

        *Overload 7:*
        Constructs an (hopefully nearby) orthogonal rotation matrix from a generic Mat33.

        |

        *Overload 8:*
        Calculate R_AB by knowing one of B's unit vector expressed in A.
        Note: The other vectors are perpendicular (but somewhat arbitrarily so).

        |

        *Overload 9:*
        Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz)
        expressed in A and a vector v (also expressed in A) that is approximately in
        the desired direction for a second one of B's unit vectors, u2 (!= u1).
        If v is not perpendicular to u1, no worries - we'll find a direction for u2
        that is perpendicular to u1 and comes closest to v. The third vector u3
        is +/- u1 X u2, as appropriate for a right-handed rotation matrix.

        |

        *Overload 10:*
        Like copy constructor but for inverse rotation.  This allows implicit conversion from InverseRotation_ to Rotation_.
        """
        _simbody.Rotation_swiginit(self, _simbody.new_Rotation(*args))

    def invert(self) -> "SimTK::InverseRotation_< double > const &":
        r""" Convert from Rotation_ to InverseRotation_ (no cost). Overrides base class invert()."""
        return _simbody.Rotation_invert(self)

    def transpose(self) -> "SimTK::InverseRotation_< double > const &":
        r"""
        Convert from Rotation_ to writable InverseRotation_ (no cost).
        Transpose, and transpose operators. For an orthogonal matrix like this one, transpose
        is the same thing as inversion. These override the base class transpose methods.
        """
        return _simbody.Rotation_transpose(self)

    def __invert__(self, *args) -> "SimTK::InverseRotation_< double > &":
        return _simbody.Rotation___invert__(self, *args)

    def __imul__(self, *args) -> "SimTK::Rotation_< double > &":
        return _simbody.Rotation___imul__(self, *args)

    def __itruediv__(self, *args):
        return _simbody.Rotation___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def asMat33(self) -> "SimTK::Mat< 3,3,double > const &":
        r"""
        Conversion from Rotation to its base class Mat33.
        Note: asMat33 is more efficient than toMat33() (no copy), but you have to know the internal layout.
        """
        return _simbody.Rotation_asMat33(self)

    def toMat33(self) -> "SimTK::Mat< 3,3,double >":
        return _simbody.Rotation_toMat33(self)

    def setRotationToBodyFixedXYZ(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set this Rotation_ to represent a rotation characterized by subsequent rotations of:
        +v[0] about the body frame's X axis,      followed by a rotation of
        +v[1] about the body frame's NEW Y axis,  followed by a rotation of
        +v[2] about the body frame's NEW Z axis.  See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3.

        |

        *Overload 2:*
        Given cosines and sines (in that order) of three angles, set this
        Rotation matrix to the body-fixed 1-2-3 sequence of those angles.
        Cost is 18 flops.
        """
        return _simbody.Rotation_setRotationToBodyFixedXYZ(self, *args)

    @staticmethod
    def convertAngVelToBodyFixed321Dot(q: "Vec3", w_PB_B: "Vec3") -> "SimTK::Vec3":
        r"""
        Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative
        angular velocity vector of B in the parent frame, *BUT EXPRESSED IN
        THE BODY FRAME*, return the Euler angle
        derivatives. You are dead if q[1] gets near 90 degrees!
        See Kane's Spacecraft Dynamics, page 428, body-three: 3-2-1.
        """
        return _simbody.Rotation_convertAngVelToBodyFixed321Dot(q, w_PB_B)

    @staticmethod
    def convertBodyFixed321DotToAngVel(q: "Vec3", qd: "Vec3") -> "SimTK::Vec3":
        r"""
        Inverse of the above routine. Returned angular velocity is B in P,
        expressed in *B*: w_PB_B.
        """
        return _simbody.Rotation_convertBodyFixed321DotToAngVel(q, qd)

    @staticmethod
    def convertAngVelDotToBodyFixed321DotDot(q: "Vec3", w_PB_B: "Vec3", wdot_PB_B: "Vec3") -> "SimTK::Vec3":
        return _simbody.Rotation_convertAngVelDotToBodyFixed321DotDot(q, w_PB_B, wdot_PB_B)

    @staticmethod
    def calcNForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Given Euler angles q forming a body-fixed X-Y-Z sequence return the
        block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where
        w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!! Note that
        N_B=N_P*R_PB. This matrix will be singular if Y (q[1]) gets near 90
        degrees!
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        Cost: about 100 flops for sin/cos plus 12 to calculate N_B.
        See also: Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3.

        |

        *Overload 2:*
        This faster version of calcNForBodyXYZInBodyFrame() assumes you have
        already calculated the cosine and sine of the three q's. Note that we
        only look at the cosines and sines of q[1] and q[2]; q[0] does not
        matter so you don't have to fill in the 0'th element of cq and sq.
        Cost is one divide plus 6 flops, say 12 flops.
        """
        return _simbody.Rotation_calcNForBodyXYZInBodyFrame(*args)

    @staticmethod
    def calcNForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return
        the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where
        w_PB is the angular velocity of B in P expressed in P (not the
        convention that Kane uses, where angular velocities are expressed in
        the outboard body B). Note that N_P = N_B*~R_PB. This matrix will be
        singular if Y (q[1]) gets near 90 degrees!

        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        Cost: about 100 flops for sin/cos plus 12 to calculate N_P.

        |

        *Overload 2:*
        This faster version of calcNForBodyXYZInParentFrame() assumes you have
        already calculated the cosine and sine of the three q's. Note that we
        only look at the cosines and sines of q[0] and q[1]; q[2] does not
        matter so you don't have to fill in the 3rd element of cq and sq.
        Cost is one divide plus 6 flops, say 12 flops.
        See also: Paul Mitiguy
        """
        return _simbody.Rotation_calcNForBodyXYZInParentFrame(*args)

    @staticmethod
    def multiplyByBodyXYZ_N_P(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", w_PB: "Vec3") -> "SimTK::Vec3":
        r"""
        This is the fastest way to form the product qdot=N_P*w_PB for a
        body-fixed XYZ sequence where angular velocity of child in parent is
        expected to be expressed in the parent. Here we assume you have
        previously calculated sincos(qx), sincos(qy), and 1/cos(qy).
        Cost is 10 flops, faster even than the 15 it would take if you had saved
        N_P and then formed the N_P*w_PB product explicitly.
        """
        return _simbody.Rotation_multiplyByBodyXYZ_N_P(cosxy, sinxy, oocosy, w_PB)

    @staticmethod
    def multiplyByBodyXYZ_NT_P(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", q: "Vec3") -> "SimTK::Vec3":
        r"""
        This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P);
        see the untransposed method multiplyByBodyXYZ_N_P() for information.
        Cost is 9 flops.
        """
        return _simbody.Rotation_multiplyByBodyXYZ_NT_P(cosxy, sinxy, oocosy, q)

    @staticmethod
    def convertAngVelInParentToBodyXYZDot(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", w_PB: "Vec3") -> "SimTK::Vec3":
        r"""
        Calculate first time derivative qdot of body-fixed XYZ Euler angles q
        given sines and cosines of the Euler angles and the angular velocity
        w_PB of child B in parent P, expressed in P. Cost is 10 flops.

        Theory: calculate qdot=N_P(q)*w_PB using multiplyByBodyXYZ_N_P().
        See also: multiplyByBodyXYZ_N_P()
        """
        return _simbody.Rotation_convertAngVelInParentToBodyXYZDot(cosxy, sinxy, oocosy, w_PB)

    @staticmethod
    def convertAngAccInParentToBodyXYZDotDot(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", qdot: "Vec3", b_PB: "Vec3") -> "SimTK::Vec3":
        r"""
        Calculate second time derivative qdotdot of body-fixed XYZ Euler
        angles q given sines and cosines of the Euler angles, the first
        derivative qdot and the angular acceleration b_PB of child B in
        parent P, expressed in P. Cost is 22 flops.

        Theory: we have qdot=N_P*w_PB, which we differentiate in P to
        get qdotdot=N_P*b_PB + NDot_P*w_PB. Note that NDot_P=NDot_P(q,qdot)
        and w_PB=NInv_P*qdot (because N_P is invertible). We can then rewrite
        qdotdot=N_P*b_PB + NDot_P*(NInv_P*qdot) which can be calculated very
        efficiently. The second term is just an acceleration remainder term
        quadratic in qdot.
        """
        return _simbody.Rotation_convertAngAccInParentToBodyXYZDotDot(cosxy, sinxy, oocosy, qdot, b_PB)

    @staticmethod
    def multiplyByBodyXYZ_NInv_P(cosxy: "Vec2", sinxy: "Vec2", qdot: "Vec3") -> "SimTK::Vec3":
        r"""
        Fastest way to form the product w_PB=NInv_P*qdot. This is never
        singular. Cost is 9 flops.
        """
        return _simbody.Rotation_multiplyByBodyXYZ_NInv_P(cosxy, sinxy, qdot)

    @staticmethod
    def multiplyByBodyXYZ_NInvT_P(cosxy: "Vec2", sinxy: "Vec2", v_P: "Vec3") -> "SimTK::Vec3":
        r"""
        Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P).
        This is never singular. Cost is 10 flops.
        """
        return _simbody.Rotation_multiplyByBodyXYZ_NInvT_P(cosxy, sinxy, v_P)

    @staticmethod
    def calcNDotForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and
        their time derivatives qdot, return the block of the NDot matrix such
        that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity
        of B in P EXPRESSED IN *B*!!! This matrix will be singular if Y (q[1])
        gets near 90 degrees! See calcNForBodyXYZInBodyFrame() for the matrix
        we're differentiating here.
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        |

        *Overload 2:*
        This faster version of calcNDotForBodyXYZInBodyFrame() assumes you
        have already calculated the cosine and sine of the three q's. Note
        that we only look at the cosines and sines of q[1] and q[2]; q[0] does
        not matter so you don't have to fill in the 0'th element of cq and sq.
        Cost is one divide plus 21 flops.
        """
        return _simbody.Rotation_calcNDotForBodyXYZInBodyFrame(*args)

    @staticmethod
    def calcNDotForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and
        their time derivatives qdot, return the block of the NDot matrix such
        that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of
        B in P expressed in P. This matrix will be singular if Y (q[1]) gets
        near 90 degrees! See calcNForBodyXYZInParentFrame() for the matrix
        we're differentiating here.
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        |

        *Overload 2:*
        This faster version of calcNDotForBodyXYZInParentFrame() assumes you
        have already calculated the cosine and sine of the three q's. Note that
        we only look at the cosines and sines of q[0] and q[1].
        Cost is 21 flops.
        """
        return _simbody.Rotation_calcNDotForBodyXYZInParentFrame(*args)

    @staticmethod
    def calcNInvForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Inverse of routine calcNForBodyXYZInBodyFrame(). Return the inverse
        NInv_B of the N_B block computed above, such that w_PB_B=NInv_B(q)*qdot
        where w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!!
        (Kane's convention.) Note that NInv_B=~R_PB*NInv_P. This matrix is
        never singular.
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        |

        *Overload 2:*
        This faster version of calcNInvForBodyXYZInBodyFrame() assumes you have
        already calculated the cosine and sine of the three q's. Note that we
        only look at the cosines and sines of q[1] and q[2]; q[0] does not
        matter so you don't have to fill in the 0'th element of cq and sq.
        Cost is 3 flops.
        """
        return _simbody.Rotation_calcNInvForBodyXYZInBodyFrame(*args)

    @staticmethod
    def calcNInvForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
        r"""
        *Overload 1:*
        Inverse of the above routine. Return the inverse NInv_P of the N_P
        block computed above, such that w_PB=NInv_P(q)*qdot where w_PB is the
        angular velocity of B in P (expressed in P). Note that
        NInv_P=R_PB*NInv_B. This matrix is never singular.
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        |

        *Overload 2:*
        This faster version of calcNInvForBodyXYZInParentFrame() assumes you
        have already calculated the cosine and sine of the three q's. Note that
        we only look at the cosines and sines of q[0] and q[1]; q[2] does not
        matter so you don't have to fill in the 3rd element of cq and sq.
        Cost is 3 flops.
        """
        return _simbody.Rotation_calcNInvForBodyXYZInParentFrame(*args)

    @staticmethod
    def convertAngVelInBodyFrameToBodyXYZDot(*args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
        Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the
        relative angular velocity vector w_PB_B of B in the parent frame,
        **BUT EXPRESSED IN THE BODY FRAME**, return the Euler angle
        derivatives. You are dead if q[1] gets near 90 degrees!
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.
        See also: Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3.

        |

        *Overload 2:*
        This faster version of convertAngVelInBodyFrameToBodyXYZDot() assumes
        you have already calculated the cosine and sine of the three q's. Note
        that we only look at the cosines and sines of q[1] and q[2]; q[0] does
        not matter so you don't have to fill in the 0'th element of cq and sq.
        Cost is XXX.
        """
        return _simbody.Rotation_convertAngVelInBodyFrameToBodyXYZDot(*args)

    @staticmethod
    def convertBodyXYZDotToAngVelInBodyFrame(*args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
        Inverse of the above routine. Returned angular velocity is B in P,
        expressed in *B*: w_PB_B.
        Notes: This version is very expensive because it has to calculate sines
              and cosines. If you already have those, use the alternate form
              of this method.

        |

        *Overload 2:*
        This faster version of convertBodyXYZDotToAngVelInBodyFrame() assumes
        you have already calculated the cosine and sine of the three q's. Note
        that we only look at the cosines and sines of q[1] and q[2]; q[0] does
        not matter so you don't have to fill in the 0'th element of cq and sq.
        Cost is XXX flops.
        """
        return _simbody.Rotation_convertBodyXYZDotToAngVelInBodyFrame(*args)

    @staticmethod
    def convertAngVelDotInBodyFrameToBodyXYZDotDot(*args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
         TODO: sherm: is this right? Warning: everything is measured in the
        PARENT* frame, but has to be expressed in the *BODY* frame.
         Notes: This version is very expensive because it has to calculate sines
               and cosines. If you already have those, use the alternate form
               of this method.

        |

        *Overload 2:*
         This faster version of convertAngVelDotInBodyFrameToBodyXYZDotDot()
         assumes you have already calculated the cosine and sine of the three
         q's. Note that we only look at the cosines and sines of q[1] and q[2];
         q[0] does not matter so you don't have to fill in the 0'th element of
         cq and sq.
         Cost is XXX flops.
        """
        return _simbody.Rotation_convertAngVelDotInBodyFrameToBodyXYZDotDot(*args)

    @staticmethod
    def convertAngVelToQuaternionDot(q: "Vec4", w_PB_P: "Vec3") -> "SimTK::Vec4":
        r"""
        Given a possibly unnormalized quaternion (0th element is the scalar) and the
        relative angular velocity vector of B in its parent, expressed
        in the *PARENT*, return the quaternion derivatives. This is never singular.
        Cost is 27 flops.
        """
        return _simbody.Rotation_convertAngVelToQuaternionDot(q, w_PB_P)

    @staticmethod
    def convertQuaternionDotToAngVel(q: "Vec4", qdot: "Vec4") -> "SimTK::Vec3":
        r"""
        Inverse of the above routine. Returned AngVel is expressed in
        the *PARENT* frame: w_PB_P.
        Cost is 28 flops.
        """
        return _simbody.Rotation_convertQuaternionDotToAngVel(q, qdot)

    @staticmethod
    def convertAngVelDotToQuaternionDotDot(q: "Vec4", w_PB: "Vec3", b_PB: "Vec3") -> "SimTK::Vec4":
        r"""
        We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where
        b is angular acceleration wdot. Note that NDot=NDot(qdot), but it is
        far better to calculate the matrix-vector product NDot(N*w)*w directly
        rather than calculate NDot separately. That gives
        NDot*w = -(w^2)/4 * q
        Cost is 41 flops.
        """
        return _simbody.Rotation_convertAngVelDotToQuaternionDotDot(q, w_PB, b_PB)

    def multiply(self, *args) -> "SimTK::RowVector_< SimTK::Vec3 >":
        return _simbody.Rotation_multiply(self, *args)
    __swig_destroy__ = _simbody.delete_Rotation

# Register Rotation in _simbody:
_simbody.Rotation_swigregister(Rotation)

def Rotation_convertAngVelToBodyFixed321Dot(q: "Vec3", w_PB_B: "Vec3") -> "SimTK::Vec3":
    r"""
    Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative
    angular velocity vector of B in the parent frame, *BUT EXPRESSED IN
    THE BODY FRAME*, return the Euler angle
    derivatives. You are dead if q[1] gets near 90 degrees!
    See Kane's Spacecraft Dynamics, page 428, body-three: 3-2-1.
    """
    return _simbody.Rotation_convertAngVelToBodyFixed321Dot(q, w_PB_B)

def Rotation_convertBodyFixed321DotToAngVel(q: "Vec3", qd: "Vec3") -> "SimTK::Vec3":
    r"""
    Inverse of the above routine. Returned angular velocity is B in P,
    expressed in *B*: w_PB_B.
    """
    return _simbody.Rotation_convertBodyFixed321DotToAngVel(q, qd)

def Rotation_convertAngVelDotToBodyFixed321DotDot(q: "Vec3", w_PB_B: "Vec3", wdot_PB_B: "Vec3") -> "SimTK::Vec3":
    return _simbody.Rotation_convertAngVelDotToBodyFixed321DotDot(q, w_PB_B, wdot_PB_B)

def Rotation_calcNForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Given Euler angles q forming a body-fixed X-Y-Z sequence return the
    block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where
    w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!! Note that
    N_B=N_P*R_PB. This matrix will be singular if Y (q[1]) gets near 90
    degrees!
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    Cost: about 100 flops for sin/cos plus 12 to calculate N_B.
    See also: Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3.

    |

    *Overload 2:*
    This faster version of calcNForBodyXYZInBodyFrame() assumes you have
    already calculated the cosine and sine of the three q's. Note that we
    only look at the cosines and sines of q[1] and q[2]; q[0] does not
    matter so you don't have to fill in the 0'th element of cq and sq.
    Cost is one divide plus 6 flops, say 12 flops.
    """
    return _simbody.Rotation_calcNForBodyXYZInBodyFrame(*args)

def Rotation_calcNForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return
    the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where
    w_PB is the angular velocity of B in P expressed in P (not the
    convention that Kane uses, where angular velocities are expressed in
    the outboard body B). Note that N_P = N_B*~R_PB. This matrix will be
    singular if Y (q[1]) gets near 90 degrees!

    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    Cost: about 100 flops for sin/cos plus 12 to calculate N_P.

    |

    *Overload 2:*
    This faster version of calcNForBodyXYZInParentFrame() assumes you have
    already calculated the cosine and sine of the three q's. Note that we
    only look at the cosines and sines of q[0] and q[1]; q[2] does not
    matter so you don't have to fill in the 3rd element of cq and sq.
    Cost is one divide plus 6 flops, say 12 flops.
    See also: Paul Mitiguy
    """
    return _simbody.Rotation_calcNForBodyXYZInParentFrame(*args)

def Rotation_multiplyByBodyXYZ_N_P(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", w_PB: "Vec3") -> "SimTK::Vec3":
    r"""
    This is the fastest way to form the product qdot=N_P*w_PB for a
    body-fixed XYZ sequence where angular velocity of child in parent is
    expected to be expressed in the parent. Here we assume you have
    previously calculated sincos(qx), sincos(qy), and 1/cos(qy).
    Cost is 10 flops, faster even than the 15 it would take if you had saved
    N_P and then formed the N_P*w_PB product explicitly.
    """
    return _simbody.Rotation_multiplyByBodyXYZ_N_P(cosxy, sinxy, oocosy, w_PB)

def Rotation_multiplyByBodyXYZ_NT_P(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", q: "Vec3") -> "SimTK::Vec3":
    r"""
    This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P);
    see the untransposed method multiplyByBodyXYZ_N_P() for information.
    Cost is 9 flops.
    """
    return _simbody.Rotation_multiplyByBodyXYZ_NT_P(cosxy, sinxy, oocosy, q)

def Rotation_convertAngVelInParentToBodyXYZDot(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", w_PB: "Vec3") -> "SimTK::Vec3":
    r"""
    Calculate first time derivative qdot of body-fixed XYZ Euler angles q
    given sines and cosines of the Euler angles and the angular velocity
    w_PB of child B in parent P, expressed in P. Cost is 10 flops.

    Theory: calculate qdot=N_P(q)*w_PB using multiplyByBodyXYZ_N_P().
    See also: multiplyByBodyXYZ_N_P()
    """
    return _simbody.Rotation_convertAngVelInParentToBodyXYZDot(cosxy, sinxy, oocosy, w_PB)

def Rotation_convertAngAccInParentToBodyXYZDotDot(cosxy: "Vec2", sinxy: "Vec2", oocosy: "double", qdot: "Vec3", b_PB: "Vec3") -> "SimTK::Vec3":
    r"""
    Calculate second time derivative qdotdot of body-fixed XYZ Euler
    angles q given sines and cosines of the Euler angles, the first
    derivative qdot and the angular acceleration b_PB of child B in
    parent P, expressed in P. Cost is 22 flops.

    Theory: we have qdot=N_P*w_PB, which we differentiate in P to
    get qdotdot=N_P*b_PB + NDot_P*w_PB. Note that NDot_P=NDot_P(q,qdot)
    and w_PB=NInv_P*qdot (because N_P is invertible). We can then rewrite
    qdotdot=N_P*b_PB + NDot_P*(NInv_P*qdot) which can be calculated very
    efficiently. The second term is just an acceleration remainder term
    quadratic in qdot.
    """
    return _simbody.Rotation_convertAngAccInParentToBodyXYZDotDot(cosxy, sinxy, oocosy, qdot, b_PB)

def Rotation_multiplyByBodyXYZ_NInv_P(cosxy: "Vec2", sinxy: "Vec2", qdot: "Vec3") -> "SimTK::Vec3":
    r"""
    Fastest way to form the product w_PB=NInv_P*qdot. This is never
    singular. Cost is 9 flops.
    """
    return _simbody.Rotation_multiplyByBodyXYZ_NInv_P(cosxy, sinxy, qdot)

def Rotation_multiplyByBodyXYZ_NInvT_P(cosxy: "Vec2", sinxy: "Vec2", v_P: "Vec3") -> "SimTK::Vec3":
    r"""
    Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P).
    This is never singular. Cost is 10 flops.
    """
    return _simbody.Rotation_multiplyByBodyXYZ_NInvT_P(cosxy, sinxy, v_P)

def Rotation_calcNDotForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and
    their time derivatives qdot, return the block of the NDot matrix such
    that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity
    of B in P EXPRESSED IN *B*!!! This matrix will be singular if Y (q[1])
    gets near 90 degrees! See calcNForBodyXYZInBodyFrame() for the matrix
    we're differentiating here.
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    |

    *Overload 2:*
    This faster version of calcNDotForBodyXYZInBodyFrame() assumes you
    have already calculated the cosine and sine of the three q's. Note
    that we only look at the cosines and sines of q[1] and q[2]; q[0] does
    not matter so you don't have to fill in the 0'th element of cq and sq.
    Cost is one divide plus 21 flops.
    """
    return _simbody.Rotation_calcNDotForBodyXYZInBodyFrame(*args)

def Rotation_calcNDotForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and
    their time derivatives qdot, return the block of the NDot matrix such
    that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of
    B in P expressed in P. This matrix will be singular if Y (q[1]) gets
    near 90 degrees! See calcNForBodyXYZInParentFrame() for the matrix
    we're differentiating here.
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    |

    *Overload 2:*
    This faster version of calcNDotForBodyXYZInParentFrame() assumes you
    have already calculated the cosine and sine of the three q's. Note that
    we only look at the cosines and sines of q[0] and q[1].
    Cost is 21 flops.
    """
    return _simbody.Rotation_calcNDotForBodyXYZInParentFrame(*args)

def Rotation_calcNInvForBodyXYZInBodyFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Inverse of routine calcNForBodyXYZInBodyFrame(). Return the inverse
    NInv_B of the N_B block computed above, such that w_PB_B=NInv_B(q)*qdot
    where w_PB_B is the angular velocity of B in P EXPRESSED IN *B*!!!
    (Kane's convention.) Note that NInv_B=~R_PB*NInv_P. This matrix is
    never singular.
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    |

    *Overload 2:*
    This faster version of calcNInvForBodyXYZInBodyFrame() assumes you have
    already calculated the cosine and sine of the three q's. Note that we
    only look at the cosines and sines of q[1] and q[2]; q[0] does not
    matter so you don't have to fill in the 0'th element of cq and sq.
    Cost is 3 flops.
    """
    return _simbody.Rotation_calcNInvForBodyXYZInBodyFrame(*args)

def Rotation_calcNInvForBodyXYZInParentFrame(*args) -> "SimTK::Mat33":
    r"""
    *Overload 1:*
    Inverse of the above routine. Return the inverse NInv_P of the N_P
    block computed above, such that w_PB=NInv_P(q)*qdot where w_PB is the
    angular velocity of B in P (expressed in P). Note that
    NInv_P=R_PB*NInv_B. This matrix is never singular.
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    |

    *Overload 2:*
    This faster version of calcNInvForBodyXYZInParentFrame() assumes you
    have already calculated the cosine and sine of the three q's. Note that
    we only look at the cosines and sines of q[0] and q[1]; q[2] does not
    matter so you don't have to fill in the 3rd element of cq and sq.
    Cost is 3 flops.
    """
    return _simbody.Rotation_calcNInvForBodyXYZInParentFrame(*args)

def Rotation_convertAngVelInBodyFrameToBodyXYZDot(*args) -> "SimTK::Vec3":
    r"""
    *Overload 1:*
    Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the
    relative angular velocity vector w_PB_B of B in the parent frame,
    **BUT EXPRESSED IN THE BODY FRAME**, return the Euler angle
    derivatives. You are dead if q[1] gets near 90 degrees!
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.
    See also: Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3.

    |

    *Overload 2:*
    This faster version of convertAngVelInBodyFrameToBodyXYZDot() assumes
    you have already calculated the cosine and sine of the three q's. Note
    that we only look at the cosines and sines of q[1] and q[2]; q[0] does
    not matter so you don't have to fill in the 0'th element of cq and sq.
    Cost is XXX.
    """
    return _simbody.Rotation_convertAngVelInBodyFrameToBodyXYZDot(*args)

def Rotation_convertBodyXYZDotToAngVelInBodyFrame(*args) -> "SimTK::Vec3":
    r"""
    *Overload 1:*
    Inverse of the above routine. Returned angular velocity is B in P,
    expressed in *B*: w_PB_B.
    Notes: This version is very expensive because it has to calculate sines
          and cosines. If you already have those, use the alternate form
          of this method.

    |

    *Overload 2:*
    This faster version of convertBodyXYZDotToAngVelInBodyFrame() assumes
    you have already calculated the cosine and sine of the three q's. Note
    that we only look at the cosines and sines of q[1] and q[2]; q[0] does
    not matter so you don't have to fill in the 0'th element of cq and sq.
    Cost is XXX flops.
    """
    return _simbody.Rotation_convertBodyXYZDotToAngVelInBodyFrame(*args)

def Rotation_convertAngVelDotInBodyFrameToBodyXYZDotDot(*args) -> "SimTK::Vec3":
    r"""
    *Overload 1:*
     TODO: sherm: is this right? Warning: everything is measured in the
    PARENT* frame, but has to be expressed in the *BODY* frame.
     Notes: This version is very expensive because it has to calculate sines
           and cosines. If you already have those, use the alternate form
           of this method.

    |

    *Overload 2:*
     This faster version of convertAngVelDotInBodyFrameToBodyXYZDotDot()
     assumes you have already calculated the cosine and sine of the three
     q's. Note that we only look at the cosines and sines of q[1] and q[2];
     q[0] does not matter so you don't have to fill in the 0'th element of
     cq and sq.
     Cost is XXX flops.
    """
    return _simbody.Rotation_convertAngVelDotInBodyFrameToBodyXYZDotDot(*args)

def Rotation_convertAngVelToQuaternionDot(q: "Vec4", w_PB_P: "Vec3") -> "SimTK::Vec4":
    r"""
    Given a possibly unnormalized quaternion (0th element is the scalar) and the
    relative angular velocity vector of B in its parent, expressed
    in the *PARENT*, return the quaternion derivatives. This is never singular.
    Cost is 27 flops.
    """
    return _simbody.Rotation_convertAngVelToQuaternionDot(q, w_PB_P)

def Rotation_convertQuaternionDotToAngVel(q: "Vec4", qdot: "Vec4") -> "SimTK::Vec3":
    r"""
    Inverse of the above routine. Returned AngVel is expressed in
    the *PARENT* frame: w_PB_P.
    Cost is 28 flops.
    """
    return _simbody.Rotation_convertQuaternionDotToAngVel(q, qdot)

def Rotation_convertAngVelDotToQuaternionDotDot(q: "Vec4", w_PB: "Vec3", b_PB: "Vec3") -> "SimTK::Vec4":
    r"""
    We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where
    b is angular acceleration wdot. Note that NDot=NDot(qdot), but it is
    far better to calculate the matrix-vector product NDot(N*w)*w directly
    rather than calculate NDot separately. That gives
    NDot*w = -(w^2)/4 * q
    Cost is 41 flops.
    """
    return _simbody.Rotation_convertAngVelDotToQuaternionDotDot(q, w_PB, b_PB)

class InverseRotation(object):
    r"""
    -----------------------------------------------------------------------------
      This InverseRotation class is the inverse of a Rotation
      See the Rotation class for information.
    -----------------------------------------------------------------------------
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        You should not ever construct one of these as they should only occur as expression
        intermediates resulting from use of the "~" operator on a Rotation.
        But if you must, the default will produce an identity rotation.

        |

        *Overload 2:*
        This is an explicit implementation of the default copy constructor.
        """
        _simbody.InverseRotation_swiginit(self, _simbody.new_InverseRotation(*args))

    def invert(self) -> "SimTK::Rotation_< double > const &":
        r"""
        Assuming this InverseRotation_ is R_AB, and given a symmetric dyadic matrix S_BB expressed
        in B, we can reexpress it in A using S_AA=R_AB*S_BB*R_BA. The matrix should be one
        that is formed as products of vectors expressed in A, such as inertia, gyration or
        covariance matrices. This can be done efficiently exploiting properties of R and S.
        Cost is 57 flops.
        See also: Rotation::reexpressSymMat33()
        We can invert an InverseRotation just by recasting it to a Rotation at zero cost.
        """
        return _simbody.InverseRotation_invert(self)

    def transpose(self) -> "SimTK::Rotation_< double > const &":
        r"""
        Transpose, and transpose operators (override BaseMat versions of transpose).
        For an orthogonal matrix like this one transpose is the same as inverse.
        """
        return _simbody.InverseRotation_transpose(self)

    def __invert__(self, *args) -> "SimTK::Rotation_< double > &":
        return _simbody.InverseRotation___invert__(self, *args)
    __swig_destroy__ = _simbody.delete_InverseRotation

# Register InverseRotation in _simbody:
_simbody.InverseRotation_swigregister(InverseRotation)

class MatrixBaseMat33(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseMat33_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseMat33_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseMat33_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseMat33_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseMat33_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseMat33_swiginit(self, _simbody.new_MatrixBaseMat33(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseMat33_clear(self)

    def setTo(self, t: "Mat33") -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseMat33_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        return _simbody.MatrixBaseMat33_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        return _simbody.MatrixBaseMat33_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.MatrixBaseMat33_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.MatrixBaseMat33_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.MatrixBaseMat33_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.MatrixBaseMat33_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.MatrixBaseMat33___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "SimTK::Mat< 3,3,double,3,1 > const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseMat33_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "SimTK::Mat< 3,3,double,3,1 > &":
        return _simbody.MatrixBaseMat33_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        return _simbody.MatrixBaseMat33_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseMat33_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Mat33 > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseMat33_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseMat33_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseMat33_unlockShape(self)
    __swig_destroy__ = _simbody.delete_MatrixBaseMat33

# Register MatrixBaseMat33 in _simbody:
_simbody.MatrixBaseMat33_swigregister(MatrixBaseMat33)

class MatrixViewMat33(MatrixBaseMat33):
    r"""
    This class is identical to a Matrix_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Matrix_ is recast to a MatrixView_.
    However, there are no owner constructors for MatrixView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m: "MatrixViewMat33"):
        _simbody.MatrixViewMat33_swiginit(self, _simbody.new_MatrixViewMat33(m))

    def __iadd__(self, r: "Mat33") -> "SimTK::MatrixView_< SimTK::Mat33 > &":
        return _simbody.MatrixViewMat33___iadd__(self, r)

    def __isub__(self, r: "Mat33") -> "SimTK::MatrixView_< SimTK::Mat33 > &":
        return _simbody.MatrixViewMat33___isub__(self, r)
    __swig_destroy__ = _simbody.delete_MatrixViewMat33

# Register MatrixViewMat33 in _simbody:
_simbody.MatrixViewMat33_swigregister(MatrixViewMat33)

class MatrixMat33(MatrixBaseMat33):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixMat33_swiginit(self, _simbody.new_MatrixMat33(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixMat33_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Mat< 3,3,double,3,1 > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixMat33_get(self, i, j)

    def set(self, i: "int", j: "int", value: "Mat33") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixMat33_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixMat33

# Register MatrixMat33 in _simbody:
_simbody.MatrixMat33_swigregister(MatrixMat33)

class VectorBaseMat33(MatrixBaseMat33):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseMat33_swiginit(self, _simbody.new_VectorBaseMat33(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseMat33_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseMat33_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseMat33_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< SimTK::Mat33 > &":
        return _simbody.VectorBaseMat33_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< SimTK::Mat33 > &":
        return _simbody.VectorBaseMat33_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseMat33_clear(self)

    def sum(self) -> "SimTK::Mat< 3,3,double,3,1 >":
        return _simbody.VectorBaseMat33_sum(self)
    __swig_destroy__ = _simbody.delete_VectorBaseMat33

# Register VectorBaseMat33 in _simbody:
_simbody.VectorBaseMat33_swigregister(VectorBaseMat33)

class VectorViewMat33(VectorBaseMat33):
    r"""
    This class is identical to a Vector_; it is used only to manage the C++ rules
    for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a Vector_ is recast to a VectorView_.
    However, there are no owner constructors for VectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, v: "VectorViewMat33"):
        _simbody.VectorViewMat33_swiginit(self, _simbody.new_VectorViewMat33(v))
    __swig_destroy__ = _simbody.delete_VectorViewMat33

# Register VectorViewMat33 in _simbody:
_simbody.VectorViewMat33_swigregister(VectorViewMat33)

class VectorMat33(VectorBaseMat33):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.VectorMat33_swiginit(self, _simbody.new_VectorMat33(*args))

    def toString(self) -> "std::string":
        return _simbody.VectorMat33_toString(self)

    def get(self, i: "int") -> "SimTK::Mat< 3,3,double,3,1 > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorMat33_get(self, i)

    def set(self, i: "int", value: "Mat33") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorMat33_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorMat33___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorMat33___len__(self)
    __swig_destroy__ = _simbody.delete_VectorMat33

# Register VectorMat33 in _simbody:
_simbody.VectorMat33_swigregister(VectorMat33)

class RowVectorBaseMat33(MatrixBaseMat33):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseMat33_swiginit(self, _simbody.new_RowVectorBaseMat33(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseMat33_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseMat33_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseMat33_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseMat33_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.RowVectorBaseMat33_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.RowVectorBaseMat33_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< SimTK::Mat< 3,3,double,3,1 > >":
        return _simbody.RowVectorBaseMat33___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< SimTK::Mat33 > const &":
        return _simbody.RowVectorBaseMat33___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Mat33 > &":
        return _simbody.RowVectorBaseMat33_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Mat33 > &":
        return _simbody.RowVectorBaseMat33_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseMat33_clear(self)

    def sum(self) -> "SimTK::Mat< 3,3,double,3,1 >":
        return _simbody.RowVectorBaseMat33_sum(self)

    def begin(self) -> "VectorIterator< SimTK::Mat< 3,3,double,3,1 >,SimTK::RowVectorBase< SimTK::Mat< 3,3,double,3,1 > > >":
        return _simbody.RowVectorBaseMat33_begin(self)

    def end(self) -> "VectorIterator< SimTK::Mat< 3,3,double,3,1 >,SimTK::RowVectorBase< SimTK::Mat< 3,3,double,3,1 > > >":
        return _simbody.RowVectorBaseMat33_end(self)
    __swig_destroy__ = _simbody.delete_RowVectorBaseMat33

# Register RowVectorBaseMat33 in _simbody:
_simbody.RowVectorBaseMat33_swigregister(RowVectorBaseMat33)

class RowVectorViewMat33(RowVectorBaseMat33):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorViewMat33"):
        _simbody.RowVectorViewMat33_swiginit(self, _simbody.new_RowVectorViewMat33(r))
    __swig_destroy__ = _simbody.delete_RowVectorViewMat33

# Register RowVectorViewMat33 in _simbody:
_simbody.RowVectorViewMat33_swigregister(RowVectorViewMat33)

class RowVectorMat33(RowVectorBaseMat33):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVectorMat33_swiginit(self, _simbody.new_RowVectorMat33(*args))
    __swig_destroy__ = _simbody.delete_RowVectorMat33

# Register RowVectorMat33 in _simbody:
_simbody.RowVectorMat33_swigregister(RowVectorMat33)

class MatrixBaseRotation(object):
    r"""
    This file defines the client side of the SimTK::Matrix classes, which
    hold medium to large, variable-sized matrices whose elements are packed
    SimTK "Composite Numerical Types" (CNTs). Unlike CNTs, the implemention here
    is opaque, and almost all properties are captured in the implementation at
    run time rather than in the type at compile time.

    Every Matrix consists logically of three pieces:
     - the matrix handle
     - the matrix helper
     - and the matrix data.

    They are organized like this:

         ------------            ------------
        |  Handle<E> | -------> |            |
         ------------  <------- | Helper<S>  |
                                |            |
                                |            |          --------~ ~--
                                |            | ------> | Data<S> ... |
                                 ------------           --------~ ~--

    The handle is the object actually appearing in SimTK API user programs.
    It always consists of just a single pointer, pointing to a library-side
    "helper" object whose implementation is opaque. The handle is templatized
    by the user's element type, which may be any packed composite numerical
    type, including scalar types like ``float`` and ``complex``<double>, but also
    composite types such as ``Vec3`` or ``Mat``<2,2,Mat<3,3>>. A Matrix handle
    owns the helper to which it points and must destruct the helper when
    the handle's destructor is called.

    The helper, on the other hand, is parameterized only by the underlying scalar
    type. There are exactly 12 SimTK scalar types, so all can be instantiated on
    the library side leaving the implementation opaque and thus flexible from
    release to release without compromising binary compatibility. (The scalar
    types are: the four C++ standard types float and double,
    complex<float>, and complex<double>; the SimTK numbers conjugate<float> and
    conjugate<double>; and negator<> types templatized by any of the six
    numeric types.) The helper contains several kinds of information:
     - the underlying scalar type S (as its template parameter)
     - the number of scalars in the handle's logical element type E
     - whether this is an owner matrix, or just a view
     - the handle "commitment"; defining the range of matrix characteristics
         to which that handle may refer
     - the actual characteristics of the matrix currently represented by
         the helper
     - a virtual function table full of methods which are aware of the
         logical structure of the Matrix and the physical structure of
         the data to support operations such as element indexing
     - a pointer to the underlying data, which may be shared with other
         helpers

    The data itself consists only of scalars
    S of the same type as the helper's template argument, but different
    helpers can look at the same data differently. For examples, when the
    elements are composite consisting of k scalars, the helper will provide a
    view of the data in which its scalars are interpreted in groups of k.
    Many other reinterpretations of the data are possible and useful, such
    as a real-valued helper viewing only the real or imaginary part of
    complex data, or a helper which views the data order as though it were
    transposed.

    At most *one* matrix helper owns the matrix data and is responsible
    for deleting that data when no longer needed. That is called an "owner"
    helper and its associated handle is an owner handle. Normally the owner
    is the handle (and helper) that allocated the data, and
    in most cases an owner can resize the data at will. Many other handles
    may reference the same data; those non-owner handles are called "views".
    Every view may present a different picture of the underlying data. The
    default view is "whole" meaning that all the elements of the data are
    visible, and appear in their normal order. A "transpose" view also shows
    all the elements but the matrix dimensions and indices are reversed.
    Other common views are "block" to select a sub-block of a matrix, and
    "diagonal" which shows only the diagonal of a matrix (as a vector).

    NOTE: Destruction of an owner destructs the data it owns
    *regardless* of the presence of other views into that data! I.e., these
    are not reference counted. TODO: should we change that?

    In some cases there may be no owner helper for a particular piece of
    matrix data. That occurs when pre-existing memory, such as a Fortran
    array, is used to construct a Matrix. In that case all the helpers are
    views and the data will persist after the destruction of the last
    referencing helper.

    A Matrix that is the owner of its data will be resized whenever
    necessary, unless you take active steps to prevent that. For example, if
    you declare a Vector, the number of rows can resize but the number of
    columns will be locked at 1. A RowVector does the reverse. You can also
    explicitly lock the number of rows and/or columns of a matrix to prevent
    unwanted resizes.

    Here are the classes and short descriptions:

      MatrixHelper<S>  interface to the opaque implementation, templatized
                         by scalar type only
      MatrixBase<CNT>  fully templatized client, contains a MatrixHelper


    The rest are dataless classes all of which can be interconverted just
    by recasting. Every one of these classes has a default conversion to
    type Matrix_<same element type>, so users can write functions that expect
    a Matrix argument and pass it a Vector, RowVectorView, or whatever.


      VectorBase<CNT>    these are derived from MatrixBase and add no new data,
      RowVectorBase<CNT> but change some of the operators and other methods to
                           be appropriate for 1d data.

      Matrix_<CNT>      2d owner class     (a MatrixBase<CNT>)
      Vector_<CNT>      column owner class (a VectorBase<CNT>)
      RowVector_<CNT>   row owner class    (a RowVectorBase<CNT>)


    Views are exactly the same as the corresponding owner class, but with
    shallow construction and assignment semantics.


      MatrixView_<CNT>, VectorView_<CNT>, RowVectorView_<CNT>


    Dead matrices are owners that are about to be destructed. Anything
    they own may be taken from them, including the helper and/or
    the data. This is a very effective performance trick for sequences
    of operations since it eliminates most of the need for allocating and
    deallocating temporaries.


      DeadMatrix_<CNT>, DeadVector_<CNT>, DeadRowVector_<CNT>

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def nrow(self) -> "int":
        r""" Return the number of rows m in the logical shape of this matrix."""
        return _simbody.MatrixBaseRotation_nrow(self)

    def ncol(self) -> "int":
        r""" Return the number of columns n in the logical shape of this matrix."""
        return _simbody.MatrixBaseRotation_ncol(self)

    def isResizeable(self) -> "bool":
        r""" Return true if either dimension of this Matrix is resizable."""
        return _simbody.MatrixBaseRotation_isResizeable(self)
    NScalarsPerElement = _simbody.MatrixBaseRotation_NScalarsPerElement
    CppNScalarsPerElement = _simbody.MatrixBaseRotation_CppNScalarsPerElement

    def __init__(self, *args):
        r"""
        *Overload 1:*
        The default constructor builds a 0x0 matrix managed by a helper that
        understands how many scalars there are in one of our elements but is
        otherwise uncommitted.

        |

        *Overload 2:*
        This constructor allocates the default matrix a completely uncommitted
        matrix commitment, given particular initial dimensions.
        """
        _simbody.MatrixBaseRotation_swiginit(self, _simbody.new_MatrixBaseRotation(*args))

    def clear(self) -> "void":
        r"""
        This restores the MatrixBase to the state it would be in had it
        been constructed specifying only its handle commitment. The size will
        have been reduced to the smallest size consistent with the commitment.
        """
        return _simbody.MatrixBaseRotation_clear(self)

    def setTo(self, t: "Rotation") -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        r""" Fill every element in current allocation with given element (or NaN or 0)."""
        return _simbody.MatrixBaseRotation_setTo(self, t)

    def setToNaN(self) -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        return _simbody.MatrixBaseRotation_setToNaN(self)

    def setToZero(self) -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        return _simbody.MatrixBaseRotation_setToZero(self)

    def row(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Rotation_< double > >":
        return _simbody.MatrixBaseRotation_row(self, i)

    def updRow(self, i: "int") -> "SimTK::RowVectorView_< SimTK::Rotation_< double > >":
        return _simbody.MatrixBaseRotation_updRow(self, i)

    def col(self, j: "int") -> "SimTK::VectorView_< SimTK::Rotation_< double > >":
        return _simbody.MatrixBaseRotation_col(self, j)

    def updCol(self, j: "int") -> "SimTK::VectorView_< SimTK::Rotation_< double > >":
        return _simbody.MatrixBaseRotation_updCol(self, j)

    def __call__(self, *args) -> "SimTK::VectorView_< SimTK::Rotation_< double > >":
        return _simbody.MatrixBaseRotation___call__(self, *args)

    def getElt(self, i: "int", j: "int") -> "SimTK::Rotation_< double > const &":
        r"""
        Element selection for stored elements. These are the fastest element access
        methods but may not be able to access all elements of the logical matrix when
        some of its elements are not stored in memory. For example, a Hermitian matrix
        stores only half its elements and other ones have to be calculated by conjugation
        if they are to be returned as type ELT. (You can get them for free by recasting
        the matrix so that the elements are reinterpreted as conjugates.) If you want
        to guarantee that you can access the value of every element of a matrix, stored or not,
        use getAnyElt() instead.
        """
        return _simbody.MatrixBaseRotation_getElt(self, i, j)

    def updElt(self, i: "int", j: "int") -> "SimTK::Rotation_< double > &":
        return _simbody.MatrixBaseRotation_updElt(self, i, j)

    def negateInPlace(self) -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        return _simbody.MatrixBaseRotation_negateInPlace(self)

    def resize(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        r"""
        Change the size of this matrix. This is only allowed for owner matrices. The
        current storage format is retained, but all the data is lost. If you want
        to keep the old data, use resizeKeep().
        See also: resizeKeep()
        """
        return _simbody.MatrixBaseRotation_resize(self, m, n)

    def resizeKeep(self, m: "int", n: "int") -> "SimTK::MatrixBase< SimTK::Rotation_< double > > &":
        r"""
        Change the size of this matrix, retaining as much of the old data as will
        fit. This is only allowed for owner matrices. The
        current storage format is retained, and the existing data is copied
        into the new memory to the extent that it will fit.
        See also: resize()
        """
        return _simbody.MatrixBaseRotation_resizeKeep(self, m, n)

    def lockShape(self) -> "void":
        return _simbody.MatrixBaseRotation_lockShape(self)

    def unlockShape(self) -> "void":
        return _simbody.MatrixBaseRotation_unlockShape(self)
    __swig_destroy__ = _simbody.delete_MatrixBaseRotation

# Register MatrixBaseRotation in _simbody:
_simbody.MatrixBaseRotation_swigregister(MatrixBaseRotation)

class MatrixRotation(MatrixBaseRotation):
    r"""
    This is the Matrix class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner itself.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.MatrixRotation_swiginit(self, _simbody.new_MatrixRotation(*args))

    def toString(self) -> "std::string":
        return _simbody.MatrixRotation_toString(self)

    def get(self, i: "int", j: "int") -> "SimTK::Rotation_< double > const &":
        r""" Variant of indexing operator that's scripting friendly to get entry (i, j) *"""
        return _simbody.MatrixRotation_get(self, i, j)

    def set(self, i: "int", j: "int", value: "Rotation") -> "void":
        r""" Variant of indexing operator that's scripting friendly to set entry (i, j) *"""
        return _simbody.MatrixRotation_set(self, i, j, value)
    __swig_destroy__ = _simbody.delete_MatrixRotation

# Register MatrixRotation in _simbody:
_simbody.MatrixRotation_swigregister(MatrixRotation)

class VectorBaseRotation(MatrixBaseRotation):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for Vectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new VectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are m X 1 with the number of columns locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 0x1 matrix locked at 1 column; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.
        """
        _simbody.VectorBaseRotation_swiginit(self, _simbody.new_VectorBaseRotation(*args))

    def size(self) -> "int":
        return _simbody.VectorBaseRotation_size(self)

    def nrow(self) -> "int":
        return _simbody.VectorBaseRotation_nrow(self)

    def ncol(self) -> "int":
        return _simbody.VectorBaseRotation_ncol(self)

    def resize(self, m: "int") -> "SimTK::VectorBase< SimTK::Rotation_< double > > &":
        return _simbody.VectorBaseRotation_resize(self, m)

    def resizeKeep(self, m: "int") -> "SimTK::VectorBase< SimTK::Rotation_< double > > &":
        return _simbody.VectorBaseRotation_resizeKeep(self, m)

    def clear(self) -> "void":
        return _simbody.VectorBaseRotation_clear(self)

    def sum(self) -> "SimTK::Rotation_< double >":
        return _simbody.VectorBaseRotation_sum(self)
    __swig_destroy__ = _simbody.delete_VectorBaseRotation

# Register VectorBaseRotation in _simbody:
_simbody.VectorBaseRotation_swigregister(VectorBaseRotation)

class VectorRotation(VectorBaseRotation):
    r"""
    This is the Vector class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one column.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.VectorRotation_swiginit(self, _simbody.new_VectorRotation(*args))

    def toString(self) -> "std::string":
        return _simbody.VectorRotation_toString(self)

    def get(self, i: "int") -> "SimTK::Rotation_< double > const &":
        r""" Variant of operator[] that's scripting friendly to get ith entry *"""
        return _simbody.VectorRotation_get(self, i)

    def set(self, i: "int", value: "Rotation") -> "void":
        r""" Variant of operator[] that's scripting friendly to set ith entry *"""
        return _simbody.VectorRotation_set(self, i, value)

    def __str__(self) -> "std::string":
        return _simbody.VectorRotation___str__(self)

    def __len__(self) -> "int":
        return _simbody.VectorRotation___len__(self)
    __swig_destroy__ = _simbody.delete_VectorRotation

# Register VectorRotation in _simbody:
_simbody.VectorRotation_swigregister(VectorRotation)

class RowVectorBaseRotation(MatrixBaseRotation):
    r"""
    This is a dataless rehash of the MatrixBase class to specialize it for RowVectors.
    This mostly entails overriding a few of the methods. Note that all the MatrixBase
    operations remain available if you static_cast<> this up to a MatrixBase.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        These constructors create new RowVectorBase objects which own their
        own data and are (at least by default) resizable. The resulting matrices
        are 1 x n with the number of rows locked at 1. If there is any data
        allocated but not explicitly initialized, that data will be uninitialized
        garbage in Release builds but will be initialized to NaN (at a performance
        cost) in Debug builds.

        Default constructor makes a 1x0 matrix locked at 1 row; you can
        provide an initial allocation if you want.

        |

        *Overload 2:*
        Copy constructor is a deep copy (not appropriate for views!). That
        means it creates a new, densely packed vector whose elements are
        initialized from the source object.

        |

        *Overload 3:*
        Construct an owner row vector of length n, with each element initialized to
        the given value.

        |

        *Overload 4:*
        Construct an owner vector of length n, with the elements initialized sequentially
        from a C++ array of elements which is assumed to be of length n. Note that we
        are expecting C++ packing; don't use this to initialize one Simmatrix vector
        from another because Simmatrix may pack its elements more densely than C++.
        """
        _simbody.RowVectorBaseRotation_swiginit(self, _simbody.new_RowVectorBaseRotation(*args))

    def size(self) -> "int":
        return _simbody.RowVectorBaseRotation_size(self)

    def nrow(self) -> "int":
        return _simbody.RowVectorBaseRotation_nrow(self)

    def ncol(self) -> "int":
        return _simbody.RowVectorBaseRotation_ncol(self)

    def nelt(self) -> "ptrdiff_t":
        return _simbody.RowVectorBaseRotation_nelt(self)

    def index(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Rotation_< double > >":
        return _simbody.RowVectorBaseRotation_index(self, indices)

    def updIndex(self, indices: "Array_< int > const &") -> "SimTK::RowVectorView_< SimTK::Rotation_< double > >":
        return _simbody.RowVectorBaseRotation_updIndex(self, indices)

    def __call__(self, *args) -> "SimTK::RowVectorView_< SimTK::Rotation_< double > >":
        return _simbody.RowVectorBaseRotation___call__(self, *args)

    def __pos__(self) -> "SimTK::RowVectorBase< SimTK::Rotation_< double > > const &":
        return _simbody.RowVectorBaseRotation___pos__(self)

    def resize(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Rotation_< double > > &":
        return _simbody.RowVectorBaseRotation_resize(self, n)

    def resizeKeep(self, n: "int") -> "SimTK::RowVectorBase< SimTK::Rotation_< double > > &":
        return _simbody.RowVectorBaseRotation_resizeKeep(self, n)

    def clear(self) -> "void":
        return _simbody.RowVectorBaseRotation_clear(self)

    def sum(self) -> "SimTK::Rotation_< double >":
        return _simbody.RowVectorBaseRotation_sum(self)

    def begin(self) -> "VectorIterator< SimTK::Rotation_< double >,SimTK::RowVectorBase< SimTK::Rotation_< double > > >":
        return _simbody.RowVectorBaseRotation_begin(self)

    def end(self) -> "VectorIterator< SimTK::Rotation_< double >,SimTK::RowVectorBase< SimTK::Rotation_< double > > >":
        return _simbody.RowVectorBaseRotation_end(self)
    __swig_destroy__ = _simbody.delete_RowVectorBaseRotation

# Register RowVectorBaseRotation in _simbody:
_simbody.RowVectorBaseRotation_swigregister(RowVectorBaseRotation)

class RowVectorViewRotation(RowVectorBaseRotation):
    r"""
    This class is identical to a RowVector_; it is used only to manage the C++
    rules for when copy constructors are called by introducing a separate type to
    prevent certain allowed optimizations from occuring when we don't want them.
    Despite the name, this may be an owner if a RowVector_ is recast to a
    RowVectorView_. However, there are no owner constructors for RowVectorView_.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, r: "RowVectorViewRotation"):
        _simbody.RowVectorViewRotation_swiginit(self, _simbody.new_RowVectorViewRotation(r))
    __swig_destroy__ = _simbody.delete_RowVectorViewRotation

# Register RowVectorViewRotation in _simbody:
_simbody.RowVectorViewRotation_swigregister(RowVectorViewRotation)

class RowVectorRotation(RowVectorBaseRotation):
    r"""
    RowVectors are much less common than Vectors. However, if a Simmatrix user
    wants one, this is the class intended to appear in user code. It can be a
    fixed-size view of someone else's data, or can be a resizable data owner
    itself, although of course it will always have just one row.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.RowVectorRotation_swiginit(self, _simbody.new_RowVectorRotation(*args))
    __swig_destroy__ = _simbody.delete_RowVectorRotation

# Register RowVectorRotation in _simbody:
_simbody.RowVectorRotation_swigregister(RowVectorRotation)

class Transform(object):
    r"""
    This class represents the rotate-and-shift transform which gives the
    location and orientation of a new frame F in a base (reference) frame
    B. A frame is an orthogonal, right-handed set of three axes, and an
    origin point. A transform X from frame B to F consists of 3 perpendicular
    unit vectors defining F's axes as viewed from B (that is, as expressed in
    the basis formed by B's axes), and a vector from B's origin point OB to F's
    origin point OF. Note that the meaning of "B" comes from the context in
    which the transform is used. We use the phrase "frame F is in frame B" to
    describe the above relationship, that is, "in" means both measured from
    and expressed in.

    The axis vectors constitute a Rotation. They are ordered 1-2-3 or x-y-z
    as you prefer, with z = x X y, making a right-handed set. These axes are
    arranged as columns of a 3x3 rotation matrix R_BF = [ x y z ] which is a
    direction cosine (rotation) matrix useful for conversions between frame
    B and F. (The columns of R_BF are F's coordinate axes, expressed in B.) For
    example, given a vector vF expressed in the F frame, that same vector
    re-expressed in B is given by vB = R_BF*vF. F's origin point OF is
    stored as the translation vector p_BF=(OF-OB) and expressed in B.

    Transform is designed to behave as much as possible like the computer
    graphics 4x4 transform X which would be arranged like this:


            [       |   ]
        X = [   R   | p ]    R is a 3x3 orthogonal rotation matrix
            [.......|...]    p os a 3x1 translation vector
            [ 0 0 0   1 ]


    These can be composed directly by matrix multiplication, but more
    importantly they have a particularly simple inverse:


       -1   [       |    ]
      X   = [  ~R   | p* ]   ~R is R transpose, p* = ~R(-p).
            [.......|....]
            [ 0 0 0   1  ]


    This inverse is so simple that we compute it simply by defining another
    type, InverseTransform, which is identical to Transform in memory but
    behaves as though it contains the inverse. That way we invert just by
    changing point of view (recasting) rather than computing.

    This is a "POD" (plain old data) class with a well-defined memory
    layout on which a client of this class may depend: There are
    exactly 4 consecutive, packed 3-vectors in the order x,y,z,p.
    That is, this class is equivalent to an array of 12 Reals with
    the order x1,x2,x3,y1,y2,y3,z1,z2,z3,p1,p2,p3. It is expressly allowed
    to reinterpret Transform objects in any appropriate manner that depends
    on this memory layout.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor gives an identity transform.

        |

        *Overload 2:*
        Combine a rotation and a translation into a transform.

        |

        *Overload 3:*
        Construct or default-convert a rotation into a transform
        containing that rotation and zero translation.

        |

        *Overload 4:*
        Construct or default-convert a translation (expressed as a Vec3)
        into a transform with that translation and a zero rotation.
        """
        _simbody.Transform_swiginit(self, _simbody.new_Transform(*args))

    def set(self, R: "Rotation", p: "Vec3") -> "SimTK::Transform_< double > &":
        r"""
        Assign a new value to this transform, explicitly providing
        the rotation and translation separately. We return a reference to
        the now-modified transform as though this were an assignment operator.
        """
        return _simbody.Transform_set(self, R, p)

    def setToZero(self) -> "SimTK::Transform_< double > &":
        r"""
        By zero we mean "zero transform", i.e., an identity rotation
        and zero translation. We return a reference to the now-modified
        transform as though this were an assignment operator.
        """
        return _simbody.Transform_setToZero(self)

    def setToNaN(self) -> "SimTK::Transform_< double > &":
        r"""
        This fills both the rotation and translation with NaNs. Note: this is
        *not* the same as a default-constructed transform, which is a
        legitimate identity transform instead. We return a reference to the now-modified
        transform as though this were an assignment operator.
        """
        return _simbody.Transform_setToNaN(self)

    def invert(self) -> "SimTK::InverseTransform_< double > const &":
        r"""
         Return a read-only inverse of the current Transform_
        , simply by casting it to
         the InverseTransform_
         type. Zero cost.
        """
        return _simbody.Transform_invert(self)

    def updInvert(self) -> "SimTK::InverseTransform_< double > &":
        r"""
        Return a writable (lvalue) inverse of the current transform, simply by casting it to
        the InverseTransform_
        type. That is, this is an lvalue. Zero cost.
        """
        return _simbody.Transform_updInvert(self)

    def __invert__(self, *args) -> "SimTK::InverseTransform_< double > &":
        r"""
        *Overload 1:*
        Overload transpose operator to mean inversion. See also: invert

        |

        *Overload 2:*
        Overload transpose operator to mean inversion. See also: updInvert
        """
        return _simbody.Transform___invert__(self, *args)

    def compose(self, *args) -> "SimTK::Transform_< double >":
        r"""
        *Overload 1:*
        Compose the current transform (X_BF) with the given one. That is,
        return X_BY=X_BF*X_FY. Cost is 63 flops.

        |

        *Overload 2:*
        Compose the current transform (X_BF) with one that is supplied
        as an InverseTransform_ (typically as a result of applying
        the "~" operator to a transform). That is, return
        X_BY=X_BF*X_FY, but now X_FY is represented as ~X_YF. Cost
        is an extra 18 flops to calculate X_FY.p(), total 81 flops.
        """
        return _simbody.Transform_compose(self, *args)

    def xformFrameVecToBase(self, vF: "Vec3") -> "SimTK::Vec< 3,double >":
        r"""
        %Transform a vector expressed in our "F" frame to our "B" frame.
        Note that this involves rotation only; it is independent of
        the translation stored in this transform. Cost is 15 flops.
        """
        return _simbody.Transform_xformFrameVecToBase(self, vF)

    def xformBaseVecToFrame(self, vB: "Vec3") -> "SimTK::Vec< 3,double >":
        r"""
        %Transform a vector expressed in our "B" frame to our "F" frame.
        Note that this involves rotation only; it is independent of
        the translation stored in this transform. Cost is 15 flops.
        """
        return _simbody.Transform_xformBaseVecToFrame(self, vB)

    def shiftFrameStationToBase(self, sF: "Vec3") -> "SimTK::Vec< 3,double >":
        r"""
        %Transform a point (station) measured from and expressed in
        our "F" frame to that same point but measured from and
        expressed in our "B" frame. Cost is 18 flops.
        """
        return _simbody.Transform_shiftFrameStationToBase(self, sF)

    def shiftBaseStationToFrame(self, sB: "Vec3") -> "SimTK::Vec< 3,double >":
        r"""
        %Transform a point (station) measured from and expressed in
        our "B" frame to that same point but measured from and
        expressed in our "F" frame. Cost is 18 flops.
        """
        return _simbody.Transform_shiftBaseStationToFrame(self, sB)

    def R(self) -> "SimTK::Rotation_< double > const &":
        r""" Return a read-only reference to the contained rotation R_BF."""
        return _simbody.Transform_R(self)

    def RInv(self) -> "SimTK::InverseRotation_< double > const &":
        r"""
        Return a read-only reference to the inverse (transpose) of
        our contained rotation, that is R_FB.
        """
        return _simbody.Transform_RInv(self)

    def p(self) -> "SimTK::Vec< 3,double > const &":
        r""" Return a read-only reference to our translation vector p_BF."""
        return _simbody.Transform_p(self)

    def setP(self, p: "Vec3") -> "SimTK::Transform_< double > &":
        r"""
        Assign a new value to our translation vector. We expect the
        supplied vector ``p`` to be expressed in our B frame. A reference
        to the now-modified transform is returned as though this were
        an assignment operator.
        """
        return _simbody.Transform_setP(self, p)

    def pInv(self) -> "SimTK::Vec< 3,double >":
        r"""
        Calculate the inverse of the translation vector in this transform.
        The returned vector will be the negative of the original and will
        be expressed in the F frame rather than our B frame. Cost is 18 flops.
        """
        return _simbody.Transform_pInv(self)

    def setPInv(self, p_FB: "Vec3") -> "SimTK::Transform_< double > &":
        r"""
        Assign a value to the *inverse* of our translation vector.
        That is, we're given a vector in F which we invert and reexpress
        in B to store it in p, so that we get the original argument back if
        we ask for the inverse of p. Sorry, can't update pInv as an lvalue, but here we
        want -(~R_BF*p_BF)=p_FB => p_BF=-(R_BF*p_FB) so we can calculate
        it in 18 flops. A reference to the now-modified transform is returned
        as though this were an assignment operator.
        """
        return _simbody.Transform_setPInv(self, p_FB)

    def asMat34(self) -> "SimTK::Mat< 3,4,double > const &":
        r"""
        Recast this transform as a read-only 3x4 matrix. This is a zero-cost
        reinterpretation of the data; the first three columns are the
        columns of the rotation and the last column is the translation.
        """
        return _simbody.Transform_asMat34(self)

    def toMat34(self) -> "SimTK::Mat< 3,4,double >":
        r""" Less efficient version of asMat34(); copies into return variable."""
        return _simbody.Transform_toMat34(self)

    def toMat44(self) -> "SimTK::Mat< 4,4,double >":
        r""" Return the equivalent 4x4 transformation matrix."""
        return _simbody.Transform_toMat44(self)

    def T(self) -> "SimTK::Vec< 3,double > const &":
        return _simbody.Transform_T(self)
    __swig_destroy__ = _simbody.delete_Transform

# Register Transform in _simbody:
_simbody.Transform_swigregister(Transform)

class Inertia(object):
    r"""
     Spatial vectors are used for (rotation,translation) quantities and
    consist of a pair of Vec3 objects, arranged as a 2-vector of 3-vectors.
    Quantities represented this way include
        - spatial velocity     = (angularVelocity,linearVelocity)
        - spatial acceleration = (angularAcceleration,linearAcceleration)
        - generalized forces   = (torque,force)

    Spatial configuration has to be handled differently though since
    orientation is not a vector quantity. (We use Transform for this concept
    which includes a Rotation matrix and a translation Vec3.) * The physical meaning of an inertia is the distribution of a rigid body's
    mass about a *particular* point. If that point is the center of mass of the
    body, then the measured inertia is called the "central inertia" of that body.
    To write down the inertia, we need to calculate the six scalars of the inertia
    tensor, which is a symmetric 3x3 matrix. These scalars must be expressed in
    an arbitrary but specified coordinate system. So an Inertia is meaningful only
    in conjunction with a particular set of axes, fixed to the body, whose origin
    is the point about which the inertia is being measured, and in whose
    coordinate system this measurement is being expressed. Note that changing the
    reference point results in a new physical quantity, but changing the reference
    axes only affects the measure numbers of that quantity. For any reference
    point, there is a unique set of reference axes in which the inertia tensor is
    diagonal; those are called the "principal axes" of the body at that point, and
    the resulting diagonal elements are the "principal moments of inertia". When
    we speak of an inertia being "in" a frame, we mean the physical quantity
    measured about the frame's origin and then expressed in the frame's axes.

    This low-level Inertia class does not attempt to keep track of *which* frame
    it is in. It provides construction and operations involving inertia that can
    proceed using only an implicit frame F. Clients of this class are responsible
    for keeping track of that frame. In particular, in order to shift the
    inertia's "measured-about" point one must know whether either the starting or
    final inertia is central, because we must always shift inertias by passing
    through the central inertia. So this class provides operations for doing the
    shifting, but expects to be told by the client where to find the center of mass.

    Re-expressing an Inertia in a different coordinate system does not entail a
    change of physical meaning in the way that shifting it to a different point
    does. Note that because inertia is a tensor, there is a "left frame" and
    "right frame". For our purposes, these will always be the same so we'll only
    indicate the frame once, as in 'I_pt_frame'. This should be understood to mean
    'frame_I_pt_frame' and re-expressing an Inertia requires both a left and right
    multiply by the rotation matrix. So I_OB_B is the inertia about body B's
    origin point OB, expressed in B, while I_OB_G is the same physical quantity
    but expressed in Ground (the latter is a component of the Spatial Inertia
    which we usually want in the Ground frame). Frame conversion is done logically
    like this:

       I_OB_G = R_GB * I_OB_B * R_BG  (R_BG=~R_GB)

    but we can save computation time by performing this as a single operation.

    The central inertia would be I_CB_B for body B.

    A Inertia is a symmetric matrix and is positive definite for nonsingular bodies
    (that is, a body composed of at least three noncollinear point masses).

    Some attempt is made to check the validity of an Inertia matrix, at least
    when running in Debug mode. Some conditions it must satisfy are:
     - must be symmetric
     - all diagonal elements must be nonnegative
     - diagonal elements must satisfy the triangle inequality (sum of any two
       is greater than or equal the other one)

    ### Abbreviations
    Typedefs exist for the most common invocations of Inertia_<P>:
     - 'Inertia' for default Real precision (this is
       almost always used)
     - 'fInertia' for single (float) precision
     - 'dInertia' for double precision
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default is a NaN-ed out mess to avoid accidents, even in Release mode.
        Other than this value, an Inertia matrix should always be valid.

        |

        *Overload 2:*
        Create a principal inertia matrix with identical diagonal elements,
        like a sphere where moment=2/5 m r^2, or a cube where
        moment=1/6 m s^2, with m the total mass, r the sphere's radius
        and s the length of a side of the cube. Note that many rigid
        bodies of different shapes and masses can have the same inertia
        matrix.

        |

        *Overload 3:*
        Create an Inertia matrix for a point mass at a given location,
        measured from the origin OF of the implicit frame F, and expressed
        in F. Cost is 14 flops.

        |

        *Overload 4:*
        Create an inertia matrix from a vector of the *moments* of
        inertia (the inertia matrix diagonal) and optionally a vector of
        the *products* of inertia (the off-diagonals). Moments are
        in the order xx,yy,zz; products are xy,xz,yz.

        |

        *Overload 5:*
        Create an inertia matrix from a vector of the *moments* of
        inertia (the inertia matrix diagonal) and optionally a vector of
        the *products* of inertia (the off-diagonals). Moments are
        in the order xx,yy,zz; products are xy,xz,yz.

        |

        *Overload 6:*
        Create a principal inertia matrix (only non-zero on diagonal).

        |

        *Overload 7:*
        This is a general inertia matrix. Note the order of these
        arguments: moments of inertia first, then products of inertia.
        """
        _simbody.Inertia_swiginit(self, _simbody.new_Inertia(*args))

    def getMoments(self) -> "SimTK::Vec3 const &":
        r"""
        Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3
        ordered xx, yy, zz.
        """
        return _simbody.Inertia_getMoments(self)

    def getProducts(self) -> "SimTK::Vec3 const &":
        r"""
        Obtain the inertia products (off-diagonals of the Inertia matrix)
        as a Vec3 with elements ordered xy, xz, yz.
        """
        return _simbody.Inertia_getProducts(self)

    def isNaN(self) -> "bool":
        return _simbody.Inertia_isNaN(self)

    def isInf(self) -> "bool":
        return _simbody.Inertia_isInf(self)

    def isFinite(self) -> "bool":
        return _simbody.Inertia_isFinite(self)
    __swig_destroy__ = _simbody.delete_Inertia

# Register Inertia in _simbody:
_simbody.Inertia_swigregister(Inertia)

class MassProperties(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
         Create a mass properties object in which the mass, mass center, and
        inertia are meaningless; you must assign values before using this. *
        """
        _simbody.MassProperties_swiginit(self, _simbody.new_MassProperties())

    def isExactlyMassless(self) -> "bool":
        r"""
         Create a mass properties object from individually supplied mass,
        mass center, and inertia matrix.  The inertia matrix is divided by the
        mass to produce the unit inertia. * Return true only if the mass stored here is *exactly* zero.\ If the mass
        resulted from a computation, you should use isNearlyMassless() instead.
        See also: isNearlyMassless(), isExactlyCentral() *
        """
        return _simbody.MassProperties_isExactlyMassless(self)

    def isNearlyMassless(self, *args) -> "bool":
        r"""
         Return true if the mass stored here is zero to within a small tolerance.
        By default we use SignificantReal (about 1e-14 in double precision) as the
        tolerance but you can override that. If you are just checking to see whether
        the mass was explicitly set to zero (rather than calculated) you can use
        isExactlyMassless() instead. See also: isExactlyMassless(), isNearlyCentral() *
        """
        return _simbody.MassProperties_isNearlyMassless(self, *args)

    def isExactlyCentral(self) -> "bool":
        r"""
         Return true only if the mass center stored here is *exactly* zero.\ If
        the mass center resulted from a computation, you should use isNearlyCentral()
        instead. See also: isNearlyCentral(), isExactlyMassless() *
        """
        return _simbody.MassProperties_isExactlyCentral(self)

    def isNearlyCentral(self, *args) -> "bool":
        r"""
         Return true if the mass center stored here is zero to within a small tolerance.
        By default we use SignificantReal (about 1e-14 in double precision) as the
        tolerance but you can override that. If you are just checking to see whether
        the mass center was explicitly set to zero (rather than calculated) you can use
        isExactlyCentral() instead. See also: isExactlyCentral(), isNearlyMassless() *
        """
        return _simbody.MassProperties_isNearlyCentral(self, *args)

    def isNaN(self) -> "bool":
        r"""
         Return true if any element of this MassProperties object is NaN.
        See also: isInf(), isFinite() *
        """
        return _simbody.MassProperties_isNaN(self)

    def isInf(self) -> "bool":
        r"""
         Return true only if there are no NaN's in this MassProperties object, and
        at least one of the elements is Infinity.\ Ground's mass properties satisfy
        these conditions.
        See also: isNan(), isFinite() *
        """
        return _simbody.MassProperties_isInf(self)

    def isFinite(self) -> "bool":
        r"""
         Return true if none of the elements of this MassProperties object are
        NaN or Infinity.\ Note that Ground's mass properties are not finite.
        See also: isNaN(), isInf() *
        """
        return _simbody.MassProperties_isFinite(self)
    __swig_destroy__ = _simbody.delete_MassProperties

# Register MassProperties in _simbody:
_simbody.MassProperties_swigregister(MassProperties)

SimTK_DEFAULT_PRECISION = _simbody.SimTK_DEFAULT_PRECISION
r"""
    Mandatory first inclusion for any Simbody source or header file.

    Every source and most header files using %SimTK must include this
    header as its *first* inclusion. Declarations and definitions that
    must be available and compiler-and machine-specific issues are dealt
    with here.

    This file must be includable from either C++ or ANSI C. It uses
    the ANSI-C++ macro "__cplusplus" for any code that will compile
    only under C++. *
    This is the top-level %SimTK namespace into which all %SimTK names are
    placed to avoid collision with other symbols. If you get tired of prefacing
    every symbol with "SimTK::", include the statement "using namespace SimTK;"
    at the beginning of your %SimTK-using compilation units. Any names which
    cannot be put in the namespace (macro names, for example) begin with the
    prefix "SimTK_" instead. *
    This compile-time constant determines the default precision used everywhere
    in %SimTK Core code. Wherever a SimTK::Real, SimTK::Vector, SimTK::Matrix,
    etc. appears with no precision specified, it will have this underlying precision.
    We use 1==float, 2==double, 4==long double. Any other value will cause
    a compile time error. The default is 2, i.e., double precision.
    """

def SimTK_version_SimTKcommon(major: "int *", minor: "int *", build: "int *") -> "void":
    r""" Obtain version information for the currently-loaded SimTKcommon library."""
    return _simbody.SimTK_version_SimTKcommon(major, minor, build)

def SimTK_about_SimTKcommon(key: "char const *", maxlen: "int", value: "char *") -> "void":
    r"""
    Obtain "about" information for the currently-loaded SimTKcommon library.
    Available keywords are "version" (major.minor.build), "library",
    "type" (shared or static), "copyright", "svn_revision", "authors",
    "debug" (debug or release).
    """
    return _simbody.SimTK_about_SimTKcommon(key, maxlen, value)

def canStoreInNonnegativeInt(*args) -> "bool":
    return _simbody.canStoreInNonnegativeInt(*args)

def isSizeInRange(*args) -> "bool":
    return _simbody.isSizeInRange(*args)

def isIndexInRange(*args) -> "bool":
    return _simbody.isIndexInRange(*args)

def isNonnegative(*args) -> "bool":
    return _simbody.isNonnegative(*args)
class Segment(object):
    r"""
     A convenient struct for anything requiring an offset and length to specify
    a segment of some larger sequence. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.Segment_swiginit(self, _simbody.new_Segment(*args))
    length = property(_simbody.Segment_length_get, _simbody.Segment_length_set)
    offset = property(_simbody.Segment_offset_get, _simbody.Segment_offset_set)
    __swig_destroy__ = _simbody.delete_Segment

# Register Segment in _simbody:
_simbody.Segment_swigregister(Segment)
cvar = _simbody.cvar
InvalidIndex = cvar.InvalidIndex

class DontCopy(object):
    r"""
     This is a special type used for causing invocation of a particular
    constructor or method overload that will avoid making a copy of the source
    (that is, perform a "shallow" copy rather than a "deep" copy). Typically these
    methods will have some dangerous side effects so make sure you know what you're
    doing. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simbody.DontCopy_swiginit(self, _simbody.new_DontCopy())
    __swig_destroy__ = _simbody.delete_DontCopy

# Register DontCopy in _simbody:
_simbody.DontCopy_swigregister(DontCopy)

class TrustMe(object):
    r"""
     This is a special type used for forcing invocation of a particularly
    dangerous constructor or method overload; don't use this unless you are an
    advanced user and know exactly what you're getting into. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simbody.TrustMe_swiginit(self, _simbody.new_TrustMe())
    __swig_destroy__ = _simbody.delete_TrustMe

# Register TrustMe in _simbody:
_simbody.TrustMe_swigregister(TrustMe)

class FalseType(object):
    r"""
     This is a compile-time equivalent of "false", used in compile-time
    condition checking in templatized implementations. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simbody.FalseType_swiginit(self, _simbody.new_FalseType())
    __swig_destroy__ = _simbody.delete_FalseType

# Register FalseType in _simbody:
_simbody.FalseType_swigregister(FalseType)

class TrueType(object):
    r"""
     This is a compile-time equivalent of "true", used in compile-time
    condition checking in templatized implementations. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _simbody.TrueType_swiginit(self, _simbody.new_TrueType())
    __swig_destroy__ = _simbody.delete_TrueType

# Register TrueType in _simbody:
_simbody.TrueType_swigregister(TrueType)

class SimTKArrayString(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayString_swiginit(self, _simbody.new_SimTKArrayString(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayString

    def deallocate(self) -> "SimTK::Array_< std::string > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< std::string >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayString_deallocate(self)

    def assign(self, n: "SimTK::Array_< std::string >::size_type", fillValue: "std::string const &") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: string, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayString_assign(self, n, fillValue)

    def fill(self, fillValue: "std::string const &") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: string, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayString_fill(self, fillValue)

    def swap(self, other: "SimTKArrayString") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayString_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< std::string > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayString_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< std::string > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayString_shareData(self, *args)

    def size(self) -> "SimTK::Array_< std::string >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayString_size(self)

    def max_size(self) -> "SimTK::Array_< std::string >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayString_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayString_empty(self)

    def capacity(self) -> "SimTK::Array_< std::string >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayString_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayString_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< std::string >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayString_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayString_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< std::string >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayString_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayString_isOwner(self)

    def cbegin(self) -> "std::string const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayString_cbegin(self)

    def begin(self, *args) -> "std::string *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayString_begin(self, *args)

    def cend(self) -> "std::string const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayString_cend(self)

    def end(self, *args) -> "std::string *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayString_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< std::string >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayString_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< std::string >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayString_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< std::string >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayString_crend(self)

    def rend(self, *args) -> "SimTK::Array_< std::string >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayString_rend(self, *args)

    def cdata(self) -> "std::string const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayString_cdata(self)

    def data(self, *args) -> "std::string *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayString_data(self, *args)

    def at(self, *args) -> "std::string &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayString_at(self, *args)

    def getElt(self, i: "SimTK::Array_< std::string >::index_type") -> "std::string const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayString_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< std::string >::index_type") -> "std::string &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayString_updElt(self, i)

    def front(self, *args) -> "std::string &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayString_front(self, *args)

    def back(self, *args) -> "std::string &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayString_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: string, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayString_push_back(self, *args)

    def raw_push_back(self) -> "std::string *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: string
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayString_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayString_pop_back(self)

    def erase(self, *args) -> "std::string *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: string
        :param first:
                Points to the first element that will be erased.
        :type last1: string
        :param last1:
                Points one element past the last element to be erased.
        :rtype: string
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: string
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: string
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayString_erase(self, *args)

    def eraseFast(self, p: "std::string *") -> "std::string *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: string
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: string
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayString_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayString_clear(self)

    def insert(self, *args) -> "std::string *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: string, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: string, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: string
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayString_insert(self, *args)

# Register SimTKArrayString in _simbody:
_simbody.SimTKArrayString_swigregister(SimTKArrayString)

class SimTKArrayDouble(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayDouble_swiginit(self, _simbody.new_SimTKArrayDouble(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayDouble

    def deallocate(self) -> "SimTK::Array_< double > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< double >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayDouble_deallocate(self)

    def assign(self, n: "SimTK::Array_< double >::size_type", fillValue: "double const &") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: float, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayDouble_assign(self, n, fillValue)

    def fill(self, fillValue: "double const &") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: float, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayDouble_fill(self, fillValue)

    def swap(self, other: "SimTKArrayDouble") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayDouble_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< double > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayDouble_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< double > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayDouble_shareData(self, *args)

    def size(self) -> "SimTK::Array_< double >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayDouble_size(self)

    def max_size(self) -> "SimTK::Array_< double >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayDouble_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayDouble_empty(self)

    def capacity(self) -> "SimTK::Array_< double >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayDouble_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayDouble_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< double >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayDouble_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayDouble_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< double >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayDouble_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayDouble_isOwner(self)

    def cbegin(self) -> "double const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayDouble_cbegin(self)

    def begin(self, *args) -> "double *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayDouble_begin(self, *args)

    def cend(self) -> "double const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayDouble_cend(self)

    def end(self, *args) -> "double *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayDouble_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< double >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayDouble_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< double >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayDouble_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< double >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayDouble_crend(self)

    def rend(self, *args) -> "SimTK::Array_< double >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayDouble_rend(self, *args)

    def cdata(self) -> "double const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayDouble_cdata(self)

    def data(self, *args) -> "double *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayDouble_data(self, *args)

    def at(self, *args) -> "double &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayDouble_at(self, *args)

    def getElt(self, i: "SimTK::Array_< double >::index_type") -> "double const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayDouble_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< double >::index_type") -> "double &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayDouble_updElt(self, i)

    def front(self, *args) -> "double &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayDouble_front(self, *args)

    def back(self, *args) -> "double &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayDouble_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: float, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayDouble_push_back(self, *args)

    def raw_push_back(self) -> "double *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: float
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayDouble_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayDouble_pop_back(self)

    def erase(self, *args) -> "double *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: float
        :param first:
                Points to the first element that will be erased.
        :type last1: float
        :param last1:
                Points one element past the last element to be erased.
        :rtype: float
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: float
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: float
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayDouble_erase(self, *args)

    def eraseFast(self, p: "double *") -> "double *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: float
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: float
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayDouble_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayDouble_clear(self)

    def insert(self, *args) -> "double *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: float, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: float, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: float
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayDouble_insert(self, *args)

# Register SimTKArrayDouble in _simbody:
_simbody.SimTKArrayDouble_swigregister(SimTKArrayDouble)

class SimTKArrayVec3(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayVec3_swiginit(self, _simbody.new_SimTKArrayVec3(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayVec3

    def deallocate(self) -> "SimTK::Array_< SimTK::Vec3 > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< SimTK::Vec3 >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayVec3_deallocate(self)

    def assign(self, n: "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type", fillValue: "Vec3") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: SimTK::Vec< 3,double,1 >, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayVec3_assign(self, n, fillValue)

    def fill(self, fillValue: "Vec3") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: SimTK::Vec< 3,double,1 >, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayVec3_fill(self, fillValue)

    def swap(self, other: "SimTKArrayVec3") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayVec3_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< SimTK::Vec3 > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayVec3_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< SimTK::Vec3 > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayVec3_shareData(self, *args)

    def size(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayVec3_size(self)

    def max_size(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayVec3_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayVec3_empty(self)

    def capacity(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayVec3_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayVec3_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayVec3_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayVec3_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayVec3_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayVec3_isOwner(self)

    def cbegin(self) -> "SimTK::Vec< 3,double,1 > const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayVec3_cbegin(self)

    def begin(self, *args) -> "SimTK::Vec< 3,double,1 > *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayVec3_begin(self, *args)

    def cend(self) -> "SimTK::Vec< 3,double,1 > const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayVec3_cend(self)

    def end(self, *args) -> "SimTK::Vec< 3,double,1 > *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayVec3_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayVec3_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayVec3_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayVec3_crend(self)

    def rend(self, *args) -> "SimTK::Array_< SimTK::Vec< 3,double,1 > >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayVec3_rend(self, *args)

    def cdata(self) -> "SimTK::Vec< 3,double,1 > const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayVec3_cdata(self)

    def data(self, *args) -> "SimTK::Vec< 3,double,1 > *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayVec3_data(self, *args)

    def at(self, *args) -> "SimTK::Vec< 3,double,1 > &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayVec3_at(self, *args)

    def getElt(self, i: "SimTK::Array_< SimTK::Vec< 3,double,1 > >::index_type") -> "SimTK::Vec< 3,double,1 > const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayVec3_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< SimTK::Vec< 3,double,1 > >::index_type") -> "SimTK::Vec< 3,double,1 > &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayVec3_updElt(self, i)

    def front(self, *args) -> "SimTK::Vec< 3,double,1 > &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayVec3_front(self, *args)

    def back(self, *args) -> "SimTK::Vec< 3,double,1 > &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayVec3_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: SimTK::Vec< 3,double,1 >, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayVec3_push_back(self, *args)

    def raw_push_back(self) -> "SimTK::Vec< 3,double,1 > *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: SimTK::Vec< 3,double,1 >
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayVec3_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayVec3_pop_back(self)

    def erase(self, *args) -> "SimTK::Vec< 3,double,1 > *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: SimTK::Vec< 3,double,1 >
        :param first:
                Points to the first element that will be erased.
        :type last1: SimTK::Vec< 3,double,1 >
        :param last1:
                Points one element past the last element to be erased.
        :rtype: SimTK::Vec< 3,double,1 >
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: SimTK::Vec< 3,double,1 >
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: SimTK::Vec< 3,double,1 >
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayVec3_erase(self, *args)

    def eraseFast(self, p: "Vec3") -> "SimTK::Vec< 3,double,1 > *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: SimTK::Vec< 3,double,1 >
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: SimTK::Vec< 3,double,1 >
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayVec3_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayVec3_clear(self)

    def insert(self, *args) -> "SimTK::Vec< 3,double,1 > *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: SimTK::Vec< 3,double,1 >, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: SimTK::Vec< 3,double,1 >, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: SimTK::Vec< 3,double,1 >
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayVec3_insert(self, *args)

# Register SimTKArrayVec3 in _simbody:
_simbody.SimTKArrayVec3_swigregister(SimTKArrayVec3)

class SimTKArrayInt(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayInt_swiginit(self, _simbody.new_SimTKArrayInt(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayInt

    def deallocate(self) -> "SimTK::Array_< int > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< int >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayInt_deallocate(self)

    def assign(self, n: "SimTK::Array_< int >::size_type", fillValue: "int const &") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: int, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayInt_assign(self, n, fillValue)

    def fill(self, fillValue: "int const &") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: int, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayInt_fill(self, fillValue)

    def swap(self, other: "SimTKArrayInt") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayInt_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< int > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayInt_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< int > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayInt_shareData(self, *args)

    def size(self) -> "SimTK::Array_< int >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayInt_size(self)

    def max_size(self) -> "SimTK::Array_< int >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayInt_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayInt_empty(self)

    def capacity(self) -> "SimTK::Array_< int >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayInt_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayInt_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< int >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayInt_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayInt_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< int >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayInt_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayInt_isOwner(self)

    def cbegin(self) -> "int const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayInt_cbegin(self)

    def begin(self, *args) -> "int *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayInt_begin(self, *args)

    def cend(self) -> "int const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayInt_cend(self)

    def end(self, *args) -> "int *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayInt_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< int >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayInt_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< int >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayInt_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< int >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayInt_crend(self)

    def rend(self, *args) -> "SimTK::Array_< int >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayInt_rend(self, *args)

    def cdata(self) -> "int const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayInt_cdata(self)

    def data(self, *args) -> "int *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayInt_data(self, *args)

    def at(self, *args) -> "int &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayInt_at(self, *args)

    def getElt(self, i: "SimTK::Array_< int >::index_type") -> "int const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayInt_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< int >::index_type") -> "int &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayInt_updElt(self, i)

    def front(self, *args) -> "int &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayInt_front(self, *args)

    def back(self, *args) -> "int &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayInt_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: int, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayInt_push_back(self, *args)

    def raw_push_back(self) -> "int *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: int
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayInt_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayInt_pop_back(self)

    def erase(self, *args) -> "int *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: int
        :param first:
                Points to the first element that will be erased.
        :type last1: int
        :param last1:
                Points one element past the last element to be erased.
        :rtype: int
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: int
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: int
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayInt_erase(self, *args)

    def eraseFast(self, p: "int *") -> "int *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: int
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: int
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayInt_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayInt_clear(self)

    def insert(self, *args) -> "int *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: int, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: int, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: int
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayInt_insert(self, *args)

# Register SimTKArrayInt in _simbody:
_simbody.SimTKArrayInt_swigregister(SimTKArrayInt)

class SimTKArrayRotation(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayRotation_swiginit(self, _simbody.new_SimTKArrayRotation(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayRotation

    def deallocate(self) -> "SimTK::Array_< SimTK::Rotation_< double > > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< SimTK::Rotation_< double > >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayRotation_deallocate(self)

    def assign(self, n: "SimTK::Array_< SimTK::Rotation_< double > >::size_type", fillValue: "Rotation") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: SimTK::Rotation_< double >, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayRotation_assign(self, n, fillValue)

    def fill(self, fillValue: "Rotation") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: SimTK::Rotation_< double >, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayRotation_fill(self, fillValue)

    def swap(self, other: "SimTKArrayRotation") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayRotation_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< SimTK::Rotation_< double > > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayRotation_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< SimTK::Rotation_< double > > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayRotation_shareData(self, *args)

    def size(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayRotation_size(self)

    def max_size(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayRotation_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayRotation_empty(self)

    def capacity(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayRotation_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayRotation_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< SimTK::Rotation_< double > >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayRotation_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayRotation_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayRotation_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayRotation_isOwner(self)

    def cbegin(self) -> "SimTK::Rotation_< double > const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayRotation_cbegin(self)

    def begin(self, *args) -> "SimTK::Rotation_< double > *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayRotation_begin(self, *args)

    def cend(self) -> "SimTK::Rotation_< double > const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayRotation_cend(self)

    def end(self, *args) -> "SimTK::Rotation_< double > *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayRotation_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayRotation_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< SimTK::Rotation_< double > >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayRotation_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< SimTK::Rotation_< double > >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayRotation_crend(self)

    def rend(self, *args) -> "SimTK::Array_< SimTK::Rotation_< double > >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayRotation_rend(self, *args)

    def cdata(self) -> "SimTK::Rotation_< double > const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayRotation_cdata(self)

    def data(self, *args) -> "SimTK::Rotation_< double > *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayRotation_data(self, *args)

    def at(self, *args) -> "SimTK::Rotation_< double > &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayRotation_at(self, *args)

    def getElt(self, i: "SimTK::Array_< SimTK::Rotation_< double > >::index_type") -> "SimTK::Rotation_< double > const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayRotation_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< SimTK::Rotation_< double > >::index_type") -> "SimTK::Rotation_< double > &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayRotation_updElt(self, i)

    def front(self, *args) -> "SimTK::Rotation_< double > &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayRotation_front(self, *args)

    def back(self, *args) -> "SimTK::Rotation_< double > &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayRotation_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: SimTK::Rotation_< double >, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayRotation_push_back(self, *args)

    def raw_push_back(self) -> "SimTK::Rotation_< double > *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: SimTK::Rotation_< double >
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayRotation_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayRotation_pop_back(self)

    def erase(self, *args) -> "SimTK::Rotation_< double > *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: SimTK::Rotation_< double >
        :param first:
                Points to the first element that will be erased.
        :type last1: SimTK::Rotation_< double >
        :param last1:
                Points one element past the last element to be erased.
        :rtype: SimTK::Rotation_< double >
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: SimTK::Rotation_< double >
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: SimTK::Rotation_< double >
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayRotation_erase(self, *args)

    def eraseFast(self, p: "Rotation") -> "SimTK::Rotation_< double > *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: SimTK::Rotation_< double >
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: SimTK::Rotation_< double >
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayRotation_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayRotation_clear(self)

    def insert(self, *args) -> "SimTK::Rotation_< double > *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: SimTK::Rotation_< double >, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: SimTK::Rotation_< double >, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: SimTK::Rotation_< double >
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayRotation_insert(self, *args)

# Register SimTKArrayRotation in _simbody:
_simbody.SimTKArrayRotation_swigregister(SimTKArrayRotation)

class SimTKArrayMobilizedBodyIndex(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.SimTKArrayMobilizedBodyIndex_swiginit(self, _simbody.new_SimTKArrayMobilizedBodyIndex(*args))
    __swig_destroy__ = _simbody.delete_SimTKArrayMobilizedBodyIndex

    def deallocate(self) -> "SimTK::Array_< MobilizedBodyIndex > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< MobilizedBodyIndex >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_deallocate(self)

    def assign(self, n: "SimTK::Array_< MobilizedBodyIndex >::size_type", fillValue: "MobilizedBodyIndex const &") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: int, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_assign(self, n, fillValue)

    def fill(self, fillValue: "MobilizedBodyIndex const &") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: int, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_fill(self, fillValue)

    def swap(self, other: "SimTKArrayMobilizedBodyIndex") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< MobilizedBodyIndex > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< MobilizedBodyIndex > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_shareData(self, *args)

    def size(self) -> "SimTK::Array_< MobilizedBodyIndex >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.SimTKArrayMobilizedBodyIndex_size(self)

    def max_size(self) -> "SimTK::Array_< MobilizedBodyIndex >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.SimTKArrayMobilizedBodyIndex_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_empty(self)

    def capacity(self) -> "SimTK::Array_< MobilizedBodyIndex >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< MobilizedBodyIndex >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< MobilizedBodyIndex >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_isOwner(self)

    def cbegin(self) -> "MobilizedBodyIndex const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_cbegin(self)

    def begin(self, *args) -> "MobilizedBodyIndex *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_begin(self, *args)

    def cend(self) -> "MobilizedBodyIndex const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_cend(self)

    def end(self, *args) -> "MobilizedBodyIndex *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< MobilizedBodyIndex >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< MobilizedBodyIndex >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< MobilizedBodyIndex >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_crend(self)

    def rend(self, *args) -> "SimTK::Array_< MobilizedBodyIndex >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_rend(self, *args)

    def cdata(self) -> "MobilizedBodyIndex const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_cdata(self)

    def data(self, *args) -> "MobilizedBodyIndex *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_data(self, *args)

    def at(self, *args) -> "MobilizedBodyIndex &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_at(self, *args)

    def getElt(self, i: "SimTK::Array_< MobilizedBodyIndex >::index_type") -> "MobilizedBodyIndex const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< MobilizedBodyIndex >::index_type") -> "MobilizedBodyIndex &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_updElt(self, i)

    def front(self, *args) -> "MobilizedBodyIndex &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_front(self, *args)

    def back(self, *args) -> "MobilizedBodyIndex &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: int, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_push_back(self, *args)

    def raw_push_back(self) -> "MobilizedBodyIndex *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: int
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_pop_back(self)

    def erase(self, *args) -> "MobilizedBodyIndex *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: int
        :param first:
                Points to the first element that will be erased.
        :type last1: int
        :param last1:
                Points one element past the last element to be erased.
        :rtype: int
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: int
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: int
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_erase(self, *args)

    def eraseFast(self, p: "MobilizedBodyIndex *") -> "MobilizedBodyIndex *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: int
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: int
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_clear(self)

    def insert(self, *args) -> "MobilizedBodyIndex *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: int, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: int, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: int
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.SimTKArrayMobilizedBodyIndex_insert(self, *args)

# Register SimTKArrayMobilizedBodyIndex in _simbody:
_simbody.SimTKArrayMobilizedBodyIndex_swigregister(SimTKArrayMobilizedBodyIndex)

class ArrayIndexUnsigned(object):
    r"""
     Specialization of ArrayIndexTraits for ``unsigned`` (that is, ``unsigned``
    ``int)`` used as an index. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def max_size() -> "SimTK::ArrayIndexTraits< unsigned int >::size_type":
        return _simbody.ArrayIndexUnsigned_max_size()

    def __init__(self):
        _simbody.ArrayIndexUnsigned_swiginit(self, _simbody.new_ArrayIndexUnsigned())
    __swig_destroy__ = _simbody.delete_ArrayIndexUnsigned

# Register ArrayIndexUnsigned in _simbody:
_simbody.ArrayIndexUnsigned_swigregister(ArrayIndexUnsigned)

def ArrayIndexUnsigned_max_size() -> "SimTK::ArrayIndexTraits< unsigned int >::size_type":
    return _simbody.ArrayIndexUnsigned_max_size()

class ArrayIndexInt(object):
    r""" Specialization of ArrayIndexTraits for (signed) ``int`` used as an index. *"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def max_size() -> "SimTK::ArrayIndexTraits< int >::size_type":
        return _simbody.ArrayIndexInt_max_size()

    def __init__(self):
        _simbody.ArrayIndexInt_swiginit(self, _simbody.new_ArrayIndexInt())
    __swig_destroy__ = _simbody.delete_ArrayIndexInt

# Register ArrayIndexInt in _simbody:
_simbody.ArrayIndexInt_swigregister(ArrayIndexInt)

def ArrayIndexInt_max_size() -> "SimTK::ArrayIndexTraits< int >::size_type":
    return _simbody.ArrayIndexInt_max_size()

class PolygonalMesh(object):
    r"""
     This class provides a description of a mesh made of polygonal faces (not
    limited to triangles). Its primary purpose is for loading geometry from files,
    which can then be used for visualization or collision detection. For example,
    the following lines load a mesh from a Wavefront OBJ file, then create a
    DecorativeMesh from it.

    .. code-block:: c++

            PolygonalMesh mesh;
            mesh.loadObjFile("teapot.obj");
            DecorativeMesh decoration(mesh);
    You can also read a polygon mesh from a VTK PolyData (.vtp) file, or an STL
    file (.stl) that is in ascii or binary format. You can also build meshes
    programmatically, and some static methods are provided here for generating some
    common shapes. If you don't know what kind of file you have, you can attempt to
    read it with the loadFile() method which will examine the file extension to
    determine the expected format.

    The mesh has its own local frame and vertex locations are given in that
    frame. You can scale and transform the vertices relative to that frame
    (changing the values stored in the mesh) but more commonly the mesh will be
    placed on a body relative to that body's frame, meaning you can re-use the
    same mesh in various places.

    We expect this to be a large object so give it shared (reference) semantics;
    that is, the copy constructor and copy assignment default to shallow copies
    (both handles will refer to the same data). If you want to make a deep
    (non-shared) copy of a PolygonalMesh, use the copyAssign() method provided by
    the PIMPLHandle base class. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Create an empty %PolygonalMesh, with no vertices or faces. *"""
        _simbody.PolygonalMesh_swiginit(self, _simbody.new_PolygonalMesh())

    @staticmethod
    def createSphereMesh(radius: "SimTK::Real", resolution: "int"=1) -> "SimTK::PolygonalMesh":
        r"""
        Create a sphere-shaped mesh, with roughly uniform mesh elements.

           :type radius: float, in
           :param radius:
                   The radius of the underlying sphere. Vertices of the mesh will be on
                   the sphere, with mesh elements somewhat inside.
           :type resolution: int, in, optional
           :param resolution:
                   Control for how dense a mesh to produce. Resolution 0 will produce an
                   octahedron (8 triangular faces). Resolution 1 (the default) gives
                   32 faces, resolution 2 gives 128. In general for resolution n there
                   will be 2*4^(n+1) faces.
           :rtype: :py:class:`PolygonalMesh`
           :return: A %PolygonalMesh representing a sphere of the specified radius. *
        """
        return _simbody.PolygonalMesh_createSphereMesh(radius, resolution)

    @staticmethod
    def createBrickMesh(halfDims: "Vec3", resolution: "int"=1) -> "SimTK::PolygonalMesh":
        r"""
        Create a brick-shaped mesh. A brick is a rectangular solid (a box)
           centered at and aligned with the mesh local frame. Note that its size is
           given with *half* dimensions. By default you will just get two mesh faces
           along the longest edge of the brick, with all other edges roughly the same
           size. You can control the mesh density with the *resolution* parameter.

           :type halfDims: :py:class:`Vec3`, in
           :param halfDims:
                   The half-dimensions of the brick. The extreme vertices are at
                   -halfDims and +halfDims, so the brick is centered around the mesh
                   local frame.
           :type resolution: int, in, optional
           :param resolution:
                   Control for how dense a mesh to produce. For this shape, *resolution*
                   is interpreted as the number of extra vertices to insert in the
                   *longest* edge of the brick. Extra vertices are inserted into the
                   shorter edges if needed to keep the edge lengths approximately
                   uniform for every mesh face. *resolution=0* gives only
                   vertices at the corners; the default is 1 meaning that the longest
                   edge is split once.
           :rtype: :py:class:`PolygonalMesh`
           :return: A %PolygonalMesh representing a brick of the requested size.

           ### Controlling the mesh density:
           If you want a brick mesh where all the edges in the mesh are roughly the
           same length, say ``wantEdgeLength``, set *resolution* like this:

           .. code-block:: c++

               Real wantEdgeLength = ...;
               Vec3 halfDims = ...;
               int resolution = (int)(max(halfDims)/wantEdgeLength + 0.5);

           If you want a brick mesh where all the edges are roughly the same length
           as the shortest edge of the brick, just set
           ``wantEdgeLength=min(halfDims)`` in the above calculation. *
        """
        return _simbody.PolygonalMesh_createBrickMesh(halfDims, resolution)

    @staticmethod
    def createCylinderMesh(axis: "UnitVec3", radius: "SimTK::Real", halfLength: "SimTK::Real", resolution: "int"=1) -> "SimTK::PolygonalMesh":
        r"""
        Create a cylinder-shaped mesh, with the long axis in a given
           direction. By default you'll get a 12 sided polygon as the base and
           elements of roughly similar dimension along the edges. You can control the
           mesh density with the *resolution* parameter.

           :type axis: :py:class:`UnitVec3`, in
           :param axis:
                   The central axis direction of the cylinder, in the mesh local frame.
                   This can be provided using the constants XAxis, YAxis, or ZAxis, or
                   you can provide a unit vector in any direction.
           :type radius: float, in
           :param radius:
                   The cylinder radius.
           :type halfLength: float, in
           :param halfLength:
                   Half the length of the cylinder along its axis. The bases are at
                   -halfLength and +halfLength along the *axis*, so the cylinder is
                   centered around the mesh local frame origin.
           :type resolution: int, in, optional
           :param resolution:
                   Control for how dense a mesh to produce (see below for details).
           :rtype: :py:class:`PolygonalMesh`
           :return: A %PolygonalMesh representing a cylinder of the requested dimensions
                   and orientation.

           ### Controlling the mesh density:
           At resolution 0 the base is a hexagon with six triangular faces, and the
           tube is meshed with quad faces that are about as long
           as the diameter of the base. Resolution 1 (the default) makes the base
           a 12-sided polygon and introduces an intermediate 12-sided polygon of
           have the diameter. There will be triangles in the center still, but
           quad faces between the polygons. The length of the tube faces will be
           reduced to match. Higher resolutions refine the mesh similarly. *
        """
        return _simbody.PolygonalMesh_createCylinderMesh(axis, radius, halfLength, resolution)

    def clear(self) -> "void":
        r"""
        Restore this %PolygonalMesh to its default-constructed state, meaning
           that it will contain no vertices or faces after this call. *
        """
        return _simbody.PolygonalMesh_clear(self)

    def getNumFaces(self) -> "int":
        r""" Get the number of faces in the mesh. *"""
        return _simbody.PolygonalMesh_getNumFaces(self)

    def getNumVertices(self) -> "int":
        r""" Get the number of vertices in the mesh. *"""
        return _simbody.PolygonalMesh_getNumVertices(self)

    def getVertexPosition(self, vertex: "int") -> "SimTK::Vec3 const &":
        r"""
        Get the position of a vertex in the mesh.
           :type vertex: int, in
           :param vertex:  The index of the vertex (as returned by addVertex()).
           :rtype: :py:class:`Vec3`
           :return: The position of the specified vertex, measured and expressed in
               the mesh local frame. *
        """
        return _simbody.PolygonalMesh_getVertexPosition(self, vertex)

    def getNumVerticesForFace(self, face: "int") -> "int":
        r"""
        Get the number of vertices that make up a particular face.
           :type face: int, in
           :param face:    The index of the face (as returned by addFace()). *
        """
        return _simbody.PolygonalMesh_getNumVerticesForFace(self, face)

    def getFaceVertex(self, face: "int", vertex: "int") -> "int":
        r"""
        Get the index of one of the vertices of a face.
           :type face: int, in
           :param face:    The index of the face (as returned by addFace()).
           :type vertex: int, in
           :param vertex:  The index of the vertex within the face (from 0, 1, or 2
                                   for a triangular face, etc.) These are ordered the same
                                   way as when the face was defined.
           :rtype: int
           :return: The index of the specified vertex. *
        """
        return _simbody.PolygonalMesh_getFaceVertex(self, face, vertex)

    def addVertex(self, position: "Vec3") -> "int":
        r"""
        Add a vertex to the mesh.
           :type position: :py:class:`Vec3`, in
           :param position:   The position of the vertex to add, measured and
                                      expressed in the mesh local frame.
           :rtype: int
           :return: The index of the newly added vertex. *
        """
        return _simbody.PolygonalMesh_addVertex(self, position)

    def addFace(self, vertices: "SimTKArrayInt") -> "int":
        r"""
        Add a face to the mesh. Note that the ordering of the vertices defines
           the outward normal for the face; they must be counterclockwise around the
           desired normal.

           :type vertices: SimTK::Array_< int >, in
           :param vertices:    Indices of the vertices which make up the new face,
                                       in counterclockwise order with respect to the face
                                       normal.
           :rtype: int
           :return: The index of the newly added face. *
        """
        return _simbody.PolygonalMesh_addFace(self, vertices)

    def scaleMesh(self, scale: "SimTK::Real") -> "SimTK::PolygonalMesh &":
        r"""
        Scale a mesh by multiplying every vertex by a fixed value. Note that
           this permanently modifies the vertex locations within the mesh. Since the
           vertices are measured in the mesh local frame, scaling will appear to
           occur around the mesh origin (that is, the origin will remain where it
           was while everything else changes.
           :type scale: float, in
           :param scale:   The scale factor. Can be any value except zero.
           :rtype: :py:class:`PolygonalMesh`
           :return: A reference to this now-scaled mesh object. *
        """
        return _simbody.PolygonalMesh_scaleMesh(self, scale)

    def transformMesh(self, X_AM: "Transform") -> "SimTK::PolygonalMesh &":
        r"""
        %Transform a mesh by applying the given Transform to every vertex,
           leaving the mesh permanently changed. This has the effect of replacing the
           mesh local frame M with a new frame A.
           :type X_AM: :py:class:`Transform`, in
           :param X_AM:   The transform giving the pose of the mesh local frame in
                                  the new frame A. Every vertex v_M becomes v_A=X_AM*v_M.
           :rtype: :py:class:`PolygonalMesh`
           :return: A reference to this now-transformed mesh object. *
        """
        return _simbody.PolygonalMesh_transformMesh(self, X_AM)

    def loadFile(self, pathname: "std::string const &") -> "void":
        r"""
        Attempt to interpret the given file as a mesh file, with the format
           determined from the file name extension. If we recognize the extension
           we'll call one of the specialized methods below; see the descriptions for
           more information. Ignoring case, we recognize:
               - .obj : Wavefront OBJ file
               - .stl : 3D Systems Stereolithography file (ascii or binary)
               - .stla: ascii-only stl extension
               - .vtp : VTK PolyData file (we can only read the ascii version)

           :type pathname: string, in
           :param pathname:    The name of a mesh file with a recognized extension.
        """
        return _simbody.PolygonalMesh_loadFile(self, pathname)
    __swig_destroy__ = _simbody.delete_PolygonalMesh

# Register PolygonalMesh in _simbody:
_simbody.PolygonalMesh_swigregister(PolygonalMesh)

def PolygonalMesh_createSphereMesh(radius: "SimTK::Real", resolution: "int"=1) -> "SimTK::PolygonalMesh":
    r"""
    Create a sphere-shaped mesh, with roughly uniform mesh elements.

       :type radius: float, in
       :param radius:
               The radius of the underlying sphere. Vertices of the mesh will be on
               the sphere, with mesh elements somewhat inside.
       :type resolution: int, in, optional
       :param resolution:
               Control for how dense a mesh to produce. Resolution 0 will produce an
               octahedron (8 triangular faces). Resolution 1 (the default) gives
               32 faces, resolution 2 gives 128. In general for resolution n there
               will be 2*4^(n+1) faces.
       :rtype: :py:class:`PolygonalMesh`
       :return: A %PolygonalMesh representing a sphere of the specified radius. *
    """
    return _simbody.PolygonalMesh_createSphereMesh(radius, resolution)

def PolygonalMesh_createBrickMesh(halfDims: "Vec3", resolution: "int"=1) -> "SimTK::PolygonalMesh":
    r"""
    Create a brick-shaped mesh. A brick is a rectangular solid (a box)
       centered at and aligned with the mesh local frame. Note that its size is
       given with *half* dimensions. By default you will just get two mesh faces
       along the longest edge of the brick, with all other edges roughly the same
       size. You can control the mesh density with the *resolution* parameter.

       :type halfDims: :py:class:`Vec3`, in
       :param halfDims:
               The half-dimensions of the brick. The extreme vertices are at
               -halfDims and +halfDims, so the brick is centered around the mesh
               local frame.
       :type resolution: int, in, optional
       :param resolution:
               Control for how dense a mesh to produce. For this shape, *resolution*
               is interpreted as the number of extra vertices to insert in the
               *longest* edge of the brick. Extra vertices are inserted into the
               shorter edges if needed to keep the edge lengths approximately
               uniform for every mesh face. *resolution=0* gives only
               vertices at the corners; the default is 1 meaning that the longest
               edge is split once.
       :rtype: :py:class:`PolygonalMesh`
       :return: A %PolygonalMesh representing a brick of the requested size.

       ### Controlling the mesh density:
       If you want a brick mesh where all the edges in the mesh are roughly the
       same length, say ``wantEdgeLength``, set *resolution* like this:

       .. code-block:: c++

           Real wantEdgeLength = ...;
           Vec3 halfDims = ...;
           int resolution = (int)(max(halfDims)/wantEdgeLength + 0.5);

       If you want a brick mesh where all the edges are roughly the same length
       as the shortest edge of the brick, just set
       ``wantEdgeLength=min(halfDims)`` in the above calculation. *
    """
    return _simbody.PolygonalMesh_createBrickMesh(halfDims, resolution)

def PolygonalMesh_createCylinderMesh(axis: "UnitVec3", radius: "SimTK::Real", halfLength: "SimTK::Real", resolution: "int"=1) -> "SimTK::PolygonalMesh":
    r"""
    Create a cylinder-shaped mesh, with the long axis in a given
       direction. By default you'll get a 12 sided polygon as the base and
       elements of roughly similar dimension along the edges. You can control the
       mesh density with the *resolution* parameter.

       :type axis: :py:class:`UnitVec3`, in
       :param axis:
               The central axis direction of the cylinder, in the mesh local frame.
               This can be provided using the constants XAxis, YAxis, or ZAxis, or
               you can provide a unit vector in any direction.
       :type radius: float, in
       :param radius:
               The cylinder radius.
       :type halfLength: float, in
       :param halfLength:
               Half the length of the cylinder along its axis. The bases are at
               -halfLength and +halfLength along the *axis*, so the cylinder is
               centered around the mesh local frame origin.
       :type resolution: int, in, optional
       :param resolution:
               Control for how dense a mesh to produce (see below for details).
       :rtype: :py:class:`PolygonalMesh`
       :return: A %PolygonalMesh representing a cylinder of the requested dimensions
               and orientation.

       ### Controlling the mesh density:
       At resolution 0 the base is a hexagon with six triangular faces, and the
       tube is meshed with quad faces that are about as long
       as the diameter of the base. Resolution 1 (the default) makes the base
       a 12-sided polygon and introduces an intermediate 12-sided polygon of
       have the diameter. There will be triangles in the center still, but
       quad faces between the polygons. The length of the tube faces will be
       reduced to match. Higher resolutions refine the mesh similarly. *
    """
    return _simbody.PolygonalMesh_createCylinderMesh(axis, radius, halfLength, resolution)

class DecorativeGeometry(object):
    r"""
     This is the client-side interface to an implementation-independent
    representation of "Decorations" suitable for visualization, annotation,
    logging, or debugging but which cannot have any effect on the behavior of
    a System or the evolution of a Study. DO NOT confuse this with real geometry
    (like contact geometry) which can represent physically meaningful objects that
    may interact and change the behavior of a System. However, all geometry objects
    can generate %DecorativeGeometry for their visualization.

    Why is there a %DecorativeGeometry facility at the System level at all, so far
    away from any application program? That's because for crude visualization and
    debugging purposes, the Subsystems themselves are best able to produce some
    illustrative geometry. Otherwise, you need a special purpose visualization
    tool which understands what's going on inside each subsystem. If you don't mind
    taking what you get, just ask each subsystem to generate what it thinks would
    be helpful visualization. To do that, the subysystems need a way to talk about
    geometry without knowing anything about how that geometry will eventually get
    onto someone's screen. And that's why we're here!

    Each %DecorativeGeometry object has its own local coordinate system and is
    defined self-consistently but independent of anything else. Clients can
    associate these with a reference frame (e.g. a body), and place the local frame
    of the geometry objects on the reference frame, or at a fixed transform from
    the reference frame. That places the %DecorativeGeometry objects in a scene. We
    support both 3D objects which are attached to actors in the scene, and 2D
    "screen" objects like titles which are attached to the display rather than the
    actors. The classes here deal only with the local-frame definitions of the
    geometric objects, not their placement in the scene.

    This is an abstract handle class using the PIMPL design pattern to hide the
    private implementation. This is effectively an abstract class although the
    virtual function table is hidden in the private part. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simbody.delete_DecorativeGeometry
    Hide = _simbody.DecorativeGeometry_Hide
    r""" hide geometry for now to display later"""
    DrawPoints = _simbody.DecorativeGeometry_DrawPoints
    r""" Use a cloud of points."""
    DrawWireframe = _simbody.DecorativeGeometry_DrawWireframe
    r""" Use a line drawing."""
    DrawSurface = _simbody.DecorativeGeometry_DrawSurface
    r""" Use a shaded surface."""
    DrawDefault = _simbody.DecorativeGeometry_DrawDefault
    r""" Let someone else decide."""

    def setBodyId(self, bodyId: "int") -> "SimTK::DecorativeGeometry &":
        r"""
         By default the geometry should be placed relative to the Ground frame. If
        you want it attached to another reference frame (body), say so here. The
        geometry should be rendered with respect to the indicated body frame; however,
        the interpretation of this integer Id is left to the implementation. If you
        don't set the *bodyId* yourself it will be zero. For use in Simbody, the
        *bodyId* is interpreted as a MobilizedBodyIndex that can be mapped to a
        MobilizedBody that carries a reference frame.

        The *bodyId* is copied if you copy the %DecorativeGeometry object. If you are
        copying to a different body you'll need to change the bodyId afterwards. *
        """
        return _simbody.DecorativeGeometry_setBodyId(self, bodyId)

    def setIndexOnBody(self, index: "int") -> "SimTK::DecorativeGeometry &":
        r"""
         For selection or other purposes, you may want to use this method to store
        an index that can identify this particular piece of geometry. As an alternative,
        or addition, see setUserRef(). In any case the *index* is simply stored with
        the object and returned if you ask for it. If you don't set it the value
        is -1. The *index* is copied if you copy the %DecorativeGeometry object. Be
        sure to change it afterwards if that is not the correct index for the copy.
        Simbody sets this index when %DecorativeGeometry is added to a Body. *
        """
        return _simbody.DecorativeGeometry_setIndexOnBody(self, index)

    def setUserRef(self, userRef: "void *") -> "SimTK::DecorativeGeometry &":
        r"""
         Use this method to store an arbitrary reference pointer with this
        %DecorativeGeometry object. This is particularly useful in selection operations
        where the rendering of this object has been picked by a user and you want to
        map it back to some meaningful object in your model. You can also use the
        setIndexOnBody() method to store some additional identifying information.
        If you don't set this pointer it will be set to zero (nullptr). This value
        is stored and returned only; no interpretation is done and the pointed-to
        object will not be deleted when the %DecorativeGeometry object is deleted.

        Warning: The value of the *userRef* pointer is copied if you make a copy of the
        %DecorativeGeometry object. That is likely to be incorrect in many
        circumstances, depending on how you are using this value. Be sure to clear or
        change the pointer if necessary after you make a copy. *
        """
        return _simbody.DecorativeGeometry_setUserRef(self, userRef)

    def setTransform(self, X_BG: "Transform") -> "SimTK::DecorativeGeometry &":
        r"""
         This transform shifts the generated polygons with respect to this object's
        local frame. Subsequent calls with other transforms simply replace the earlier
        one; they do not accumulate. The default transform is identity and you can call
        setTransform(Transform()) to put the transform back into its original state.
        This value affects the generated polygonal data. *
        """
        return _simbody.DecorativeGeometry_setTransform(self, X_BG)

    def setResolution(self, arg2: "SimTK::Real") -> "SimTK::DecorativeGeometry &":
        r"""
         Each concrete %DecorativeGeometry object is expected to have a default
        resolution that gets the point across but is cheap to draw and hence probably
        somewhat "chunky". The resolution parameter here scales that default up or
        down. The face density in the displayed representation is roughly
        proportional to this value. 1.0 means to use the default resolution. Values
        less than 1.0 are lower resolution, and values greater than 1.0 are higher
        resolution. A value less than or equal to zero here is interpreted as an
        instruction to "use the default". *
        """
        return _simbody.DecorativeGeometry_setResolution(self, arg2)

    def setScaleFactors(self, scale: "Vec3") -> "SimTK::DecorativeGeometry &":
        r"""
         Each concrete DecorativeGeometry object is expected to have a default size
        around "1", whatever that means for a particular object, and most objects also
        allow a user-specified size on construction. The x,y,z scale factors here are
        given in the object's coordinate frame, and apply to the object as the user
        built it, or to the default if the user didn't specify a size. The default
        scaling is 1,1,1 and any value less than or equal to zero here is interpreted
        as a request to "use the default" in that direction. *
        """
        return _simbody.DecorativeGeometry_setScaleFactors(self, scale)

    def setScale(self, scale: "SimTK::Real") -> "SimTK::DecorativeGeometry &":
        r""" Convenience method to set all three scale factors to the same value. *"""
        return _simbody.DecorativeGeometry_setScale(self, scale)

    def getBodyId(self) -> "int":
        r"""
         Return the *bodyId* that was supplied to the most recent setBodyId()
        call for this %DecorativeGeometry object, or zero if that method has not been
        called. Copy construction and copy assignment copy the *bodyId*. This is
        intended to identify the body frame to which this geometry's placement should be
        relative; with the default zero value meaning the Ground or World frame. *
        """
        return _simbody.DecorativeGeometry_getBodyId(self)

    def getIndexOnBody(self) -> "int":
        r"""
         Return the *index* that was supplied to the most recent setIndexOnBody()
        call for this %DecorativeGeometry object, or -1 if that method has not been
        called. Copy construction and copy assignment copy the *index*. Interpretation
        of this integer is up to the caller. *
        """
        return _simbody.DecorativeGeometry_getIndexOnBody(self)

    def getUserRef(self) -> "void *":
        r"""
         Return the pointer value that was supplied to the most recent setUserRef()
        call for this %DecorativeGeometry object, or zero (nullptr) if that method has
        not been called. Copy construction and copy assignment copy the pointer.
        Interpretation of this value is up to the caller. *
        """
        return _simbody.DecorativeGeometry_getUserRef(self)

    def getResolution(self) -> "SimTK::Real":
        r"""
         Return the current setting of the "resolution" factor. A return value of
        -1 means "use the default". *
        """
        return _simbody.DecorativeGeometry_getResolution(self)

    def getTransform(self) -> "SimTK::Transform const &":
        r"""
         Return the current value of the object's transform. If none has been set
        this will be the identity transform. Note that this transform specifies how the
        polygons are placed with respect to the object's local frame. *
        """
        return _simbody.DecorativeGeometry_getTransform(self)

    def getScaleFactors(self) -> "SimTK::Vec3 const &":
        r"""
         Return the current setting of the "scale" factors. A return value of -1
        in one of the factors means to "use the default" (which is typically 1) in
        that direction. *
        """
        return _simbody.DecorativeGeometry_getScaleFactors(self)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeGeometry &":
        r"""
         Request a specific color for this DecorativeGeometry object. The default
        is that the color is determined elsewhere. To explicitly request the default,
        set the color to Vec3(-1). The implementation will check the 0'th element
        (that is, the "R" element) and if it is less than zero will ignore the other
        two elements and use the default for all three. *
        """
        return _simbody.DecorativeGeometry_setColor(self, rgb)

    def setOpacity(self, arg2: "SimTK::Real") -> "SimTK::DecorativeGeometry &":
        r"""
         Request a level of transparency for this DecorativeGeometry. This does NOT
        affect the generated geometry here. The default is that opacity is
        determined elsewhere. *
        """
        return _simbody.DecorativeGeometry_setOpacity(self, arg2)

    def setLineThickness(self, arg2: "SimTK::Real") -> "SimTK::DecorativeGeometry &":
        r"""
         Request an adjustment to the default rendering of lines and curves. This
        does NOT affect geometry generated here; it is a request passed on to the
        renderer which will probably pass it on to the hardware. A value less
        than or equal to zero here is interpreted as "use the default". *
        """
        return _simbody.DecorativeGeometry_setLineThickness(self, arg2)

    def getColor(self) -> "SimTK::Vec3 const &":
        r"""
         Return the color specified for this object, if any, otherwise Vec3(-1)
        indicating that the default color will be used. *
        """
        return _simbody.DecorativeGeometry_getColor(self)

    def getOpacity(self) -> "SimTK::Real":
        r""" Return the opacity specified for this object. *"""
        return _simbody.DecorativeGeometry_getOpacity(self)

    def getLineThickness(self) -> "SimTK::Real":
        r"""
         Return the line thickness specified for this object, if any, otherwise
        return -1 to indicate that the default line thickness should be used. *
        """
        return _simbody.DecorativeGeometry_getLineThickness(self)

    def setFaceCamera(self, shouldFace: "int") -> "SimTK::DecorativeGeometry &":
        r"""
         Set whether the geometry acts as a billboard, always rotating to face the
        camera. The default is typically no except for text. If you want 3D text that
        moves with your model, set this to false. Here 0 means false, 1 means true,
        and -1 means "use default". *
        """
        return _simbody.DecorativeGeometry_setFaceCamera(self, shouldFace)

    def getFaceCamera(self) -> "int":
        r"""
         Get whether the geometry acts as a billboard, always rotating to face the
        camera. Returns 0 for no, 1 for yes, -1 for "is using default". *
        """
        return _simbody.DecorativeGeometry_getFaceCamera(self)

    def setRepresentation(self, arg2: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeGeometry &":
        r"""
         Request a particular rendering representation of this DecorativeGeometry
        object. The default is that the rendering representation choice is made
        elsewhere. *
        """
        return _simbody.DecorativeGeometry_setRepresentation(self, arg2)

    def getRepresentation(self) -> "SimTK::DecorativeGeometry::Representation":
        r""" Returns drawing mode: -1 means "use default"; see above for others. *"""
        return _simbody.DecorativeGeometry_getRepresentation(self)

    def implementGeometry(self, arg2: "DecorativeGeometryImplementation") -> "void":
        return _simbody.DecorativeGeometry_implementGeometry(self, arg2)

    def isOwnerHandle(self) -> "bool":
        return _simbody.DecorativeGeometry_isOwnerHandle(self)

    def isEmptyHandle(self) -> "bool":
        return _simbody.DecorativeGeometry_isEmptyHandle(self)

    def __init__(self, *args):
        _simbody.DecorativeGeometry_swiginit(self, _simbody.new_DecorativeGeometry(*args))

    def hasRep(self) -> "bool":
        return _simbody.DecorativeGeometry_hasRep(self)

    def getRep(self) -> "DecorativeGeometryRep const &":
        return _simbody.DecorativeGeometry_getRep(self)

    def updRep(self) -> "DecorativeGeometryRep &":
        return _simbody.DecorativeGeometry_updRep(self)

# Register DecorativeGeometry in _simbody:
_simbody.DecorativeGeometry_swigregister(DecorativeGeometry)
Black = cvar.Black
Gray = cvar.Gray
Red = cvar.Red
Green = cvar.Green
Blue = cvar.Blue
Yellow = cvar.Yellow
Orange = cvar.Orange
Magenta = cvar.Magenta
Purple = cvar.Purple
Cyan = cvar.Cyan
White = cvar.White

class DecorativePoint(DecorativeGeometry):
    r"""
     A point of interest. Note that the point's location is given relative
    to the DecorativeGeometry frame so it will move if the geometry is transformed
    when attached somewhere or displayed. The default constructor will put the
    point at (0,0,0). *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativePoint_swiginit(self, _simbody.new_DecorativePoint(*args))

    def setPoint(self, p: "Vec3") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setPoint(self, p)

    def getPoint(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativePoint_getPoint(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativePoint &":
        return _simbody.DecorativePoint_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativePoint

# Register DecorativePoint in _simbody:
_simbody.DecorativePoint_swigregister(DecorativePoint)

class DecorativeLine(DecorativeGeometry):
    r"""
     A line between two points. Note that the actual placement can be changed
    by the parent class transform & scale; here we are just generating the
    initial line in the geometry object's local frame.

    There is a default constructor for this object but it is not much
    use unless followed by endpoint specifications. By default we produce
    a line going from (0,0,0) to (1,1,1) just so it will show up if you
    forget to set it to something meaningful. Having a default constructor
    allows us to have arrays of these objects. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeLine_swiginit(self, _simbody.new_DecorativeLine(*args))

    def setPoint1(self, p1: "Vec3") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setPoint1(self, p1)

    def setPoint2(self, p2: "Vec3") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setPoint2(self, p2)

    def setEndpoints(self, p1: "Vec3", p2: "Vec3") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setEndpoints(self, p1, p2)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeLine &":
        return _simbody.DecorativeLine_setRepresentation(self, r)

    def getPoint1(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeLine_getPoint1(self)

    def getPoint2(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeLine_getPoint2(self)
    __swig_destroy__ = _simbody.delete_DecorativeLine

# Register DecorativeLine in _simbody:
_simbody.DecorativeLine_swigregister(DecorativeLine)

class DecorativeCircle(DecorativeGeometry):
    r"""
     This defines a circle in the x-y plane, centered at the origin. The
    default constructor creates a circle of diameter 1. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, radius: "SimTK::Real"=0.5):
        _simbody.DecorativeCircle_swiginit(self, _simbody.new_DecorativeCircle(radius))

    def setRadius(self, arg2: "SimTK::Real") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setRadius(self, arg2)

    def getRadius(self) -> "SimTK::Real":
        return _simbody.DecorativeCircle_getRadius(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeCircle &":
        return _simbody.DecorativeCircle_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeCircle

# Register DecorativeCircle in _simbody:
_simbody.DecorativeCircle_swigregister(DecorativeCircle)

class DecorativeSphere(DecorativeGeometry):
    r"""
     This defines a sphere centered at the origin. The default constructor
    creates a sphere of diameter 1. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, radius: "SimTK::Real"=0.5):
        _simbody.DecorativeSphere_swiginit(self, _simbody.new_DecorativeSphere(radius))

    def setRadius(self, arg2: "SimTK::Real") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setRadius(self, arg2)

    def getRadius(self) -> "SimTK::Real":
        return _simbody.DecorativeSphere_getRadius(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeSphere &":
        return _simbody.DecorativeSphere_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeSphere

# Register DecorativeSphere in _simbody:
_simbody.DecorativeSphere_swigregister(DecorativeSphere)

class DecorativeEllipsoid(DecorativeGeometry):
    r"""
     This defines an ellipsoidal solid centered at the origin and aligned with
    the local frame axes. The default constructor creates an ellipsoid with radii
    (1/2, 1/3, 1/4) in x,y,z resp. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeEllipsoid_swiginit(self, _simbody.new_DecorativeEllipsoid(*args))

    def setRadii(self, arg2: "Vec3") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setRadii(self, arg2)

    def getRadii(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeEllipsoid_getRadii(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeEllipsoid &":
        return _simbody.DecorativeEllipsoid_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeEllipsoid

# Register DecorativeEllipsoid in _simbody:
_simbody.DecorativeEllipsoid_swigregister(DecorativeEllipsoid)

class DecorativeBrick(DecorativeGeometry):
    r"""
     This defines a rectangular solid centered at the origin and aligned with
    the local frame axes. The default constructor creates a cube of length 1 on
    each side. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeBrick_swiginit(self, _simbody.new_DecorativeBrick(*args))

    def setHalfLengths(self, arg2: "Vec3") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setHalfLengths(self, arg2)

    def getHalfLengths(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeBrick_getHalfLengths(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeBrick &":
        return _simbody.DecorativeBrick_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeBrick

# Register DecorativeBrick in _simbody:
_simbody.DecorativeBrick_swigregister(DecorativeBrick)

class DecorativeCylinder(DecorativeGeometry):
    r"""
     This defines a cylinder centered on the origin and aligned in the y
    direction. The default constructor gives it a height of 1 and the base circle
    a diameter of 1. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, radius: "SimTK::Real"=0.5, halfHeight: "SimTK::Real"=0.5):
        _simbody.DecorativeCylinder_swiginit(self, _simbody.new_DecorativeCylinder(radius, halfHeight))

    def setRadius(self, arg2: "SimTK::Real") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setRadius(self, arg2)

    def setHalfHeight(self, arg2: "SimTK::Real") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setHalfHeight(self, arg2)

    def getRadius(self) -> "SimTK::Real":
        return _simbody.DecorativeCylinder_getRadius(self)

    def getHalfHeight(self) -> "SimTK::Real":
        return _simbody.DecorativeCylinder_getHalfHeight(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeCylinder &":
        return _simbody.DecorativeCylinder_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeCylinder

# Register DecorativeCylinder in _simbody:
_simbody.DecorativeCylinder_swigregister(DecorativeCylinder)

class DecorativeFrame(DecorativeGeometry):
    r"""
     This defines geometry to represent a coordinate frame. The default
    constructor makes three perpendicular lines beginning at the origin and
    extending in the +x, +y, and +z directions by 1 unit. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, axisLength: "SimTK::Real"=1):
        _simbody.DecorativeFrame_swiginit(self, _simbody.new_DecorativeFrame(axisLength))

    def setAxisLength(self, arg2: "SimTK::Real") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setAxisLength(self, arg2)

    def getAxisLength(self) -> "SimTK::Real":
        return _simbody.DecorativeFrame_getAxisLength(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeFrame &":
        return _simbody.DecorativeFrame_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeFrame

# Register DecorativeFrame in _simbody:
_simbody.DecorativeFrame_swigregister(DecorativeFrame)

class DecorativeText(DecorativeGeometry):
    r"""
     This defines a text label with its base at the origin. The default
    constructor creates a blank label. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeText_swiginit(self, _simbody.new_DecorativeText(*args))

    def setText(self, label: "std::string const &") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setText(self, label)

    def getText(self) -> "std::string const &":
        return _simbody.DecorativeText_getText(self)

    def setIsScreenText(self, isScreen: "bool") -> "SimTK::DecorativeText &":
        r"""
        By default the text is part of the scene; set this flag if you want
           it to just show up in a fixed spot on the screen instead. *
        """
        return _simbody.DecorativeText_setIsScreenText(self, isScreen)

    def getIsScreenText(self) -> "bool":
        return _simbody.DecorativeText_getIsScreenText(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setLineThickness(self, t)

    def setFaceCamera(self, yn: "int") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setFaceCamera(self, yn)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeText &":
        return _simbody.DecorativeText_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeText

# Register DecorativeText in _simbody:
_simbody.DecorativeText_swigregister(DecorativeText)

class DecorativeMesh(DecorativeGeometry):
    r"""
     This defines a displayable mesh by referencing an already-existing
    PolygonalMesh object. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mesh: "PolygonalMesh"):
        _simbody.DecorativeMesh_swiginit(self, _simbody.new_DecorativeMesh(mesh))

    def getMesh(self) -> "SimTK::PolygonalMesh const &":
        return _simbody.DecorativeMesh_getMesh(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeMesh &":
        return _simbody.DecorativeMesh_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeMesh

# Register DecorativeMesh in _simbody:
_simbody.DecorativeMesh_swigregister(DecorativeMesh)

class DecorativeMeshFile(DecorativeGeometry):
    r"""
     This defines a displayable mesh by referencing a file name containing the
    mesh. If format is not supported by visualizer it will be ignored. . *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, meshFileName: "std::string const &"):
        _simbody.DecorativeMeshFile_swiginit(self, _simbody.new_DecorativeMeshFile(meshFileName))

    def getMeshFile(self) -> "std::string const &":
        return _simbody.DecorativeMeshFile_getMeshFile(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeMeshFile &":
        return _simbody.DecorativeMeshFile_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeMeshFile

# Register DecorativeMeshFile in _simbody:
_simbody.DecorativeMeshFile_swigregister(DecorativeMeshFile)

class DecorativeTorus(DecorativeGeometry):
    r"""
     This defines a displayable torus, the torus is centered at the
    origin with the axial direction aligned to the z-axis. It is defined by
    a torusRadius (radius of the circular centerline of the torus, measured
    from the origin), and a tubeRadius (radius of the torus cross-section:
    perpendicular distance from the circular centerline to the surface). *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, torusR: "SimTK::Real"=1, tubeR: "SimTK::Real"=0.1):
        _simbody.DecorativeTorus_swiginit(self, _simbody.new_DecorativeTorus(torusR, tubeR))

    def setTorusRadius(self, arg2: "SimTK::Real") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setTorusRadius(self, arg2)

    def setTubeRadius(self, arg2: "SimTK::Real") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setTubeRadius(self, arg2)

    def getTorusRadius(self) -> "SimTK::Real":
        return _simbody.DecorativeTorus_getTorusRadius(self)

    def getTubeRadius(self) -> "SimTK::Real":
        return _simbody.DecorativeTorus_getTubeRadius(self)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeTorus &":
        return _simbody.DecorativeTorus_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeTorus

# Register DecorativeTorus in _simbody:
_simbody.DecorativeTorus_swigregister(DecorativeTorus)

class DecorativeArrow(DecorativeGeometry):
    r"""
     An arrow with start point, end point and tip-length. Note that
    the actual placement can be changed by the parent class transform & scale;
    here we are just generating the initial arrow in the geometry object's local
    frame.

    There is a default constructor for this object but it is not much
    use unless followed by end point(s) specifications. By default
    we produce an arrow going from (0,0,0) to (1,1,1) and tip
    length of .35 just so it will show up if you forget to set it to something
    meaningful. Having a  default constructor allows us to have arrays of these
    objects. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeArrow_swiginit(self, _simbody.new_DecorativeArrow(*args))

    def getStartPoint(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeArrow_getStartPoint(self)

    def getEndPoint(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeArrow_getEndPoint(self)

    def getTipLength(self) -> "SimTK::Real const &":
        return _simbody.DecorativeArrow_getTipLength(self)

    def setStartPoint(self, start: "Vec3") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setStartPoint(self, start)

    def setEndPoint(self, end: "Vec3") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setEndPoint(self, end)

    def setTipLength(self, arg2: "SimTK::Real") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setTipLength(self, arg2)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeArrow &":
        return _simbody.DecorativeArrow_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeArrow

# Register DecorativeArrow in _simbody:
_simbody.DecorativeArrow_swigregister(DecorativeArrow)

class DecorativeCone(DecorativeGeometry):
    r"""
     A cone with origin point, direction, height and base radius. Note that
    the actual placement can be changed by the parent class transform & scale;
    here we are just generating the initial cone in the geometry object's local frame.

    There is a default constructor for this object but it is not much
    use unless followed by point, direction, height and base-radius specifications. By default
    we produce a cone going from (0,0,0) in direction (1,1,1) of height 1 and base
    radius of 0.5 just so it will show up if you forget to set it to something meaningful.
    Having a default constructor allows us to have arrays of these objects. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _simbody.DecorativeCone_swiginit(self, _simbody.new_DecorativeCone(*args))

    def getOrigin(self) -> "SimTK::Vec3 const &":
        return _simbody.DecorativeCone_getOrigin(self)

    def getDirection(self) -> "SimTK::UnitVec3 const &":
        return _simbody.DecorativeCone_getDirection(self)

    def getHeight(self) -> "SimTK::Real const &":
        return _simbody.DecorativeCone_getHeight(self)

    def getBaseRadius(self) -> "SimTK::Real const &":
        return _simbody.DecorativeCone_getBaseRadius(self)

    def setOrigin(self, origin: "Vec3") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setOrigin(self, origin)

    def setDirection(self, direction: "UnitVec3") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setDirection(self, direction)

    def setHeight(self, length: "SimTK::Real") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setHeight(self, length)

    def setBaseRadius(self, base: "SimTK::Real") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setBaseRadius(self, base)

    def setBodyId(self, b: "int") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::DecorativeCone &":
        return _simbody.DecorativeCone_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_DecorativeCone

# Register DecorativeCone in _simbody:
_simbody.DecorativeCone_swigregister(DecorativeCone)

class Decorations(DecorativeGeometry):
    r"""
     This defines a single DecorativeGeometry object that is composed of a
    collection of other DecorativeGeometry objects. Parameters set for the
    parent object serve as defaults for the contained objects, but those objects
    can override or be composed with the default values. Body id, index, and
    userRef pointer (if any) for the contained objects are overridden
    unconditionally from the %Decorations object so that implementations will see
    these as identical for each piece of the composite object. Reference frames are
    composed; scale factors, resolution, opacity, and line thickness are composed,
    with unspecified values (-1) being treated as 1. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct an empty container for DecorativeGeometry objects. *

        |

        *Overload 2:*
        Construct a Decorations container initially consting of just a single
           DecorativeGeometry object. *
        """
        _simbody.Decorations_swiginit(self, _simbody.new_Decorations(*args))

    def addDecoration(self, *args) -> "SimTK::Decorations &":
        r"""
        *Overload 1:*
        Add a DecorativeGeometry object to this collection. *

        |

        *Overload 2:*
        Add a DecorativeGeometry object to this collection and place it
           relative to the Decorations frame. *
        """
        return _simbody.Decorations_addDecoration(self, *args)

    def getNumDecorations(self) -> "int":
        r"""
        Determine how many DecorativeGeometry objects are in this
           collection. *
        """
        return _simbody.Decorations_getNumDecorations(self)

    def getDecoration(self, i: "int") -> "SimTK::DecorativeGeometry const &":
        r"""
        Get access to one of the DecorativeGeometry objects in this
           collection. *
        """
        return _simbody.Decorations_getDecoration(self, i)

    def setBodyId(self, b: "int") -> "SimTK::Decorations &":
        return _simbody.Decorations_setBodyId(self, b)

    def setIndexOnBody(self, x: "int") -> "SimTK::Decorations &":
        return _simbody.Decorations_setIndexOnBody(self, x)

    def setUserRef(self, p: "void *") -> "SimTK::Decorations &":
        return _simbody.Decorations_setUserRef(self, p)

    def setTransform(self, X_BD: "Transform") -> "SimTK::Decorations &":
        return _simbody.Decorations_setTransform(self, X_BD)

    def setResolution(self, r: "SimTK::Real") -> "SimTK::Decorations &":
        return _simbody.Decorations_setResolution(self, r)

    def setScaleFactors(self, s: "Vec3") -> "SimTK::Decorations &":
        return _simbody.Decorations_setScaleFactors(self, s)

    def setColor(self, rgb: "Vec3") -> "SimTK::Decorations &":
        return _simbody.Decorations_setColor(self, rgb)

    def setOpacity(self, o: "SimTK::Real") -> "SimTK::Decorations &":
        return _simbody.Decorations_setOpacity(self, o)

    def setLineThickness(self, t: "SimTK::Real") -> "SimTK::Decorations &":
        return _simbody.Decorations_setLineThickness(self, t)

    def setRepresentation(self, r: "SimTK::DecorativeGeometry::Representation const &") -> "SimTK::Decorations &":
        return _simbody.Decorations_setRepresentation(self, r)
    __swig_destroy__ = _simbody.delete_Decorations

# Register Decorations in _simbody:
_simbody.Decorations_swigregister(Decorations)

class DecorativeGeometryImplementation(object):
    r"""
     Use this abstract class to connect your implementation of decorative
    geometry to the implementation-independent classes above. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simbody.delete_DecorativeGeometryImplementation

    def implementPointGeometry(self, arg0: "DecorativePoint") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementPointGeometry(self, arg0)

    def implementLineGeometry(self, arg0: "DecorativeLine") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementLineGeometry(self, arg0)

    def implementBrickGeometry(self, arg0: "DecorativeBrick") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementBrickGeometry(self, arg0)

    def implementCylinderGeometry(self, arg0: "DecorativeCylinder") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementCylinderGeometry(self, arg0)

    def implementCircleGeometry(self, arg0: "DecorativeCircle") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementCircleGeometry(self, arg0)

    def implementSphereGeometry(self, arg0: "DecorativeSphere") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementSphereGeometry(self, arg0)

    def implementEllipsoidGeometry(self, arg0: "DecorativeEllipsoid") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementEllipsoidGeometry(self, arg0)

    def implementFrameGeometry(self, arg0: "DecorativeFrame") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementFrameGeometry(self, arg0)

    def implementTextGeometry(self, arg0: "DecorativeText") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementTextGeometry(self, arg0)

    def implementMeshGeometry(self, arg0: "DecorativeMesh") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementMeshGeometry(self, arg0)

    def implementMeshFileGeometry(self, arg0: "DecorativeMeshFile") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementMeshFileGeometry(self, arg0)

    def implementTorusGeometry(self, arg0: "DecorativeTorus") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementTorusGeometry(self, arg0)

    def implementArrowGeometry(self, arg0: "DecorativeArrow") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementArrowGeometry(self, arg0)

    def implementConeGeometry(self, arg0: "DecorativeCone") -> "void":
        return _simbody.DecorativeGeometryImplementation_implementConeGeometry(self, arg0)

    def __init__(self):
        if self.__class__ == DecorativeGeometryImplementation:
            _self = None
        else:
            _self = self
        _simbody.DecorativeGeometryImplementation_swiginit(self, _simbody.new_DecorativeGeometryImplementation(_self, ))
    def __disown__(self):
        self.this.disown()
        _simbody.disown_DecorativeGeometryImplementation(self)
        return weakref.proxy(self)

# Register DecorativeGeometryImplementation in _simbody:
_simbody.DecorativeGeometryImplementation_swigregister(DecorativeGeometryImplementation)

class ArrayDecorativeGeometry(object):
    r"""
     The SimTK::Array_<T> container class is a plug-compatible replacement for
    the C++ standard template library (STL) std::vector<T> class, but with some
    important advantages in performance, and functionality, and binary
    compatibility.

    :param T:
            The type of object to be stored in this container.
    :param X:
            The type to be used for indexing this container, with default unsigned
            (not size_t). Any integral type may be used, as well as user types that
            satisfy the requirements discussed with class ArrayIndexTraits.

    Title: Performance:
    There are several performance and memory footprint problems with the C++
    standard STL design in general, and with Microsoft's implementation in
    particular, that are addressed here. Microsoft in its wisdom decided that STL
    containers should still do runtime range checks in Release builds for safety,
    but that makes them too slow for use in some high-performance contexts (and
    also breaks the promise of generic programming but that's another rant). In
    practice, VC++9 std::vector runs about half speed for simple operations like
    indexing and push_back. Attempting to disable these runtime checks with
    _SECURE_SCL breaks binary compatibility. In contrast the performance of this
    Array_<T> class on any platform is indistinguishable from what you would get
    by managing your own heap-allocated arrays.

    Title: Regarding memory footprint, the typical implementation of std::vector uses
    three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.
    Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit
    machine -- I don't know what they do on a 64 bit machine but I'm not
    optimistic! Array_ instead uses one pointer and two lengths for a total size
    as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.

    Title: Some nuts and bolts:

    - We promise that no heap allocation occurs when an empty Array_<T> object
      is declared (that is, when an Array_<T> is default-constructed); in
      that case both begin() and end() are null.
    - Array_<T> methods are extremely fast in Release builds with zero overhead,
      inline, unchecked methods. The implementations of inline methods are kept
      small to ensure that they are actually inlined in practice; and generated
      assembly code was examined to make sure.
    - There are some dangerous extensions provided that permit the expert user
      to construct objects directly into the array without having to copy them,
      a big win for complicated objects and even bigger for those that don't
      have copy constructors!
    - There is a constant-time eraseFast() method you can use if you don't mind the
      array being reordered after the erase. This avoids the extremely expensive
      "compress" activity required by the standard erase() method.
    - The optional index-type template parameter can be used to reduce the memory
      footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit
      pointer and two shorts).
    - The default size_type for an Array_<T> is a 32-bit unsigned integer rather
      than a size_t. On a 64-bit machine that keeps the overhead down substantially
      since the structure is then one 64-bit pointer and two 32-bit integers,
      fitting tightly into a cleanly alignable 16 bytes.


    Title: Functionality:
    For the most part Array_<T> is a plug-compatible replacement for std::vector<T>,
    and everything that both classes can do is done with an identical API. However,
    there are a few additions and subtractions:

    - This class always uses the default new/delete allocator; there is no option
      to specify your own as there is in std::vector.
    - Instead of an allocator, the second template argument X to Array_<T,X> is an
      optional index type which can be used to provide type-safe indexing (i.e. the
      array can only be indexed by indices of a particular type, like
      MobilizedBodyIndex). This has zero performance cost if the index is an
      integral type or class consisting of only an integral value such as those
      produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.
    - You can create uninitialized slots in the array and construct directly into
      them rather than having to construct a temporary object which must then be
      copied into the array.
    - You can create Array_<T> objects that reference existing data, including
      the contents of std::vectors.
    - Where possible this class implements the new std::vector features proposed
      for the C++0x standard (see below).

    Title: Compatibility:
    Included here are binary compatibility issues and compatibility with the C++
    standard STL objects.

    - Most important, it is safe to pass an Array_<T> through an API to a binary
      library without worrying about compiler version or Release/Debug compatibility
      issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit
      vs. 32 bit), Array_<T> has an extremely stable memory layout that is preserved
      across compiler versions, and between Release and Debug builds. This allows us
      to use Array_<T> in the SimTK API where use of std::vector<T> would be
      desirable but problematic.
    - It supports all standard types, methods, iterators, and operators of the
      C++98 standard std::vector and the C++0x proposed improvements other than
      those requiring rvalue references, so it works smoothly with all STL
      containers and algorithms.
    - It is convertible to and from std::vector, usually without copying the
      elements. It is easy to provide APIs that accept either Array_<T> or
      std::vector<T>; the std::vector's data is referenced by an Array_ handle
      that is used to convey the data across the API without binary compatibility
      problems.

    See also: Array_, ArrayViewConst_, ArrayIndexTraits *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor allocates no heap space and is very fast. *

        |

        *Overload 2:*
         Construct an array containing *n* default-constructed elements. T's default
        constructor (if any) is called exactly *n* times. If *n* is zero no heap space
        will be allocated; although in that case it is preferable to use the default
        constructor if you can since that will be somewhat faster. *

        |

        *Overload 3:*
         Construct an array containing *n* elements each set to a copy of the given
        initial value. T's copy constructor will be called exactly *n* times. If *n*
        is zero no space will be allocated. *

        |

        *Overload 4:*
         Copy constructor allocates exactly as much memory as is in use in the
        source (not its capacity) and copy constructs the elements so that T's copy
        constructor will be called exactly src.size() times. If the source is empty,
        no heap space will be allocated. *

        |

        *Overload 5:*
         Construct an Array_<T> by referencing (sharing) a given range of data
        [first,last1), without copying that data; better to use the corresponding
        ArrayView_<T> constructor if you can. This is very fast but can be
        dangerous -- it is most useful for argument passing where the array handle
        will be discarded immediately after use. Note that this is available only if
        you have write access to the data because there is no way to construct
        a non-writable array. This will work as long as the size of the data does
        not exceed the array's max_size. The resulting array object is not resizeable
        but can be used to read and write elements of the original data. The
        array is invalid if the original data is destructed or resized, but there is
        no way for the array class to detect that.

        Remarks: 
          - If the source data is empty, the resulting array will also
            be empty and will look just like a default-constructed array. It will
            therefore not have any connection to the source and will be an
            ordinary resizable array.
          - This is quite dangerous to use since the connection between the array and
            the data is tenuous and subject to the data remaining untouched during
            the lifetime of the array handle. There is no reference counting;
            destructing the original data would leave the array referring to garbage.
            Be careful!
          - You can break the connection between the array and the data it was
            constructed from by calling deallocate().

        Title: Complexity:
            Dirt cheap. There will be no construction, destruction, or heap allocation
            performed.
        See also: deallocate() *
        """
        _simbody.ArrayDecorativeGeometry_swiginit(self, _simbody.new_ArrayDecorativeGeometry(*args))
    __swig_destroy__ = _simbody.delete_ArrayDecorativeGeometry

    def deallocate(self) -> "SimTK::Array_< SimTK::DecorativeGeometry > &":
        r"""
         Empty this array of its contents, returning the array to its
        default-constructed, all-zero state. If this array is the owner of its data,
        the destructor (if any) is called for each data element and the array's
        allocated heap space is freed. If it is a non-owner the array handle is
        cleaned out using disconnect() but the referenced data is untouched.
        Notes: There is no equivalent to this method for std::vector.
        :rtype: SimTK::Array_< SimTK::DecorativeGeometry >
        :return: A reference to the now-empty, default-constructed array, ready for
            reassignment. *
        """
        return _simbody.ArrayDecorativeGeometry_deallocate(self)

    def assign(self, n: "SimTK::Array_< SimTK::DecorativeGeometry >::size_type", fillValue: "DecorativeGeometry") -> "void":
        r"""
        These methods put new data values in an existing array, but the meaning of
        assignment is subtly different for resizeable (owner) arrays and fixed
        (non-owner) arrays. The standard std::vector type is always an owner so the
        non-owner description here is an extension applying only to Array_.

        For the normal case of resizeable arrays, assignment does not have an
        elementwise definition because the source will typically have a different
        number of elements than the array's current size. So regardless of the actual
        numbers, assignment in the resizeable case is defined as it is for std::vector:
        first clear the array by erasing (destructing) all the current elements in the
        array, then reserve sufficient heap space to hold a copy of the source, then
        use appropriate constructors of type T (most commonly T's copy constructor
        T(T)) to initialize each element to be a copy of the corresponding source
        element. T's assignment operators are never used in this case.

        For fixed arrays, the source must have the same number of elments as are
        currently in the array and the meaning is conventional elementwise assignment;
        that is, an appropriate assignment operator of type T (most commonly T's copy
        assignment operator T=T) is used to change the value of each existing element.

        So there are different requirements on the value type T for owner and non-owner
        assignments to type T2: for owner assignment T must have a constructor T(T2)
        available; for non-owner assignment, T must have an assignment operator T=T2
        available; .

        Remarks: 
        - When reallocating the destination array, we may reuse the existing heap
        allocation if it is sufficient and not *too* big; otherwise we'll reallocate
        before copying.
        - The fill() method here has elementwise assignment semantics regardless of
        whether the array is an owner or non-owner. * Set this array to be *n* copies of the supplied *fillValue*. Note that
        this serves to allow fill from an object whose type T2 is different from T, as
        long as there is a constructor T(T2) that works since that can be invoked
        (implicitly or explicitly) to convert the T2 object to type T prior to the
        call. If this is a non-owner array then *n* must be the same as the current
        size(); consider using the fill() method instead.
        :type n: int, in
        :param n:            The number of elements to be in the result.
        :type fillValue: :py:class:`DecorativeGeometry`, in
        :param fillValue:    The value to which to initialize each element.

        Title: Complexity:
        For a non-owner with *n==size()*, there will be exactly *n* calls to T's
        copy assignment operator. For an owner, there will be size() calls to T's
        destructor (if it has one), possibly a heap reallocation (but with no element
        copying), followed by *n* calls to T's copy constructor.
        See also: fill() *
        """
        return _simbody.ArrayDecorativeGeometry_assign(self, n, fillValue)

    def fill(self, fillValue: "DecorativeGeometry") -> "void":
        r"""
         Assign all current elements of the array to the same *fillValue*. This is
        similar to assign(size(),fillValue) but the semantics are subtly different.
        Here we use repeated application of T's copy assignment operator T=fillValue,
        whereas the assign() semantics are to first destruct all the existing elements,
        then allocate if necessary, then use the copy constructor to initialize the
        new elements. Note that you can use this to fill from a source type T2 that
        is different from T as long as there exists a suitable constructor T(T2) that
        can be used to create the type T *fillValue* from the original T2 source.
        Notes: Unlike other assignment methods, the behavior of fill() is identical for
        owner and non-owner arrays.

        :type fillValue: :py:class:`DecorativeGeometry`, in
        :param fillValue:    The value to which all existing elements are set.
        Title: Complexity:
        Just size() calls to T's copy assignment operator. *
        """
        return _simbody.ArrayDecorativeGeometry_fill(self, fillValue)

    def swap(self, other: "ArrayDecorativeGeometry") -> "void":
        r"""
         This is a specialized algorithm providing constant time exchange of data
        with another array that has identical element and index types. This is *much*
        faster than using the std::swap() algorithm on the arrays since that would
        involve O(n) copying operations. This method makes no calls to any constructors
        or destructors. This is allowable even for non-owner arrays; the non-owner
        attribute will follow the non-owned data. *
        """
        return _simbody.ArrayDecorativeGeometry_swap(self, other)

    def adoptData(self, *args) -> "SimTK::Array_< SimTK::DecorativeGeometry > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to supply your own already-allocated
        heap space for use by this array, which then becomes the owner of the supplied
        heap space. Any memory currently associated with the array is deallocated;
        see deallocate() for more information.
        See also: deallocate(), shareData() *

        |

        *Overload 2:*
         A variant of adoptData() that assumes the capacity is the same as the
        current size. See also: adoptData(data,size,capacity) *
        """
        return _simbody.ArrayDecorativeGeometry_adoptData(self, *args)

    def shareData(self, *args) -> "SimTK::Array_< SimTK::DecorativeGeometry > &":
        r"""
        *Overload 1:*
         This dangerous extension allows you to make this array handle refer to
        someone else's data without copying it. Any memory currently associated
        with the array is deallocated; see deallocate() for more information. This
        method makes the array a fixed-size, non-owner array that cannot be
        reallocated, and no element destruction nor heap deallocation will occur when
        the handle is subsequently destructed or deallocated.
        Notes: 
          - A null (0) pointer is allowed for the pointer as long as *dataSize==0*,
            however in that case the array handle ends up deallocated (that is,
            indistinguishable from a default-constructed array) so is resizeable.
          - This is implemented by setting the nAllocated data member to zero while
            the nUsed data member is set to the given *dataSize*.
        See also: deallocate(), adoptData() *

        |

        *Overload 2:*
         Same as shareData(data,size) but uses a pointer range [first,last1) to
        identify the data to be referenced. *
        """
        return _simbody.ArrayDecorativeGeometry_shareData(self, *args)

    def size(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::size_type":
        r""" Return the current number of elements stored in this array. *"""
        return _simbody.ArrayDecorativeGeometry_size(self)

    def max_size(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::size_type":
        r""" Return the maximum allowable size for this array. *"""
        return _simbody.ArrayDecorativeGeometry_max_size(self)

    def empty(self) -> "bool":
        r"""
         Return true if there are no elements currently stored in this array. This
        is equivalent to the tests begin() == end() or size()==0. *
        """
        return _simbody.ArrayDecorativeGeometry_empty(self)

    def capacity(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::size_type":
        r"""
         Return the number of elements this array can currently hold without
        requiring reallocation. The value returned by capacity() is always greater
        than or equal to size(), even if the data is not owned by this array in
        which case we have capacity() == size() and the array is not reallocatable. *
        """
        return _simbody.ArrayDecorativeGeometry_capacity(self)

    def resize(self, *args) -> "void":
        r"""
        *Overload 1:*
         Change the size of this Array, preserving all the elements that will still
        fit, and default constructing any new elements that are added. This is not
        allowed for non-owner arrays unless the requested size is the same as the
        current size. *

        |

        *Overload 2:*
         Change the size of this array, preserving all the elements that will still
        fit, and initializing any new elements that are added by repeatedly copy-
        constructing from the supplied value. This is not allowed for non-owner arrays
        unless the requested size is the same as the current size. *
        """
        return _simbody.ArrayDecorativeGeometry_resize(self, *args)

    def reserve(self, n: "SimTK::Array_< SimTK::DecorativeGeometry >::size_type") -> "void":
        r"""
         Ensure that this array has enough allocated capacity to hold the indicated
        number of elements. No heap reallocation will occur after this until the array
        is grown beyond this capacity, meaning that adding elements will not invalidate
        any iterators or element addresses until that point. This method will never
        reduce the capacity of the array. It is OK to call this on a non-owner array
        as long as you are not asking for an increase in capacity. *
        """
        return _simbody.ArrayDecorativeGeometry_reserve(self, n)

    def shrink_to_fit(self) -> "void":
        r"""
         Request that the capacity of this array be reduced to the minimum necessary
        to hold the number of elements currently in use. In practice no shrinkage will
        occur if the current size is just slightly too big, unless the current size is
        exactly zero in which case we guarantee to deallocate all heap space associated
        with this array leaving a null data pointer and begin()==end()==0, exactly as
        though the array had just been default-constructed. Otherwise you can check
        capacity() afterwards to see what happened. If the capacity() is reduced by
        this method, then all the elements will have been moved to new locations so
        existing iterators and references into the array will become invalid.

        Notes: 
          - This method is from the proposed C++0x standard for std::vector, except for
            the guaranteed behavior for a zero-size container.
          - It is OK to call this on a non-owner array but it has no effect since
            capacity()==size() already in that case.

        Title: Complexity:
            If the capacity is reduced, there will be one call to T's copy constructor
            and destructor (if any) for each element currently in the array. Otherwise
            this is very fast. *
        """
        return _simbody.ArrayDecorativeGeometry_shrink_to_fit(self)

    def allocated(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::size_type":
        r"""
         Return the amount of heap space owned by this array; this is the same
        as capacity() for owner arrays but is zero for non-owners.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.ArrayDecorativeGeometry_allocated(self)

    def isOwner(self) -> "bool":
        r"""
         Does this array own the data to which it refers? If not, it can't be
        resized, and the destructor will not free any heap space nor call any element
        destructors. If the array does not refer to *any* data it is considered to be
        an owner and it is resizeable.
        Notes: There is no equivalent of this method for std::vector. *
        """
        return _simbody.ArrayDecorativeGeometry_isOwner(self)

    def cbegin(self) -> "SimTK::DecorativeGeometry const *":
        r"""
         Return a const pointer to the first element of this array if any, otherwise
        cend(), which may be null (0) in that case but does not have to be. This method
        is from the proposed C++0x standard; there is also an overloaded begin() from
        the original standard that returns a const pointer. *
        """
        return _simbody.ArrayDecorativeGeometry_cbegin(self)

    def begin(self, *args) -> "SimTK::DecorativeGeometry *":
        r"""
        *Overload 1:*
         The const version of begin() is the same as cbegin(). *

        |

        *Overload 2:*
         Return a writable pointer to the first element of this array if any,
        otherwise end(). If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin() == end() for
        an empty array. *
        """
        return _simbody.ArrayDecorativeGeometry_begin(self, *args)

    def cend(self) -> "SimTK::DecorativeGeometry const *":
        r"""
         Return a const pointer to what would be the element just after the last one
        in the array; this may be null (0) if there are no elements but doesn't have to
        be. This method is from the proposed C++0x standard; there is also an
        overloaded end() from the original standard that returns a const pointer. *
        """
        return _simbody.ArrayDecorativeGeometry_cend(self)

    def end(self, *args) -> "SimTK::DecorativeGeometry *":
        r"""
        *Overload 1:*
         The const version of end() is the same as cend(). *

        |

        *Overload 2:*
         Return a writable pointer to what would be the element just after the last
        one in this array. If the array is empty, this *may* return null (0) but does
        not have to -- the only thing you can be sure of is that begin()==end() for an
        empty array. *
        """
        return _simbody.ArrayDecorativeGeometry_end(self, *args)

    def crbegin(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::const_reverse_iterator":
        r"""
         Return a const reverse iterator pointing to the last element in the array
        or crend() if the array is empty. *
        """
        return _simbody.ArrayDecorativeGeometry_crbegin(self)

    def rbegin(self, *args) -> "SimTK::Array_< SimTK::DecorativeGeometry >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rbegin() is the same as crbegin(). *

        |

        *Overload 2:*
         Return a writable reverse iterator pointing to the last element in the
        array or rend() if the array is empty. *
        """
        return _simbody.ArrayDecorativeGeometry_rbegin(self, *args)

    def crend(self) -> "SimTK::Array_< SimTK::DecorativeGeometry >::const_reverse_iterator":
        r"""
         Return the past-the-end reverse iterator that tests equal to a reverse
        iterator that has been incremented past the front of the array. You cannot
        dereference this iterator. *
        """
        return _simbody.ArrayDecorativeGeometry_crend(self)

    def rend(self, *args) -> "SimTK::Array_< SimTK::DecorativeGeometry >::reverse_iterator":
        r"""
        *Overload 1:*
         The const version of rend() is the same as crend(). *

        |

        *Overload 2:*
         Return a writable past-the-end reverse iterator that tests equal to a
        reverse iterator that has been incremented past the front of the array. You
        cannot dereference this iterator. *
        """
        return _simbody.ArrayDecorativeGeometry_rend(self, *args)

    def cdata(self) -> "SimTK::DecorativeGeometry const *":
        r"""
         Return a const pointer to the first element of the array, or possibly
        (but not necessarily) null (0) if the array is empty.
        Notes: 
            cdata() does not appear to be in the C++0x standard although it would seem
            obvious in view of the cbegin() and cend() methods that had to be added.
            The C++0x overloaded const data() method is also available. *
        """
        return _simbody.ArrayDecorativeGeometry_cdata(self)

    def data(self, *args) -> "SimTK::DecorativeGeometry *":
        r"""
        *Overload 1:*
         The const version of the data() method is identical to cdata().
        Notes: This method is from the proposed C++0x std::vector. *

        |

        *Overload 2:*
         Return a writable pointer to the first allocated element of the array, or
        a null pointer if no space is associated with the array.
        Notes: This method is from the proposed C++0x std::vector. *
        """
        return _simbody.ArrayDecorativeGeometry_data(self, *args)

    def at(self, *args) -> "SimTK::DecorativeGeometry &":
        r"""
        *Overload 1:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Same as operator[] but always range-checked, even in a Release build.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.ArrayDecorativeGeometry_at(self, *args)

    def getElt(self, i: "SimTK::Array_< SimTK::DecorativeGeometry >::index_type") -> "SimTK::DecorativeGeometry const &":
        r"""
         Same as the const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.ArrayDecorativeGeometry_getElt(self, i)

    def updElt(self, i: "SimTK::Array_< SimTK::DecorativeGeometry >::index_type") -> "SimTK::DecorativeGeometry &":
        r"""
         Same as the non-const form of operator[]; exists to provide a non-operator
        method for element access in case that's needed. *
        """
        return _simbody.ArrayDecorativeGeometry_updElt(self, i)

    def front(self, *args) -> "SimTK::DecorativeGeometry &":
        r"""
        *Overload 1:*
         Return a const reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the first element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.ArrayDecorativeGeometry_front(self, *args)

    def back(self, *args) -> "SimTK::DecorativeGeometry &":
        r"""
        *Overload 1:*
         Return a const reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *

        |

        *Overload 2:*
         Return a writable reference to the last element in this array, which must
        not be empty.
        Title: Complexity:
            Constant time. *
        """
        return _simbody.ArrayDecorativeGeometry_back(self, *args)

    def push_back(self, *args) -> "void":
        r"""
        *Overload 1:*
         This method increases the size of the Array by one element at the end and
        initializes that element by copy constructing it from the given value. If
        capacity() > size(), that's all that will happen. If capacity()==size(), there
        is no room for another element so we'll allocate more space and move all the
        elements there. A reference to the just-inserted element can be obtained using
        the back() method after the call to push_back().
        :type value: :py:class:`DecorativeGeometry`, in
        :param value:
                An object of type T from which the new element is copy-constructed.

        Remarks: 
          - If you are appending a default-constructed object of type T, consider using
            the alternate non-standard but safe push_back() method rather than
            push_back(T()). The non-standard method default-constructs the new element
            internally. That avoids a call to the copy constructor which can be
            expensive for some objects, and nonexistent for others.
          - If you are constructing the source object with a non-default constructor,
            and the object is expensive or impossible to default-construct and/or
            copy-construct, consider using the non-standard and dangerous method
            raw_push_back() which enables you to construct the new element in place.

        Title: Complexity:
            Constant time if no reallocation is required; otherwise the current
            contents of the array must be copied to new space, costing one call to T's
            copy constructor and destructor (if any) for each element currently in the
            array. Either way there is also one call to T's copy constructor to
            construct the new element from the supplied value. *

        |

        *Overload 2:*
         This is a non-standard version of push_back() that increases the size of the
        array by one default-constructed element at the end. This avoids having to
        default-construct the argument to the standard push_back(value) method which
        then has to copy-construct it into the array. By carefully avoiding
        reallocation and using this form of push_back() you can use the Array_<T> class
        to hold objects of type T even if T has no copy constructor, which is
        prohibited by the standard std::vector<T> definition.

        Title: Complexity:
            Same as the standard push_back(value) method except without the final
            call to T's copy constructor.
        See also: push_back(value)
        """
        return _simbody.ArrayDecorativeGeometry_push_back(self, *args)

    def raw_push_back(self) -> "SimTK::DecorativeGeometry *":
        r"""
         This dangerous method increases the Array's size by one element at the end
        but doesn't perform any construction so the memory is filled with garbage. You
        must immediately construct into this space, using code like:

        .. code-block:: c++

                new(a.raw_push_back()) MyConstructor(...args...);
        This is a substantial performance improvement when the element type is something
        complicated since the constructor is called once and not copied; it can also be
        used for objects that have neither default nor copy constructors.
        :rtype: :py:class:`DecorativeGeometry`
        :return: 
                An iterator (pointer) pointing at the unconstructed element.
        Title: Complexity:
            Same as ordinary push_back().
        See also: push_back(value), push_back()
        """
        return _simbody.ArrayDecorativeGeometry_raw_push_back(self)

    def pop_back(self) -> "void":
        r"""
         Remove the last element from this array, which must not be empty. The
        element is destructed, not returned. The array's size() is reduced by one. *
        """
        return _simbody.ArrayDecorativeGeometry_pop_back(self)

    def erase(self, *args) -> "SimTK::DecorativeGeometry *":
        r"""
        *Overload 1:*
         Erase elements in range [first,last1), packing in any later elements into
        the newly-available space and reducing the array's size by the number of
        elements erased. Capacity is unchanged. If the range is empty nothing happens.

        :type first: :py:class:`DecorativeGeometry`
        :param first:
                Points to the first element that will be erased.
        :type last1: :py:class:`DecorativeGeometry`
        :param last1:
                Points one element past the last element to be erased.
        :rtype: :py:class:`DecorativeGeometry`
        :return: 
                An iterator pointing to the new location of the element immediately
                following the erased ones, or end() if there are none. Either way, this is
                the same memory address as the passed-in *first* argument since there can
                be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for each erased element and calls T's copy
            constructor and destructor once for each element that has to be moved. *

        |

        *Overload 2:*
         Erase just one element, moving all subsequent elements down one slot and
        reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;
        that means *p* cannot be end() because end()+1 is not defined. Capacity is
        unchanged.

        Notes: If you don't mind the elements being reordered, you can erase an element
        in constant time using the non-standard extension eraseFast().

        :type p: :py:class:`DecorativeGeometry`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`DecorativeGeometry`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: eraseFast() *
        """
        return _simbody.ArrayDecorativeGeometry_erase(self, *args)

    def eraseFast(self, p: "DecorativeGeometry") -> "SimTK::DecorativeGeometry *":
        r"""
         Be careful with this non-standard extension; it erases one element and
        then moves the last one in its place which changes the element order
        from what it was before (unlike the standard erase() method). This avoids
        having to compress the elements so this runs in constant time:
        the element is destructed; then if it wasn't the last element the
        copy constructor is used to copy the last element into the vacated
        space, and the destructor is called to clear the last element. The
        size is reduced by 1 but the capacity does not change.

        :type p: :py:class:`DecorativeGeometry`
        :param p:
                Points to the element that will be erased; *p* cannot be end().
        :rtype: :py:class:`DecorativeGeometry`
        :return: 
                A pointer to the element that replaced the one at *p*, or end() if *p*
                was the last element. Either way, this is the same memory address as the
                erased element had since there can be no reallocation here.
        Title: Complexity:
            Calls T's destructor once for the erased element and calls T's copy
            constructor and destructor once for each element that has to be moved.
        See also: erase() *
        """
        return _simbody.ArrayDecorativeGeometry_eraseFast(self, p)

    def clear(self) -> "void":
        r"""
         Erase all the elements currently in this array without changing the
        capacity; equivalent to erase(begin(),end()) but a little faster. Size is
        zero after this call. T's destructor is called exactly once for each element
        in the array.

        Title: Complexity:
            O(n) if T has a destructor; constant time otherwise. *
        """
        return _simbody.ArrayDecorativeGeometry_clear(self)

    def insert(self, *args) -> "SimTK::DecorativeGeometry *":
        r"""
        *Overload 1:*
         Insert *n* copies of a given value at a particular location within this
        array, moving all following elements up by *n* positions.

        :type p: :py:class:`DecorativeGeometry`, in
        :param p:
                Where to insert the new elements. This must be an iterator (pointer) that
                is valid for this array, that is, begin() <= *p* <= end().
        :type n: int, in
        :param n:
                How many copies of the given *value* to insert. Nothing happens if
                *n* is zero.
        :type value: :py:class:`DecorativeGeometry`, in
        :param value:
                A value of the element type that is copied into the newly-created elements
                using T's copy constructor.
        :rtype: :py:class:`DecorativeGeometry`
        :return: 
                A pointer to the first of the newly-created elements in the array. This
                will be different from *p* if reallocation occurred, otherwise it is the
                same as *p* was on entry.

        Title: Complexity:
            If size() + *n* > capacity() then the array must be reallocated, resulting
            in size() copy constructor/destructor call pairs to move the old data to
            the new location. Otherwise, the m=(end()-*p)* elements above the insertion
            point must be moved up *n* positions resulting in m copy/destruct pairs.
            Then there are n additional copy constructor calls to construct the new
            elements from the given value.


        |

        *Overload 2:*
         Insert a new element at a given location within this array, initializing
        it to a copy of a given value and moving all following elements up one
        position. This is identical to insert(*p,1*,*value)* but slightly faster; see
        that method for full documentation. *
        """
        return _simbody.ArrayDecorativeGeometry_insert(self, *args)

# Register ArrayDecorativeGeometry in _simbody:
_simbody.ArrayDecorativeGeometry_swigregister(ArrayDecorativeGeometry)

class Stage(object):
    r"""
     This class is basically a glorified enumerated type, type-safe and range
    checked but permitting convenient (if limited) arithmetic. Constants look like
    Stage::Position, and loops can be written like

    .. code-block:: c++

            for(Stage s = Stage::LowestValid; s <= Stage::HighestValid; ++s) {
        ...
            }
    Stage constants (of type Stage::Level) are implicitly converted to type
    Stage when necessary.

    Default construction gives Stage::Empty which really means "invalid". *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Empty = _simbody.Stage_Empty
    r""" Lower than any legitimate Stage."""
    Topology = _simbody.Stage_Topology
    r""" System topology realized."""
    Model = _simbody.Stage_Model
    r""" Modeling choices made."""
    Instance = _simbody.Stage_Instance
    r""" Physical parameters set."""
    Time = _simbody.Stage_Time
    r""" A new time has been realized."""
    Position = _simbody.Stage_Position
    r""" Spatial configuration available."""
    Velocity = _simbody.Stage_Velocity
    r""" Spatial velocities available."""
    Dynamics = _simbody.Stage_Dynamics
    r""" Forces calculated."""
    Acceleration = _simbody.Stage_Acceleration
    r""" Accelerations and multipliers calculated."""
    Report = _simbody.Stage_Report
    r""" Report-only quantities evaluated."""
    Infinity = _simbody.Stage_Infinity
    r""" Higher than any legitimate Stage."""
    LowestValid = _simbody.Stage_LowestValid
    r""" For iterating over all stage values."""
    HighestValid = _simbody.Stage_HighestValid
    LowestRuntime = _simbody.Stage_LowestRuntime
    r""" For iterating over meaningful stage values."""
    HighestRuntime = _simbody.Stage_HighestRuntime
    NValid = _simbody.Stage_NValid
    NRuntime = _simbody.Stage_NRuntime

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default construction gives Stage::Empty. *

        |

        *Overload 2:*
        This is an implicit conversion from Stage::Level to Stage. * You can explicitly create a Stage from an int if it is in range. *
        """
        _simbody.Stage_swiginit(self, _simbody.new_Stage(*args))

    def next(self) -> "SimTK::Stage":
        r"""
        Return the Stage following this one, with Stage::Infinity returned
           if this Stage is already at its highest value, Stage::Report. An exception
           is thrown if this Stage is already Stage::Infinity. *
        """
        return _simbody.Stage_next(self)

    def prev(self) -> "SimTK::Stage":
        r"""
        Return the Stage before this one, with Stage::Empty returned
           if this Stage is already at its lowest value, Stage::Topology. An exception
           is thrown if this Stage is already Stage::Empty. *
        """
        return _simbody.Stage_prev(self)

    def getName(self) -> "String":
        r"""
        Return a printable name corresponding to the stage level currently
           stored in this Stage. *
        """
        return _simbody.Stage_getName(self)

    def invalidate(self, tooHigh: "Stage") -> "void":
        r""" Set this Stage=min(stageNow, tooHigh-1). *"""
        return _simbody.Stage_invalidate(self, tooHigh)

    def isInRuntimeRange(self) -> "bool":
        r"""
        Return true if this Stage has one of the meaningful values between
           Stage::Topology and Stage::Report, rather than one of the end markers
           Stage::Empty or Stage::Infinity. *
        """
        return _simbody.Stage_isInRuntimeRange(self)
    __swig_destroy__ = _simbody.delete_Stage

# Register Stage in _simbody:
_simbody.Stage_swigregister(Stage)

class State(object):
    r"""
     This is the handle class for the hidden State implementation.

    This object is intended to contain all state information for a SimTK::System,
    except topological information which is stored in the system itself. A system
    is "const" after its topology has been constructed and realized.

    Systems contain a set of Subsystem objects, and %State supports that concept by
    allowing per-subsystem partitioning of the total system state. This allows
    subsystems to have their own private state variables, while permitting the
    system to allow shared access to state among the subsystems when necessary.

    The %State provides services reflecting the structure of the equations it
    expects to find in the System. Three different views of the same state
    information are supported to accommodate three different users:
       - the system as a whole
       - Subsystems contained in the system
       - numerical methods operating on the state

    Typically numerical methods have a much less nuanced view of the state
    than do the system or subsystems.

    The system is expected to be a "hybrid DAE", that is, a mixture of continuous
    and discrete dynamic equations, and algebraic constraints. There is an
    independent variable t, continuous state variables y, and discrete state
    variables d.

    The continuous part is an ODE-on-a-manifold system suitable for solution via
    coordinate projection, structured like this for the view taken by numerical
    methods:

         (1)  y' = f(d;t,y)         differential equations
         (2)  c  = c(d;t,y)         algebraic equations (manifold is c=0)
         (3)  e  = e(d;t,y)         event triggers (watch for zero crossings)

    with initial conditions t0,y0,d0 such that c=0. The discrete variables d are
    updated upon occurence of specific events. When those events are functions of
    time or state, they are detected using the set of scalar-valued event trigger
    functions e (3).

    In the more detailed view as seen from the System, we consider y={q,u,z} to
    be partitioned into position variables q, velocity variables u, and auxiliary
    variables z. There will be algebraic constraints involving q, u, and u's time
    derivatives udot. The system is now assumed to look like this:

         (4) qdot    = N(q) u
         (5) zdot    = zdot(d;t,q,u,z)

         (6) M(q) udot + ~G(q) mult = f(d;t,q,u,z)
             G(q) udot              = b(d;t,q,u)

                       [ pdotdot(d;t,q,u,udot) ]
         (7) udotErr = [ vdot(d;t,q,u,udot)    ] = 0
                       [ a(d;t,q,u,udot)       ]

         (8) uErr    = [ pdot(d;t,q,u) ]         = 0
                       [ v(d;t,q,u)    ]

         (9) qErr    = [ p(d;t,q) ]              = 0
                       [ n(q)     ]

    The q's can also be dealt with directly as second order variables via

        (10) qdotdot = Ndot(q,qdot) u + N(q) udot


    Here G = [P;V;A] with A(q) being the coefficient matrix for constraints
    appearing only at the acceleration level, and V(q)=partial(v)/partial(u)
    the coefficient matrix for the velocity (nonholonomic) constraints, and
    P(q)=partial(pdot)/partial(u) is the coefficient matrix of the first
    time derivatives of the position (holonomic) constraints.
    Note that uErr in Eq 8 is assumed to include equations resulting from
    differentiation of p() in Eq 9, as well as ones first introduced at the
    velocity level (nonholonomic constraints), and udotErr is similarly
    built from acceleration-only constraints a() and derivatives of higher-level
    constraints.

    If a system allocates nq q's, nu u's, and nz z's the State will also allocate
    matching cache variables qdot, qdotdot, udot, and zdot. If mp position
    (holonomic) constraints (9), mpv velocity constraints (8) and mpva acceleration
    constraints (7) are allocated, the state creates cache entries of like sizes
    qErr, uErr, udotErr. In addition room for the mpva Lagrange multipliers 'mult'
    is allocated in the cache.

    In the final view, the Subsystem view, the same variables and cache entries
    exist, but only the ones allocated by that Subsystem are visible. All of a
    Subsystem's q's are consecutive in memory, as are its u's, uErr's, etc., but
    the q's are not adjacent to the u's as they are for the System's view.

    The default constructor creates a %State containing no state variables and with
    its realization cache stage set to Stage::Empty. During subsystem construction,
    variables and cache entries for any stage can be allocated, however *all*
    Model stage variables must be allocated during this time. At the end of
    construction, call advanceSubsystemToStage(Topology) which will put the
    subsystem at Stage::Topology. Then the subsystems realize their Model stages,
    during which variables at any stage > Model, and cache entries at any stage
    >= Model can be allocated. After that call advanceSubsystemToStage(Model)
    which sets the stage to Stage::Model and disallows further state allocation.

    Note that there is a global Stage for the state as a whole, and individual
    Stages for each subsystem. The global stage can never be higher than
    the lowest subsystem stage. Global state resources are allocated when the
    global Stage advances to "Model" and tossed out if that stage is
    invalidated. Similarly, cache resources are allocated at stage Instance
    and forgotten when Instance is invalidated. Note that subsystems will
    "register" their use of the global variable pools during their own modeling
    stages, but that the actual global resources won't exist until the *system*
    has been advanced to Model or Instance stage. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _simbody.delete_State

    def clear(self) -> "void":
        r""" Restore State to default-constructed condition."""
        return _simbody.State_clear(self)

    def setNumSubsystems(self, i: "int") -> "void":
        r"""
        Set the number of subsystems in this state. This is done during
        initialization of the State by a System; it completely wipes out
        anything that used to be in the State so use cautiously!
        """
        return _simbody.State_setNumSubsystems(self, i)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Create an empty State.

        |

        *Overload 2:*
        Make the current State a copy of the source state, copying only
        state variables and not the cache. If the source state hasn't
        been realized to Model stage, then we don't copy its state
        variables either, except those associated with the Topology stage.
        """
        _simbody.State_swiginit(self, _simbody.new_State(*args))

    def getNumSubsystems(self) -> "int":
        return _simbody.State_getNumSubsystems(self)

    def getSystemStage(self) -> "SimTK::Stage const &":
        r""" This returns the *global* stage for this State."""
        return _simbody.State_getSystemStage(self)

    def invalidateAll(self, arg2: "Stage") -> "void":
        r"""
        If any subsystem or the system stage is currently at or
        higher than the passed-in one, back up to the stage just prior;
        otherwise do nothing. This is for use if you have write
        access to the state and can invalidate even Topology and Model
        stages which may destroy state variables. "All" here refers to
        all Subysystems.
        """
        return _simbody.State_invalidateAll(self, arg2)

    def invalidateAllCacheAtOrAbove(self, arg2: "Stage") -> "void":
        r"""
        If any subsystem or the system stage is currently at or
        higher than the passed-in one, back up to the stage just prior;
        otherwise do nothing. This const method can only be used to
        invalidate Stage::Instance or higher. To invalidate Model or
        Topology stage you must have write access to the state because
        invalidating those stages can destroy state variables in addition
        to cache entries. "All" here refers to all Subsystems.
        """
        return _simbody.State_invalidateAllCacheAtOrAbove(self, arg2)

    def getNY(self) -> "int":
        r"""
        These are the dimensions of the global shared state and cache resources,
        as well as the dimensions of the per-Subsystem partioning of those
        resources. State resource dimensions (including cache resources directly
        related to state variables) are known after the System has been
        realized to Model stage. Other cache resource dimensions are known after
        the System has been realized to Instance stage. Access to the actual data arrays
        may have stricter requirements (for example, you can't ask to look at UErr
        arrays until Velocity stage). Hence it is better to use these explicit
        dimension-providing methods than to get a reference to a Vector and ask
        for its size().

        See also: Per-Subsystem Dimensions group
        See also: Global-to-Subsystem Maps group

        Get the total number ny=nq+nu+nz of shared continuous state variables.
        This is also the number of state derivatives in the cache entry ydot.
        Callable at Model stage.
        """
        return _simbody.State_getNY(self)

    def getNYErr(self) -> "int":
        r"""
        Get the total number nyerr=nqerr+nuerr of shared cache entries for
        position-level and velocity-level constraint errors.
        Callable at Instance stage.
        """
        return _simbody.State_getNYErr(self)

    def getNMultipliers(self) -> "int":
        r"""
        Return the total number of constraint multipliers; necessarily the same
        as the number of acceleration-level constraint errors nUDotErr. Callable
        at Instance stage.
        See also: getNUDotErr()
        """
        return _simbody.State_getNMultipliers(self)

    def getNEventTriggers(self) -> "int":
        r"""
        Return the total number of event trigger function slots in the cache.
        Callable at Instance stage.
        """
        return _simbody.State_getNEventTriggers(self)

    def getNEventTriggersByStage(self, arg2: "Stage") -> "int":
        r"""
        Return the size of the partition of event trigger functions which are
        evaluated at a given Stage. Callable at Instance stage.
        """
        return _simbody.State_getNEventTriggersByStage(self, arg2)

    def getEventTriggerStartByStage(self, arg2: "Stage") -> "SystemEventTriggerIndex":
        r"""
        Return the index within the global event trigger array at which the
        first of the event triggers associated with a particular Stage are stored;
        the rest follow contiguously. Callable at Instance stage.
        """
        return _simbody.State_getEventTriggerStartByStage(self, arg2)

    def getQStart(self, *args) -> "SystemQIndex":
        r"""
        *Overload 1:*
        Returns the y index at which the q's begin. Callable at Model stage.

        |

        *Overload 2:*


        These are the dimensions and locations within the global resource arrays
        of state and cache resources allocated to a particular Subsystem. Note
        that a Subsystem has contiguous q's, contiguous u's, and contiguous z's
        but that the q-, u-, and z-partitions are not contiguous. Hence there is
        no Subsystem equivalent of the global y vector.

        These serve as a mapping from Subsystem-local indices for the various
        shared resources to their global resource indices.

        See also: Global Resource Dimensions
        """
        return _simbody.State_getQStart(self, *args)

    def getNQ(self, *args) -> "int":
        return _simbody.State_getNQ(self, *args)

    def getUStart(self, *args) -> "SystemUIndex":
        return _simbody.State_getUStart(self, *args)

    def getNU(self, *args) -> "int":
        return _simbody.State_getNU(self, *args)

    def getZStart(self, *args) -> "SystemZIndex":
        return _simbody.State_getZStart(self, *args)

    def getNZ(self, *args) -> "int":
        return _simbody.State_getNZ(self, *args)

    def getQErrStart(self, *args) -> "SystemQErrIndex":
        return _simbody.State_getQErrStart(self, *args)

    def getNQErr(self, *args) -> "int":
        return _simbody.State_getNQErr(self, *args)

    def getUErrStart(self, *args) -> "SystemUErrIndex":
        return _simbody.State_getUErrStart(self, *args)

    def getNUErr(self, *args) -> "int":
        return _simbody.State_getNUErr(self, *args)

    def getUDotErrStart(self, arg2: "SubsystemIndex") -> "SystemUDotErrIndex":
        return _simbody.State_getUDotErrStart(self, arg2)

    def getNUDotErr(self, *args) -> "int":
        return _simbody.State_getNUDotErr(self, *args)

    def getEventTriggers(self) -> "SimTK::Vector const &":
        
        return _simbody.State_getEventTriggers(self)

    def getEventTriggersByStage(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getEventTriggersByStage(self, *args)

    def updEventTriggers(self) -> "SimTK::Vector &":
        return _simbody.State_updEventTriggers(self)

    def updEventTriggersByStage(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updEventTriggersByStage(self, *args)

    def getTime(self) -> "double const &":
        r""" You can call these as long as *system* stage >= Model."""
        return _simbody.State_getTime(self)

    def getY(self) -> "SimTK::Vector const &":
        return _simbody.State_getY(self)

    def getQ(self, *args) -> "SimTK::Vector const &":
        r"""
        *Overload 1:*
        Per-subsystem access to the global shared variables.

        |

        *Overload 2:*
        These are just views into Y.
        """
        return _simbody.State_getQ(self, *args)

    def getU(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getU(self, *args)

    def getZ(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getZ(self, *args)

    def getUWeights(self, *args) -> "SimTK::Vector const &":
        r"""
         Get a unit weighting (1/unit change) for each u that can be used to
        weight a vector du so that the disparate elements are comparable in physical
        effect. This permits mixing of generalized speeds
        that have different units, and scaling of generalized speeds that have
        differing amounts of leverage due to their positions in the multibody tree.
        This can be used to create a scaled norm that represents the overall
        significance of a change du to u.

        Define a unit change di for each ui such that a change
        ui+eps*di to each generalized speed in turn produces a physical velocity change
        of roughly equal significance. Then a diagonal matrix Wu=diag(1/di) is
        a weighting matrix such that wdu=Wu*du is a vector in which each element wdu_i
        has units of "unit change" for its corresponding ui. This method returns a
        vector which is the diagonal of Wu.

        These same weights on u also determine the scaling of the generalized
        coordinates q, because q and u are related via qdot=N*u. For cases where
        qdot_i=u_i, the numerical value of the unit change to q_i is just di because
        dP/dq_i == dV/du_i. Otherwise, they are related by Wq = N*Wu*pinv(N) where
        Wq is the weighting matrix for dq (block diagonal), and pinv() is the
        pseudoinverse.

        For example, say you define unit scaling for an angle coordinate to be 1 radian
        (about 57 degrees), meaning that a 1 radian change of coordinate produces
        (roughly) one length unit of meaningful position change. Then if a generalized
        coordinate is measured in radians, its unit scale would be 1. If instead you
        created a generalized coordinate with units of degrees, its unit scale would
        be 57 degrees. That would allow mixing of such coordinates in the same system
        by bringing the coordinates into a physically-meaningful basis.
        Scaling is defined in the u basis where each variable is independent;
        the N matrix couples variables in the q basis. So here the units would actually
        be 1 radian/time unit and 57 degrees/time unit (numerically identical).

        This is allocated and set to 1 at the end of realize(Model). *
        """
        return _simbody.State_getUWeights(self, *args)

    def getZWeights(self, *args) -> "SimTK::Vector const &":
        r"""
         Get a unit weighting (1/unit change) for each z that can be used to
        weight a vector dz so that the disparate elements are comparable in physical
        effect. This defines a weighting matrix Wz=diag(1/unitchange_zi) such
        that wdz=Wz*dz is a vector in which each element wdz_i has units of
        "unit change" for its corresponding zi.  This method returns a
        vector which is the diagonal of Wz. *
        """
        return _simbody.State_getZWeights(self, *args)

    def updUWeights(self, *args) -> "SimTK::Vector &":
        r"""
         Set u weights (and q weights indirectly). You can call this after Model
        stage has been realized. This will invalidate just Report stage because it is
        not used in calculating udots. *
        """
        return _simbody.State_updUWeights(self, *args)

    def updZWeights(self, *args) -> "SimTK::Vector &":
        r"""
         Set z weights. You can call this after Model stage has been realized. This
        will invalidate just Report stage because it is not used in calculating
        zdots. *
        """
        return _simbody.State_updZWeights(self, *args)

    def updTime(self) -> "double &":
        r"""
        You can call these as long as System stage >= Model, but the
        stage will be backed up if necessary to the indicated stage.
        """
        return _simbody.State_updTime(self)

    def updY(self) -> "SimTK::Vector &":
        return _simbody.State_updY(self)

    def setTime(self, t: "double") -> "void":
        r""" An alternate syntax equivalent to updTime() and updY()."""
        return _simbody.State_setTime(self, t)

    def setY(self, y: "Vector") -> "void":
        return _simbody.State_setY(self, y)

    def updQ(self, *args) -> "SimTK::Vector &":
        r""" These are just views into Y."""
        return _simbody.State_updQ(self, *args)

    def updU(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updU(self, *args)

    def updZ(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updZ(self, *args)

    def setQ(self, q: "Vector") -> "void":
        r""" Alternate interface."""
        return _simbody.State_setQ(self, q)

    def setU(self, u: "Vector") -> "void":
        return _simbody.State_setU(self, u)

    def setZ(self, z: "Vector") -> "void":
        return _simbody.State_setZ(self, z)

    def getYDot(self) -> "SimTK::Vector const &":
        return _simbody.State_getYDot(self)

    def getQDot(self, *args) -> "SimTK::Vector const &":
        r"""
        *Overload 1:*
        Per-subsystem access to the shared cache entries.

        |

        *Overload 2:*
        These are just views into YDot.
        """
        return _simbody.State_getQDot(self, *args)

    def getZDot(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getZDot(self, *args)

    def getUDot(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getUDot(self, *args)

    def getQDotDot(self, *args) -> "SimTK::Vector const &":
        r""" This has its own space, not a view."""
        return _simbody.State_getQDotDot(self, *args)

    def updYDot(self) -> "SimTK::Vector &":
        r""" These are mutable"""
        return _simbody.State_updYDot(self)

    def updQDot(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updQDot(self, *args)

    def updZDot(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updZDot(self, *args)

    def updUDot(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updUDot(self, *args)

    def updQDotDot(self, *args) -> "SimTK::Vector &":
        r"""
        This is a separate shared cache entry, not part of YDot. If you
        have a direct 2nd order integrator you can integrate QDotDot
        (twice) to get Q.
        """
        return _simbody.State_updQDotDot(self, *args)

    def getYErr(self) -> "SimTK::Vector const &":
        r"""
        Return the current constraint errors for all constraints. This
        is {QErr,UErr} packed and in that order.
        """
        return _simbody.State_getYErr(self)

    def getQErr(self, *args) -> "SimTK::Vector const &":
        r""" These are just views into YErr."""
        return _simbody.State_getQErr(self, *args)

    def getUErr(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getUErr(self, *args)

    def getUDotErr(self, *args) -> "SimTK::Vector const &":
        r""" These have their own space, they are not views."""
        return _simbody.State_getUDotErr(self, *args)

    def getMultipliers(self, *args) -> "SimTK::Vector const &":
        return _simbody.State_getMultipliers(self, *args)

    def getQErrWeights(self, *args) -> "SimTK::Vector const &":
        r"""
         Get the unit weighting (1/unit error) for each of the mp+mquat position
        constraints equations. Allocated and initialized to 1 on realize(Instance). *
        """
        return _simbody.State_getQErrWeights(self, *args)

    def getUErrWeights(self, *args) -> "SimTK::Vector const &":
        r"""
         Get the unit weighting (1/unit error) for each of the mp+mv velocity-level
        constraint equations, meaning mp time derivatives of position (holonomic)
        constraint equations followed by mv velocity (nonholonomic) constraints.
        Typically the weight of position constraint derivatives is just the
        position constraint weight times the System's characteristic time scale.

        There is no entry corresponding to quaternions here since they do not
        produce velocity-level constraints in Simbody's forumulation.

        This is allocated and initialized to 1 on realize(Instance). *
        """
        return _simbody.State_getUErrWeights(self, *args)

    def updQErrWeights(self, *args) -> "SimTK::Vector &":
        r"""
         Set the unit weighting (1/unit error) for each of the mp+mquat position
        constraint equations. You can call this after the weight variable is allocated
        at the end of Instance stage. Position stage is invalidated to force
        recalculation of weighted position constraint errors. *
        """
        return _simbody.State_updQErrWeights(self, *args)

    def updUErrWeights(self, *args) -> "SimTK::Vector &":
        r"""
         Set the unit weighting (1/unit error) for each of the mp+mv velocity-level
        constraints. You can call this after the weight variable is allocated at the
        end of Instance stage. Velocity stage is invalidated to force recalculation of
        weighted velocity-level constraint errors. *
        """
        return _simbody.State_updUErrWeights(self, *args)

    def updYErr(self) -> "SimTK::Vector &":
        r""" These are mutable"""
        return _simbody.State_updYErr(self)

    def updQErr(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updQErr(self, *args)

    def updUErr(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updUErr(self, *args)

    def updUDotErr(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updUDotErr(self, *args)

    def updMultipliers(self, *args) -> "SimTK::Vector &":
        return _simbody.State_updMultipliers(self, *args)

    def getSystemStageVersions(self, versions: "SimTKArrayInt") -> "void":
        r"""
         (Advanced) Record the current version numbers of each valid System-level
        stage. This can be used to unambiguously determine what stages have been
        changed by some opaque operation, even if that operation realized the stages
        after modifying them. This is particularly useful for event handlers as a way
        for a time stepper to know how much damage may have been done by a handler, and
        thus how much reinitialization is required before continuing on.
        See also: getLowestSystemStageDifference() *
        """
        return _simbody.State_getSystemStageVersions(self, versions)

    def getLowestSystemStageDifference(self, prevVersions: "SimTKArrayInt") -> "SimTK::Stage":
        r"""
         (Advanced) Given a list of per-stage version numbers extracted by an
        earlier call to getSystemStageVersions(), note the lowest system stage in the
        current State whose version number differs from the corresponding previous
        version number. Returns Stage::Infinity if all the stages present in
        *prevVersions* are valid and have identical versions now, even if there are
        additional valid stages now, since nothing the caller cared about before has
        been changed. If the current State is not realized as far as the previous one,
        then the first unrealized stage is returned if all the lower versions match.
        See also: getSystemStageVersions() *
        """
        return _simbody.State_getLowestSystemStageDifference(self, prevVersions)

    def setSystemTopologyStageVersion(self, topoVersion: "SimTK::StageVersion") -> "void":
        r"""
         (Advanced) This explicitly modifies the Topology stage version; don't
        use this method unless you know what you're doing! This can be used to force
        compatibility with a System that has had Topology changes since this %State
        was created. This has no effect on the realization level.
        See also: getSystemTopologyStageVersion(), System::getSystemTopologyCacheVersion()
        """
        return _simbody.State_setSystemTopologyStageVersion(self, topoVersion)

    def autoUpdateDiscreteVariables(self) -> "void":
        r"""
         (Advanced) This is called at the beginning of every integration step to set
        the values of auto-update discrete variables from the values stored in their
        associated cache entries. *
        """
        return _simbody.State_autoUpdateDiscreteVariables(self)

    def cacheToString(self) -> "String":
        return _simbody.State_cacheToString(self)

# Register State in _simbody:
_simbody.State_swigregister(State)


def __lshift__(*args) -> "std::ostream &":
    return _simbody.__lshift__(*args)
class StdVectorState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _simbody.StdVectorState_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _simbody.StdVectorState___nonzero__(self)

    def __bool__(self) -> "bool":
        return _simbody.StdVectorState___bool__(self)

    def __len__(self) -> "std::vector< SimTK::State >::size_type":
        return _simbody.StdVectorState___len__(self)

    def __getslice__(self, i: "std::vector< SimTK::State >::difference_type", j: "std::vector< SimTK::State >::difference_type") -> "std::vector< SimTK::State,std::allocator< SimTK::State > > *":
        return _simbody.StdVectorState___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _simbody.StdVectorState___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SimTK::State >::difference_type", j: "std::vector< SimTK::State >::difference_type") -> "void":
        return _simbody.StdVectorState___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _simbody.StdVectorState___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SimTK::State >::value_type const &":
        return _simbody.StdVectorState___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _simbody.StdVectorState___setitem__(self, *args)

    def pop(self) -> "std::vector< SimTK::State >::value_type":
        return _simbody.StdVectorState_pop(self)

    def append(self, x: "State") -> "void":
        return _simbody.StdVectorState_append(self, x)

    def empty(self) -> "bool":
        return _simbody.StdVectorState_empty(self)

    def size(self) -> "std::vector< SimTK::State >::size_type":
        return _simbody.StdVectorState_size(self)

    def swap(self, v: "StdVectorState") -> "void":
        return _simbody.StdVectorState_swap(self, v)

    def begin(self) -> "std::vector< SimTK::State >::iterator":
        return _simbody.StdVectorState_begin(self)

    def end(self) -> "std::vector< SimTK::State >::iterator":
        return _simbody.StdVectorState_end(self)

    def rbegin(self) -> "std::vector< SimTK::State >::reverse_iterator":
        return _simbody.StdVectorState_rbegin(self)

    def rend(self) -> "std::vector< SimTK::State >::reverse_iterator":
        return _simbody.StdVectorState_rend(self)

    def clear(self) -> "void":
        return _simbody.StdVectorState_clear(self)

    def get_allocator(self) -> "std::vector< SimTK::State >::allocator_type":
        return _simbody.StdVectorState_get_allocator(self)

    def pop_back(self) -> "void":
        return _simbody.StdVectorState_pop_back(self)

    def erase(self, *args) -> "std::vector< SimTK::State >::iterator":
        return _simbody.StdVectorState_erase(self, *args)

    def __init__(self, *args):
        _simbody.StdVectorState_swiginit(self, _simbody.new_StdVectorState(*args))

    def push_back(self, x: "State") -> "void":
        return _simbody.StdVectorState_push_back(self, x)

    def front(self) -> "std::vector< SimTK::State >::value_type const &":
        return _simbody.StdVectorState_front(self)

    def back(self) -> "std::vector< SimTK::State >::value_type const &":
        return _simbody.StdVectorState_back(self)

    def assign(self, n: "std::vector< SimTK::State >::size_type", x: "State") -> "void":
        return _simbody.StdVectorState_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _simbody.StdVectorState_resize(self, *args)

    def insert(self, *args) -> "void":
        return _simbody.StdVectorState_insert(self, *args)

    def reserve(self, n: "std::vector< SimTK::State >::size_type") -> "void":
        return _simbody.StdVectorState_reserve(self, n)

    def capacity(self) -> "std::vector< SimTK::State >::size_type":
        return _simbody.StdVectorState_capacity(self)
    __swig_destroy__ = _simbody.delete_StdVectorState

# Register StdVectorState in _simbody:
_simbody.StdVectorState_swigregister(StdVectorState)

class SimbodyMatterSubsystem(object):
    r"""
     This subsystem contains the bodies ("matter") in the multibody system,
    the mobilizers (joints) that define the generalized coordinates used to
    represent the motion of those bodies, and constraints that must be satisfied
    by the values of those coordinates.

    There are many methods in the API for this class. For whole-system information
    and calculations, the methods here are the right ones to use. For information
    associated with individual objects contained in the subsystem, such as
    MobilizedBody and Constraint objects, it is generally easier to obtain the
    information through the contained objects' APIs instead.

    This class is is a "handle" containing only an opaque reference to the
    underlying implementation class.

    ### Theory discussion
    The bodies, mobilizers, and constraints are represented mathematically with
    the following set of equations:

                         qdot = N u                 Kinematic differential eqns.
                         zdot = zdot(t,q,u,z)       Auxiliary states

             M udot + ~G mult = f(t,q,u,z)          Equations of motion
             G udot           = b(t,q,u)

                     where

              [P]    [bp]
            G=[V]  b=[bv]  f = T + ~J*(F-C)
              [A]    [ba]

              pdotdot = P udot - bp(t,q,u) = 0      Acceleration constraints
                 vdot = V udot - bv(t,q,u) = 0
        a(t,q,u,udot) = A udot - ba(t,q,u) = 0

                       pdot = P u - c(t,q) = 0      Velocity constraints
                                  v(t,q,u) = 0

                                    p(t,q) = 0      Position constraints
                                      n(q) = 0      Normalization constraints

    where M(q) is the mass matrix, G(t,q,u) the acceleration constraint matrix,
    C(q,u) the coriolis and gyroscopic forces, T is user-applied joint mobility
    forces, F is user-applied body forces and torques and gravity. J(q) is the
    %System Jacobian (partial velocity matrix) whose transpose ~J maps spatial
    forces to joint mobility forces. p(t,q) are the holonomic (position)
    constraints, v(t,q,u) the non-holonomic (velocity) constraints, and
    a(t,q,u,udot) the acceleration-only constraints, which must be linear in udot,
    with A(t,q,u) the coefficient matrix for a(). pdot, pdotdot are obtained by
    differentiation of p(), vdot by differentiation of v(). P(t,q)=Dpdot/Du
    (yes, that's u, not q -- we can get Pq=Dp/Dq when we need it as Pq=P*N^-1) and
    V(t,q,u)=Dv/Du. (We use capital "D" to indicate partial derivative.) n(q) is
    the set of quaternion normalization constraints, which exist only at the
    position level and are uncoupled from everything else.

    We calculate the constraint multipliers like this:

              G M^-1 ~G mult = G udot0 - b
              where    udot0 = M^-1 f

    using the pseudo inverse of G M^-1 ~G to give a least squares solution for
    mult: mult = pinv(G M^-1 ~G)(G M^-1 f - b). Then the real udot is
    udot = udot0 - udotC, with udotC = M^-1 ~G mult. Note: M^-1* is an
    O(n) operator that provides the desired result; it **does not** require
    forming or factoring M.

    NOTE: only the following constraint matrices have to be formed and factored:

       [G M^-1 ~G]   to calculate multipliers

       [P N^-1]      for projection onto position manifold (a.k.a. Pq)

       [ P ]         for projection onto velocity manifold
       [ V ]


    When working in a weighted norm with weights W on the state variables and
    weights T (1/tolerance) on the constraint errors, the matrices we need are
    actually [Tp Pq Wq^-1], [Tpv [P;V] Wu^-1], etc. with T and W diagonal
    weighting matrices. These can then be used to find least squares solutions
    in the weighted norms.

    In many cases these matrices consist of decoupled blocks which can
    be solved independently. (TODO: take advantage of that whenever possible
    to solve a set of smaller systems rather than one large one.) Also, in the
    majority of biosimulation applications we are likely to have only holonomic
    (position) constraints, so there is no V or A and G=P is the whole story.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        * Create an orphan matter subsystem containing only the Ground body
        (mobilized body 0); normally use the other constructor to place the
        subsystem in a MultibodySystem. *
        """
        _simbody.SimbodyMatterSubsystem_swiginit(self, _simbody.new_SimbodyMatterSubsystem())
    __swig_destroy__ = _simbody.delete_SimbodyMatterSubsystem

    def calcSystemMass(self, s: "State") -> "SimTK::Real":
        r"""
        These methods perform calculations that yield properties of the system as
        a whole. These are *operators*, meaning that they make use of the supplied
        State but do not modify the State. They simply calculate a result and return
        it to you without storing it internally. Each method requires that the
        State has already been realized to at least a particular stage which is
        documented with the method. ** Calculate the total system mass.
        Title: Required stage
          ``Stage::Instance`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMass(self, s)

    def calcSystemMassCenterLocationInGround(self, s: "State") -> "SimTK::Vec3":
        r"""
         Return the position vector p_GC of the system mass center C, measured from
        the Ground origin, and expressed in Ground.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMassCenterLocationInGround(self, s)

    def calcSystemMassPropertiesInGround(self, s: "State") -> "SimTK::MassProperties":
        r"""
         Return total system mass, mass center location measured from the Ground
        origin, and system inertia taken about the Ground origin, expressed in Ground.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMassPropertiesInGround(self, s)

    def calcSystemCentralInertiaInGround(self, s: "State") -> "SimTK::Inertia":
        r"""
         Return the system inertia matrix taken about the system center of mass,
        expressed in Ground.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemCentralInertiaInGround(self, s)

    def calcSystemMassCenterVelocityInGround(self, s: "State") -> "SimTK::Vec3":
        r"""
         Return the velocity v_GC = d/dt p_GC of the system mass center C in the
        Ground frame G, measured from Ground origin and expressed in G.
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMassCenterVelocityInGround(self, s)

    def calcSystemMassCenterAccelerationInGround(self, s: "State") -> "SimTK::Vec3":
        r"""
         Return the acceleration a_GC = d/dt p_GC of the system mass center C in the
        Ground frame G, measured from Ground origin and expressed in G.
        Title: Required stage
          ``Stage::Acceleration`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMassCenterAccelerationInGround(self, s)

    def calcSystemMomentumAboutGroundOrigin(self, s: "State") -> "SimTK::SpatialVec":
        r"""
         Return the momentum of the system as a whole (angular, linear) measured
        in the Ground frame, taken about the Ground origin and expressed in Ground.
        (The linear component is independent of the "about" point.)
        See also: calcSystemCentralMomentum()
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemMomentumAboutGroundOrigin(self, s)

    def calcSystemCentralMomentum(self, s: "State") -> "SimTK::SpatialVec":
        r"""
         Return the momentum of the system as a whole (angular, linear) measured
        in the Ground frame, taken about the current system center of mass
        location C and expressed in Ground. (The linear component is independent of the
        "about" point.)
        See also: calcSystemMomentumAboutGroundOrigin()
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemCentralMomentum(self, s)

    def calcKineticEnergy(self, state: "State") -> "SimTK::Real":
        r"""
         Calculate the total kinetic energy of all the mobilized bodies in this
        matter subsystem, given the configuration and velocities in *state*.
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcKineticEnergy(self, state)

    def multiplyBySystemJacobian(self, state: "State", u: "Vector", Ju: "VectorOfSpatialVec") -> "void":
        r"""
        *
        The system kinematic Jacobian maps between mobility space (generalized speeds
        and generalized forces) and Cartesian body space (mobilized body frame spatial
        velocities and spatial forces). A task space Jacobian maps between mobility
        space and a specified set of task points or frames fixed to a subset of the
        bodies, and generally located away from the body frame. A task space Jacobian
        J can be used to construct various task space matrices such as the task space
        compliance matrix J M^-1 ~J or its inverse, the task space (or operational
        space) inertia matrix.

        The system Jacobian J(q) maps n generalized speeds u to spatial velocities V of
        each of the nb mobilized bodies (including Ground), measured at the body frame
        origin relative to Ground, and expressed in the Ground frame. The transpose ~J
        of this matrix maps nb spatial forces to n generalized forces, where the spatial
        forces are applied at the body frame origin and expressed in Ground. Similarly,
        task space Jacobians map from n generalized speeds to nt task frame spatial
        velocities (expressed in Ground), and transposed task space Jacobians map
        between task frame spatial forces (or impulses), expressed in Ground, and
        generalized forces (or generalized impulses).

        Simbody provides fast O(n) methods ("operators") that can form matrix-vector
        products like J*u or ~J*F without forming J. The "bias" term Jdot*u (also known
        as the Coriolis acceleration) is also available; this arises when working at
        the acceleration level because d/dt J*u = J*udot+Jdot*u (where dot means time
        derivative). The computational cost of these operators is O(n+nt) so it is
        *much* more efficient to work with a group of tasks simultaneously than to
        process one at a time, which would have complexity O(n*nt). Alternatively, we
        provide methods that will return all or part of J explicitly; in general it
        is *much* more efficient computationally to work with the O(n) matrix-vector
        multiply operators rather than to form explicit matrices and then perform O(n^2)
        matrix-vector products. Performance estimates are given with each method so that
        you can determine which methods to use. If you can, you should use the O(n)
        methods -- it is a good habit to get into when using an O(n) multibody code like
        Simbody!

        Note that the Jacobian is associated with an expressed-in frame for the
        velocity or force vector and a designated station (point) on each body. We
        always use the Ground frame for Jacobians. For the system Jacobian, the body
        origin is always the designated station; for task Jacobians different stations
        may be specified. We provide three different sets of methods for working with
            - the full %System Jacobian: J, nb X n 6-vectors (or 6*nb X n scalars)
            - the Station Jacobian for a set of nt task stations (points): JS, nt rows
              of n 3-vectors (or a 3*nt X n Matrix of scalars)
            - the Frame Jacobian for a set of nt task frames fixed to a body: JF, nt
              rows of n 6-vectors (or a 6*nt X n Matrix of scalars)

        The rotational part of a Jacobian is the same for any frame fixed to the same
        body. So for Frame Jacobians you need specify only a station on the body (the
        frame's origin point). That means if you want a 3*nt X n Orientation Jacobian,
        you can obtain it from alternate rows of a Frame Jacobian. Using the above
        terminology, the complete %System Jacobian is a Frame Jacobian for which the
        task frames are the body frames, with each MobilizedBody appearing only once
        and in order of MobilizedBodyIndex (starting with Ground).

        It is acceptable for the same body to appear more than once in a list of tasks;
        these are likely to conflict but that can be dealt with elsewhere. ** Calculate the product of the %System kinematic Jacobian J (also known as the
        partial velocity matrix) and a mobility-space vector u in O(n) time. If the
        vector u is a set of generalized speeds, then this produces the body spatial
        velocities that result from those generalized speeds. That is, the result is
        V_GB = J*u where V_GB[i] is the spatial velocity of the i'th body's body frame
        origin (in Ground) that results from the given set of generalized speeds.

        :type state: :py:class:`State`, in
        :param state:
                A State compatible with this System that has already been realized to
                Stage::Position.
        :type u: :py:class:`Vector`, in
        :param u:
                A mobility-space Vector, such as a set of generalized speeds. The length
                and order must match the mobilities of this system (that is n, the number
                of generalized speeds u, *not* nq, the number of generalized
                coordinates q).
        :type Ju: SimTK::Vector_< SimTK::SpatialVec >, out
        :param Ju:
                This is the product V=J*u as described above. Each element is a spatial
                vector, one per mobilized body, to be indexed by MobilizedBodyIndex.
                If the input vector is a set of generalized speeds u, then the results
                are nb spatial velocities V_GBi (that is, a pair of vectors w_GBi and v_GBi
                giving angular and linear velocity). Note that Ground is body 0 so the 0th
                element V_GB0=V_GG=Ju[0] is always zero on return.

        The kinematic Jacobian (partial velocity matrix) J is defined as follows:

              partial(V)                                 T                        T
          J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
              partial(u)

        Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a
        spatial vector). The transpose of this matrix maps spatial forces to
        generalized forces; see multiplyBySystemJacobianTranspose().

        Note that we're using "monogram" notation for the spatial velocities, where

                    G Bi
            V_GBi =  V

        the spatial velocity of body i's body frame Bi (at its origin), measured and
        expressed in the Ground frame G.

        ### Performance discussion
        This is a very fast operator, costing about 12*(nb+n) flops, where nb is the
        number of bodies and n the number of mobilities (degrees of freedom) u. In
        contrast, even if you have already calculated the entire nbXnX6 matrix J, the
        multiplication J*u would cost 12*nb*n flops. As an example, for a 20 body
        system with a free flying base and 19 pin joints (25 dofs altogether), this
        method takes 12*(20+25)=540 flops while the explicit matrix-vector multiply
        would take 12*20*25=6000 flops. So this method is already >10X faster for
        that small system; for larger systems the difference grows rapidly.

        See also: multiplyBySystemJacobianTranspose(), calcSystemJacobian() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyBySystemJacobian(self, state, u, Ju)

    def calcBiasForSystemJacobian(self, *args) -> "void":
        r"""
        *Overload 1:*
         Calculate the acceleration bias term for the %System Jacobian, that is, the
        part of the acceleration that is due only to velocities. This term is also
        known as the Coriolis acceleration, and it is returned here as a spatial
        acceleration of each body frame in Ground.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Velocity stage.
        :type JDotu: SimTK::Vector_< SimTK::SpatialVec >, out
        :param JDotu:
                The product JDot*u where JDot = d/dt J, and u is the vector of generalized
                speeds taken from *state*. This is a Vector of nb SpatialVec elements.

        ### Theory
        The spatial velocity V_GBi of each body i can be obtained from the generalized
        speeds u by V = {V_GBi} = J*u. Taking the time derivative in G gives

            A = d/dt V = {A_GBi} = J*udot + JDot*u

        where JDot=JDot(q,u). This method returns JDot*u, which depends only on
        configuration q and speeds u. Note that the same u is used to calculate JDot,
        which is linear in u, so this term is quadratic in u.

        ### Implementation
        This method simply extracts the total Coriolis acceleration for each body that
        is already available in the *state* cache so there is no computation done
        here.
        See also: getTotalCoriolisAcceleration()


        |

        *Overload 2:*
         Alternate signature that returns the bias as a 6*nb-vector of scalars
        rather than as an nb-vector of 2x3 spatial vectors. See the other signature for
        documentation. *
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForSystemJacobian(self, *args)

    def multiplyBySystemJacobianTranspose(self, state: "State", F_G: "VectorOfSpatialVec", f: "Vector") -> "void":
        r"""
         Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and
        a vector F_G of spatial force-like elements, one per body, in O(n) time to
        produce a generalized force-like result f=~J*F. If F_G is actually a set of
        spatial forces applied at the body frame origin of each body, and expressed
        in the Ground frame, then the result is the equivalent set of generalized
        forces f that would produce the same accelerations as F_G.

        :type state: :py:class:`State`, in
        :param state:
                A State compatible with this System that has already been realized to
                Stage::Position.
        :type F_G: SimTK::Vector_< SimTK::SpatialVec >, in
        :param F_G:
                This is a vector of SpatialVec elements, one per mobilized body and in
                order of MobilizedBodyIndex (with the 0th entry a force on Ground; hence
                ignored). Each SpatialVec is a spatial force-like pair of 3-vectors
                (torque,force) with the force applied at the body origin and the vectors
                expressed in Ground.
        :type f: :py:class:`Vector`, out
        :param f:
                This is the product f=~J*F_G as described above. This result is in the
                generalized force space, that is, it has one scalar entry for each of the
                n system mobilities (velocity degrees of freedom). Resized if necessary.

        The kinematic Jacobian (partial velocity matrix) J is defined as follows:

              partial(V)                                 T                        T
          J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
              partial(u)

        Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a
        spatial vector). J maps generalized speeds to spatial velocities (see
        multiplyBySystemJacobian()); its transpose ~J maps spatial forces
        to generalized forces.

        Note that we're using "monogram" notation for the spatial velocities, where

                    G Bi
            V_GBi =  V

        the spatial velocity of body i's body frame Bi (at its origin), measured and
        expressed in the Ground frame G.

        ### Performance discussion
        This is a very fast operator, costing about 18*nb+11*n flops, where nb is the
        number of bodies and n the number of mobilities (degrees of freedom) u. In
        contrast, even if you have already calculated the entire 6*nbXnu matrix J, the
        multiplication ~J*F would cost 12*nb*n flops. As an example, for a 20 body
        system with a free flying base and 19 pin joints (25 dofs altogether), this
        method takes 18*20+11*25=635 flops while the explicit matrix-vector multiply
        would take 12*20*25=6000 flops. So this method is already >9X faster for
        that small system; for larger systems the difference grows rapidly.

        See also: multiplyBySystemJacobian(), calcSystemJacobian() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyBySystemJacobianTranspose(self, state, F_G, f)

    def calcSystemJacobian(self, *args) -> "void":
        r"""
        *Overload 1:*
         Explicitly calculate and return the nb x nu whole-system kinematic
        Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec). This matrix
        maps generalized speeds to the spatial velocities of all the bodies, which
        will be at the body origins, measured and expressed
        in Ground. That is, if you have a set of n generalized speeds u, you can
        find the spatial velocities of all nb bodies as V_G = J_G*u. The transpose of
        this matrix maps a set of spatial forces F_G, applied at the body frame
        origins and expressed in Ground, to the equivalent set of n generalized
        forces f: f = ~J_G*F_G.

        Notes: The 0th row of the returned Jacobian is always zero since it represents
        the spatial velocity of Ground.

        ### Performance discussion
        Before using this method, consider whether you really need to form this
        very large matrix which necessarily will take O(n^2) space and time; it will
        almost always be *much* faster to use the multiplyBySystemJacobian() method
        that directly calculate the matrix-vector product in O(n) time without explicitly
        forming the matrix. Here are the details:

        As currently implemented, forming the full Jacobian J costs about
        12*n*(nb+n) flops. Assuming nb ~= n, this is about 24*n^2 flops. Then
        if you want to form a product J*u explicitly, the matrix-vector multiply will
        cost about 12*n^2 flops each time you do it. In contrast the J*u product is
        calculated using multiplyBySystemJacobian() in about 24*n flops. Even for
        very small systems it is cheaper to make repeated calls to
        multiplyBySystemJacobian() than to form J explicitly and multiply by it.
        See the Performance section for multiplyBySystemJacobian() for more
        comparisons.

        See also: multiplyBySystemJacobian(), multiplyBySystemJacobianTranspose()
        See also: calcSystemJacobian() alternate signature using scalar elements *

        |

        *Overload 2:*
         Alternate signature that returns a system Jacobian as a 6*nb X n Matrix
        of scalars rather than as an nb X n matrix of 2x3 spatial vectors. See
        the other signature for documentation and important performance
        considerations. *
        """
        return _simbody.SimbodyMatterSubsystem_calcSystemJacobian(self, *args)

    def multiplyByStationJacobian(self, *args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
         Calculate the Cartesian ground-frame velocities of a set of task stations
        (points fixed on bodies) that results from a particular set of generalized
        speeds u. The result is the station velocities measured and expressed in Ground.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Position stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the stations of
                interest are fixed.
        :type stationPInB: SimTK::Array_< SimTK::Vec3 >, in
        :param stationPInB:
                The array of nt station points P of interest (one per task), each
                corresponding to one of the bodies B from *onBodyB*, given as vectors
                from each body B's origin Bo to its station P, expressed in frame B.
        :type u: :py:class:`Vector`, in
        :param u:
                A mobility-space Vector, such as a set of generalized speeds. The length
                and order must match the mobilities of this system (that is n, the number
                of generalized speeds u, *not* nq, the number of generalized
                coordinates q).
        :type JSu: SimTK::Vector_< SimTK::Vec3 >, out
        :param JSu:
                The resulting product JS*u, where JS is the station task Jacobian. Resized
                to nt if needed.

        ### Performance discussion
        It is almost always better to use this method than to form an explicit 3*nt X n
        station task Jacobian explicitly and then multiply by it. If you have only one
        or two tasks, so that the matrix is only 3xn or 6xn, and then perform many
        multiplies with that matrix, it might be slightly cheaper to form it. For
        example, it is about 4X cheaper to use this method than to form a one-task
        Station Jacobian JS explicitly and use it once. However, because this would be
        such a skinny matrix (3 X n) explicit multiplication is cheap so if you will
        re-use this same Jacobian repeatedly before recalculating (at least 6 times)
        then it may be worth calculating and saving it. Here are the details:

        A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that
        nb ~= n >> 1, you could say this is about 27*nt + 24*n flops. In
        contrast, assuming you already have the 3*nt X n station Jacobian JS available,
        you can compute the JS*u product in about 6*nt*n flops, 3X faster for one task,
        about even for three tasks, and slower for more than three tasks.
        However forming JS costs about 40*nt+90*n flops (see calcStationJacobian()).
        So to form a one-task Jacobian and use it once is 4X more expensive (96*n vs
        24*n), but if you use it more than 5 times it is cheaper to do it
        explicitly. Forming a one-task JS and using it 100 times costs about 690*n
        flops while calling this method 100 times would cost about 2400*n flops.

        See also: multiplyByStationJacobianTranspose(), calcStationJacobian() *

        |

        *Overload 2:*
         Alternate signature for when you just have a single station task.
        :rtype: :py:class:`Vec3`
        :return: JS*u, where JS is the station task Jacobian. *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByStationJacobian(self, *args)

    def multiplyByStationJacobianTranspose(self, *args) -> "void":
        r"""
        *Overload 1:*
         Calculate the generalized forces resulting from a single force applied
        to a set of nt station tasks (points fixed to bodies) P. The applied forces
        f_GP should be 3-vectors expressed in Ground. This is considerably faster than
        forming the Jacobian explicitly and then performing the matrix-vector multiply.

        ### Performance discussion
        Cost is about 30*nt + 18*nb + 11*n. Assuming nb ~= n, this is roughly
        30*(n+nt). In contrast, forming the complete 3*nt X n matrix would cost about
        90*(n+nt/2), and subsequent explicit matrix-vector multiplies would cost
        about 6*nt*n each.

        See also: multiplyByStationJacobian(), calcStationJacobian() *

        |

        *Overload 2:*
         Alternate signature for when you just have a single station task. *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByStationJacobianTranspose(self, *args)

    def calcStationJacobian(self, *args) -> "void":
        r"""
        *Overload 1:*
         Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a
        set of nt station tasks P (a station is a point fixed on a particular mobilized
        body). This matrix maps generalized speeds to the Cartesian velocity of each
        station, measured and expressed in Ground. That is, if you have a set of n
        generalized speeds u, you can find the Cartesian velocities of stations P as
        v_GP = JS*u, where v_GP is a 3*nt column vector. The transpose of this
        matrix maps a 3*nt vector of forces f_GP (expressed in Ground and applied
        to P) to the equivalent set of n generalized forces f: f = ~JS*f_GP.

        Notes: It is almost always far more efficient to use multiplyByStationJacobian()
        or multiplyByStationJacobianTranspose() to form matrix-vector products rather
        than to use this method to form the Jacobian explicitly. See the performance
        discussions there.

        Overloaded signatures of this method are available to allow you to obtain the
        Jacobian either as an nt X n Matrix with Vec3 elements, or as 3*nt X n Matrix
        with scalar elements.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Position stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the stations of
                interest are fixed.
        :type stationPInB: SimTK::Array_< SimTK::Vec3 >, in
        :param stationPInB:
                The array of nt station points P of interest (one per task), each
                corresponding to one of the bodies B from *onBodyB*, given as vectors
                from each body B's origin Bo to its station P, expressed in frame B.
        :type JS: SimTK::Matrix_< SimTK::Vec3 >, out
        :param JS:
                The resulting nt X n station task Jacobian. Resized if necessary.

        ### Performance discussion
        The cost of a call to this method is about 42*nt + 54*nb + 33*n flops. If we
        assume that nb ~= n >> 1, this is roughly 90*(n+nt/2) flops. Then once the
        Station Jacobian JS has been formed, each JS*u matrix-vector product costs
        6*nt*n flops to form. When nt is small enough (say one or two tasks), and you
        plan to re-use it a lot, this can be computationally efficient; but for single
        use or more than a few tasks you can do much better with
        multiplyByStationJacobian() or multiplyByStationJacobianTranspose().

        See also: multiplyByStationJacobian(), multiplyByStationJacobianTranspose() *

        |

        *Overload 2:*
         Alternate signature for when you just have a single station task. *

        |

        *Overload 3:*
         Alternate signature that returns a station Jacobian as a 3*nt x n Matrix
        rather than as a Matrix of Vec3 elements. See the other signature for
        documentation and important performance considerations. *

        |

        *Overload 4:*
         Alternate signature for when you just have a single station task. *
        """
        return _simbody.SimbodyMatterSubsystem_calcStationJacobian(self, *args)

    def calcBiasForStationJacobian(self, *args) -> "SimTK::Vec3":
        r"""
        *Overload 1:*
         Calculate the acceleration bias term for a station Jacobian, that is, the
        part of the station's acceleration that is due only to velocities. This term
        is also known as the Coriolis acceleration, and it is returned here as a linear
        acceleration of the station in Ground.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Velocity stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the stations of
                interest are fixed.
        :type stationPInB: SimTK::Array_< SimTK::Vec3 >, in
        :param stationPInB:
                The array of nt station points P of interest (one per task), each
                corresponding to one of the bodies B from *onBodyB*, given as vectors
                from each body B's origin Bo to its station P, expressed in frame B.
        :type JSDotu: SimTK::Vector_< SimTK::Vec3 >, out
        :param JSDotu:
                The resulting product JSDot*u, where JSDot is the time derivative of JS,
                the station task Jacobian. Resized to nt if needed.

        ### Theory
        The velocity v_GP of a station point P in the Ground frame G can be obtained
        from the generalized speeds u using the station Jacobian for P, as
            v_GP = JS_P*u
         Taking the time derivative in G gives
            a_GP = JS_P*udot + JSDot_P*u

        This method returns JSDot_P*u, which depends only on configuration and
        velocities. We allow for a set of task points P so that all their bias terms
        can be calculated in a single sweep of the multibody tree. Note that u is taken
        from the *state* and that the same u shown above is also used to calculate
        JSDot_P, which is linear in u, so the bias term is quadratic in u.

        ### Implementation
        This method just obtains body B's total Coriolis acceleration already available
        in the *state* cache and shifts it to station point P. Cost is 48*nt flops.
        See also: getTotalCoriolisAcceleration(), shiftAccelerationBy()


        |

        *Overload 2:*
         Alternate signature that returns the bias as a 3*nt-vector of scalars
        rather than as an nt-vector of Vec3s. See the other signature for
        documentation. *

        |

        *Overload 3:*
         Alternate signature for when you just have a single station task.
        :rtype: :py:class:`Vec3`
        :return: JSDot*u, where JSDot is the station Jacobian time derivative. *
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForStationJacobian(self, *args)

    def multiplyByFrameJacobian(self, *args) -> "SimTK::SpatialVec":
        r"""
        *Overload 1:*
         Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to
        nt bodies B={Bi}, that result from a particular set of n generalized speeds u.

        The result is each task frame's angular and linear velocity measured and
        expressed in Ground. Using this method is considerably faster than forming the
        6*nt X n Frame Jacobian explicitly and then performing the matrix-vector
        multiply. See the performance analysis below for details.

        There is a simplified signature of this method available if you have only a
        single frame task.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Position stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the task frames of
                interest are fixed. These may be in any order and the same body may appear
                more than once if there are multiple task frames on it.
        :type originAoInB: SimTK::Array_< SimTK::Vec3 >, in
        :param originAoInB:
                An array of nt frame origin points Ao for the task frames interest (one
                per task), each corresponding to one of the bodies B from *onBodyB*, given
                as vectors from each body B's origin Bo to its task frame origin Ao,
                expressed in frame B.
        :type u: :py:class:`Vector`, in
        :param u:
                A mobility-space Vector, such as a set of generalized speeds. The length
                and order must match the mobilities of this system (that is n, the number
                of generalized speeds u, *not* nq, the number of generalized
                coordinates q).
        :type JFu: SimTK::Vector_< SimTK::SpatialVec >, out
        :param JFu:
                The resulting product JF*u, where JF is the frame task Jacobian. Resized
                if needed to a Vector of nt SpatialVec entries.

        Notes: All frames A fixed to a given body B have the same angular velocity so
        we do not actually need to know the task frames' orientations here, just the
        location on B of their origin points Ao. If you have a Transform X_BA giving
        the pose of frame A in the body frame B, you can extract the position vector
        for the origin point Ao using X_BA.p() and pass that as the *originAoInB*
        parameter here.

        ### Performance discussion
        A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that
        nb ~= n >> 1, you could say this is about 25*(nt+n) flops. In contrast, assuming
        you already have the 6*nt X n Frame Jacobian JF available, you can compute the
        JF*u product in about 12*nt*n flops. If you have just one task (nt==1) this
        explicit multiplication is about twice as fast; at two tasks it is about even
        and for more than two it is more expensive. However forming JF costs about
        180*(n+nt/4) flops (see calcFrameJacobian()). So to form a one-task Jacobian
        and use it once is almost 8X more expensive (192*n vs 25*n), but if you use it
        more than 16 times it is (marginally) cheaper to do it explicitly (for one
        task). For example, forming a one-task JF and using it 100 times costs 1392*n
        flops while calling this method 100 times would cost about 2500*n flops.

        Conclusion: in almost all practical cases you are better off using this operator
        rather than forming JF, even if you have only a single frame task and certainly
        if you have more than two tasks.

        See also: multiplyByFrameJacobianTranspose(), calcFrameJacobian() *

        |

        *Overload 2:*
         Simplified signature for when you just have a single frame task; see the
        main signature for documentation.
        :rtype: :py:class:`SpatialVec`
        :return: JF*u, where JF is the single frame task Jacobian. *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByFrameJacobian(self, *args)

    def multiplyByFrameJacobianTranspose(self, *args) -> "void":
        r"""
        *Overload 1:*
         Calculate the n generalized forces f resulting from a set of spatial forces
        (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. The
        applied forces are spatial vectors (pairs of 3-vectors) expressed in Ground. Use
        of this O(n) method is considerably faster than forming the 6*nt X n Jacobian
        explicitly and then performing an O(n^2) matrix-vector multiply.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Position stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the task frames of
                interest are fixed. These may be in any order and the same body may appear
                more than once if there are multiple task frames on it.
        :type originAoInB: SimTK::Array_< SimTK::Vec3 >, in
        :param originAoInB:
                An array of nt frame origin points Ao for the task frames interest (one
                per task), each corresponding to one of the bodies B from *onBodyB*, given
                as vectors from each body B's origin Bo to its task frame origin Ao,
                expressed in frame B.
        :type F_GAo: SimTK::Vector_< SimTK::SpatialVec >, in
        :param F_GAo:
                A Vector of nt spatial forces, each applied one of the task frames. These
                are expressed in Ground.
        :type f: :py:class:`Vector`, out
        :param f:
                The Vector of n generalized forces that results from applying the forces
                *F_GAo* to the task frames. Resized if necessary.

        ### Performance discussion
        A call to this method costs 33*nt + 18*nb + 11*n flops. If you assume that
        nb ~= n >> 1, you could say this is about 30*(n+nt) flops. In contrast, assuming
        you already have the 6*nt X n Frame Jacobian JF available, you can compute the
        ~JF*F product in about 12*nt*n flops. For one or two tasks that would be faster
        than applying the operator. However forming JF costs about 180*(n+nt/4) flops
        (see calcFrameJacobian()). So to form even a one-task Frame Jacobian and use
        it once is about 6X more expensive than using the operator (192*n vs 30*n),
        but if you use it more than 10 times it is (marginally) cheaper to do it
        explicitly. For example, forming a one-task JF and using it 100 times costs
        around 1392*n flops while calling this method 100 times would cost about
        3000*n flops.

        Conclusion: in almost all practical cases you are better off using this operator
        rather than forming JF, even if you have only a single frame task and certainly
        if you have more than two tasks.

        See also: multiplyByFrameJacobian(), calcFrameJacobian() *

        |

        *Overload 2:*
         Simplified signature for when you just have a single frame task. See the
        other signature for documentation. *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByFrameJacobianTranspose(self, *args)

    def calcFrameJacobian(self, *args) -> "void":
        r"""
        *Overload 1:*
         Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a
        set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}. This matrix maps
        generalized speeds to the Cartesian spatial velocity (angular and linear
        velocity) of each frame, measured and expressed in Ground. That is, if you have
        a set of n generalized speeds u, you can find the Cartesian spatial velocities
        of task frames A as V_GA = JF*u, where V_GA is a 6*nt column vector. The
        transpose of this matrix maps a 6*nt vector of spatial forces F_GA (expressed
        in Ground and applied to the origins of frames A) to the equivalent set of n
        generalized forces f: f = ~JF*F_GA.

        Notes: It is almost always far more efficient to use multiplyByFrameJacobian() or
        multiplyByFrameJacobianTranspose() to form matrix-vector products rather than to
        use this method to form the Jacobian explicitly. See the performance discussion
        there.

        Overloaded signatures of this method are available to allow you to obtain the
        Jacobian either as an nt X n Matrix with SpatialVec elements, or as 6*nt X n
        Matrix with scalar elements.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Position stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the task frames of
                interest are fixed. These may be in any order and the same body may appear
                more than once if there are multiple task frames on it.
        :type originAoInB: SimTK::Array_< SimTK::Vec3 >, in
        :param originAoInB:
                An array of nt frame origin points Ao for the task frames of interest (one
                per task), each corresponding to one of the bodies B from *onBodyB*, given
                as vectors from each body B's origin Bo to its task frame origin Ao,
                expressed in frame B.
        :type JF: SimTK::Matrix_< SimTK::SpatialVec >, out
        :param JF:
                The resulting nt X n frame task Jacobian, with each element a SpatialVec.
                Resized if necessary.

        ### Performance discussion
        The cost of a call to this method is about 42*nt + 108*nb + 66*n flops. If we
        assume that nb ~= n >> 1, this is roughly 180*(n+nt/4) flops. Then once the
        Frame Jacobian JF has been formed, each JF*u matrix-vector product costs about
        12*nt*n flops to form. When nt is small enough (say one or two tasks), and you
        plan to re-use it a lot, this can be computationally efficient; but for single
        use or more than a few tasks you can do much better with
        multiplyByFrameJacobian() or multiplyByFrameJacobianTranspose().

        See also: multiplyByFrameJacobian(), multiplyByFrameJacobianTranspose() *

        |

        *Overload 2:*
         Simplified signature for when you just have a single frame task. See the
        other signature for documentation. *

        |

        *Overload 3:*
         Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix
        rather than as an nt X n Matrix of SpatialVecs. See the other signature for
        documentation and important performance considerations.*

        |

        *Overload 4:*
         Simplified signature for when you just have a single frame task. See the
        other signature for documentation. *
        """
        return _simbody.SimbodyMatterSubsystem_calcFrameJacobian(self, *args)

    def calcBiasForFrameJacobian(self, *args) -> "SimTK::SpatialVec":
        r"""
        *Overload 1:*
         Calculate the acceleration bias term for a task frame Jacobian, that is, the
        parts of the frames' accelerations that are due only to velocities. This term
        is also known as the Coriolis acceleration, and it is returned here as spatial
        accelerations of the frames in Ground.

        There is a simplified signature of this method available if you have only a
        single frame task.

        :type state: :py:class:`State`, in
        :param state:
                A State that has already been realized through Velocity stage.
        :type onBodyB: SimTK::Array_< MobilizedBodyIndex >, in
        :param onBodyB:
                An array of nt mobilized bodies (one per task) to which the task frames of
                interest are fixed. These may be in any order and the same body may appear
                more than once if there are multiple task frames on it.
        :type originAoInB: SimTK::Array_< SimTK::Vec3 >, in
        :param originAoInB:
                An array of nt frame origin points Ao for the task frames of interest (one
                per task), each corresponding to one of the bodies B from *onBodyB*, given
                as vectors from each body B's origin Bo to its task frame origin Ao,
                expressed in frame B.
        :type JFDotu: SimTK::Vector_< SimTK::SpatialVec >, out
        :param JFDotu:
                The result JFDot*u, where JF is the task frame Jacobian and JFDot its
                time derivative, and u is the set of generalized speeds taken from the
                the supplied *state*.

        ### Theory
        The spatial velocity V_GA of frame A can be obtained from the generalized
        speeds u using the frame Jacobian for A, as V_GA = JF*u. Taking the time
        derivative in G gives

            A_GA = JF*udot + JFDot*u

        This method returns JFDot*u, which depends only on configuration and
        velocities. Note that the same u is used to calculate JFDot, which is linear
        in u, so the term JFDot*u is quadratic in u.

        ### Implementation
        This method just obtains body B's total Coriolis acceleration already available
        in the *state* cache and shifts it to the A frame's origin Ao, for each of the
        nt task frames. Cost is 48*nt flops.

        See also: getTotalCoriolisAcceleration(), shiftAccelerationBy()


        |

        *Overload 2:*
         Alternate signature that returns the bias as a 6*nt-vector of scalars
        rather than as an nt-vector of SpatialVec elements. See the other signature for
        documentation. *

        |

        *Overload 3:*
         Simplified signature for when you just have a single frame task.
        :rtype: :py:class:`SpatialVec`
        :return: JFDot*u, where JFDot is the frame task Jacobian time derivative and
            u the generalized speeds taken from *state*. *
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForFrameJacobian(self, *args)

    def multiplyByM(self, state: "State", a: "Vector", Ma: "Vector") -> "void":
        r"""
        ** This operator calculates in O(n) time the product M*v where M is the
        system mass matrix and v is a supplied mobility-space vector (that is, it has
        one entry for each of the n mobilities). If v is a set of mobility accelerations
        (generalized accelerations udot), then the result is a generalized force
        (f=M*udot). Only the supplied vector is used, and M depends only on position
        states, so the result here is not affected by velocities in the State.
        Constraints and prescribed motions are ignored.

        The current implementation requires about 120*n flops and does not require
        realization of composite-body or articulated-body inertias.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByM(self, state, a, Ma)

    def multiplyByMInv(self, state: "State", v: "Vector", MinvV: "Vector") -> "void":
        r"""
         This operator calculates in O(n) time the product M^-1*v where M is the
        system mass matrix and v is a supplied vector with one entry per u-space
        mobility. If v is a set of generalized forces f, the result is a generalized
        acceleration (udot=M^-1*f). Only the supplied vector is used, and M depends
        only on position states, so the result here is not affected by velocities in
        *state*. In particular, you'll have to obtain your own inertial forces and
        put them in f if you want them included.

        :type state: :py:class:`State`, in
        :param state:
                This is a State that has been realized through Position stage, from which
                the current system configuration and articulated body inertias are
                obtained. If necessary, the articulated body inertias will be realized in
                the state the first time this is called. They will then be retained in the
                *state* cache for speed.
        :type v: :py:class:`Vector`, in
        :param v:
                This is a generalized-force like vector in mobility space (u-space). If
                there is any prescribed motion specified using Motion objects or mobilizer
                locking (see below), then only the entries of v corresponding to
                non-prescribed mobilities are examined by this method; the prescribed ones
                are not referenced at all.
        :type MinvV: :py:class:`Vector`, out
        :param MinvV:
                This is the result M^-1*v. If there is any prescribed motion specified
                using Motion objects or mobilizer locks (see below), then only the
                non-prescribed entries in MinvV are calculated; the prescribed ones are set
                to zero.

        ### Behavior with prescribed motion
        If you prescribe the motion of one or more mobilizers using Motion objects or
        mobilizer locking, the behavior of this method is altered. (This does *not*
        apply if you use Constraint objects to specify the motion.) With prescribed
        motion enabled, this method works only with the free (non-prescribed)
        mobilities. Only the entries in *v* corresponding to free mobilities are
        examined, and only the entries in the result *MinvV* corresponding to free
        mobilities are calculated; the others are set to zero.

        ### Theory
        View the unconstrained, prescribed zero-velocity equations of motion
        M udot + tau = f as partitioned into "free" and "prescribed" variables like
        this:

            [M_ff ~M_fp] [udot_f]   [ 0 ]   [f_f]
            [          ] [      ] + [   ] = [   ]
            [M_fp  M_pp] [udot_p]   [tau]   [f_p]

        The free and prescribed variables have been grouped here for clarity but
        in general they are interspersed among the columns and rows of M.

        Given that decomposition, this method returns

            [udot_f]   [udot_f]   [M_ff^-1  0  ][f_f]
            [      ] = [      ] = [            ][   ]
            [udot_p]   [  0   ]   [   0     0  ][f_p]

        When there is no prescribed motion M_ff is the entire mass matrix, and the
        result is udot_f=udot=M^-1*f. When there is prescribed motion, M_ff is a
        submatrix of M, and the result is the nf elements of udot_f, with udot_p=0.

        ### Implementation
        This is a stripped-down version of forward dynamics. It requires the hybrid
        free/prescribed articulated body inertias to have been realized and will
        initiate that calculation if necessary the first time it is called for a given
        configuration q. The M^-1*f calculation requires two sweeps of the multibody
        tree, an inward sweep to accumulate forces, followed by an outward sweep to
        propagate accelerations.

        ### Performance
        If the supplied State does not already contain realized values for the
        articulated body inertias, then they will be realized when this operator is
        first called for a new set of positions. Calculating articulated body inertias
        is O(n) but relatively expensive. Once the appropriate articulated body
        inertias are available, repeated calls to this operator are very fast, with
        worst case around 80*n flops when all mobilizers have 1 dof. If you want to
        force realization of the articulated body inertias, call the method
        realizeArticulatedBodyInertias().

        Title: Required stage
          ``Stage::Position`` (articulated body inertias realized first if necessary)

        See also: multiplyByM(), calcMInv(), realizeArticulatedBodyInertias() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByMInv(self, state, v, MinvV)

    def calcM(self, arg2: "State", M: "Matrix") -> "void":
        r"""
         This operator explicitly calculates the n X n mass matrix M. Note that this
        is inherently an O(n^2) operation since the mass matrix has n^2 elements
        (although only n(n+1)/2 are unique due to symmetry). **DO NOT USE THIS CALL
        DURING NORMAL DYNAMICS**. To do so would change an O(n) operation into an
        O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators
        like multiplyByM() which calculates the matrix-vector product M*v in O(n)
        without explicitly forming M. Also, don't invert this matrix numerically to get
        M^-1. Instead, call the method calcMInv() which can produce M^-1 directly.

        Title: Required stage
          ``Stage::Position``

        See also: multiplyByM(), calcMInv() *
        """
        return _simbody.SimbodyMatterSubsystem_calcM(self, arg2, M)

    def calcMInv(self, arg2: "State", MInv: "Matrix") -> "void":
        r"""
         This operator explicitly calculates the inverse of the part of the system
        mobility-space mass matrix corresponding to free (non-prescribed)
        mobilities. The returned matrix is always n X n, but rows and columns
        corresponding to prescribed mobilities are zero. This is an O(n^2) operation,
        which is of course within a constant factor of optimal for returning a matrix
        with n^2 elements explicitly. (There are actually only n(n+1)/2 unique elements
        since the matrix is symmetric.) **DO NOT USE THIS CALL DURING NORMAL
        DYNAMICS**. To do so would change an O(n) operation into an O(n^2) one.
        Instead, see if you can accomplish what you need with O(n) operators like
        multiplyByMInv() which calculates the matrix-vector product M^-1*v in O(n)
        without explicitly forming M or M^-1. If you need M explicitly, you can get it
        with the calcM() method.

        Title: Required stage
          ``Stage::Position`` (articulated body inertias realized first if necessary)

        See also: multiplyByMInv(), calcM() *
        """
        return _simbody.SimbodyMatterSubsystem_calcMInv(self, arg2, MInv)

    def calcProjectedMInv(self, s: "State", GMInvGt: "Matrix") -> "void":
        r"""
         This operator calculates in O(m*n) time the m X m "projected inverse mass
        matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the
        acceleration-level constraint Jacobian mapped to generalized coordinates,
        and M (nXn) is the unconstrained system mass matrix. In case there is prescribed
        motion specified with Motion objects or mobilizer locking, M^-1 here is really
        M_ff^-1, that is, it is restricted to the free (non-prescribed) mobilities, but
        scattered into a full n X n matrix (conceptually). See multiplyByMInv() and
        calcMInv() for more information.

        W is the projection of the inverse mass matrix into the constraint coordinate
        space (that is, the vector space of the multipliers lambda). It can be used to
        solve for the constraint forces that will eliminate a given constraint
        acceleration error:

            (1)     W * lambda = aerr
            (2)     aerr = G*udot - b(t,q,u)

        where udot is an unconstrained generalized acceleration. Note that you can
        view equation (1) as a dynamic system in a reduced set of m generalized
        coordinates, with the caveat that W may be singular.

        In general W is singular and does not uniquely determine lambda. Simbody
        normally calculates a least squares solution for lambda so that loads are
        distributed among redundant constraints.

        Notes: If you just need to multiply W by a vector or matrix, you do not need
        to form W explicitly. Instead you can use the method described in the
        Implementation section to produce a W*v product in the O(n) time it takes to
        compute a single column of W.

        ### Implementation
        We are able to form W without forming G or M^-1 and without performing any
        matrix-matrix multiplies. Instead, W is calculated using m applications of
        O(n) operators:
            - multiplyByGTranspose() by a unit vector to form a column of ~G
            - multiplyByMInv() to form a column of M^-1 ~G
            - multiplyByG() to form a column of W

        Even if G and M^-1 were already available, computing W by matrix multiplication
        would cost O(m^2*n + m*n^2) time and O(m*n) intermediate storage. Here we do
        it in O(m*n) time with O(n) intermediate storage, which is a *lot* better.

        Title: Required stage
          ``Stage::Velocity`` (articulated body inertias realized first if necessary)

        See also: multiplyByG(), calcG(), multiplyByGTranspose(), calcGTranspose()
        See also: multiplyByMInv(), calcMInv() *
        """
        return _simbody.SimbodyMatterSubsystem_calcProjectedMInv(self, s, GMInvGt)

    def solveForConstraintImpulses(self, state: "State", deltaV: "Vector", impulse: "Vector") -> "void":
        r"""
         Given a set of desired constraint-space speed changes, calculate the
        corresponding constraint-space impulses that would cause those changes. Here we
        are solving the equation

            W * impulse = deltaV

        for *impulse*, where W=G*M^-1*~G is the "projected inverse mass matrix" as
        described for calcProjectedMInv(). In general W is singular due to constraint
        redundancies, so the solution for *impulse* is not unique. Simbody handles
        redundant constraints by finding least squares solutions, and this operator
        method duplicates the method Simbody uses for determining the rank and
        performing the factorization of W.

        :type state: :py:class:`State`, in
        :param state:
                The State whose generalized coordinates and speeds define the matrix W.
                Must already be realized to Velocity stage.
        :type deltaV: :py:class:`Vector`, in
        :param deltaV:
                The set of desired velocity changes to be produced by the impulse, in
                constraint space. These will consist of observed velocity constraint
                violations (-verr) and constraint violations that would be generated by
                impulsive applied forces (-G*M^-1*f).
        :type impulse: :py:class:`Vector`, out
        :param impulse:
                The set of constraint multiplier-space impulses that will produce the
                desired velocity changes without violating the constraints.

        To convert these constraint-space impulses into updates to the mobility-space
        generalized speeds u, use code like this:

        .. code-block:: c++

                const SimbodyMatterSubsystem& matter=...;
                Vector deltaV=...;  // constraint space speed change desired; length m
                Vector impulse;     // constraint space impulses; length m
                solveForConstraintImpulses(state, deltaV, impulse);
                Vector f;           // mobility space impulses; length n
                Vector du;          // change to generalized speeds u; length n
                matter.multiplyByGTranspose(s,impulse,f);
                matter.multiplyByMInv(s,f,du);
                state.updU() += du; // update generalized speeds

        Note that the length of the constraint-space vectors is m=mp+mv+ma, the total
        number of acceleration-level constraints including the second time derivatives
        of the position (holonomic) constraints, the first time derivatives of the
        velocity (nonholonomic) constraints, and the acceleration-only constraints.
        See also: calcProjectedMInv(), multiplyByGTranspose(), multiplyByMInv() *
        """
        return _simbody.SimbodyMatterSubsystem_solveForConstraintImpulses(self, state, deltaV, impulse)

    def multiplyByG(self, *args) -> "void":
        r"""
        *Overload 1:*
         Returns Gulike = G*ulike, the product of the mXn acceleration
        constraint Jacobian G and a "u-like" (mobility space) vector of length n.
        m is the number of active acceleration-level constraint equations, n is the
        number of mobilities. This is an O(m+n) operation.

        If you are going to call this method repeatedly at the same time, positions and
        velocities, you should precalculate the bias term once and supply it to the
        alternate signature of this method. See the Implementation section for more
        information.

        Title: Implementation
        This is accomplished by treating the input vector *ulike* as though it were
        a set of generalized accelerations (for nonholonomic and acceleration-only
        constraints) or generalized speeds (for holonomic constraints). These are
        mapped to body accelerations (or velocities) in O(n) time. See
        calcBodyAccelerationFromUDot() for more information (converting from
        generalized speeds to velocities is just multiplying by the System Jacobian).
        The method calcBiasForMultiplyByG() is used to determine the state-dependent
        term of the constraint error equations. Then a second call is made to
        evaluate the bias term aerr(t,q,u;0)=-b(t,q,u). We then calculate
        Gulike = aerr(t,q,u;ulike)-aerr(t,q,u;0) in O(m) time.
        See also: calcBiasForMultiplyByG() *

        |

        *Overload 2:*
         Multiply Gulike=G*ulike using the supplied precalculated bias vector to
        improve performance (approximately 2X) over the other signature.
        See also: calcBiasForMultiplyByG() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByG(self, *args)

    def calcBiasForMultiplyByG(self, state: "State", bias: "Vector") -> "void":
        r"""
         Calculate the bias vector needed for the higher-performance signature of
        the multiplyByG() method above.

        :type state: :py:class:`State`, in
        :param state:
                Provides time t, positions q, and speeds u; must be realized through
                Velocity stage so that all body spatial velocities are known.
        :type bias: :py:class:`Vector`, out
        :param bias:
                This is the bias vector for use in repeated calls to multiplyByG(). It
                will be resized if necessary to length m=mp+mv+ma, the total number of
                active acceleration-level constraint equations.

        Title: Implementation
        This method uses either velocity- or acceleration- level constraint error
        functions with zero input to determine the bias term for use in
        multiplyByG(). Body quantities and generalized quantities are supplied to each
        of the m active constraints' (constant time) error methods to calculate

           pverr(t,q,u;ulike)=G*ulike - c(t,q)    (holonomic)
        or aerr(t,q,u;ulike)=G*ulike - b(t,q,u)   (nonholonomic or acceleration-only)

        with ulike=0, giving the bias term in O(m) time.

        If you want the acceleration-level bias terms b for all the constraints, even
        if they are holonomic, use calcBiasForAccelerationConstraints(). *
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForMultiplyByG(self, state, bias)

    def calcG(self, state: "State", G: "Matrix") -> "void":
        r"""
         This O(m*n) operator explicitly calculates the m X n acceleration-level
        constraint Jacobian G which appears in the system equations of
        motion. Consider using the multiplyByG() method instead of this one,
        which forms the matrix-vector product G*v in O(m+n) time without explicitly
        forming G.

        Title: Implementation
        This method generates G columnwise using repeated calls to multiplyByG(),
        which makes use of the constraint error methods to perform a G*v product
        in O(m+n) time. To within numerical error, for non-working constraints
        this should be identical to the transpose of the matrix returned by calcGt()
        which uses the constraint force methods instead.
        See also: multiplyByG(), calcGt(), calcPq() *
        """
        return _simbody.SimbodyMatterSubsystem_calcG(self, state, G)

    def calcBiasForAccelerationConstraints(self, state: "State", bias: "Vector") -> "void":
        r"""
         Calculate the acceleration constraint bias vector, that is, the terms in
        the acceleration constraints that are independent of the accelerations.

        :type state: :py:class:`State`, in
        :param state:
                Provides time t, positions q, and speeds u; must be realized through
                Velocity stage so that all body spatial velocities are known.
        :type bias: :py:class:`Vector`, out
        :param bias:
                This is the bias vector for all the acceleration constraint equations
                together. It will be resized if necessary to length m=mp+mv+ma, the total
                number of active acceleration-level constraint equations.

        Title: Implementation
        We have constant-time constraint acceleration error methods

        paerr(t,q,u;udot)=P*udot - b_p(t,q,u)
        vaerr(t,q,u;udot)=V*udot - b_v(t,q,u)
         aerr(t,q,u;udot)=A*udot - b_a(t,q,u)

        that together define the acceleration constraint equation G*udot-b=0
        where G=[P;V;A] and b=[b_p b_v b_a]. There is one of these error functions
        for each %Constraint, with paerr() the twice-differentiated position (holonomic)
        constraints, vaerr() the once-differentiated velocity (nonholonomic)
        constraints, and aerr() the acceleration-only constraints. This method
        sets ``udot`` = 0 and invokes each of those methods to obtain
        bias = -[b_p b_v b_a].

        ### Performance note
        The actual acceleration constraint functions require both udot and body
        accelerations for the constrained bodies; even with udot==0 body accelerations
        may have a non-zero velocity-dependent component (the coriolis accelerations).
        Those are already available in the state, but only as accelerations in Ground.
        For constraints that have a non-Ground Ancestor, we have to convert the
        accelerations to A at a cost of 105 flops/constrained body. *
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForAccelerationConstraints(self, state, bias)

    def multiplyByGTranspose(self, state: "State", _lambda: "Vector", f: "Vector") -> "void":
        r"""
         Returns f = ~G*lambda, the product of the n X m transpose of the
        acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector
        *lambda* of length m, returning a generalized-force like quantity *f* of
        length n. m=mp+mv+ma is the total number of active constraint equations,
        n (==nu) is the number of mobilities (generalized speeds u). If lambda is a set
        of constraint multipliers, then f=~G*lambda is the set of forces generated by
        the constraints, mapped into generalized forces. This is an O(m+n) operation.

        Because the velocity (non-holonomic) or acceleration-only constraint Jacobians
        V and A can have velocity dependence, the *state* supplied here must generally
        be realized through Velocity stage. If the system has only position (holonomic)
        constraints then the *state* need be realized only through Position stage.

        :type state: :py:class:`State`, in
        :param state:
                A State that has been realized through Velocity stage (or Position stage
                if the system has no velocity-dependent constraint Jacobians).
                Configuration and velocities if needed are taken from *state*.
        :type lambda: :py:class:`Vector`, in
        :param lambda:
                A multiplier-like vector to be multiplied by ~G. Its length must be the
                same as the total number of active constraint equations m.
        :type f: :py:class:`Vector`, out
        :param f:
                This is the generalized force-like output. It will be resized if necessary
                to length equal to the number of mobilities (generalized speeds) n (==nu).

        Title: Implementation
        This is accomplished by treating the input vector *lambda* as though it were
        a set of Lagrange multipliers, then calling each of the active Constraints'
        (constant time) force generation methods, providing the appropriate subset of
        the multipliers each time. That gives body forces F0 and mobility forces f0 in
        O(m) time. We then use the equivalent of multiplyBySystemJacobianTranspose()
        to convert the returned body spatial forces to generalized forces in O(n)
        time, and finally return the generalized force-like result f = ~J*F0 + f0.
        See also: multiplyByG(), multiplyBySystemJacobianTranspose() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByGTranspose(self, state, _lambda, f)

    def calcGTranspose(self, arg2: "State", Gt: "Matrix") -> "void":
        r"""
         This O(nm) operator explicitly calculates the n X m transpose of the
        acceleration-level constraint Jacobian G = [P;V;A] which appears in the system
        equations of motion. This method generates ~G columnwise use the constraint
        force generating methods which map constraint multipliers to constraint forces.
        To within numerical error, this should be identical to the transpose of
        the matrix returned by calcG() which uses a different method. Consider using
        the multiplyByGTranspose() method instead of this one, which forms the
        matrix-vector product ~G*v in O(n) time without explicitly forming ~G.
        Title: Required stage
          ``Stage::Velocity``
        See also: calcG(), multiplyByGTranspose() *
        """
        return _simbody.SimbodyMatterSubsystem_calcGTranspose(self, arg2, Gt)

    def multiplyByPq(self, *args) -> "void":
        r"""
        *Overload 1:*
         Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq
        position (holonomic) constraint Jacobian and *qlike* is a "q-like"
        (generalized coordinate space) vector of length nq. Here mp is the number of
        active position-level constraint equations in this system.

        If you are going to call this method repeatedly at the same time t and
        configuration q and want maximum efficiency, you can gain a factor of almost
        2X by precalculating a bias term once using calcBiasForMultiplyByPq() and
        supplying it to the alternate signature of this method. See the Theory
        section below for an explanation of the bias term.

        ### Theory
        Simbody's position (holonomic) constraints are defined by the constraint
        error equation

            (1)    perr(t;q) = p(t,q)

        where we try to maintain perr=0 at all times. We also have available time
        derivatives of equation (1); the first time derivative is relevant here:

            (2)    pverr(t,q;qdot) = dperr/dt = Pq * qdot + Pt

        where Pq=Dperr/Dq and Pt=Dperr/Dt (capital "D" means partial derivative).
        Pt=Pt(t,q) is called the "bias" term. (Note that because u=N^-1*qdot we also
        have Pq=P*N^-1, where P=Dpverr/Du is the very useful mobility-space holonomic
        constraint Jacobian.) Eq. (2) can be used to perform efficient multiplication
        by Pq, since it can be used to calculate Pq*qlike+Pt, and a second evaluation
        at qlike=0 can be used to calculate the unwanted bias term for removal:

            (3)    Pq*qlike = pverr(t,q;qlike) - pverr(t,q;0)

        Despite appearances, eq. (2) calculates its result in constant time per
        constraint equation, for a total cost that is O(n) or more strictly O(mp+nq).
        The matrix Pq is never actually formed; instead the matrix-vector product
        is calculated directly.

        ### Implementation
        We treat the input vector *qlike* as though it were a set of generalized
        coordinate derivatives qdot. These are mapped to body velocities V in O(n)
        time, using V=Jq*qdot, where Jq is the coordinate space system Jacobian
        (partial velocity matrix), with Jq=J*N^-1. Then the body velocities and qdots
        are supplied to each of the mp active position constraints' (constant time)
        velocity error methods to get pverr(t,q;qlike)=Pq*qlike-Pt in O(n) time. A
        second call is made to evaluate the bias term pverr(t,q;0)=-Pt. We then
        calculate the result *PqXqlike* = pverr(t,q;qlike)-pverr(t,q;0) in O(n) time
        using equation (3).

        See also: calcBiasForMultiplyByPq() *

        |

        *Overload 2:*
         Multiply Pq*qlike using the supplied precalculated bias vector to
        improve performance (approximately 2X) over the other signature.
        See also: calcBiasForMultiplyByPq() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByPq(self, *args)

    def calcBiasForMultiplyByPq(self, state: "State", biasp: "Vector") -> "void":
        r"""
         Calculate the bias vector needed for the higher-performance signature of
        the multiplyByPq() method above.

        :type state: :py:class:`State`, in
        :param state:
                Provides time t, and positions q; must be realized through
                Position stage so that all body spatial poses are known.
        :type biasp: :py:class:`Vector`, out
        :param biasp:
                This is the bias vector for use in repeated calls to multiplyByPq(). It
                will be resized if necessary to length mp, the total number of
                active position-level (holonomic) constraint equations.

        See multiplyByPq() for theory and implementation; this method is just
        performing the qlike=0 case described there for calculating the bias term Pt.
        """
        return _simbody.SimbodyMatterSubsystem_calcBiasForMultiplyByPq(self, state, biasp)

    def calcPq(self, state: "State", Pq: "Matrix") -> "void":
        r"""
         This O(m*n) operator explicitly calculates the mp X nq position-level
        (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the
        position error equations with respect to q. Consider using the multiplyByPq()
        method instead of this one, which forms the matrix-vector product Pq*v in
        O(m+n) time without explicitly forming Pq.

        Note that quaternion normalization constraints are *not* included in mp; we
        do not consider those holonomic constraints.

        :type state: :py:class:`State`, in
        :param state:
                A State realized through Position stage so that time and the pose
                (configuration) of each body is known.
        :type Pq: :py:class:`Matrix`, out
        :param Pq:
                The position constraint Jacobian Dperr/Dq. This will be resized to
                mp X nq if necessary.

        Title: Implementation
        This method generates Pq columnwise using repeated calls to multiplyByPq(),
        which makes use of the position constraint velocity-level error methods to
        perrform a Pq*v product in O(m+n) time. See multiplyByPq() for a more
        detailed explanation. If Pq's columns are in contiguous memory we'll work
        in place, otherwise columns are generated into a contiguous temporary and
        then copied into Pq.

        See also: multiplyByPq() *
        """
        return _simbody.SimbodyMatterSubsystem_calcPq(self, state, Pq)

    def multiplyByPqTranspose(self, state: "State", lambdap: "Vector", f: "Vector") -> "void":
        r"""
         Returns f = ~Pq*lambdap, the product of the n X mp transpose of the
        position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like
        vector *lambdap* of length mp, returning a generalized-force like quantity
        *f* of length n. mp is the number of active position constraint equations,
        n (==nu) is the number of mobilities (generalized speeds u). If lambdap is a set
        of mp constraint multipliers, then f=~G*lambdap is the set of forces generated
        by the position constraints, mapped into generalized forces. This is an
        O(mp+n) operation.

        A holonomic constraint Jacobian cannot have a velocity dependence, so the
        *state* need be realized only to Position stage here.

        :type state: :py:class:`State`, in
        :param state:
                A State that has been realized through Position stage. Time and
                configuration are taken from *state*.
        :type lambdap: :py:class:`Vector`, in
        :param lambdap:
                A multiplier-like vector to be multiplied by ~Pq. Its length must be the
                same as the number of active position constraint equations mp.
        :type f: :py:class:`Vector`, out
        :param f:
                This is the generalized force-like output. It will be resized if necessary
                to length equal to the number of mobilities (generalized speeds) n (==nu).

        Title: Implementation
        This is accomplished by treating the input vector *lambdap* as though it were
        a set of Lagrange multipliers, then calling each of the active holonomic
        Constraints' (constant time) force generation methods, providing the
        appropriate subset of the multipliers each time. That gives body forces F0 and
        mobility forces f0 in O(mp) time. We then use the equivalent of
        multiplyBySystemJacobianTranspose() to convert the returned body spatial
        forces to generalized forces in O(n) time, and finally return the generalized
        force-like result f = ~J*F0 + f0.
        See also: multiplyByPq(), multiplyBySystemJacobianTranspose() *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByPqTranspose(self, state, lambdap, f)

    def calcPqTranspose(self, state: "State", Pqt: "Matrix") -> "void":
        r"""
         This O(m*n) operator explicitly calculates the nq X mp transpose of
        the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial
        derivative of the position error equations with respect to q. Consider using
        the multiplyByPqTranspose() method instead of this one, which forms the
        matrix-vector product ~Pq*v in O(m+n) time without explicitly forming ~Pq.

        Note that quaternion normalization constraints are *not* included in mp; we
        do not consider those holonomic constraints.

        :type state: :py:class:`State`, in
        :param state:
                A State realized through Position stage so that time and the pose
                (configuration) of each body is known.
        :type Pqt: :py:class:`Matrix`, out
        :param Pqt:
                The transposed position constraint Jacobian ~Pq=(Dperr/Dq)^T. This will be
                resized to nq X mp if necessary.

        Title: Implementation
        This method generates *Pqt* columnwise using repeated calls to
        multiplyByPqTranspose(), which makes use of the position constraint force
        generating methods to perform a ~Pq*v product in O(m+n) time. See
        multiplyByPqTranspose() for a more detailed explanation. If Pqt's columns
        are in contiguous memory we'll work in place, otherwise columns are generated
        into a contiguous temporary and then copied into Pqt.

        See also: multiplyByPqTranspose() *
        """
        return _simbody.SimbodyMatterSubsystem_calcPqTranspose(self, state, Pqt)

    def calcP(self, state: "State", P: "Matrix") -> "void":
        r"""
         Returns the mp X nu matrix P which is the Jacobian of the first time
        derivative of the holonomic (position) constraint errors with respect to the
        generalized speeds u; that is, P = partial( dperr/dt )/partial(u). Here mp is
        the number of holonomic constraint equations (not including quaternion
        normalization constraints) and nu is the total number of generalized speeds as
        found in the supplied State. P is resized if necessary; an error will be thrown
        if the Matrix is not the right size and not resizeable.

        Title: Complexity:
        Calculates the m X n matrix in O(m*n) time, which is good if you really need
        this matrix. However, in many cases what is really needed is the product
        of this matrix with a vector which can be done in O(n) time; consider whether
        you really need the whole matrix explicitly.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcP(self, state, P)

    def calcPt(self, state: "State", Pt: "Matrix") -> "void":
        r"""
         Returns the nu X mp matrix ~P - see calcP() for a description.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcPt(self, state, Pt)

    def multiplyByN(self, s: "State", transpose: "bool", _in: "Vector", out: "Vector") -> "void":
        r"""
         Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q. Note that
        one of "in" and "out" is always "q-like" while the other is "u-like", but which
        is which changes if the matrix is transposed. Note that the transposed
        operation here is the same as multiplying by N on the right, with the Vectors
        viewed as RowVectors instead. This is an O(n) operator since N is block
        diagonal.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByN(self, s, transpose, _in, out)

    def multiplyByNInv(self, s: "State", transpose: "bool", _in: "Vector", out: "Vector") -> "void":
        r"""
         Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u.
        Note that one of "in" and "out" is always "q-like" while the other is "u-like",
        but which is which changes if the matrix is transposed. Note that the
        transposed operation here is the same as multiplying by NInv on the right,
        with the Vectors viewed as RowVectors instead. This is an O(N) operator since
        NInv is block diagonal. The configuration q is taken from the supplied state.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByNInv(self, s, transpose, _in, out)

    def multiplyByNDot(self, s: "State", transpose: "bool", _in: "Vector", out: "Vector") -> "void":
        r"""
         Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q. This is used,
        for example, as part of the conversion between udot and qdotdot. Note that one
        of "in" and "out" is always "q-like" while the other is "u-like", but which is
        which changes if the matrix is transposed. Note that the transposed operation
        here is the same as multiplying by NDot on the right, with the Vectors viewed
        as RowVectors instead. This is an O(N) operator since NDot is block diagonal.
        Configuration q and generalized speeds u are taken from the supplied state.
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_multiplyByNDot(self, s, transpose, _in, out)

    def calcAcceleration(self, state: "State", appliedMobilityForces: "Vector", appliedBodyForces: "VectorOfSpatialVec", udot: "Vector", A_GB: "VectorOfSpatialVec") -> "void":
        r"""
        ** This is the primary forward dynamics operator. It takes a state which
        has been realized to the Dynamics stage, a complete set of forces to apply,
        and returns the accelerations that result. Only the forces supplied here,
        and those calculated internally from prescribed motion, constraints, and
        centrifugal effects, affect the results. Acceleration constraints are
        always satisfied on return as long as the constraints are consistent.
        If the position and velocity constraints aren't already satisified in the
        State, results are harder to interpret physically, but they will still be
        calculated and the acceleration constraints will still be satisfied. No
        attempt will be made to satisfy position and velocity constraints, or to
        set prescribed positions and velocities, nor even to check whether these
        are satisfied; position and velocity constraint and prescribed positions
        and velocities are simply irrelevant here.

        Given applied forces f_applied, this operator solves this set of equations:

             M udot + tau + ~G lambda + f_inertial = f_applied       (1)
                                          G udot   = b               (2)
                                            udot_p = udot_p(t,q,u,z) (3)

        where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are: the free
        generalized accelerations udot_f, the constraint multipliers lambda, and the
        prescribed motion generalized forces tau_p. A subset udot_p of udot may have
        been prescribed as a known function of state via Motion objects or locks
        associated with the mobilized bodies. On return all the entries in udot will
        have been set to their calculated or prescribed values, and body spatial
        accelerations A_GB (that is, measured and expressed in Ground) are also
        returned. Lambda and tau_p are necessarily calculated but are not returned here.

        f_applied is the set of generalized (mobility) forces equivalent to the
        *appliedMobilityForces* and *appliedBodyForces* arguments supplied here.
        That is,

            f_applied = appliedMobilityForces + ~J * appliedBodyForces

        where J is the system Jacobian mapping between spatial and generalized
        coordinates. Typically these forces will have been calculated as a function of
        state so we will have f_applied(t,q,u,z).

        M(t,q), G(t,q,u), and b(t,q,u) are defined by the mobilized bodies and
        constraints present in the system. f_inertial(q,u) includes the
        velocity-dependent gyroscopic and coriolis forces due to rigid body
        rotations and is extracted internally from the already-realized state.

        Note that this method does not allow you to specify your own prescribed udots;
        those are calculated from the mobilizers' state-dependent Motion specifications
        (or are zero due to mobilizer locks) that are already part of the system.

        This is an O(n*m + m^3) operator where n is the number of generalized speeds
        and m the number of constraint equations (mobilities with prescribed motion are
        counted in n, not m).

        Title: Required stage
          ``Stage::Dynamics`` (articulated body inertia will be realized if needed) *
        """
        return _simbody.SimbodyMatterSubsystem_calcAcceleration(self, state, appliedMobilityForces, appliedBodyForces, udot, A_GB)

    def calcAccelerationIgnoringConstraints(self, state: "State", appliedMobilityForces: "Vector", appliedBodyForces: "VectorOfSpatialVec", udot: "Vector", A_GB: "VectorOfSpatialVec") -> "void":
        r"""
         This operator is similar to calcAcceleration() but ignores the effects of
        acceleration constraints although it obeys prescribed accelerations. The
        supplied forces, prescribed motion forces, and velocity-induced centrifugal
        and gyroscopic effects are properly accounted for, but any forces that would
        have resulted from enforcing the constraints are not present. This operator
        solves the equations

                    M udot + tau + f_inertial = f_applied           (1)
                                       udot_p = udot_p(t,q,u,z)     (2)

        where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are the free
        generalized accelerations udot_f and the prescribed motion generalized forces
        tau_p. f_inertial contains the velocity-dependent gyroscopic and coriolis
        forces due to rigid body rotations. No constraint forces are included.

        On return all the entries in udot will have been set to their calculated or
        prescribed values, and body spatial accelerations A_GB (that is, measured and
        expressed in Ground) are also returned. tau_p is not returned.

        This is an O(n) operator.

        Title: Required stage
          ``Stage::Dynamics`` (articulated body inertia will be realized if needed) *
        """
        return _simbody.SimbodyMatterSubsystem_calcAccelerationIgnoringConstraints(self, state, appliedMobilityForces, appliedBodyForces, udot, A_GB)

    def calcResidualForceIgnoringConstraints(self, state: "State", appliedMobilityForces: "Vector", appliedBodyForces: "VectorOfSpatialVec", knownUdot: "Vector", residualMobilityForces: "Vector") -> "void":
        r"""
         This is the inverse dynamics operator for the tree system; if there are
        any constraints or prescribed motion they are ignored. This method solves

             f_residual = M udot + f_inertial - f_applied

        for f_residual in O(n) time, meaning that the mass matrix M is never formed.
        Inverse dynamics is considerably faster than forward dynamics, even though
        both are O(n) in Simbody.

        In the above equation we solve for the residual forces ``f_residual`` given
        desired accelerations and (optionally) a set of applied forces. Here
        ``f_applied`` is the mobility-space equivalent of all the applied forces
        (including mobility and body forces), ``f_inertial`` is the mobility-space
        equivalent of the velocity-dependent inertial forces due to rigid
        body rotations (coriolis and gyroscopic forces), and ``udot`` is the
        given set of values for the desired generalized accelerations. The returned
        ``f_residual`` is the additional generalized force (that is, mobility
        force) that would have to be applied at each mobility to give the desired
        ``udot``. The inertial forces depend on the velocities ``u`` already realized
        in the State. Otherwise, only the explicitly-supplied forces affect the
        results of this operator; any forces that may be present elsewhere in
        the system are ignored.

        :type state: :py:class:`State`, in
        :param state:
                 A State valid for the containing System, already realized to
                 Stage::Velocity.
        :type appliedMobilityForces: :py:class:`Vector`, in
        :param appliedMobilityForces:
                 One scalar generalized force applied per mobility. Can be zero
                 length if there are no mobility forces; otherwise must have exactly
                 one entry per mobility in the matter subsystem.
        :type appliedBodyForces: SimTK::Vector_< SimTK::SpatialVec >, in
        :param appliedBodyForces:
                 One spatial force for each body. A spatial force is a force applied
                 to the body origin and a torque on the body, each expressed in the
                 Ground frame. Gravity, if present, is specified here as a body force.
                 The supplied Vector must be either zero length (interpreted as all-zero)
                 or have exactly one entry per body in the matter subsystem, starting with
                 Ground as body zero.
        :type knownUdot: :py:class:`Vector`, in
        :param knownUdot:
                 These are the desired generalized accelerations, one per mobility.
                 If this is zero length it will be treated as all-zero; otherwise
                 it must have exactly one entry per mobility in the matter subsystem.
        :type residualMobilityForces: :py:class:`Vector`, out
        :param residualMobilityForces:
                 These are the residual generalized forces which, if added to the applied
                 forces, would produce the given *knownUdot* in forward dynamics (assuming
                 the system is unconstrained). This will be resized if necessary to have
                 length nu; that is, one scalar entry per mobility. You can view this as a
                 measure of how much the given *knownUdot* fails to satisfy the equations
                 of motion.

        Title: Required stage
          ``Stage::Velocity``

        See also: calcResidualForce(), multiplyByM()
        See also: calcAcceleration(), calcAccelerationIgnoringConstraints() *
        """
        return _simbody.SimbodyMatterSubsystem_calcResidualForceIgnoringConstraints(self, state, appliedMobilityForces, appliedBodyForces, knownUdot, residualMobilityForces)

    def calcResidualForce(self, state: "State", appliedMobilityForces: "Vector", appliedBodyForces: "VectorOfSpatialVec", knownUdot: "Vector", knownLambda: "Vector", residualMobilityForces: "Vector") -> "void":
        r"""
         This is the inverse dynamics operator for when you know both the
        accelerations and Lagrange multipliers for a constrained system. Prescribed
        motion is ignored. Using position and velocity from the given state, a set of
        applied forces, and a known set of generalized accelerations udot and
        constraint multipliers lambda, it calculates the additional generalized forces
        that would be required to satisfy Newton's 2nd law, f=Ma. That is, this
        operator returns

            f_residual = M udot + ~G lambda + f_inertial - f_applied

        where f_applied is the mobility-space equivalent to all the applied forces
        (including mobility and body forces), f_inertial is the mobility-space
        equivalent of the velocity-dependent inertial forces due to rigid body
        rotations (coriolis and gyroscopic forces), and the udots and lambdas are given
        values of the generalized accelerations and constraint multipliers, resp.

        Note that there is no requirement that the given udots satisfy the constraint
        equations; we simply solve the above equation for ``f_residual``.

        The inertial forces depend on the velocities ``u`` already realized in the State.
        Otherwise, only the explicitly-supplied forces affect the results of this
        operator; any forces that may be defined elsewhere in the system are ignored
        here.

        :type state: :py:class:`State`, in
        :param state:
                 A State valid for the containing System, already realized to
                 ``Stage::Velocity``.
        :type appliedMobilityForces: :py:class:`Vector`, in
        :param appliedMobilityForces:
                 One scalar generalized force applied per mobility. Can be zero
                 length if there are no mobility forces; otherwise must have exactly
                 one entry per mobility in the matter subsystem.
        :type appliedBodyForces: SimTK::Vector_< SimTK::SpatialVec >, in
        :param appliedBodyForces:
                 One spatial force for each body. A spatial force is a force applied
                 to the body origin and a torque on the body, each expressed in the
                 Ground frame. Gravity, if present, is specified here as a body force.
                 The supplied Vector must be either zero length (interpreted as all-zero)
                 or have exactly one entry per body in the matter subsystem, starting with
                 Ground as body zero.
        :type knownUdot: :py:class:`Vector`, in
        :param knownUdot:
                 These are the specified generalized accelerations, one per mobility so
                 the length should be nu. If this is zero length it will be treated as
                 all-zero of length nu; otherwise it must have exactly one entry per
                 mobility in the matter subsystem.
        :type knownLambda: :py:class:`Vector`, in
        :param knownLambda:
                 These are the specified Lagrange multipliers, one per constraint
                 equation. If this is zero length it will be treated as all-zero; otherwise
                 it must have exactly m entries, where m=mp+mv+ma is the total number of
                 position, velocity, and acceleration-only constraints. There are no
                 entries here corresponding to quaternion constraints, which do not
                 generate forces.
        :type residualMobilityForces: :py:class:`Vector`, out
        :param residualMobilityForces:
                 These are the residual generalized forces which, if added to the applied
                 forces along with the constraint forces ~G*lambda, would produce the
                 given *knownUdot* in unconstrained forward dynamics. This will be resized
                 if necessary to have length nu; that is, one scalar entry per mobility.
                 You can view this as a measure of how much the given udot and lambda fail
                 to satisfy the equations of motion.

        Title: Required stage
          ``Stage::Velocity``

        See also: calcResidualForceIgnoringConstraints() *
        """
        return _simbody.SimbodyMatterSubsystem_calcResidualForce(self, state, appliedMobilityForces, appliedBodyForces, knownUdot, knownLambda, residualMobilityForces)

    def calcBodyAccelerationFromUDot(self, state: "State", knownUDot: "Vector", A_GB: "VectorOfSpatialVec") -> "void":
        r"""
         Given a complete set of n generalized accelerations udot, this kinematic
        operator calculates in O(n) time the resulting body accelerations, including
        velocity-dependent terms taken from the supplied *state*.

        :type state: :py:class:`State`, in
        :param state:
                The State from which position- and velocity- related terms are taken;
                must already have been realized to Velocity stage.
        :type knownUDot: :py:class:`Vector`, in
        :param knownUDot:
                A complete set of generalized accelerations. Must have the same length
                as the number of mobilities nu, or if length zero the udots will be taken
                as all zero in which case only velocity-dependent (Coriolis) accelerations
                will be returned in *A_GB*.
        :type A_GB: SimTK::Vector_< SimTK::SpatialVec >, out
        :param A_GB:
                Spatial accelerations of all the body frames measured and expressed in
                the Ground frame, resulting from supplied generalized accelerations
                *knownUDot* and velocity-dependent acceleration terms taken from
                *state*. This will be resized if necessary to the number of bodies
                **including** Ground so that the returned array may be indexed by
                MobilizedBodyIndex with A_GB[0]==0 always. The angular acceleration
                vector for MobilizedBody i is A_GB[i][0]; linear acceleration of the
                body's origin is A_GB[i][1].

        Title: Theory
        The generalized speeds u and spatial velocities V are related by the system
        Jacobian J as V=J*u. Thus the spatial accelerations A=Vdot=J*udot+Jdot*u.

        Title: Implementation
        The Coriolis accelerations Jdot*u are already available in a State realized
        to Velocity stage. The J*udot term is equivalent to an application of
        multiplyBySystemJacobian() to the *knownUdot* vector. The current
        implementation uses 12*nu + 18*nb flops to produce nb body accelerations.

        Title: Required stage
          ``Stage::Velocity``

        See also: multiplyBySystemJacobian(), getTotalCoriolisAcceleration() *
        """
        return _simbody.SimbodyMatterSubsystem_calcBodyAccelerationFromUDot(self, state, knownUDot, A_GB)

    def calcConstraintForcesFromMultipliers(self, state: "State", multipliers: "Vector", bodyForcesInG: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        r"""
         Treating all Constraints together, given a comprehensive set of m
        Lagrange multipliers *lambda*, generate the complete set of body spatial forces
        and mobility (generalized) forces applied by all the Constraints.

        Spatial forces are applied at each body's origin and the moment and force
        vectors therein are expressed in the Ground frame. Watch the
        sign -- normally constraint forces have opposite sign from applied forces,
        because our equations of motion are
               M udot + ~G lambda = f_applied
        If you want to take Simbody-calculated multipliers and use them to generate
        forces that look like applied forces, negate the multipliers in the argument
        passed to this call.

        State must be realized to Stage::Velocity to call this operator (although
        typically the multipliers are obtained by realizing to Stage::Acceleration).

        This is an O(m) operator. In particular it does *not* involve forming or
        multiplying by the constraint force matrix ~G. Instead, one constant-time call
        is made to each %Constraint's calcConstraintForce methods.

        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcConstraintForcesFromMultipliers(self, state, multipliers, bodyForcesInG, mobilityForces)

    def calcMobilizerReactionForces(self, state: "State", forcesAtMInG: "VectorOfSpatialVec") -> "void":
        r"""
         Calculate the mobilizer reaction force generated at each MobilizedBody,
        as felt at the mobilizer's outboard frame M, and expressed in Ground.

        :type state: :py:class:`State`, in
        :param state:
                A State compatible with this System that has already been realized
                to Stage::Acceleration.
        :type forcesAtMInG: SimTK::Vector_< SimTK::SpatialVec >, out
        :param forcesAtMInG:
                A Vector of spatial force vectors, indexed by MobilizedBodyIndex
                (beginning with 0 for Ground), giving the reaction moment and force
                applied by each body's unique inboard mobilizer to that body. The
                force is returned as though it were applied at the origin of the
                body's mobilizer frame M. The returned force is expressed in the
                Ground frame. Applied mobility (generalized) forces are *included* in the
                returned reaction forces.

        A simple way to think of the reaction force is to think of cutting the
        mobilizer, then imagine the force required to make the system move in
        the same manner as when the mobilizer was present. This is what the
        reaction forces accomplish. With that definition, mobility forces (that is,
        generalized forces as opposed to body forces) are *included* in the reactions.
        Some conventions do not include the mobility forces in the definition of a
        reaction force. We chose to include them since this preserves Newton's
        3rd law of equal and opposite reactions between bodies. Ours is the same
        convention as used in SD/FAST.

        Notes: You can think of the Ground body being welded to the universe at the
        Ground origin. The reactions reported for Ground are the ones that would
        occur in that Weld mobilizer if it were really present. That is, it includes
        the effects of all the base bodies on Ground.

        ### How to find the reaction felt by the parent body

        A mobilizer connects a frame F fixed on the parent (inboard) body P to a
        frame M fixed on the child (outboard) body B. It exerts equal and opposite
        reaction forces on the two bodies, at a given location in space. This method
        reports the force on the child body, as though it were applied at the origin
        Mo of frame M, and expressed in the Ground frame. The force on the parent body
        **at Mo** is just the negative of the returned value. However, it is
        more likely that you would want it as felt **at Fo**, the origin of the
        F frame on the parent. Here is one way to calculate that from the returned
        quantities:

        .. code-block:: c++

                matter.calcMobilizerReactionForces(state,forcesAtMInG); // This method.
                const int nb = matter.getNumBodies();
                Vector_<SpatialVec> forcesAtFInG(nb); // to hold the result
                forcesAtFInG[0] = -forcesAtMInG[0]; // Ground is "welded" at origin
                for (MobilizedBodyIndex i(1); i < nb; ++i) {
                    const MobilizedBody& mobod  = matter.getMobilizedBody(i);
                    const MobilizedBody& parent = mobod.getParentMobilizedBody();
            Want to shift reaction by p_MF, the vector from M to F across the
            mobilizer, and negate. Can get p_FM; must reexpress in G.
                    const Vec3& p_FM = mobod.getMobilizerTransform(state).p();
                    const Rotation& R_PF = mobod.getInboardFrame(state).R(); // In parent.
                    const Rotation& R_GP = parent.getBodyTransform(state).R();
                    Rotation R_GF   =   R_GP*R_PF;  // F frame orientation in Ground.
                    Vec3     p_MF_G = -(R_GF*p_FM); // Re-express and negate shift vector.
                    forcesAtFInG[i] = -shiftForceBy(forcesAtMInG[i], p_MF_G);
                }

        ### Implementation
        This method combines already-calculated quantities to calculate the reactions.
        See Abhi Jain's 2011 book "Robot and Multibody Dynamics", Eq. 7.34 page 128:
           F_reaction = PPlus*APlus + zPlus
        where P is the articulated body inertia, A is the spatial acceleration,
        a the Coriolis acceleration and z the articulated body forces, and "Plus"
        indicates that we evaluate these on the inboard (parent) side of the mobilizer
        rather than on the body's side. (The alternative P(A-a)+z given there does not
        work for prescribed mobilizers unless you replace "a" with "a_underscore" from
        equation 16.14.) After calculating F_reaction at the body frame
        origin Bo, we shift it to M for reporting.

        ### Performance
        The cost of the above calculation is 114 flops/body. The code presented
        above for converting from M to F costs an additional 81 flops/body if you
        use it.

        Title: Required stage
          ``Stage::Acceleration``

        See also: SimTK::MobilizedBody::findMobilizerReactionOnBodyAtMInGround()
        See also: calcMobilizerReactionForcesUsingFreebodyMethod() *
        """
        return _simbody.SimbodyMatterSubsystem_calcMobilizerReactionForces(self, state, forcesAtMInG)

    def getMotionMultipliers(self, state: "State") -> "SimTK::Vector const &":
        r"""
         Return a reference to the prescribed motion multipliers tau that have
        already been calculated in the given *state*, which must have been realized
        through Acceleration stage. The result contains entries only for prescribed
        mobilities; if you want these unpacked into u-space mobility forces, use
        findMotionForces() instead. A mobilizer may follow prescribed motion either
        because of a Motion object or a call to MobilizedBody::lock().

        Title: Required stage
          ``Stage::Acceleration`` *
        """
        return _simbody.SimbodyMatterSubsystem_getMotionMultipliers(self, state)

    def calcMotionErrors(self, state: "State", stage: "Stage") -> "SimTK::Vector":
        r"""
         Calculate the degree to which the supplied *state* does not satisfy the
        prescribed motion requirements at a particular Stage. For Position and Velocity
        stage, a call to the prescribe() solver using the same stage will eliminate
        the error. Accelerations should have been calculated to satisfy all prescribed
        accelerations, so the returned value should be zero always. The returned
        Vector has one element per known (prescribed) q, known u, or known udot.

        The *state* must be realized to Time stage to check Position errors,
        Position stage to check Velocity errors, and Acceleration stage to check
        Acceleration errors.

        Errors are calculated actualValue - prescribedValue so a positive error
        indicates that the value in *state* is too large. *
        """
        return _simbody.SimbodyMatterSubsystem_calcMotionErrors(self, state, stage)

    def findMotionForces(self, state: "State", mobilityForces: "Vector") -> "void":
        r"""
         Find the generalized mobility space forces produced by all the Motion
        objects active in this system. These are the same values as returned by
        getMotionMultipliers() but unpacked into u-space slots, with zeroes
        corresponding to any "free" mobilities, that is, those whose motion is not
        prescribed.

        Title: Required stage
          ``Stage::Acceleration`` *
        """
        return _simbody.SimbodyMatterSubsystem_findMotionForces(self, state, mobilityForces)

    def getConstraintMultipliers(self, state: "State") -> "SimTK::Vector const &":
        r"""
         Return a reference to the constraint multipliers lambda that have already
        been calculated in the given *state*, which must have been realized through
        Acceleration stage. Constraint multipliers are not directly interpretable as
        forces; if you want the actual forces use findConstraintForces() instead. If
        you want to know individual Constraint contributions to these forces, ask the
        Constraint objects rather than this SimbodyMatterSubsystem object.

        Title: Required stage
          ``Stage::Acceleration`` *
        """
        return _simbody.SimbodyMatterSubsystem_getConstraintMultipliers(self, state)

    def findConstraintForces(self, state: "State", bodyForcesInG: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        r"""
         Find the forces produced by all the active Constraint objects in this
        system. Constraints produce both body spatial forces and generalized
        mobility-space forces. The supplied *state* must have been realized through
        Acceleration stage.

        Title: Required stage
          ``Stage::Acceleration`` *
        """
        return _simbody.SimbodyMatterSubsystem_findConstraintForces(self, state, bodyForcesInG, mobilityForces)

    def calcMotionPower(self, state: "State") -> "SimTK::Real":
        r"""
         Calculate the power being generated or dissipated by all the Motion objects
        currently active in this system. The sign is chosen so that a positive value for
        power means the Motion is adding energy to the system; negative means it is
        removing energy. The *state* must already have been realized through
        Acceleration stage so that the prescribed motion forces are available.

        :type state: :py:class:`State`, in
        :param state:
                A State realized through Acceleration stage from which we obtain the
                prescribed motion forces and the velocities needed to calculate power.

        ### Implementation
        We calculate power=-dot(tau, u) where tau is the set of mobility reaction
        forces generated by Motion objects and mobilizer locks (tau[i]==0 if mobility
        i is free), and u is the set of all generalized speeds.

        Title: Required stage
          ``Stage::Acceleration``
        See also: calcConstraintPower() *
        """
        return _simbody.SimbodyMatterSubsystem_calcMotionPower(self, state)

    def calcConstraintPower(self, state: "State") -> "SimTK::Real":
        r"""
         Return the power begin generated or dissipated by all the Constraint
        objects currently active in this system. The sign is chosen so that a positive
        value for power means the Constraints (taken together) are adding energy to the
        system; negative means they are removing energy. The *state* must already have
        been realized through Acceleration stage so that the constraint forces are
        available.

        Note that if you want to know the power output of an individual Constraint,
        you should call that Constraint's calcPower() method; here they are all summed
        together.

        :type state: :py:class:`State`, in
        :param state:
                A State realized through Acceleration stage from which we obtain the
                constraint forces and the velocities needed to calculate power.
        :rtype: float
        :return: 
                The signed sum over all the Constraint objects of the power being generated
                or dissipated by each Constraint. A positive value means that together the
                constraints are adding energy to the system; negative means they are
                removing energy.

        ### Implementation
        We calculate power=-(dot(F,V)+dot(f,u)) where F is the set of body spatial
        reaction forces produced by the Constraints, V is the body spatial velocities,
        f is the set of mobility reaction forces produced by the Constraints, and u is
        the set of generalized speeds.

        Title: Required stage
          ``Stage::Acceleration``
        See also: calcMotionPower() *
        """
        return _simbody.SimbodyMatterSubsystem_calcConstraintPower(self, state)

    def calcTreeEquivalentMobilityForces(self, arg2: "State", bodyForces: "VectorOfSpatialVec", mobilityForces: "Vector") -> "void":
        r"""
         Accounts for applied forces and inertial forces produced by non-zero
        velocities in the State. Returns a set of mobility forces which replace both
        the applied bodyForces and the inertial forces.
        Title: Required stage
          ``Stage::Dynamics`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcTreeEquivalentMobilityForces(self, arg2, bodyForces, mobilityForces)

    def calcQDot(self, s: "State", u: "Vector", qdot: "Vector") -> "void":
        r"""
         Calculate qdot = N(q)*u in O(n) time (very fast). Note that q is taken
        from the supplied state while u is an argument to this operator method.
        Title: Required stage
          ``Stage::Position`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcQDot(self, s, u, qdot)

    def calcQDotDot(self, s: "State", udot: "Vector", qdotdot: "Vector") -> "void":
        r"""
         Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast). Note
        that q and u are taken from the supplied state while udot is an argument to
        this operator method.
        Title: Required stage
          ``Stage::Velocity`` *
        """
        return _simbody.SimbodyMatterSubsystem_calcQDotDot(self, s, udot, qdotdot)

    @staticmethod
    def isInstanceOf(arg1: "Subsystem const &") -> "bool":
        return _simbody.SimbodyMatterSubsystem_isInstanceOf(arg1)

    @staticmethod
    def downcast(arg1: "Subsystem const &") -> "SimTK::SimbodyMatterSubsystem const &":
        return _simbody.SimbodyMatterSubsystem_downcast(arg1)

    @staticmethod
    def updDowncast(arg1: "Subsystem &") -> "SimTK::SimbodyMatterSubsystem &":
        return _simbody.SimbodyMatterSubsystem_updDowncast(arg1)

    def getRep(self) -> "SimbodyMatterSubsystemRep const &":
        return _simbody.SimbodyMatterSubsystem_getRep(self)

    def updRep(self) -> "SimbodyMatterSubsystemRep &":
        return _simbody.SimbodyMatterSubsystem_updRep(self)

# Register SimbodyMatterSubsystem in _simbody:
_simbody.SimbodyMatterSubsystem_swigregister(SimbodyMatterSubsystem)

def SimbodyMatterSubsystem_isInstanceOf(arg1: "Subsystem const &") -> "bool":
    return _simbody.SimbodyMatterSubsystem_isInstanceOf(arg1)

def SimbodyMatterSubsystem_downcast(arg1: "Subsystem const &") -> "SimTK::SimbodyMatterSubsystem const &":
    return _simbody.SimbodyMatterSubsystem_downcast(arg1)

def SimbodyMatterSubsystem_updDowncast(arg1: "Subsystem &") -> "SimTK::SimbodyMatterSubsystem &":
    return _simbody.SimbodyMatterSubsystem_updDowncast(arg1)

class SimTKVisualizer(object):
    r"""
     Provide simple visualization of and interaction with a Simbody simulation,
    with real time control of the frame rate.\ There are several operating modes
    available, including real time operation permitting responsive user interaction
    with the simulation.

    Frames are sent to the renderer at a regular interval that is selectable, with
    a default rate of 30 frames/second. The various operating modes provide
    different methods of controlling which simulation frames are selected and how
    they are synchronized for display.

    ### Visualization modes

    There are three operating modes for the Visualizer's display of simulation
    results, selectable via setMode():

    - **PassThrough**. This is the default mode. It sends through to the
    renderer *every* frame that is received from the simulation, slowing down the
    simulation if necessary so that the frames are presented at a selected frame
    rate. But note that the simulation time will not be synchronized to real time;
    because Simbody simulations generally proceed at a variable rate, the
    regularly-spaced output frames will represent different amounts of simulated
    time. If you want real time and simulation time synchronized, use the RealTime
    mode.

    - **Sampling**. This mode is useful for monitoring a simulation that is
    allowed to run at full speed. We send frames for display at a maximum rate
    given by the frame rate setting. After a frame is sent, all subsequent frames
    received from the simulation are ignored until the frame interval has passed;
    then the next received frame is displayed. This allows the simulation to
    proceed at the fastest rate possible but time will be irregular and not all
    frames generated by the simulation will be shown.

    - **RealTime**. Synchronize frame times with the simulated time, slowing
    down the simulation if it is running ahead of real time, as modifed by the
    time scale; see setRealTimeScale(). Frames are sent to the renderer at the
    selected frame rate. Smoothness is maintained by buffering up frames before
    sending them; interactivity is maintained by keeping the buffer length below
    human perception time (150-200ms). The presence and size of the buffer is
    selectable; see setDesiredBufferLengthInSec().

    ### User interaction

    The Simbody visualizer provides some user interaction of its own, for
    example allowing the user to control the viewpoint and display options. User
    inputs that it does not interpret locally are passed on to the simulation,
    and can be intercepted by registering InputListeners with the Visualizer. The
    Visualizer provides a class Visualizer::InputSilo which is an InputListener
    that simply captures and queues all user input, with the intent that a running
    simulation will occasionally stop to poll the InputSilo to process any input
    that has been collected.

    ### Implementation notes

    RealTime mode is worth some discussion. There is a simulation thread that
    produces frames at a variable rate, and a draw thread that consumes frames at a
    variable rate (by sending them to the renderer). We want to engineer things so
    that frames are sent to the renderer at a steady rate that is synchronized with
    simulation time (possibly after scaling). When a thread is running too fast,
    that is easily handled by blocking the speeding thread for a while. The "too
    slow" case takes careful handling.

    In normal operation, we expect the simulation to take varying amounts of
    real time to generate fixed amounts of simulation time, because we prefer
    to use variable time-step integrators that control errors by taking smaller
    steps in more difficult circumstances, and large steps through the easy
    parts of the simulation. For real time operation, the simulation must of
    course *average* real time performance; we use a frame buffer to smooth
    out variable delivery times. That is, frames go into the buffer at an
    irregular rate but are pulled off at a regular rate. A longer buffer can
    mask wider deviations in frame time, at the expense of interactive response.
    In most circumstances people cannot perceive delays below about 200ms, so
    for good response the total delay should be kept around that level.

    Despite the buffering, there will be occasions when the simulation can't
    keep up with real time. A common cause of that is that a user has paused
    either the simulation or the renderer, such as by hitting a breakpoint while
    debugging. In that case we deem the proper behavior to be that when we
    resume we should immediately resume real time behavior at a new start time,
    *not* attempt to catch up to the previous real time by running at high speed.
    As much as possible, we would like the simulation to behave just as it would
    have without the interruption, but with a long pause where interrupted. We
    deal with this situation by introducing a notion of "adjusted real time"
    (AdjRT). That is a clock that tracks the real time interval counter, but uses
    a variable base offset that is used to match it to the expected simulation
    time. When the simulation is long delayed, we modify the AdjRT base when we
    resume so that AdjRT once again matches the simulation time t. Adjustments
    to the AdjRT base occur at the time we deliver frames to the renderer; at that
    moment we compare the AdjRT reading to the frame's simulation time t and
    correct AdjRT for future frames.

    You can also run in RealTime mode without buffering. In that case frames are
    sent directly from the simulation thread to the renderer, but the above logic
    still applies. Simulation frames that arrive earlier than the corresponding
    AdjRT are delayed; frames that arrive later are drawn immediately but cause
    AdjRT to be readjusted to resynchronize. Overall performance can be better
    in unbuffered RealTime mode because the States provided by the simulation do
    not have to be copied before being drawn. However, intermittent slower-than-
    realtime frame times cannot be smoothed over; they will cause rendering delays.

    PassThrough and Sampling modes are much simpler because no synchronization
    is done to the simulation times. There is only a single thread and draw
    time scheduling works in real time without adjustment.

    With the above explanation, you may be able to figure out most of what comes
    out of the dumpStats() method which can be used to help diagnose performance
    problems. *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a new %Visualizer for the indicated System, and launch the
        visualizer display executable from a default or specified location. The camera's
        "up" direction will initially be set to match the "up" direction hint that is
        stored with the supplied *system;* the default is that "up" is in the
        direction of the positive Y axis. The background will normally include a
        ground plane and sky, but if the *system* has been set to request a uniform
        background we'll use a plain white background instead. You can override the
        chosen defaults using %Visualizer methods setSystemUpDirection() and
        setBackgroundType().

        Simbody is shipped with a separate executable program simbody-visualizer
        (simbody-visualizer_d if building as Debug) that provides the graphics display
        and collects user input. Normally that executable is installed in the "bin"
        subdirectory of the Simbody installation directory.  However, first we look in
        the same directory as the currently-running executable and, if found, we will
        use that visualizer. If no visualizer is found with the executable, we check if
        environment variables SIMBODY_HOME or SimTK_INSTALL_DIR exist, and look in
        their "bin" (or "libexec/simbody" on UNIX) subdirectories if so. Next, we
        attempt to use the relative path from the SimTKsimbody library to the
        simbody-visualizer (this helps if Simbody is relocated, but does not work on
        Windows, or if using static Simbody libraries). Then, we check the installed
        location of the visualizer, as specified when Simbody is compiled. If the
        visualizer is not there, we'll look in platform-specific default locations.
        The other constructor allows specification of a search path that will be
        checked before attempting to find the installation directory.

        If you want to override the name of the visualizer executable for which Simbody
        searches, set the environment variable SIMBODY_VISUALIZER_NAME
        to the desired executable name. For example, if you want to use the
        debug visualizer with release libraries, set SIMBODY_VISUALIZER_NAME
        to simbody-visualizer_d.

        The SimTK::Pathname class is used to process the supplied search path, which
        can consist of absolute, working directory-relative, or executable
        directory-relative path names.

        See also: SimTK::Pathname *

        |

        *Overload 2:*
         Construct a new Visualizer for a given system, with a specified search
        path for locating the SimbodyVisualizer executable. The search path is
        checked *after* looking in the current executable directory, and *before*
        trying to locate the Simbody or SimTK installation directory. See the other
        constructor's documentation for more information. *

        |

        *Overload 3:*
         Copy constructor has reference counted, shallow copy semantics;
        that is, the Visualizer copy is just another reference to the same
        Visualizer object. *
        """
        _simbody.SimTKVisualizer_swiginit(self, _simbody.new_SimTKVisualizer(*args))
    __swig_destroy__ = _simbody.delete_SimTKVisualizer

    def shutdown(self) -> "void":
        r"""
         Ask the visualizer to shut itself down immediately. This will cause the
        display window to close and the associated process to die. This method returns
        immediately but it may be some time later when the visualizer acts on the
        instruction; there is no way to wait for it to die. Normally the visualizer
        will persist even after the death of the simulator connection unless you have
        called setShutdownWhenDestructed() to make shutdown() get called automatically.
        See also: setShutdownWhenDestructed() *
        """
        return _simbody.SimTKVisualizer_shutdown(self)

    def setShutdownWhenDestructed(self, shouldShutdown: "bool") -> "SimTK::Visualizer &":
        r"""
         Set the flag that determines whether we will automatically send a Shutdown
        message to the visualizer when this %Visualizer object is destructed.
        Normally we allow the GUI to persist even after death of the simulator
        connection, unless an explicit call to shutdown() is made.
        See also: getShutdownWhenDestructed(), shutdown() *
        """
        return _simbody.SimTKVisualizer_setShutdownWhenDestructed(self, shouldShutdown)

    def getShutdownWhenDestructed(self) -> "bool":
        r"""
         Return the current setting of the "shutdown when destructed" flag. By
        default this is false.
        See also: setShutdownWhenDestructed(), shutdown() *
        """
        return _simbody.SimTKVisualizer_getShutdownWhenDestructed(self)
    PassThrough = _simbody.SimTKVisualizer_PassThrough
    r"""
    Send through to the renderer every frame that is received from the
       simulator (default mode). *
    """
    Sampling = _simbody.SimTKVisualizer_Sampling
    r"""
    Sample the results from the simulation at fixed real time intervals
       given by the frame rate. *
    """
    RealTime = _simbody.SimTKVisualizer_RealTime
    r""" Synchronize real frame display times with the simulated time. *"""
    GroundAndSky = _simbody.SimTKVisualizer_GroundAndSky
    r"""
    Show a ground plane on which shadows may be cast, as well as a sky
       in the far background. *
    """
    SolidColor = _simbody.SimTKVisualizer_SolidColor
    r""" Display a solid background color that has been provided elsewhere. *"""
    ViewMenuId = _simbody.SimTKVisualizer_ViewMenuId
    r""" The id of the predefined View pull-down. *"""

    def setBackgroundType(self, background: "SimTK::Visualizer::BackgroundType") -> "SimTK::Visualizer &":
        r"""
        * Change the background mode currently in effect in the GUI.\ By default
        we take the desired background type from the System, which will usually be
        at its default value which is to show a ground plane and sky. You can override
        that default choice with this method.
        :type background: int
        :param background:   The background type to use.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls.
        Notes: Molmodel's CompoundSystem requests a solid background by default, since
        ground and sky is not the best way to display a molecule! *
        """
        return _simbody.SimTKVisualizer_setBackgroundType(self, background)

    def setBackgroundColor(self, color: "Vec3") -> "SimTK::Visualizer const &":
        r"""
         Set the background color.\ This will be used when the solid background
        mode is in effect but has no effect otherwise. This is a const method so you
        can call it from within a FrameController, for example if you want to flash
        the background color.
        :type color: :py:class:`Vec3`
        :param color:   The background color in r,g,b format with [0,1] range.
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const. *
        """
        return _simbody.SimTKVisualizer_setBackgroundColor(self, color)

    def setShowShadows(self, showShadows: "bool") -> "SimTK::Visualizer const &":
        r"""
         Control whether shadows are generated when the GroundAndSky background
        type is in effect.\ This has no effect if the ground plane is not being
        displayed. The default if for shadows to be displayed. This is a const method
        so you can call it from within a FrameController.
        :type showShadows: boolean
        :param showShadows:     Set true to have shadows generated; false for none.
        See also: setBackgroundType()
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const. *
        """
        return _simbody.SimTKVisualizer_setShowShadows(self, showShadows)

    def setShowFrameRate(self, showFrameRate: "bool") -> "SimTK::Visualizer const &":
        r"""
         Control whether frame rate is shown in the Visualizer.\ This is a const
        method so you can call it from within a FrameController.
        :type showFrameRate: boolean
        :param showFrameRate:     Set true to show the frame rate; false for none.
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const. *
        """
        return _simbody.SimTKVisualizer_setShowFrameRate(self, showFrameRate)

    def setShowSimTime(self, showSimTime: "bool") -> "SimTK::Visualizer const &":
        r"""
         Control whether simulation time is shown in the Visualizer.\ This is a const
        method so you can call it from within a FrameController.
        :type showSimTime: boolean
        :param showSimTime:     Set true to show the simulation time; false for none.
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const. *
        """
        return _simbody.SimTKVisualizer_setShowSimTime(self, showSimTime)

    def setShowFrameNumber(self, showFrameNumber: "bool") -> "SimTK::Visualizer const &":
        r"""
         Control whether frame number is shown in the Visualizer.\ This is a const
        method so you can call it from within a FrameController.
        :type showFrameNumber: boolean
        :param showFrameNumber:     Set true to show the frame number; false for none.
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const. *
        """
        return _simbody.SimTKVisualizer_setShowFrameNumber(self, showFrameNumber)

    def setWindowTitle(self, title: "String const &") -> "SimTK::Visualizer const &":
        r"""
         Change the title on the main visualizer window.\ The default title
        is Simbody *version* : *exename*, where *version* is the current Simbody
        version number in major.minor.patch format and *exename* is the name of the
        executing simulation application's executable file (without suffix if any).
        :type title: String, in
        :param title:
                The new window title. The amount of room for the title varies; keep
                it short.
        :rtype: :py:class:`Visualizer`
        :return: A const reference to this Visualizer so that you can chain "set"
            calls, provided subsequent ones are also const.
        See also: SimTK_version_simbody(), Pathname::getThisExecutablePath(),
        Pathname::desconstructPathname() *
        """
        return _simbody.SimTKVisualizer_setWindowTitle(self, title)

    def setSystemUpDirection(self, upDirection: "CoordinateDirection") -> "SimTK::Visualizer &":
        r"""
        ** Set the coordinate direction that should be considered the System's "up"
        direction.\ When the ground and sky background is in use, this is the
        direction that serves as the ground plane normal, and is used as the initial
        orientation for the camera's up direction (which is subsequently under user
        or program control and can point anywhere). If you don't set this explicitly
        here, the Visualizer takes the default up direction from the System, which
        provides a method allowing the System's creator to specify it, with the +Y
        axis being the default.
        :type upDirection: :py:class:`CoordinateDirection`, in
        :param upDirection:
                This must be one of the CoordinateAxis constants XAxis, YAxis, or ZAxis,
                or one of the opposite directions -XAxis, -YAxis, or -ZAxis.
        :rtype: :py:class:`Visualizer`
        :return: A writable reference to this Visualizer so that you can chain "set"
            calls in the manner of chained assignments. *
        """
        return _simbody.SimTKVisualizer_setSystemUpDirection(self, upDirection)

    def getSystemUpDirection(self) -> "SimTK::CoordinateDirection":
        r"""
         Get the value the Visualizer is using as the System "up" direction (
        not to be confused with the camera "up" direction). *
        """
        return _simbody.SimTKVisualizer_getSystemUpDirection(self)

    def setGroundHeight(self, height: "SimTK::Real") -> "SimTK::Visualizer &":
        r"""
         Set the height at which the ground plane should be displayed when the
        GroundAndSky background type is in effect.\ This is interpreted along the
        system "up" direction that was specified in the Visualizer's System or was
        overridden with the setSystemUpDirection() method. The default value is zero,
        meaning that the ground plane passes through the ground origin.
        :type height: float
        :param height:
                The position of the ground plane along the system "up" direction that
                serves as the ground plane normal. Note that *height* is *along* the
                up direction, meaning that if up is one of the negative coordinate axis
                directions a positive *height* will move the ground plane to a more
                negative position.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls.
        See also: setSystemUpDirection(), setBackgroundType() *
        """
        return _simbody.SimTKVisualizer_setGroundHeight(self, height)

    def getGroundHeight(self) -> "SimTK::Real":
        r"""
         Get the value the Visualizer considers to be the height of the ground
        plane for this System.\ The value must be interpreted along the System's "up"
        direction. See also: setSystemUpDirection() *
        """
        return _simbody.SimTKVisualizer_getGroundHeight(self)

    def setMode(self, mode: "SimTK::Visualizer::Mode") -> "SimTK::Visualizer &":
        r"""
         Set the operating mode for the Visualizer. See 'Visualizer::Mode' for
        choices, and the discussion for the Visualizer class for meanings.
        :type mode: int, in
        :param mode:    The new Mode to use.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls. *
        """
        return _simbody.SimTKVisualizer_setMode(self, mode)

    def getMode(self) -> "SimTK::Visualizer::Mode":
        r"""
         Get the current mode being used by the Visualizer. See 'Visualizer::Mode'
        for the choices, and the discussion for the Visualizer class for meanings. *
        """
        return _simbody.SimTKVisualizer_getMode(self)

    def setDesiredFrameRate(self, framesPerSec: "SimTK::Real") -> "SimTK::Visualizer &":
        r"""
         Set the frame rate in frames/sec (of real time) that you want the
        Visualizer to attempt to achieve. This affects all modes. The default is 30
        frames per second. Set the frame rate to zero to return to the default
        behavior.
        :type framesPerSec: float, in
        :param framesPerSec:
                The desired frame rate; specify as zero to get the default.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls.
        """
        return _simbody.SimTKVisualizer_setDesiredFrameRate(self, framesPerSec)

    def getDesiredFrameRate(self) -> "SimTK::Real":
        r"""
         Get the current value of the frame rate the Visualizer has been asked to
        attempt; this is not necessarily the rate actually achieved. A return value of
        zero means the Visualizer is using its default frame rate, which may be
        dependent on the current operating mode.
        See also: setDesiredFrameRate() for more information. *
        """
        return _simbody.SimTKVisualizer_getDesiredFrameRate(self)

    def setRealTimeScale(self, simTimePerRealSecond: "SimTK::Real") -> "SimTK::Visualizer &":
        r"""
         In RealTime mode we normally assume that one unit of simulated time should
        map to one second of real time; however, in some cases the time units are not
        seconds, and in others you may want to run at some multiple or fraction of
        real time. Here you can say how much simulated time should equal one second of
        real time. For example, if your simulation runs in seconds, but you want to
        run twice as fast as real time, then call setRealTimeScale(2.0), meaning that
        two simulated seconds will pass for every one real second. This call will have
        no immediate effect if you are not in RealTime mode, but the value will be
        remembered.

        :type simTimePerRealSecond: float, in
        :param simTimePerRealSecond:
            The number of units of simulation time that should be displayed in one second
            of real time. Zero or negative value will be interpeted as the default ratio
            of 1:1.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls.
        """
        return _simbody.SimTKVisualizer_setRealTimeScale(self, simTimePerRealSecond)

    def getRealTimeScale(self) -> "SimTK::Real":
        r"""
         Return the current time scale, which will be 1 by default.
        See also: setRealTimeScale() for more information. *
        """
        return _simbody.SimTKVisualizer_getRealTimeScale(self)

    def setDesiredBufferLengthInSec(self, bufferLengthInSec: "SimTK::Real") -> "SimTK::Visualizer &":
        r"""
         When running an interactive realtime simulation, you can smooth out changes
        in simulation run rate by buffering frames before sending them on for
        rendering. The length of the buffer introduces an intentional response time
        lag from when a user reacts to when he can see a response from the simulator.
        Under most circumstances a lag of 150-200ms is undetectable. The default
        buffer length is the time represented by the number of whole frames
        that comes closest to 150ms; 9 frames at 60fps, 5 at 30fps, 4 at 24fps, etc.
        To avoid frequent block/unblocking of the simulation thread, the buffer is
        not kept completely full; you can use dumpStats() if you want to see how the
        buffer was used during a simulation. Shorten the buffer to improve
        responsiveness at the possible expense of smoothness. Note that the total lag
        time includes not only the buffer length here, but also lag induced by the
        time stepper taking steps that are larger than the frame times. For maximum
        responsiveness you should keep the integrator step sizes limited to about
        100ms, or reduce the buffer length so that worst-case lag doesn't go much over
        200ms.
        :type bufferLengthInSec: float, in
        :param bufferLengthInSec:
            This is the target time length for the buffer. The actual length is the nearest
            integer number of frames whose frame times add up closest to the request. If
            you ask for a non-zero value, you will always get at least one frame in the
            buffer. If you ask for zero, you'll get no buffering at all. To restore the
            buffer length to its default value, pass in a negative number.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "set" calls. *
        """
        return _simbody.SimTKVisualizer_setDesiredBufferLengthInSec(self, bufferLengthInSec)

    def getDesiredBufferLengthInSec(self) -> "SimTK::Real":
        r"""
         Get the current value of the desired buffer time length the Visualizer
        has been asked to use for smoothing the frame rate, or the default value
        if none has been requested. The actual value will differ from this number
        because the buffer must contain an integer number of frames.
        See also: getActualBufferTime() to see the frame-rounded buffer length *
        """
        return _simbody.SimTKVisualizer_getDesiredBufferLengthInSec(self)

    def getActualBufferLengthInSec(self) -> "SimTK::Real":
        r"""
         Get the actual length of the real time frame buffer in seconds, which
        may differ from the requested time because the buffer contains an integer
        number of frames. *
        """
        return _simbody.SimTKVisualizer_getActualBufferLengthInSec(self)

    def getActualBufferLengthInFrames(self) -> "int":
        r""" Get the actual length of the real time frame buffer in number of frames. *"""
        return _simbody.SimTKVisualizer_getActualBufferLengthInFrames(self)

    def addInputListener(self, listener: "SimTKVisualizerInputListener") -> "int":
        r"""
         Add a new input listener to this Visualizer, methods of which will be
        called when the GUI detects user-driven events like key presses, menu picks,
        and slider or mouse moves. See Visualizer::InputListener for more
        information. The Visualizer takes over ownership of the supplied *listener*
        object and deletes it upon destruction of the Visualizer; don't delete it
        yourself.
        :rtype: int
        :return: An integer index you can use to find this input listener again. *
        """
        return _simbody.SimTKVisualizer_addInputListener(self, listener)

    def getNumInputListeners(self) -> "int":
        r""" Return the count of input listeners added with addInputListener(). *"""
        return _simbody.SimTKVisualizer_getNumInputListeners(self)

    def getInputListener(self, i: "int") -> "SimTK::Visualizer::InputListener const &":
        r""" Return a const reference to the i'th input listener. *"""
        return _simbody.SimTKVisualizer_getInputListener(self, i)

    def updInputListener(self, i: "int") -> "SimTK::Visualizer::InputListener &":
        r""" Return a writable reference to the i'th input listener. *"""
        return _simbody.SimTKVisualizer_updInputListener(self, i)

    def addFrameController(self, controller: "SimTK::Visualizer::FrameController *") -> "int":
        r"""
         Add a new frame controller to this Visualizer, methods of which will be
        called just prior to rendering a frame for the purpose of simulation-controlled
        camera positioning and other frame-specific effects.
        See Visualizer::FrameController for more information. The Visualizer takes
        over ownership of the supplied *controller* object and deletes it upon
        destruction of the Visualizer; don't delete it yourself.
        :rtype: int
        :return: An integer index you can use to find this frame controller again. *
        """
        return _simbody.SimTKVisualizer_addFrameController(self, controller)

    def getNumFrameControllers(self) -> "int":
        r""" Return the count of frame controllers added with addFrameController(). *"""
        return _simbody.SimTKVisualizer_getNumFrameControllers(self)

    def getFrameController(self, i: "int") -> "SimTK::Visualizer::FrameController const &":
        r""" Return a const reference to the i'th frame controller. *"""
        return _simbody.SimTKVisualizer_getFrameController(self, i)

    def updFrameController(self, i: "int") -> "SimTK::Visualizer::FrameController &":
        r""" Return a writable reference to the i'th frame controller. *"""
        return _simbody.SimTKVisualizer_updFrameController(self, i)

    def report(self, state: "State") -> "void":
        r"""
        ** Report that a new simulation frame is available for rendering. Depending
        on the current Visualizer::Mode, handling of the frame will vary:

        Title: PassThrough
        All frames will be rendered, but the calling thread (that is, the simulation)
        may be blocked if the next frame time has not yet been reached or if the
        renderer is unable to keep up with the rate at which frames are being supplied
        by the simulation.

        Title: Sampling 
        The frame will be rendered immediately if the next sample time has been reached
        or passed, otherwise the frame will be ignored and report() will return
        immediately.

        Title: RealTime
        Frames are queued to smooth out the time stepper's variable time steps. The
        calling thread may be blocked if the buffer is full, or if the simulation time
        is too far ahead of real time. Frames will be dropped if they come too
        frequently; only the ones whose simulated times are at or near a frame time
        will be rendered. Frames that come too late will be queued for rendering as
        soon as possible, and also reset the expected times for subsequent frames so
        that real time operation is restored. *
        """
        return _simbody.SimTKVisualizer_report(self, state)

    def flushFrames(self) -> "void":
        r"""
         In RealTime mode there will typically be frames still in the buffer at
        the end of a simulation.\ This allows you to wait while the buffer empties.
        When this returns, all frames that had been supplied via report() will have
        been sent to the renderer and the buffer will be empty. Returns immediately
        if not in RealTime mode, if there is no buffer, or if the buffer is already
        empty. *
        """
        return _simbody.SimTKVisualizer_flushFrames(self)

    def drawFrameNow(self, state: "State") -> "void":
        r"""
         This method draws a frame unconditionally without queuing or checking
        the frame rate. Typically you should use the report() method instead, and
        let the the internal queuing and timing system decide when to call
        drawFrameNow(). *
        """
        return _simbody.SimTKVisualizer_drawFrameNow(self, state)

    def addMenu(self, title: "String const &", id: "int", items: "SimTK::Array_< std::pair< String,int > > const &") -> "SimTK::Visualizer &":
        r"""
        * These methods are used to add permanent elements to the scene being displayed
        by the Visualizer. Once added, these elements will contribute to every frame.
        Calling one of these methods requires writable (non-const) access to the
        Visualizer object; you can't call them from within a FrameController object.
        Note that adding DecorationGenerators does allow different
        geometry to be produced for each frame; however, once added a
        DecorationGenerator will be called for *every* frame generated. ** Add a new pull-down menu to the visualizer's display. A label
        for the pull-down button is provided along with an integer identifying the
        particular menu. A list of (string,int) pairs defines the menu and submenu
        item labels and associated item numbers. The item numbers must be unique
        across the entire menu and all its submenus. The strings have a pathname-like
        syntax, like "submenu/item1", "submenu/item2", "submenu/lowermenu/item1", etc.
        that is used to define the pulldown menu layout.
        :type title: String
        :param title:    the title to display on the menu's pulldown button
        :type id: int
        :param id:       an integer value >= 0 that uniquely identifies this menu
        :type items: SimTK::Array_< std::pair< String,int > >
        :param items:    item names, possibly with submenus as specified above, with
                            associated item numbers
            When a user picks an item on a menu displayed in the visualizer, that
            selection is delievered to the simulation application via an InputListener
            associated with this Visualizer. The selection will be identified by
            (*id*, itemNumber) pair.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "add" and
            "set" calls. *
        """
        return _simbody.SimTKVisualizer_addMenu(self, title, id, items)

    def addSlider(self, title: "String const &", id: "int", min: "SimTK::Real", max: "SimTK::Real", value: "SimTK::Real") -> "SimTK::Visualizer &":
        r"""
         Add a new slider to the visualizer's display.
        :type title: String
        :param title:    the title to display next to the slider
        :type id: int
        :param id:       an integer value that uniquely identifies this slider
        :type min: float
        :param min:      the minimum value the slider can have
        :type max: float
        :param max:      the maximum value the slider can have
        :type value: float
        :param value:    the initial value of the slider, which must be between
                            min and max
            When a user moves a slider displayed in the visualizer, the new value
            is delievered to the simulation application via an InputListener associated
            with this Visualizer. The slider will be identified by the *id* supplied
            here.
        :rtype: :py:class:`Visualizer`
        :return: A reference to this Visualizer so that you can chain "add" and
            "set" calls. *
        """
        return _simbody.SimTKVisualizer_addSlider(self, title, id, min, max, value)

    def addDecoration(self, mobodIx: "MobilizedBodyIndex", X_BD: "Transform", geometry: "DecorativeGeometry") -> "int":
        r"""
         Add an always-present, body-fixed piece of geometry like the one passed in,
        but attached to the indicated body. The supplied transform is applied on top of
        whatever transform is already contained in the supplied geometry, and any body
        index stored with the geometry is ignored.
        :rtype: int
        :return: An integer index you can use to find this decoration again. *
        """
        return _simbody.SimTKVisualizer_addDecoration(self, mobodIx, X_BD, geometry)

    def getNumDecorations(self) -> "int":
        r""" Return the count of decorations added with addDecoration(). *"""
        return _simbody.SimTKVisualizer_getNumDecorations(self)

    def getDecoration(self, i: "int") -> "SimTK::DecorativeGeometry const &":
        r""" Return a const reference to the i'th decoration. *"""
        return _simbody.SimTKVisualizer_getDecoration(self, i)

    def updDecoration(self, i: "int") -> "SimTK::DecorativeGeometry &":
        r"""
         Return a writable reference to the i'th decoration. This is allowed for
        a const %Visualizer since it is just a decoration. *
        """
        return _simbody.SimTKVisualizer_updDecoration(self, i)

    def addRubberBandLine(self, b1: "MobilizedBodyIndex", station1: "Vec3", b2: "MobilizedBodyIndex", station2: "Vec3", line: "DecorativeLine") -> "int":
        r"""
         Add an always-present rubber band line, modeled after the DecorativeLine
        supplied here. The end points of the supplied line are ignored, however: at
        run time the spatial locations of the two supplied stations are calculated and
        used as end points.
        :rtype: int
        :return: An integer index you can use to find this rubber band line again. *
        """
        return _simbody.SimTKVisualizer_addRubberBandLine(self, b1, station1, b2, station2, line)

    def getNumRubberBandLines(self) -> "int":
        r""" Return the count of rubber band lines added with addRubberBandLine(). *"""
        return _simbody.SimTKVisualizer_getNumRubberBandLines(self)

    def getRubberBandLine(self, i: "int") -> "SimTK::DecorativeLine const &":
        r""" Return a const reference to the i'th rubber band line. *"""
        return _simbody.SimTKVisualizer_getRubberBandLine(self, i)

    def updRubberBandLine(self, i: "int") -> "SimTK::DecorativeLine &":
        r"""
         Return a writable reference to the i'th rubber band line. This is allowed
        for a const %Visualizer since it is just a decoration. *
        """
        return _simbody.SimTKVisualizer_updRubberBandLine(self, i)

    def addDecorationGenerator(self, generator: "SimTK::DecorationGenerator *") -> "int":
        r"""
         Add a DecorationGenerator that will be invoked to add dynamically generated
        geometry to each frame of the the scene. The Visualizer assumes ownership of the
        object passed to this method, and will delete it when the Visualizer is
        deleted.
        :rtype: int
        :return: An integer index you can use to find this decoration generator
            again. *
        """
        return _simbody.SimTKVisualizer_addDecorationGenerator(self, generator)

    def getNumDecorationGenerators(self) -> "int":
        r"""
         Return the count of decoration generators added with
        addDecorationGenerator(). *
        """
        return _simbody.SimTKVisualizer_getNumDecorationGenerators(self)

    def getDecorationGenerator(self, i: "int") -> "SimTK::DecorationGenerator const &":
        r""" Return a const reference to the i'th decoration generator. *"""
        return _simbody.SimTKVisualizer_getDecorationGenerator(self, i)

    def updDecorationGenerator(self, i: "int") -> "SimTK::DecorationGenerator &":
        r""" Return a writable reference to the i'th decoration generator. *"""
        return _simbody.SimTKVisualizer_updDecorationGenerator(self, i)

    def setCameraTransform(self, X_GC: "Transform") -> "SimTK::Visualizer const &":
        r"""
        ** Set the transform defining the position and orientation of the camera.

        :type X_GC: :py:class:`Transform`, in
        :param X_GC:   This is the transform giving the pose of the camera's
                                frame C in the ground frame G; see below for a precise
                                description.

        Our camera uses a right-handed frame with origin at the image location,
        with axes oriented as follows: the x axis is to the right, the y axis is the
        "up" direction, and the z axis is the "back" direction; that is, the camera is
        looking in the -z direction. If your simulation coordinate system is different,
        such as the common "virtual world" system where ground is the x-y plane
        (x right and y "in") and z is up, be careful to account for that when
        positioning the camera.

        For example, in the virtual world coordinate system, setting *X_GC* to
        identity would put the camera at the ground origin with the x axis as expected,
        but the camera would be looking down (your -z) with the camera's "up" direction
        aligned with your y. In this case to make the camera look in the y direction
        with up in z, you would need to rotate it +90 degrees about the x axis:

        .. code-block:: c++

            Visualizer viz;
            ...

            Point camera along Ground's y axis with z up, by rotating the camera
            frame's z axis to align with Ground's -y.
            viz.setCameraTransform(Rotation(Pi/2, XAxis)); *
        """
        return _simbody.SimTKVisualizer_setCameraTransform(self, X_GC)

    def zoomCameraToShowAllGeometry(self) -> "SimTK::Visualizer const &":
        r"""
         Move the camera forward or backward so that all geometry in the scene is
        visible. *
        """
        return _simbody.SimTKVisualizer_zoomCameraToShowAllGeometry(self)

    def pointCameraAt(self, point: "Vec3", upDirection: "Vec3") -> "SimTK::Visualizer const &":
        r"""
         Rotate the camera so that it looks at a specified point.
        :type point: :py:class:`Vec3`
        :param point:        the point to look at
        :type upDirection: :py:class:`Vec3`
        :param upDirection:  a direction which should point upward as seen by the camera
        """
        return _simbody.SimTKVisualizer_pointCameraAt(self, point, upDirection)

    def setCameraFieldOfView(self, fov: "SimTK::Real") -> "SimTK::Visualizer const &":
        r""" Set the camera's vertical field of view, measured in radians. *"""
        return _simbody.SimTKVisualizer_setCameraFieldOfView(self, fov)

    def setCameraClippingPlanes(self, nearPlane: "SimTK::Real", farPlane: "SimTK::Real") -> "SimTK::Visualizer const &":
        r""" Set the distance from the camera to the near and far clipping planes. *"""
        return _simbody.SimTKVisualizer_setCameraClippingPlanes(self, nearPlane, farPlane)

    def setSliderValue(self, slider: "int", value: "SimTK::Real") -> "SimTK::Visualizer const &":
        r"""
         Change the value currently shown on one of the sliders.
        :type slider: int
        :param slider:       the id given to the slider when created
        :type value: float
        :param value:        a new value for the slider; if out of range it will
                                be at one of the extremes *
        """
        return _simbody.SimTKVisualizer_setSliderValue(self, slider, value)

    def setSliderRange(self, slider: "int", newMin: "SimTK::Real", newMax: "SimTK::Real") -> "SimTK::Visualizer const &":
        r"""
         Change the allowed range for one of the sliders.
        :type slider: int
        :param slider:   the id given to the slider when created
        :type newMin: float
        :param newMin:   the new lower limit on the slider range, <= newMax
        :type newMax: float
        :param newMax:   the new upper limit on the slider range, >= newMin
            The slider's current value remains unchanged if it still fits in the
            new range, otherwise it is moved to the nearest limit. *
        """
        return _simbody.SimTKVisualizer_setSliderRange(self, slider, newMin, newMax)

    def dumpStats(self, o: "std::ostream &") -> "void":
        r"""** Dump statistics to the given ostream (for example, std::cout). *"""
        return _simbody.SimTKVisualizer_dumpStats(self, o)

    def clearStats(self) -> "void":
        r""" Reset all statistics to zero. *"""
        return _simbody.SimTKVisualizer_clearStats(self)

    def getInputListeners(self) -> "SimTK::Array_< SimTK::Visualizer::InputListener * > const &":
        r"""**"""
        return _simbody.SimTKVisualizer_getInputListeners(self)

    def getFrameControllers(self) -> "SimTK::Array_< SimTK::Visualizer::FrameController * > const &":
        return _simbody.SimTKVisualizer_getFrameControllers(self)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        return _simbody.SimTKVisualizer_getSystem(self)

    def getRefCount(self) -> "int":
        return _simbody.SimTKVisualizer_getRefCount(self)

    def setBackgroundTypeByInt(self, index: "int") -> "SimTK::Visualizer const &":
        return _simbody.SimTKVisualizer_setBackgroundTypeByInt(self, index)

# Register SimTKVisualizer in _simbody:
_simbody.SimTKVisualizer_swigregister(SimTKVisualizer)

class SimTKVisualizerInputListener(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ShiftIsDown = _simbody.SimTKVisualizerInputListener_ShiftIsDown
    r""" Shift (left or right)"""
    ControlIsDown = _simbody.SimTKVisualizerInputListener_ControlIsDown
    r""" Ctrl (left or right)"""
    AltIsDown = _simbody.SimTKVisualizerInputListener_AltIsDown
    r""" Alt (left or right)"""
    IsSpecialKey = _simbody.SimTKVisualizerInputListener_IsSpecialKey
    r""" Special non-ASCII keycode being used"""
    SpecialKeyOffset = _simbody.SimTKVisualizerInputListener_SpecialKeyOffset
    KeyControlC = _simbody.SimTKVisualizerInputListener_KeyControlC
    KeyBeep = _simbody.SimTKVisualizerInputListener_KeyBeep
    KeyBackspace = _simbody.SimTKVisualizerInputListener_KeyBackspace
    KeyTab = _simbody.SimTKVisualizerInputListener_KeyTab
    KeyLF = _simbody.SimTKVisualizerInputListener_KeyLF
    KeyReturn = _simbody.SimTKVisualizerInputListener_KeyReturn
    KeyEnter = _simbody.SimTKVisualizerInputListener_KeyEnter
    KeyEsc = _simbody.SimTKVisualizerInputListener_KeyEsc
    KeyDelete = _simbody.SimTKVisualizerInputListener_KeyDelete
    KeyF1 = _simbody.SimTKVisualizerInputListener_KeyF1
    KeyF2 = _simbody.SimTKVisualizerInputListener_KeyF2
    KeyF3 = _simbody.SimTKVisualizerInputListener_KeyF3
    KeyF4 = _simbody.SimTKVisualizerInputListener_KeyF4
    KeyF5 = _simbody.SimTKVisualizerInputListener_KeyF5
    KeyF6 = _simbody.SimTKVisualizerInputListener_KeyF6
    KeyF7 = _simbody.SimTKVisualizerInputListener_KeyF7
    KeyF8 = _simbody.SimTKVisualizerInputListener_KeyF8
    KeyF9 = _simbody.SimTKVisualizerInputListener_KeyF9
    KeyF10 = _simbody.SimTKVisualizerInputListener_KeyF10
    KeyF11 = _simbody.SimTKVisualizerInputListener_KeyF11
    KeyF12 = _simbody.SimTKVisualizerInputListener_KeyF12
    KeyLeftArrow = _simbody.SimTKVisualizerInputListener_KeyLeftArrow
    KeyUpArrow = _simbody.SimTKVisualizerInputListener_KeyUpArrow
    KeyRightArrow = _simbody.SimTKVisualizerInputListener_KeyRightArrow
    KeyDownArrow = _simbody.SimTKVisualizerInputListener_KeyDownArrow
    KeyPageUp = _simbody.SimTKVisualizerInputListener_KeyPageUp
    KeyPageDown = _simbody.SimTKVisualizerInputListener_KeyPageDown
    KeyHome = _simbody.SimTKVisualizerInputListener_KeyHome
    KeyEnd = _simbody.SimTKVisualizerInputListener_KeyEnd
    KeyInsert = _simbody.SimTKVisualizerInputListener_KeyInsert
    __swig_destroy__ = _simbody.delete_SimTKVisualizerInputListener

    def keyPressed(self, key: "unsigned int", modifiers: "unsigned int") -> "bool":
        r"""
         This method is called when a user hits a keyboard key in the Visualizer
        window, unless that key is being intercepted by the Visualizer for its own
        purposes. Ordinary ASCII characters 0-127 are represented by their own values;
        special keys like arrows and function keys are mapped to unique values > 255.
        You can check whether *modifers* & IsSpecialKey is true if you care; otherwise
        just mix the ordinary and special codes in a case statement. You can tell if
        any or all of Shift/Control/Alt were depressed when the key was hit by checking
        the *modifiers*. Note that for an ordinary capital letter you'll get the ASCII
        code for the capital as well as an indication that the Shift key was down. If
        caps lock was down you'll get the capital letter but no Shift modifier.
        :type key: int, in
        :param key:         The ASCII character or special key code.
        :type modifiers: int, in
        :param modifiers:   Whether Shift,Ctrl,Alt are down or key is special.
        :rtype: boolean
        :return: Return ``true`` if you have handled this key press and don't want any
            subsequent listeners called. *
        """
        return _simbody.SimTKVisualizerInputListener_keyPressed(self, key, modifiers)

    def menuSelected(self, menu: "int", item: "int") -> "bool":
        r"""
         The user has clicked one of the menu items you defined; here is
        the integer value you specified when you defined it.
        :type menu: int, in
        :param menu:        The id number of the menu in use.
        :type item: int, in
        :param item:        The menu item number that the user selected.
        :rtype: boolean
        :return: Return ``true`` if you have handled this menu click and don't
            want any subsequent listeners called. *
        """
        return _simbody.SimTKVisualizerInputListener_menuSelected(self, menu, item)

    def sliderMoved(self, slider: "int", value: "SimTK::Real") -> "bool":
        r"""
         The user has moved one of the sliders you defined; here is the integer
        value you specified when you defined it, and the new value of the slider.
        :type slider: int, in
        :param slider:      The id number of the slider that moved.
        :type value: float, in
        :param value:       The new value represented by this slider position.
        :rtype: boolean
        :return: Return ``true`` if you have handled this move and don't want any
            subsequent listeners called. *
        """
        return _simbody.SimTKVisualizerInputListener_sliderMoved(self, slider, value)

    def __init__(self):
        _simbody.SimTKVisualizerInputListener_swiginit(self, _simbody.new_SimTKVisualizerInputListener())

# Register SimTKVisualizerInputListener in _simbody:
_simbody.SimTKVisualizerInputListener_swigregister(SimTKVisualizerInputListener)

class SimTKVisualizerInputSilo(SimTKVisualizerInputListener):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Default construction is all that is needed; there are no options. *"""
        _simbody.SimTKVisualizerInputSilo_swiginit(self, _simbody.new_SimTKVisualizerInputSilo())
    __swig_destroy__ = _simbody.delete_SimTKVisualizerInputSilo

    def isAnyUserInput(self) -> "bool":
        r"""
         This is a very fast test that does not require locking; you don't have to
        use this but it is a good idea to do so. *
        """
        return _simbody.SimTKVisualizerInputSilo_isAnyUserInput(self)

    def waitForAnyUserInput(self) -> "void":
        r"""
         This will wait quietly until the user has provided some input to the
        visualizer.\ Any kind of input will terminate the wait; you'll have
        to look to see what it was. *
        """
        return _simbody.SimTKVisualizerInputSilo_waitForAnyUserInput(self)

    def takeKeyHit(self, key: "unsigned int &", modifiers: "unsigned int &") -> "bool":
        r"""
         This will return user key hits until they have all been consumed, in the
        same order they were received. The *key* and *modifiers* values are those that
        were provided to our implementation of the InputListener::keyPressed() method.
        :type key: int, out
        :param key:
                The key code for the key that was hit. See InputListener::KeyCode for
                interpretation.
        :type modifiers: int, out
        :param modifiers:
                Status of Shift,Ctrl,Alt and "special" key code. See InputListener::Modifier
                for interpretation.
        :rtype: boolean
        :return: ``true`` if a key and modifiers have been returned; ``false`` if the
                character silo is now empty in which case both *key* and *modifiers* will
                be set to zero. *
        """
        return _simbody.SimTKVisualizerInputSilo_takeKeyHit(self, key, modifiers)

    def waitForKeyHit(self, key: "unsigned int &", modifiers: "unsigned int &") -> "void":
        r"""
         Same as takeKeyHit() except that if there is no key hit input available
        it waits until there is, then returns the first one (which is removed from
        the silo just as takeKeyHit() would do. The behavior is like calling
        waitForAnyUserInput() repeatedly until takeKeyHit() returns ``true``.
        See also: takeKeyHit(), waitForAnyUserInput() *
        """
        return _simbody.SimTKVisualizerInputSilo_waitForKeyHit(self, key, modifiers)

    def takeMenuPick(self, menu: "int &", item: "int &") -> "bool":
        r"""
         This will return user menu picks until they have all been consumed, in the
        same order they were received. The *item* value returned is the value that was
        provided to our implementation of the InputListener::menuSelected() method.
        :type menu: int, out
        :param menu:
                The id number of the menu that was selected. This is the value that was
                assigned to this menu in the Visualizer::addMenu() call.
        :type item: int, out
        :param item:
                The menu item number for the entry that the user selected. This is the
                number that was assigned at the time the menu was added via the
                Visualizer::addMenu() method.
        :rtype: boolean
        :return: ``true`` if a menu item number has been returned; ``false`` if the menu
                pick silo is now empty in which case *item* will be set to zero. *
        """
        return _simbody.SimTKVisualizerInputSilo_takeMenuPick(self, menu, item)

    def waitForMenuPick(self, menu: "int &", item: "int &") -> "void":
        r"""
         Same as takeMenuPick() except that if there is no menu pick input available
        it waits until there is, then returns the first one (which is removed from
        the silo just as takeMenuPick() would do. The behavior is like calling
        waitForAnyUserInput() repeatedly until takeMenuPick() returns ``true``.
        See also: takeMenuPick(), waitForAnyUserInput() *
        """
        return _simbody.SimTKVisualizerInputSilo_waitForMenuPick(self, menu, item)

    def takeSliderMove(self, slider: "int &", value: "SimTK::Real &") -> "bool":
        r"""
         This will return user changes to slider positions until they have all been
        consumed, in the same order they were received. The *slider* and *value*
        returns are those that were provided to our implementation of the
        InputListener::sliderMoved() method.
        :type slider: int, out
        :param slider:
                The id number of the slider that was moved. This is the value that was
                assigned to this slider in the Visualizer::addSlider() call.
        :type value: float, out
        :param value:
                This is the new value associated with the slider position to which the user
                moved it.
        :rtype: boolean
        :return: ``true`` if a slider move has been returned; ``false`` if the slider move
                silo is now empty in which case *which* will be set to zero and *value*
                will be NaN. *
        """
        return _simbody.SimTKVisualizerInputSilo_takeSliderMove(self, slider, value)

    def waitForSliderMove(self, slider: "int &", value: "SimTK::Real &") -> "void":
        r"""
         Same as takeSliderMove() except that if there is no slider move input
        available it waits until there is, then returns the first one (which is removed
        from the silo just as takeSliderMove() would do. The behavior is like calling
        waitForAnyUserInput() repeatedly until takeSliderMove() returns ``true``.
        See also: takeSliderMove(), waitForAnyUserInput() *
        """
        return _simbody.SimTKVisualizerInputSilo_waitForSliderMove(self, slider, value)

    def clear(self) -> "void":
        r""" Throw away any pending unprocessed input of all types. *"""
        return _simbody.SimTKVisualizerInputSilo_clear(self)

    def takeKeyHitKeyOnly(self) -> "unsigned int":
        return _simbody.SimTKVisualizerInputSilo_takeKeyHitKeyOnly(self)

# Register SimTKVisualizerInputSilo in _simbody:
_simbody.SimTKVisualizerInputSilo_swigregister(SimTKVisualizerInputSilo)



