# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _common
else:
    import _common

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _common.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _common.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _common.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _common.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _common.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _common.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _common.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _common.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _common.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _common.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _common.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _common.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _common.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _common.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _common.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _common.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _common:
_common.SwigPyIterator_swigregister(SwigPyIterator)

import opensim.simbody

def opensim_version_common(major: "int *", minor: "int *", build: "int *") -> "void":
    return _common.opensim_version_common(major, minor, build)

def opensim_about_common(key: "char const *", maxlen: "int", value: "char *") -> "void":
    return _common.opensim_about_common(key, maxlen, value)

def GetVersionAndDate() -> "std::string":
    return _common.GetVersionAndDate()

def GetVersion() -> "std::string":
    return _common.GetVersion()

def GetOSInfoVerbose() -> "std::string":
    return _common.GetOSInfoVerbose()

def GetOSInfo() -> "std::string":
    return _common.GetOSInfo()

def GetCompilerVersion() -> "std::string":
    return _common.GetCompilerVersion()
class OpenSimException(object):
    r"""
     This macro checks the given condition and throws the given exception if the
    condition is true. Here's an example that throws an exception if some result is
    incorrect, and passes `result` and `5` to the constructor of the
    `ResultIsIncorrect` exception:

    .. code-block:: c++

        auto result = getSomeResult();
        OPENSIM_THROW_IF(result != 5, ResultIsIncorrect, result, 5);
                                                        Macro to throw from within an Object. This macro picks up implicit pointer
    to the object and uses it to print information.                                Macro to throw from within an Object if a condition evaluates to TRUE. This
    macro picks up implicit pointer to the object and uses it to print
    information.
    A class for basic exception functionality.
    If: developer {
    To create exception classes in OpenSim, use the following guidelines.
    If the intention is to derive from an exception named, for example,
    BaseException that is part of OpenSim, use the following blueprint:

    .. code-block:: c++

            class MyNewException : public BaseException {
            public:
                MyNewException(const std::string& file,
                               size_t line,
                               const std::string& func,
                               <more parameters as appropriate>) :
                BaseException(file, line, func) {
                    std::string message = <create the desired message>;
                    addMessage(message);
                }
            };
    Exception class manages the concatenation of error messages from all the
    derived classes. When creating new exceptions, remember to call addMessage()
    as shown above if the exception class does have any error message.
    }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        This constructor is for backward compatibility. Use the constructor
           taking file, line, func.

        |

        *Overload 2:*
        Call this constructor from derived classes to add file, line and
           function information to the error message. Use this when throwing
           Derived classes. Use OPENSIM_THROW_<> macros at throw sites.

        |

        *Overload 3:*
        Use this when you want to throw an Exception (with OPENSIM_THROW or
           OPENSIM_THROW_IF) and also provide a message.

        |

        *Overload 4:*
        The message created by this constructor will contain the class name and
           instance name of the provided Object. Use this when throwing derived
           classes. Use OPENSIM_THROW_<> macros at throw sites.

        |

        *Overload 5:*
        The message created by this constructor will contain the class name and
           instance name of the provided Object, and also accepts a message. Use this
           when throwing Exception directly. Use OPENSIM_THROW_<> macros at throw
           sites.
        """
        _common.OpenSimException_swiginit(self, _common.new_OpenSimException(*args))
    __swig_destroy__ = _common.delete_OpenSimException

    def setMessage(self, aMsg: "std::string const &") -> "void":
        return _common.OpenSimException_setMessage(self, aMsg)

    def getMessage(self) -> "char const *":
        return _common.OpenSimException_getMessage(self)

    def what(self) -> "char const *":
        return _common.OpenSimException_what(self)

# Register OpenSimException in _common:
_common.OpenSimException_swigregister(OpenSimException)

class InvalidArgument(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.InvalidArgument_swiginit(self, _common.new_InvalidArgument(*args))
    __swig_destroy__ = _common.delete_InvalidArgument

# Register InvalidArgument in _common:
_common.InvalidArgument_swigregister(InvalidArgument)

class InvalidCall(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.InvalidCall_swiginit(self, _common.new_InvalidCall(*args))
    __swig_destroy__ = _common.delete_InvalidCall

# Register InvalidCall in _common:
_common.InvalidCall_swigregister(InvalidCall)

class InvalidTemplateArgument(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", msg: "std::string const &"):
        _common.InvalidTemplateArgument_swiginit(self, _common.new_InvalidTemplateArgument(file, line, func, msg))
    __swig_destroy__ = _common.delete_InvalidTemplateArgument

# Register InvalidTemplateArgument in _common:
_common.InvalidTemplateArgument_swigregister(InvalidTemplateArgument)

class IndexOutOfRange(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", index: "size_t", min: "size_t", max: "size_t"):
        _common.IndexOutOfRange_swiginit(self, _common.new_IndexOutOfRange(file, line, func, index, min, max))
    __swig_destroy__ = _common.delete_IndexOutOfRange

# Register IndexOutOfRange in _common:
_common.IndexOutOfRange_swigregister(IndexOutOfRange)

class KeyNotFound(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.KeyNotFound_swiginit(self, _common.new_KeyNotFound(file, line, func, key))
    __swig_destroy__ = _common.delete_KeyNotFound

# Register KeyNotFound in _common:
_common.KeyNotFound_swigregister(KeyNotFound)

class IOError(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.IOError_swiginit(self, _common.new_IOError())
    __swig_destroy__ = _common.delete_IOError

# Register IOError in _common:
_common.IOError_swigregister(IOError)

class ComponentNotFound(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", toFindName: "std::string const &", toFindClassName: "std::string const &", thisName: "std::string const &"):
        _common.ComponentNotFound_swiginit(self, _common.new_ComponentNotFound(file, line, func, toFindName, toFindClassName, thisName))
    __swig_destroy__ = _common.delete_ComponentNotFound

# Register ComponentNotFound in _common:
_common.ComponentNotFound_swigregister(ComponentNotFound)

class NonUniqueLabels(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.NonUniqueLabels_swiginit(self, _common.new_NonUniqueLabels())
    __swig_destroy__ = _common.delete_NonUniqueLabels

# Register NonUniqueLabels in _common:
_common.NonUniqueLabels_swigregister(NonUniqueLabels)


def getFormattedDateTime(*args) -> "std::string":
    r"""
    Get a string with the current date and time formatted as %Y-%m-%dT%H%M%S
    (year, month, day, "T", hour, minute, second). You can change the datetime
    format via the `format` parameter.
    If you specify "ISO", then we use the ISO 8601 extended datetime format
    %Y-%m-%dT%H:%M:%S.
    See https://en.cppreference.com/w/cpp/io/manip/put_time.
    """
    return _common.getFormattedDateTime(*args)
class FileRemover(object):
    r"""
    When an instance of this class is destructed, it removes (deletes)
    the file at the path provided in the constructor. You can also manually
    cause removal of the file by invoking `remove()`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, filepath: "std::string"):
        _common.FileRemover_swiginit(self, _common.new_FileRemover(filepath))

    def remove(self) -> "void":
        r""" Remove the file at the path provided in the constructor."""
        return _common.FileRemover_remove(self)
    __swig_destroy__ = _common.delete_FileRemover

# Register FileRemover in _common:
_common.FileRemover_swigregister(FileRemover)


def createVectorLinspace(length: "int", start: "double", end: "double") -> "SimTK::Vector":
    r"""
    Create a SimTK::Vector with the provided length whose elements are
    uniformly spaced between start and end (same as Matlab's linspace()).
    """
    return _common.createVectorLinspace(length, start, end)

def interpolate(x: "Vector", y: "Vector", newX: "Vector", ignoreNaNs: "bool const"=False) -> "SimTK::Vector":
    r"""
    Linearly interpolate y(x) at new values of x. The optional 'ignoreNaNs'
    argument will ignore any NaN values contained in the input vectors and
    create the interpolant from the non-NaN values only. Note that this option
    does not necessarily prevent NaN values from being returned in 'newX', which
    will have NaN for any values of newX outside of the range of x.
    :raises: Exception if x and y are different sizes, or x or y is empty.
    """
    return _common.interpolate(x, y, newX, ignoreNaNs)

def convertRelativeFilePathToAbsoluteFromXMLDocument(documentFileName: "std::string const &", filePathRelativeToDirectoryContainingDocument: "std::string const &") -> "std::string":
    r"""
    An OpenSim XML file may contain file paths that are relative to the
    directory containing the XML file; use this function to convert that
    relative path into an absolute path.
    """
    return _common.convertRelativeFilePathToAbsoluteFromXMLDocument(documentFileName, filePathRelativeToDirectoryContainingDocument)

def solveBisection(calcResidual: "std::function< double (double const &) >", left: "double", right: "double", tolerance: "double const &"=1e-6, maxIterations: "int"=1000) -> "SimTK::Real":
    r"""
    Solve for the root of a scalar function using the bisection method.
    If the values of calcResidual(left) and calcResidual(right) have the same
    sign and the logger level is Debug (or more verbose), then this function
    writes a file `solveBisection_residual_<timestamp>.sto` containing the
    residual function.
    :type calcResidual: std::function< double (double const &) >
    :param calcResidual: a function that computes the error
    :type left: float
    :param left: lower bound on the root
    :type right: float
    :param right: upper bound on the root
    :type tolerance: float, optional
    :param tolerance: convergence requires that the bisection's "left" and
            "right" are less than tolerance apart.
    :type maxIterations: int, optional
    :param maxIterations: abort after this many iterations.
    """
    return _common.solveBisection(calcResidual, left, right, tolerance, maxIterations)
class LogSink(object):
    r"""
    Derive from this class to implement your own way of reporting logged
    messages.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_LogSink

    def sinkImpl(self, msg: "std::string const &") -> "void":
        r"""
        This function is invoked whenever a message is logged at the desired
        Log::Level.
        """
        return _common.LogSink_sinkImpl(self, msg)

    def flushImpl(self) -> "void":
        return _common.LogSink_flushImpl(self)

    def __init__(self):
        if self.__class__ == LogSink:
            _self = None
        else:
            _self = self
        _common.LogSink_swiginit(self, _common.new_LogSink(_self, ))
    def __disown__(self):
        self.this.disown()
        _common.disown_LogSink(self)
        return weakref.proxy(self)

# Register LogSink in _common:
_common.LogSink_swigregister(LogSink)

class StringLogSink(LogSink):
    r"""
    This sink stores all messages in a string. This is useful for testing the
    content of logs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clear(self) -> "void":
        r""" Clear the contents of the string."""
        return _common.StringLogSink_clear(self)

    def getString(self) -> "std::string const &":
        r""" Obtain the string."""
        return _common.StringLogSink_getString(self)

    def __init__(self):
        _common.StringLogSink_swiginit(self, _common.new_StringLogSink())
    __swig_destroy__ = _common.delete_StringLogSink

# Register StringLogSink in _common:
_common.StringLogSink_swigregister(StringLogSink)

class Logger(object):
    r"""
    This is a singleton class (single instance) for logging messages and
    controlling how those messages are presented to the user.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Level_Off = _common.Logger_Level_Off
    r"""
    Do not log any messages. Useful when running an optimization or
    automated pipeline.
    """
    Level_Critical = _common.Logger_Level_Critical
    r""" Only log critical errors."""
    Level_Error = _common.Logger_Level_Error
    r""" Log all messages that require user intervention."""
    Level_Warn = _common.Logger_Level_Warn
    r"""
    Log warnings. Warnings are generated when the software will proceed
    but the user should check their input.
    """
    Level_Info = _common.Logger_Level_Info
    r""" Default."""
    Level_Debug = _common.Logger_Level_Debug
    r"""
    Log information that may be useful when debugging the operation of
    the
    software to investigate unexpected results.
    """
    Level_Trace = _common.Logger_Level_Trace
    r"""
    Log as much as possible, including messages that describe the
    software's
    behavior step by step. Note: OpenSim has very few Trace-level
    messages.
    """

    @staticmethod
    def setLevel(level: "OpenSim::Logger::Level") -> "void":
        r"""
        Log messages of importance `level` and greater.
        For example, if the level is set to Info, then Critical, Error, Warn,
        and Info messages are logged, while Debug and Trace messages are not
        logged.
        """
        return _common.Logger_setLevel(level)

    @staticmethod
    def getLevel() -> "OpenSim::Logger::Level":
        return _common.Logger_getLevel()

    @staticmethod
    def setLevelString(level: "std::string") -> "void":
        r"""
        Set the logging level using one of the following strings
        (case-insensitive):
        - Off
        - Critical
        - Error
        - Warn
        - Info
        - Debug
        - Trace
        This variant of setLevel() is for use in Matlab.
        See also: Level.
        """
        return _common.Logger_setLevelString(level)

    @staticmethod
    def getLevelString() -> "std::string":
        return _common.Logger_getLevelString()

    @staticmethod
    def shouldLog(level: "OpenSim::Logger::Level") -> "bool":
        r"""
        Returns true if messages at the provided level should be logged,
        based on the set logging level. The following code will produce output:

        .. code-block:: c++

            Log::setLevel(Log::Level::Warn);
            if (shouldLog(Log::Level::Error)) {
                std::cout << "Error encountered." << std::endl;
            }
        """
        return _common.Logger_shouldLog(level)

    @staticmethod
    def addFileSink(*args) -> "void":
        r"""
        Log messages to a file at the level getLevel().
        OpenSim logs messages to the file opensim.log by default.
        If we are already logging messages to a file, then this
        function issues a warning and returns; invoke removeFileSink() first.
        Notes: This function is not thread-safe. Do not invoke this function
        concurrently, or concurrently with addSink() or removeSink().
        If filepath can't be opened, no log file is created.
        """
        return _common.Logger_addFileSink(*args)

    @staticmethod
    def removeFileSink() -> "void":
        r"""
        Remove the filesink if it exists.
        If the filesink was already removed, then this does nothing.
        Notes: This function is not thread-safe. Do not invoke this function
        concurrently, or concurrently with addSink() or removeSink().
        """
        return _common.Logger_removeFileSink()

    @staticmethod
    def addSink(sink: "std::shared_ptr< OpenSim::LogSink > const") -> "void":
        r"""
        Start reporting messages to the provided sink.
        Notes: This function is not thread-safe. Do not invoke this function
        concurrently, or concurrently with addLogFile() or removeSink().
        """
        return _common.Logger_addSink(sink)

    @staticmethod
    def removeSink(sink: "std::shared_ptr< OpenSim::LogSink > const") -> "void":
        r"""
        Remove a sink. If it doesn't exist, do nothing.
        Notes: This function is not thread-safe. Do not invoke this function
        concurrently, or concurrently with addLogFile() or addSink().
        """
        return _common.Logger_removeSink(sink)
    __swig_destroy__ = _common.delete_Logger

# Register Logger in _common:
_common.Logger_swigregister(Logger)

def Logger_setLevel(level: "OpenSim::Logger::Level") -> "void":
    r"""
    Log messages of importance `level` and greater.
    For example, if the level is set to Info, then Critical, Error, Warn,
    and Info messages are logged, while Debug and Trace messages are not
    logged.
    """
    return _common.Logger_setLevel(level)

def Logger_getLevel() -> "OpenSim::Logger::Level":
    return _common.Logger_getLevel()

def Logger_setLevelString(level: "std::string") -> "void":
    r"""
    Set the logging level using one of the following strings
    (case-insensitive):
    - Off
    - Critical
    - Error
    - Warn
    - Info
    - Debug
    - Trace
    This variant of setLevel() is for use in Matlab.
    See also: Level.
    """
    return _common.Logger_setLevelString(level)

def Logger_getLevelString() -> "std::string":
    return _common.Logger_getLevelString()

def Logger_shouldLog(level: "OpenSim::Logger::Level") -> "bool":
    r"""
    Returns true if messages at the provided level should be logged,
    based on the set logging level. The following code will produce output:

    .. code-block:: c++

        Log::setLevel(Log::Level::Warn);
        if (shouldLog(Log::Level::Error)) {
            std::cout << "Error encountered." << std::endl;
        }
    """
    return _common.Logger_shouldLog(level)

def Logger_addFileSink(*args) -> "void":
    r"""
    Log messages to a file at the level getLevel().
    OpenSim logs messages to the file opensim.log by default.
    If we are already logging messages to a file, then this
    function issues a warning and returns; invoke removeFileSink() first.
    Notes: This function is not thread-safe. Do not invoke this function
    concurrently, or concurrently with addSink() or removeSink().
    If filepath can't be opened, no log file is created.
    """
    return _common.Logger_addFileSink(*args)

def Logger_removeFileSink() -> "void":
    r"""
    Remove the filesink if it exists.
    If the filesink was already removed, then this does nothing.
    Notes: This function is not thread-safe. Do not invoke this function
    concurrently, or concurrently with addSink() or removeSink().
    """
    return _common.Logger_removeFileSink()

def Logger_addSink(sink: "std::shared_ptr< OpenSim::LogSink > const") -> "void":
    r"""
    Start reporting messages to the provided sink.
    Notes: This function is not thread-safe. Do not invoke this function
    concurrently, or concurrently with addLogFile() or removeSink().
    """
    return _common.Logger_addSink(sink)

def Logger_removeSink(sink: "std::shared_ptr< OpenSim::LogSink > const") -> "void":
    r"""
    Remove a sink. If it doesn't exist, do nothing.
    Notes: This function is not thread-safe. Do not invoke this function
    concurrently, or concurrently with addLogFile() or addSink().
    """
    return _common.Logger_removeSink(sink)

class InvalidPropertyValue(OpenSimException):
    r""" Property Exceptions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", propertyName: "std::string const &", errorMsg: "std::string const &"):
        _common.InvalidPropertyValue_swiginit(self, _common.new_InvalidPropertyValue(file, line, func, obj, propertyName, errorMsg))
    __swig_destroy__ = _common.delete_InvalidPropertyValue

# Register InvalidPropertyValue in _common:
_common.InvalidPropertyValue_swigregister(InvalidPropertyValue)
cvar = _common.cvar
Array_CAPMIN = cvar.Array_CAPMIN

class AbstractProperty(object):
    r"""
     An abstract property is a serializable (name,value) pair, for which we
    do not know the type of the value. Values may be simple types like int or
    string, or may be serializable objects derived from the %OpenSim Object class.

    %AbstractProperty is an abstract base class that provides the functionality
    common to all properties that does not involve knowledge of the value
    type. Property<T> derives from %AbstractProperty to represent properties
    where the type is known.

    See also: Property, Object

    Author: Cassidy Kelly, Ajay Seth, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setAllowableListSize(self, *args) -> "void":
        r"""
        *Overload 1:*
        Require that the number of values n in the value list of this property
           be in the range aMin <= n <= aMax.

        |

        *Overload 2:*
        Require that the number of values n in the value list of this property
           be exactly n=aNum values. *
        """
        return _common.AbstractProperty_setAllowableListSize(self, *args)
    __swig_destroy__ = _common.delete_AbstractProperty

    def clone(self) -> "OpenSim::AbstractProperty *":
        r"""
        Return a new instance of this concrete property object, containing
           new copies of this property's values. The new property object is
           allocated on the heap and it is up to the caller to delete it when done. *
        """
        return _common.AbstractProperty_clone(self)

    def toString(self) -> "std::string":
        r"""
        For relatively simple types, return the current value of this property
           in a string suitable for displaying to a user in the GUI (i.e., this number
           may be rounded and not an exact representation of the actual value being
           used). Objects just return something like "(Object)".
           For `Property`s, This function calls `toStringForDisplay()` with
           `precision = 6`.*
        """
        return _common.AbstractProperty_toString(self)

    def toStringForDisplay(self, precision: "int const") -> "std::string":
        r"""
        For relatively simple types, return the current value of this property
           in a string suitable for displaying to a user in the GUI (i.e., this number
           may be rounded and not an exact representation of the actual value being
           used). Objects just return something like "(Object)". This differs from
           `toString()` as it has an argument, `precision`, for controlling the number
           of digits printed to string for floats. If this function is not overridden
           in a derived class, this function uses `toString()` and the `precision`
           argument is ignored.
           For `Property`s, in general, this means that floats will
           be represented with the number of significant digits denoted by the
           `precision` argument, and the default formatting of `stringstream`
           determines whether or not exponential notation is used. *
        """
        return _common.AbstractProperty_toStringForDisplay(self, precision)

    def getTypeName(self) -> "std::string":
        r"""
        This returns a string representation of this property's value type
           which will be the same as T::getClassName() for Object-derived types T, and
           some reasonably nice name for simple types, including at least "bool",
           "int", "double", "string", "Vec3", "Vector", and "Transform". *
        """
        return _common.AbstractProperty_getTypeName(self)

    def isObjectProperty(self) -> "bool":
        r"""
        Return true if this is an "object property", meaning that its values
           are all concrete objects of types that ultimately derive from the %OpenSim
           serializable base class Object. If this returns true then it is safe to
           call getValueAsObject(). Otherwise this property contains only simple types
           like "int" or "std::string", and you'll need to know the actual type in
           order to access the values. *
        """
        return _common.AbstractProperty_isObjectProperty(self)

    def isUnnamedProperty(self) -> "bool":
        r"""
        An unnamed property is a one-object property whose name was given as
           null or as the contained object's type tag. In that case getName() will
           return the object type tag, and the XML representation will just be the
           object, with name attribute ignored if there is one. *
        """
        return _common.AbstractProperty_isUnnamedProperty(self)

    def equals(self, other: "AbstractProperty") -> "bool":
        r"""
        Compare this property with another one; this is primarily used
           for testing. The properties must be of the identical concrete type, and
           their names and other base class attributes must
           be identical (including the comment). If they both have the "use default"
           flag set then we consider the values identical without looking. Otherwise,
           we delegate to the concrete property to determine if the values are equal;
           the meaning is determined by the concrete property depending on its type.
           Floating point values should be compared to a tolerance, and should be
           considered equal if both are the same infinity or both are NaN (the latter
           in contrast to normal IEEE floating point behavior, where NaN!=NaN). *
        """
        return _common.AbstractProperty_equals(self, other)

    def isSamePropertyClass(self, other: "AbstractProperty") -> "bool":
        r"""
        Return true if the *other* property is an object of exactly the same
           concrete class as this one. *
        """
        return _common.AbstractProperty_isSamePropertyClass(self, other)

    def size(self) -> "int":
        r"""
        A property can be viewed as a random-access container of values. These
        methods provide a subset of the usual container methods modeled after
        std::vector. Note that any methods involving the actual property value type
        T must be templatized; they will be delegated to the concrete Property<T>
        for resolution. ** Return the number of values currently in this property's value list. *
        """
        return _common.AbstractProperty_size(self)

    def empty(self) -> "bool":
        r""" Return true if this property's value list is currently empty. *"""
        return _common.AbstractProperty_empty(self)

    def clear(self) -> "void":
        r"""
        Empty the value list for this property; fails if zero is not an
           allowable size for this property. *
        """
        return _common.AbstractProperty_clear(self)

    def getValueAsObject(self, index: "int"=-1) -> "OpenSim::Object const &":
        r"""
        For an object property, the values can be obtained as references to
           the abstract base class Object from which all the objects derive. If the
           property can hold a list of values you must provide an index to select
           the value, otherwise it is optional but if supplied must be 0. This will
           throw an exception if this is not an object property, that is, if it is
           a simple property, because its values can't be represented as an Object in
           that case.

           :type index: int, in, optional
           :param index:    If supplied must be 0 <= index < getNumValues().
           :rtype: :py:class:`Object`
           :return: const reference to the value as an Object
           See also: updValueAsObject(), getValue<T>() *
        """
        return _common.AbstractProperty_getValueAsObject(self, index)

    def updValueAsObject(self, index: "int"=-1) -> "OpenSim::Object &":
        r"""
        Get writable access to an existing object value. Note that you can't
           use this to install a different concrete object; see setValueAsObject()
           if you want to do that.
           :type index: int, in, optional
           :param index:    If supplied must be 0 <= index < getNumValues().
           :rtype: :py:class:`Object`
           :return: writable reference to the value as an Object
           See also: getValueAsObject(), updValue<T>() *
        """
        return _common.AbstractProperty_updValueAsObject(self, index)

    def setValueAsObject(self, obj: "OpenSimObject", index: "int"=-1) -> "void":
        r"""
        %Set the indicated value element to a new copy of the supplied object.
           If you already have a heap-allocated object you're willing to give up and
           want to avoid the extra copy, use adoptValueObject(). *
        """
        return _common.AbstractProperty_setValueAsObject(self, obj, index)

    def assign(self, that: "AbstractProperty") -> "void":
        r""" Assign (copy) property *that* to this object."""
        return _common.AbstractProperty_assign(self, that)

    def setAllPropertiesUseDefault(self, shouldUseDefault: "bool") -> "void":
        r"""
        * This method sets the "use default" flag for this property and the
            properties of any objects it contains to the given value. *
        """
        return _common.AbstractProperty_setAllPropertiesUseDefault(self, shouldUseDefault)

    def readFromXMLParentElement(self, parent: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        r"""
        Given an XML parent element expected to contain a value for this
           property as an immediate child element, find that property element and set
           the property value from it. If no such property element can be found, the
           "use default value" attribute of this property will be set on return; that
           is not an error. However, if the property element is found but is
           malformed or unsuitable in some way, an exception will be thrown with
           a message explaining what is wrong. *
        """
        return _common.AbstractProperty_readFromXMLParentElement(self, parent, versionNumber)

    def writeToXMLParentElement(self, parent: "SimTK::Xml::Element &") -> "void":
        r"""
        Given an XML parent element, append a single child element representing
           the serialized form of this property. *
        """
        return _common.AbstractProperty_writeToXMLParentElement(self, parent)

    def setName(self, name: "std::string const &") -> "void":
        r""" %Set the property name. *"""
        return _common.AbstractProperty_setName(self, name)

    def setComment(self, aComment: "std::string const &") -> "void":
        r"""
        %Set a user-friendly comment to be associated with property. This will
           be displayed in XML and in "help" output for %OpenSim Objects. *
        """
        return _common.AbstractProperty_setComment(self, aComment)

    def setValueIsDefault(self, isDefault: "bool") -> "void":
        r"""
        %Set flag indicating whether the value of this property was simply
           taken from a default object and thus should not be written out when
           serializing. *
        """
        return _common.AbstractProperty_setValueIsDefault(self, isDefault)

    def getName(self) -> "std::string const &":
        r""" Get the property name. *"""
        return _common.AbstractProperty_getName(self)

    def getComment(self) -> "std::string const &":
        r""" Get the comment associated with this property. *"""
        return _common.AbstractProperty_getComment(self)

    def getValueIsDefault(self) -> "bool":
        r"""
        Get the flag indicating whether the current value is just the default
           value for this property (in which case it doesn't need to be written
           out). *
        """
        return _common.AbstractProperty_getValueIsDefault(self)

    def getMinListSize(self) -> "int":
        r"""
        Get the minimum number of values allowed in this property's value
           list. Will be zero for optional properties, zero for list properties
           (unless explicitly changed), and one for one-value properties. *
        """
        return _common.AbstractProperty_getMinListSize(self)

    def getMaxListSize(self) -> "int":
        r"""
        Get the maximum number of values allowed in this property's value
           list. Will be unlimited for list properties (unless explicitly changed),
           and one for optional and one-value properties. *
        """
        return _common.AbstractProperty_getMaxListSize(self)

    def isOptionalProperty(self) -> "bool":
        r"""
        This is an "optional" property if its value list can contain at most
           one value. This is the kind of property created by the
           Object::addOptionalProperty<T> method, for any type T. *
        """
        return _common.AbstractProperty_isOptionalProperty(self)

    def isListProperty(self) -> "bool":
        r"""
        This is a "list" property if its value list can contain more than
           one value. This is the kind of property created by the
           Object::addListProperty<T> method, for any type T. *
        """
        return _common.AbstractProperty_isListProperty(self)

    def isOneValueProperty(self) -> "bool":
        r"""
        This is a "one-value" property if its value list must always contain
           exactly one value. This is the kind of property created by the
           Object::addProperty<T> method, for any type T. *
        """
        return _common.AbstractProperty_isOneValueProperty(self)

    def isOneObjectProperty(self) -> "bool":
        r"""
        This is a "one-object" property if it is a "one-value" property and
           it contains an Object-derived value. This is the kind of property created
           by the Object::addProperty<T> method when T is a type derived from
           %OpenSim's Object serializable base class. One-object properties have
           a special, compact representation in XML. *
        """
        return _common.AbstractProperty_isOneObjectProperty(self)

# Register AbstractProperty in _common:
_common.AbstractProperty_swigregister(AbstractProperty)

class PropertyGroup(object):
    r"""
    A class implementing a property group.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.PropertyGroup_swiginit(self, _common.new_PropertyGroup(*args))
    __swig_destroy__ = _common.delete_PropertyGroup

    def clone(self) -> "OpenSim::PropertyGroup *":
        return _common.PropertyGroup_clone(self)

    def copyData(self, aGroup: "PropertyGroup") -> "void":
        return _common.PropertyGroup_copyData(self, aGroup)

    def clear(self) -> "void":
        return _common.PropertyGroup_clear(self)

    def contains(self, aName: "std::string const &") -> "bool":
        return _common.PropertyGroup_contains(self, aName)

    def add(self, aProperty: "Property_Deprecated *") -> "void":
        return _common.PropertyGroup_add(self, aProperty)

    def remove(self, aProperty: "Property_Deprecated *") -> "void":
        return _common.PropertyGroup_remove(self, aProperty)

    def get(self, aIndex: "int") -> "Property_Deprecated *":
        return _common.PropertyGroup_get(self, aIndex)

    def getPropertyIndex(self, aProperty: "Property_Deprecated *") -> "int":
        return _common.PropertyGroup_getPropertyIndex(self, aProperty)

    def setName(self, aName: "std::string const &") -> "void":
        return _common.PropertyGroup_setName(self, aName)

    def getName(self) -> "std::string const &":
        return _common.PropertyGroup_getName(self)

# Register PropertyGroup in _common:
_common.PropertyGroup_swigregister(PropertyGroup)

class ArrayPtrsPropertyGroup(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayPtrsPropertyGroup

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::PropertyGroup >
        :param aArray: Array to be copied.
        """
        _common.ArrayPtrsPropertyGroup_swiginit(self, _common.new_ArrayPtrsPropertyGroup(*args))

    def clearAndDestroy(self) -> "void":
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsPropertyGroup_clearAndDestroy(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.ArrayPtrsPropertyGroup_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayPtrsPropertyGroup_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayPtrsPropertyGroup_size(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::PropertyGroup >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.ArrayPtrsPropertyGroup_getIndex(self, *args)

    def append(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`PropertyGroup`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::PropertyGroup >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.ArrayPtrsPropertyGroup_append(self, *args)

    def insert(self, aIndex: "int", aObject: "PropertyGroup") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`PropertyGroup`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.ArrayPtrsPropertyGroup_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::PropertyGroup >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.ArrayPtrsPropertyGroup_remove(self, *args)

    def set(self, aIndex: "int", aObject: "PropertyGroup") -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`PropertyGroup`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsPropertyGroup_set(self, aIndex, aObject)

    def get(self, *args) -> "OpenSim::PropertyGroup *":
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`PropertyGroup`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`PropertyGroup`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`PropertyGroup`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.ArrayPtrsPropertyGroup_get(self, *args)

    def getLast(self) -> "OpenSim::PropertyGroup *":
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`PropertyGroup`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`PropertyGroup`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayPtrsPropertyGroup_getLast(self)

    def searchBinary(self, aObject: "OpenSim::ArrayPtrs< OpenSim::PropertyGroup >::ConstT &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayPtrsPropertyGroup_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register ArrayPtrsPropertyGroup in _common:
_common.ArrayPtrsPropertyGroup_swigregister(ArrayPtrsPropertyGroup)

class PropertyString(AbstractProperty):
    r"""
     A %Property<T> is a serializable (name, list-of-values) pair, where each
    value is of type T. The number of values allowed in the list is an attribute of
    the property; often it is just a single value. Properties are owned by classes
    that derive from %OpenSim's serializable Object base class. The documentation
    here is most useful for developers who are interested in creating a new
    Component, ModelComponent, or other serializable class derived from Object.

    A property's contained type T must be a serializable type. Serializable types
    come in two flavors:
      - simple types (like int or string) for which serialization instructions
        have been provided, and
      - object types, in which case type T derives from Object and knows
        how to serialize itself.

    When T is a simple type we'll write T=S and refer to a %Property<S> as a
    "simple property". When T is an object type, we'll write T=O and
    refer to a %Property<O> as an "object property".

    In case type O is a still-abstract Object-derived type like Function or
    Controller, a %Property<O> can hold a mix of any concrete objects derived from
    O (e.g., any Object that can be dynamic_cast to a Function can be
    held by a %Property<Function>).

    The objects in an object property will themselves have
    properties so a %Property<O> can be viewed as a node in the tree of objects
    that constitute an %OpenSim Model. Simple properties %Property<S> can be
    viewed as the terminal nodes of that tree. Properties are thus an integral part
    of the structure of an %OpenSim Model; anything contained in a property is
    owned by that property; deleting the property deletes its contained objects. If
    you want to *reference* another Object from within a property, use a string
    property to reference it by name; the result is a simple property. It is not
    permitted for type T to be a pointer or reference.

    ### XML file representation of properties

    The general representation for a %Property<T> with name "prop_name" is

    .. code-block:: c++

            <prop_name> T T ... T </prop_name>
    where "T" is the XML representation for objects of type T. Note that if T is
    an object type O, its representation follows the pattern

    .. code-block:: c++

            <OTypeName> OContents </OTypeName>
    where ``OTypeName`` stands for the name of the concrete, Object-derived class
    being serialized, and ``OContents`` is the representation generated by that
    class when asked to serialize itself.

    A %Property<O> that is restricted to holding **exactly one** object of
    type O is called a "one-object property". It could be represented in XML as

    .. code-block:: c++

            <prop_name> <OTypeName> OContents </OTypeName> </prop_name>
    but we allow a more compact representation for one-object properties:

    .. code-block:: c++

            <OTypeName name="prop_name"> OContents </OTypeName>
    In the one-object case it is also permissible for the property to be unnamed,
    in which case it may be referenced as though its name were the same as the
    object type name, and there is no separate "name" attribute. The XML
    representation for an unnamed property is just:

    .. code-block:: c++

            <OTypeName> OContents </OTypeName>
    On input, if a name attribute is seen for an unnamed property it is ignored;
    only the object type name tag matters in the unnamed case. Note that only
    one-object properties can be unnamed, and no single %OpenSim object can have
    more than one unnamed property of the same type.

    ### %Property attributes

    In addition to the name and list of values, every property has the following
    attributes:
      - A comment string, provided at the time the property is created.
      - The minimum and maximum number of values allowed.
      - A "used default value" flag.

    The "used default value" flag specifies that the value stored with this
    property was taken from a default object and not subsequently changed. A
    property with this flag set is not written out when a model is serialized.

    ### How to declare properties in your class declaration

    Properties are maintained in a PropertyTable by %OpenSim's Object base class
    that is used for all serializable objects. Do not create %Property objects
    directly; instead, use the provided macros to declare them in the class
    declarations for objects derived from Object. These macros should appear in the
    header file near the top of your class declaration. Comments that should appear
    in the generated Doxygen documentation as well as in XML files should be in the
    comment string; if you have a comment that should appear in Doxygen
    documentation but not in XML, then you can place it in a Doxygen comment just
    above the line where you declare your property.

    **Naming conventions:** %OpenSim property names should use lower case letters
    with ``words_separated_by_underscores``. In contrast, %OpenSim object types
    begin with a capital letter and use camel case, that is,
    ``MixedUpperAndLowerLikeThis``. This prevents any possible collisions between
    property names and object types, allowing both to be used as XML tag
    identifiers with no conflicts.

    These are the most common forms of property declaration.  Click on the macro
    names below for more information.

    .. code-block:: c++

        Exactly one value required; this is the basic property type.
            OpenSim_DECLARE_PROPERTY(name, T, "property description");
        Zero or one value only.
            OpenSim_DECLARE_OPTIONAL_PROPERTY(name, T, "property description");
        Zero or more values.
            OpenSim_DECLARE_LIST_PROPERTY(name, T, "property description");
    In the above, T may be a simple type S or object type O. In the case of a
    single-value property where type T is a type derived from
    Object (i.e., T=O), you can declare the property to be unnamed and instead use
    the class name of the object type O to identify the property:

    .. code-block:: c++

        Exactly one value of object type O required.
            OpenSim_DECLARE_UNNAMED_PROPERTY(O, "property description");
    Only one unnamed property of a particular object type O may be declared in
    any given Object.

    Finally, for list properties you can declare restrictions on the allowable
    list length:

    .. code-block:: c++

        List must contain exactly listSize (> 0) elements.
            OpenSim_DECLARE_LIST_PROPERTY_SIZE(name, T, listSize,
                                               "property description");
        List must contain at least minSize (> 0) elements.
            OpenSim_DECLARE_LIST_PROPERTY_ATLEAST(name, T, minSize,
                                                  "property description");
        List must contain at most maxSize (> 0) elements.
            OpenSim_DECLARE_LIST_PROPERTY_ATMOST(name, T, maxSize,
                                                 "property description");
        List must contain between minSize (> 0) and maxSize (>minSize) elements.
            OpenSim_DECLARE_LIST_PROPERTY_RANGE(name, T, minSize, maxSize,
                                                "property description");
    Here is an example of an object declaring two properties: *

    .. code-block:: c++

          class ActuatorWorkMeter : public ModelComponent {
          OpenSim_DECLARE_CONCRETE_OBJECT(ActuatorWorkMeter, ModelComponent);
          public:
        =======================================================================
        PROPERTIES
        =======================================================================
              OpenSim_DECLARE_PROPERTY(actuator_name, std::string,
                  "The name of the actuator whose work use will be calculated.");
        The value for this property is used for reporting purposes.
              OpenSim_DECLARE_PROPERTY(initial_actuator_work, double,
                  "Initial value for work; normally zero.");
        =======================================================================
        PUBLIC METHODS
        =======================================================================
              ...
          };
    ### How to construct properties in your constructors

    The constructors for your Object-derived class are required to construct and
    initialize the properties to whatever default values you want them to have.
    The above macros will have generated for each property a method for this
    purpose. If your property is named **prop_name**, then the method will be
    called constructProperty_**prop_name**(). (In the case of unnamed
    properties, the object type serves as **prop_name**.) The initial value is
    provided as an argument, which is optional for those properties that are
    allowed to contain a zero-length value list. Here are the various types of
    generated construction methods:

    .. code-block:: c++

        Construct and initialize a single-valued property containing type T.
            void constructProperty_prop_name(const T& value);
        Construct a property with a zero-length value list.
            void constructProperty_prop_name();
        Construct a list property, initializing from a container.
            template <template <class> class Container>
            void constructProperty_prop_name(const Container<T>& valueList);
    The first form above is generated for basic, optional, and unnamed properties.
    The second, uninitialized form is generated for optional, unrestricted list,
    and list "atmost" properties, since those can accept a zero-element value list.
    The last form is generated for all list properties, regardless of size
    restriction; a runtime check verifies that size restrictions are met. That
    form accepts any container type that supports a %size() method and random access
    element selection with operator[], such as std::vector<T>,
    OpenSim::Array<T>, or SimTK::Array_<T>.

    The above methods are conventionally collected into a private method of each
    object class called ``constructProperties()``. This method is then invoked from
    every constructor, *except* the copy constructor (which you normally should
    let the compiler generate, but see below).

    <h4>Copy constructor and copy assignment operator<h4>

    Your best bet is to use the compiler-generated default copy constructor and
    default copy assignment operator that you get whenever you leave these methods
    undefined. If you do that, all your properties and their associated local
    data will be copied automatically. It is worth some effort to design your
    objects so that their data members can copy and assign themselves correctly;
    you might find SimTK::ReferencePtr<T> and SimTK::ClonePtr<T> useful for getting
    pointer members to behave themselves properly.

    However, if you do have to write your own copy constructor and copy assignment
    operator (and if you write one you must write the other also), the
    property table will still have been copied properly by your superclass, it is
    only the local property indices that you have to deal with. For that, each
    property has defined a method like:

    .. code-block:: c++

        Copy the local data member associated with property prop_name.
            void copyProperty_prop_name(const Self& source);
    In the above, ``Self`` is the type of the object being defined and ``source`` is
    the argument that was passed to the containing copy constructor or copy
    assignment operator.

    ### Runtime access to property values

    The property declaration macros also generate per-property methods for getting
    access to property values or the %Property objects themselves. These inline
    methods are very fast and can be used whenever you need access to a property
    value. The following are generated for single-valued property types, including
    the basic, optional, and unnamed properties:

    .. code-block:: c++

        Get a const reference to the value of a single-valued property
        named "prop_name" (basic, optional, unnamed properties only).
            const T& get_prop_name() const;
        Same, but returns a writable reference.
            T& upd_prop_name();
        Set the value of a single-valued property.
            void set_prop_name(const T& value);

    Additional methods are generated for list properties:

    .. code-block:: c++

        Get a const reference to the i'th element in a list property's value
        list.
            const T& get_prop_name(int i) const;
        Same, but returns a writable reference.
            T& upd_prop_name(int i);
        Set the i'th element of a list property to the given value. Only
        allowed if the list currently has at least i elements, so no gaps can
        be created with this method.
            void set_prop_name(int i, const T& value);
        Use this to append one element to a list property's value list; the
        assigned index is returned.
            int append_prop_name(const T& value);
        Use this to set all the values of a list-valued property.
            template <template <class> class Container>
            void set_prop_name(const Container<T>& valueList);
    The last form accepts any container that has a %size() method and allows
    element access using operator[]. Runtime checks verify that the list length
    is within the allowable range for the property. Note that every property is
    considered to have a value list (even when restricted to one element) so the
    indexed forms above can also be used with single-valued properties as long as
    the index is zero.

    To get access to the %Property object rather than one of its values, the
    following methods are provided:

    .. code-block:: c++

        Get a const reference to the Property<T> object for "prop_name".
            const Property<T>& getProperty_prop_name() const;
        Same, but returns a writable reference.
            Property<T>& updProperty_prop_name();

    The %Property<T> class acts as a container of values, and has the usual
    %size(), %empty(), and operator[] methods available so you can use
    getProperty...() above to get access to those methods. For example, to write
    out all the values of any property:

    .. code-block:: c++

        Assumes type T can be written to a stream with operator<<.
            for (int i=0; i < getProperty_prop_name().size(); ++i)
                std::cout << get_prop_name(i) << std::endl;


    See also: OpenSim::Object, OpenSim::AbstractProperty
    Author: Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self) -> "OpenSim::Property< std::string > *":
        r"""
        Make a new, deep copy (clone) of this concrete property and return
           a pointer to the heap space. Caller must delete the returned object when
           done with it. *
        """
        return _common.PropertyString_clone(self)

    def getTypeName(self) -> "std::string":
        r""" Use TypeHelper's getTypeName() to satisfy this pure virtual. *"""
        return _common.PropertyString_getTypeName(self)

    def setValue(self, *args) -> "void":
        r"""
        *Overload 1:*
        Replace the i'th value list element with a copy of the given *value*.
           The index i must be between 0 and the current list length, meaning it is
           OK to refer one element past the last element. In that case the new
           *value* is appended to the list using appendValue(), which will throw an
           exception if the list is already at its maximum allowable size. In the case
           where index i refers to an existing element, a simple property
           will assign a new value to the existing element but an object property
           will delete the old object and replace it with a clone() of the new one
           -- it will *not* invoke the old object's assignment operator. That means
           that the concrete object type may be changed by this operation, provided
           it is still a type derived from object type T. If you want to invoke the
           existing value's assignment operator, use updValue(i) rather than
           setValue(i). *

        |

        *Overload 2:*
        Provide a new value for a single-valued
           property. The current value (if any) is replaced, and %size()==1
           afterwards. An exception is thrown if this is a list property. *
        """
        return _common.PropertyString_setValue(self, *args)

    def getValue(self, index: "int"=-1) -> "std::string const &":
        r"""
        Return a const reference to the selected value from this property's
           value list. If the property is at most single valued then the *index* is
           optional and we'll behave as though index=0 were supplied. You can use
           the square bracket operator property[index] instead. *
        """
        return _common.PropertyString_getValue(self, index)

    def updValue(self, index: "int"=-1) -> "std::string &":
        r"""
        Return a writable reference to the selected value from this property's
           value list. If the property is at most single valued then the *index* is
           optional and we'll behave as though index=0 were supplied.  You can use
           the square bracket operator property[index] instead. *
        """
        return _common.PropertyString_updValue(self, index)

    def appendValue(self, value: "std::string const &") -> "int":
        r"""
        Append a copy of the supplied *value* to the end of this property's
           value list. An exception is thrown if the property can't hold any more
           values. The index assigned to this value is returned. *
        """
        return _common.PropertyString_appendValue(self, value)

    def adoptAndAppendValue(self, value: "std::string *") -> "int":
        r"""
        Add a new value to the end of this property's value list, taking over
           ownership of the supplied heap-allocated object. An exception
           is thrown if the property can't hold any more values. The index assigned
           to this value is returned. *
        """
        return _common.PropertyString_adoptAndAppendValue(self, value)

    def findIndex(self, value: "std::string const &") -> "int":
        r"""
        Search the value list for an element that has the given *value* and
           return its index if found, otherwise -1. This requires only that the
           template type T supports operator==(). This is a linear search so will
           take time proportional to the length of the value list. *
        """
        return _common.PropertyString_findIndex(self, value)

    def findIndexForName(self, name: "SimTK::String const &") -> "int":
        r"""
        Return index of passed in name if the Property contains objects that are
           derived from OpenSim::Object, and -1 if no such Object is found. Throws an
           Exception if the List doesn't contain OpenSim Objects (e.g. primitive types)
           since these are not named. When a search is performed, it's a linear search.
        """
        return _common.PropertyString_findIndexForName(self, name)

    @staticmethod
    def isA(prop: "AbstractProperty") -> "bool":
        r"""
        Return true if the given AbstractProperty references a concrete
           property of this type (%Property<T>). Note that for this to return true,
           the type T must be exactly the type used when the concrete property was
           allocated; it is not sufficient for T to be a more general base type from
           which the actual type was derived. *
        """
        return _common.PropertyString_isA(prop)

    @staticmethod
    def getAs(prop: "AbstractProperty") -> "OpenSim::Property< std::string > const &":
        r"""
        Downcast the given AbstractProperty to a concrete
           property of this type (%Property<T>). An exception is thrown if
           this is not the right type only in DEBUG mode; see isA() if you need to
           check first. *
        """
        return _common.PropertyString_getAs(prop)

    @staticmethod
    def updAs(prop: "AbstractProperty") -> "OpenSim::Property< std::string > &":
        r"""
        Downcast the given AbstractProperty to a writable concrete
           property of this type (%Property<T>). An exception is thrown if
           this is not the right type only in DEBUG mode; see isA() if you need to
           check first. *
        """
        return _common.PropertyString_updAs(prop)

# Register PropertyString in _common:
_common.PropertyString_swigregister(PropertyString)

def PropertyString_isA(prop: "AbstractProperty") -> "bool":
    r"""
    Return true if the given AbstractProperty references a concrete
       property of this type (%Property<T>). Note that for this to return true,
       the type T must be exactly the type used when the concrete property was
       allocated; it is not sufficient for T to be a more general base type from
       which the actual type was derived. *
    """
    return _common.PropertyString_isA(prop)

def PropertyString_getAs(prop: "AbstractProperty") -> "OpenSim::Property< std::string > const &":
    r"""
    Downcast the given AbstractProperty to a concrete
       property of this type (%Property<T>). An exception is thrown if
       this is not the right type only in DEBUG mode; see isA() if you need to
       check first. *
    """
    return _common.PropertyString_getAs(prop)

def PropertyString_updAs(prop: "AbstractProperty") -> "OpenSim::Property< std::string > &":
    r"""
    Downcast the given AbstractProperty to a writable concrete
       property of this type (%Property<T>). An exception is thrown if
       this is not the right type only in DEBUG mode; see isA() if you need to
       check first. *
    """
    return _common.PropertyString_updAs(prop)

class OpenSimObject(object):
    r"""
     This is the base class for all %OpenSim objects that are serializable
    (meaning they can be written to and read back from files). In particular, all
    ModelComponent objects derive from %Object. It provides a common base class
    from which to derive serializable objects and also some basic functionality,
    such as writing to files in XML format, managing properties, and the equality,
    less than, and output operators.

    An %Object maintains a table of "properties" that know how to read themselves
    from XML and write themselves to XML. The available Property types are
      -# Primitive data types (int, bool, double, std::string, ...)
      -# Properties that contain other Objects,
      -# Properties containing lists of either of the previous 2 categories

    It is important to note that Objects and Properties together form a recursive
    tree structure that is the representation of an %OpenSim Model. See the
    documentation for the OpenSim::Property class for more information.

    ### %Object declaration

    The declaration of every class derived from %Object *must* have its first line
    (that is, immediately after the "{" in the class declaration) one of four
    standard "boilerplate" macros:

    .. code-block:: c++

          OpenSim_DECLARE_CONCRETE_OBJECT  (ClassName, SuperclassName);
          OpenSim_DECLARE_CONCRETE_OBJECT_T(ClassName, T, SuperclassName);
          OpenSim_DECLARE_ABSTRACT_OBJECT  (ClassName, SuperclassName);
          OpenSim_DECLARE_ABSTRACT_OBJECT_T(ClassName, T, SuperclassName);
    ("Superclass" means the immediate class from which the class derives; that
    terminology is borrowed from Java. It is often called the "Parent" class but
    we'll use "Super" which is more precise.) The "_T" variants of the above macros
    are used for objects that are templatized, like Set<T>.

    These macros provide a standardized set of declarations for every object,
    including

    .. code-block:: c++

            typedef ClassName      Self;                // for all classes
            typedef SuperclassName Super;               // for all classes
            static const std::string& getClassName();   // for all classes
            const std::string& getConcreteClassName();  // for concrete classes only
            ClassName* clone() const;                   // see below
    getClassName() is a static method that returns the name of the %Object-derived
    class for which it is invoked. For example, ModelComponent::getClassName()
    returns "ModelComponent". In contrast, getConcreteClassName() is a pure virtual
    method of %Object that returns the class name of the actual concrete object
    being referenced through the abstract base class. This method is implemented
    only in concrete classes.

    Note that getClassName() and getConcreteClassName() will return the same string
    only if the referenced class is concrete. For example,

    .. code-block:: c++

            Function* funcp = new LinearFunction(...);
            std::cout << funcp->getClassName();          // output: "Function"
            std::cout << funcp->getConcreteClassName();  // output: "LinearFunction"

    For concrete objects, the class name is used as the "object type tag", the tag
    string that will appear in XML files. Also, when a Property<T> has no name
    (allowed for properties that contain just a single object) the object class
    name T (which may be abstract like Function or ModelComponent) is used to
    select the property. See OpenSim::Property for more information.

    The standard clone() method produces a duplicate of a concrete object and thus
    is implemented only for concrete classes. However, the return type must
    always match the type of the invoking object (this is called a "covariant type"
    and does not change the method's identity). It is therefore redeclared even in
    abstract classes, but remains pure virtual in those cases. That means if you
    invoke Function::clone() you'll get back a Function* rather than an Object*;
    this avoids many unnecessary invocations of the awkward and expensive
    dynamic_cast operator.

    ### %Object registration and renaming

    An %Object type needs to be "registered" by calling Object::registerType() with
    an instance of a concrete object so that the serialization infrastructure knows
    what kind of %Object to create when it encounters a specific XML tag. This
    associates the concrete object's class name (object type tag) with a default
    instance of that object. The registration process is normally done during
    dynamic library (DLL) loading, that is, as part of the static initializer
    execution that occurs before program execution.

    For backwards compatibility, we support a renaming mechanism in which
    now-deprecated class names can be mapped to their current equivalents. This
    is done via a string-to-string table mapping the old names to the new ones;
    only the current names appear in the registered objects table. Specification of
    these aliases is done immediately after registration in the DLL static
    initializer.

    ### Defaults mechanism

    When an %Object is registered (either programmatically, or
    overridden in the defaults section of a document), a copy of it is maintained
    in a dictionary as a "default" object of its class. When new instances of this
    class are requested, the contents of the default object are used to populate the
    new instance before deserialization. This allows for specifying default values
    that will be commonly used in one place in the XML file rather than with each
    object which leads to smaller files that are easier to read. Property values
    that obtain their values from the defaults and are not subsequently overridden
    are marked as being default values, allowing us to avoid writing
    them back out when serializing.

    Author: Frank C. Anderson, Ayman Habib, Ajay Seth, Michael Sherman
    See also: OpenSim::Property
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_OpenSimObject

    def clone(self) -> "OpenSim::Object *":
        r"""
        Create a new heap-allocated copy of the concrete object to which this
           %Object refers. It is up to the caller to delete the returned object
           when no longer needed. Every concrete object deriving from %Object
           implements this pure virtual method automatically, via the declaration
           macro it invokes (e.g., OpenSim_DECLARE_CONCRETE_OBJECT()). Note that the
           concrete class overrides modify the return type to be a pointer to the
           *concrete* object; that still overrides the base class method because the
           return type is covariant with (that is, derives from) %Object. *
        """
        return _common.OpenSimObject_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        r"""
        Returns the class name of the concrete %Object-derived class of the
           actual object referenced by this %Object, as a string. This is the
           string that is used as the tag for this concrete object in an XML file.
           Every concrete class derived from %Object automatically overrides this
           method via the declaration macro it uses. See getClassName() to get the
           class name of the referencing (possibly abstract) class rather than the
           concrete object.
           See also: getClassName() *
        """
        return _common.OpenSimObject_getConcreteClassName(self)

    def assign(self, aObject: "OpenSimObject") -> "void":
        r""" Conditional comment:"""
        return _common.OpenSimObject_assign(self, aObject)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _common.OpenSimObject_isEqualTo(self, aObject)

    def setName(self, name: "std::string const &") -> "void":
        r""" %Set the name of the Object."""
        return _common.OpenSimObject_setName(self, name)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _common.OpenSimObject_getName(self)

    def setDescription(self, description: "std::string const &") -> "void":
        r""" %Set description, a one-liner summary."""
        return _common.OpenSimObject_setDescription(self, description)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _common.OpenSimObject_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _common.OpenSimObject_getAuthors(self)

    def setAuthors(self, authors: "std::string const &") -> "void":
        r""" %Set Authors of this object. Call this method in your constructor if needed."""
        return _common.OpenSimObject_setAuthors(self, authors)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _common.OpenSimObject_getReferences(self)

    def setReferences(self, references: "std::string const &") -> "void":
        r""" %Set references or publications to cite if using this object."""
        return _common.OpenSimObject_setReferences(self, references)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _common.OpenSimObject_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _common.OpenSimObject_getPropertyByIndex(self, propertyIndex)

    def updPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty &":
        r"""
        Get a writable reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _common.OpenSimObject_updPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _common.OpenSimObject_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _common.OpenSimObject_getPropertyByName(self, name)

    def updPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty &":
        r"""
        Get a writable reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _common.OpenSimObject_updPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _common.OpenSimObject_isObjectUpToDateWithProperties(self)

    @staticmethod
    def PrintPropertyInfo(*args) -> "bool":
        r"""
        *Overload 1:*
        Dump formatted property information to a given output stream, useful
           for creating a "help" facility for registered objects. Object name,
           property name, and property comment are output. Input is a
           class name and property name. If the property name is the empty string or
           just "*", then information for all properties in the class is printed. If
           the class name is empty, information in all properties of all registered
           classes is printed.
           :type os: std::ostream
           :param os:
                   Output stream to which info is printed.
           :type classNameDotPropertyName: string
           :param classNameDotPropertyName:
                   A string combining the class name and property name. The two names
                   should be separated by a period (ClassName.PropertyName). If
                   PropertyName is empty or "*", the information for all properties in the
                   class is printed. If ClassName is empty, the information for the
                   properties of all registered classes is printed.
           :type printFlagInfo: boolean, optional
           :param printFlagInfo:
                   Print to the ostream some instructions for using the -PropertyInfo
                   command line flag.

           Returns false if the provided names do not match known classes or
           properties; otherwise, returns true. *

        |

        *Overload 2:*
        Same as the other signature but the class name and property name are
           provided as two separate strings.
           Returns false if the provided names do not match known classes or
           properties; otherwise, returns true. *

        |

        *Overload 3:*
        Same as the other signature but the class name and property name are
           provided as two separate strings.
           Returns false if the provided names do not match known classes or
           properties; otherwise, returns true. *
        """
        return _common.OpenSimObject_PrintPropertyInfo(*args)

    @staticmethod
    def registerType(defaultObject: "OpenSimObject") -> "void":
        r"""
        ** Register an instance of a class; if the class is already registered it
            will be replaced. This is normally called as part of the static
            initialization of a dynamic library (DLL). The supplied object's concrete
            class name will be used as a key, and a *copy* (via clone()) of the
            supplied %Object is used as the default value for objects of this type when
            created (typically during the deserialization process when reading an
            XML file). *
        """
        return _common.OpenSimObject_registerType(defaultObject)

    @staticmethod
    def renameType(oldTypeName: "std::string const &", newTypeName: "std::string const &") -> "void":
        r"""
        Support versioning by associating the current %Object type with an
           old name. This is only allowed if *newTypeName* has already been
           registered with registerType(). Renaming is applied first prior to lookup
           so can be used both for translating now-obsolete names to their new names
           and for overriding one registered type with another. *
        """
        return _common.OpenSimObject_renameType(oldTypeName, newTypeName)

    @staticmethod
    def getDefaultInstanceOfType(concreteClassName: "std::string const &") -> "OpenSim::Object const *":
        r"""
        Return a pointer to the default instance of the registered (concrete)
           %Object whose class name is given, or NULL if the type is not registered.
           Note that this refers to the default %Object instance that is stored with
           the %Object class; do not delete it! If you want a copy of this object
           instead, use newInstanceOfType(). The given *concreteClassName* will be
           mapped through the renamed type table if necessary but the returned object
           will always have the new type name, which may differ from the supplied
           one. Note that renaming is applied first, prior to looking up the name
           in the registered objects table.
           See also: registerType(), renameType() *
        """
        return _common.OpenSimObject_getDefaultInstanceOfType(concreteClassName)

    @staticmethod
    def newInstanceOfType(concreteClassName: "std::string const &") -> "OpenSim::Object *":
        r"""
        Create a new instance of the concrete %Object type whose class name is
           given as *concreteClassName*. The instance is initialized to the default
           object of corresponding type, possibly after renaming to the current class
           name. Writes a message to stderr and returns null if the tag isn't
           registered. *
        """
        return _common.OpenSimObject_newInstanceOfType(concreteClassName)

    @staticmethod
    def getRegisteredTypenames(typeNames: "ArrayStr") -> "void":
        r"""
        Retrieve all the typenames registered so far. This is done by traversing
           the registered objects map, so only concrete classes that have registered
           instances are returned; renamed types will not appear unless they were
           separately registered. (Note that even if one registered type has been
           renamed to another, both will appear in the returned list.) The result
           returned in *typeNames* should not be cached while more shared libraries
           or plugins are loaded, because more types may be registered as a result.
           Instead the list should be reconstructed whenever in doubt. *
        """
        return _common.OpenSimObject_getRegisteredTypenames(typeNames)

    @staticmethod
    def makeObjectFromFile(fileName: "std::string const &") -> "OpenSim::Object *":
        r"""
        ** Create an %OpenSim object whose type is based on the tag at the root
            node of the XML file passed in. This is useful since the constructor of
            %Object doesn't have the proper type info. This works by using the defaults
            table so that %Object does not need to know about its derived classes. It
            uses the defaults table to get an instance. *
        """
        return _common.OpenSimObject_makeObjectFromFile(fileName)

    def readObjectFromXMLNodeOrFile(self, objectElement: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        r"""
        We're given an XML element from which we are to populate this %Object.
           If the element has a ``file`` attribute, we'll instead read the %Object from
           that file. Otherwise we'll invoke updateFromXMLNode() to read the %Object
           directly from the supplied element. Note that a relative file name will
           be interpreted relative to the current working directory, but that will
           normally have been set earlier to the directory containing the top-level
           (root) %Object, such as the Model file. *
        """
        return _common.OpenSimObject_readObjectFromXMLNodeOrFile(self, objectElement, versionNumber)

    def updateFromXMLNode(self, objectElement: "SimTK::Xml::Element &", versionNumber: "int") -> "void":
        r"""
        Use this method to deserialize an object from a SimTK::Xml::Element. The
           element is assumed to be in the format consistent with the passed-in
           *versionNumber*. If there is a file attribute in *objectElement* it
           will be ignored; if you want it processed you should call
           readObjectFromXMLNodeOrFile() instead. *
        """
        return _common.OpenSimObject_updateFromXMLNode(self, objectElement, versionNumber)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _common.OpenSimObject_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _common.OpenSimObject_getInlined(self)

    def setInlined(self, *args) -> "void":
        r"""
        Mark this as inlined or not and optionally provide a file name
           to associate with the new XMLDocument for the non-inline case. If
           there was already a document associated with this object it is
           deleted. *
        """
        return _common.OpenSimObject_setInlined(self, *args)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _common.OpenSimObject_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _common.OpenSimObject_getDocumentFileVersion(self)

    def setAllPropertiesUseDefault(self, aUseDefault: "bool") -> "void":
        return _common.OpenSimObject_setAllPropertiesUseDefault(self, aUseDefault)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _common.OpenSimObject_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _common.OpenSimObject_dump(self)

    @staticmethod
    def getClassName() -> "std::string const &":
        r"""
        ** Return the name of this class as a string; i.e., "Object". See
            getConcreteClassName() if you want the class name of the underlying concrete
            object instead. Note that this method is automatically supplied for
            every class declaration that derives from Object via the standard macro
            provided for that purpose. See introductory text for this Object class
            for more information. *
        """
        return _common.OpenSimObject_getClassName()

    @staticmethod
    def setSerializeAllDefaults(shouldSerializeDefaults: "bool") -> "void":
        r"""
        Static function to control whether all registered objects and
           their properties are written to the defaults section of output files rather
           than only those values for which the default was explicitly overwritten
           when read in from an input file or set programmatically. *
        """
        return _common.OpenSimObject_setSerializeAllDefaults(shouldSerializeDefaults)

    @staticmethod
    def getSerializeAllDefaults() -> "bool":
        r""" Report the value of the "serialize all defaults" flag. *"""
        return _common.OpenSimObject_getSerializeAllDefaults()

    @staticmethod
    def isKindOf(type: "char const *") -> "bool":
        r"""
        Returns true if the passed-in string is "Object"; each %Object-derived
           class defines a method of this name for its own class name. *
        """
        return _common.OpenSimObject_isKindOf(type)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _common.OpenSimObject_isA(self, type)

    @staticmethod
    def setDebugLevel(newLevel: "int") -> "void":
        r"""
        %Set the amount of logging output. Higher numbers generate more logging
           output.
            - -4: Off
            - -3: Critical
            - -2: Error
            - -1: Warn
            -  0: Info
            -  1: Debug
            -  2: Trace
            -  3: Trace (for backwards compatibility).
           **(Deprecated)** Use Log::setLevel() instead. *
        """
        return _common.OpenSimObject_setDebugLevel(newLevel)

    @staticmethod
    def getDebugLevel() -> "int":
        r"""
        Get the current setting of debug level.
           **(Deprecated)** Use Log::getLevel() instead. *
        """
        return _common.OpenSimObject_getDebugLevel()

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _common.OpenSimObject_toString(self)

    @staticmethod
    def SafeCopy(aObject: "OpenSimObject") -> "OpenSim::Object *":
        r"""
        Use the clone() method to duplicate the given object unless the pointer
           is null in which case null is returned. *
        """
        return _common.OpenSimObject_SafeCopy(aObject)

    @staticmethod
    def RegisterType(defaultObject: "OpenSimObject") -> "void":
        r""" OBSOLETE alternate name for registerType(). *"""
        return _common.OpenSimObject_RegisterType(defaultObject)

    @staticmethod
    def RenameType(oldName: "std::string const &", newName: "std::string const &") -> "void":
        r""" OBSOLETE alternate name for renameType(). *"""
        return _common.OpenSimObject_RenameType(oldName, newName)

    def _markAdopted(self):
        if self.this and self.thisown:
            self.thisown = False


# Register OpenSimObject in _common:
_common.OpenSimObject_swigregister(OpenSimObject)
ObjectDEFAULT_NAME = cvar.ObjectDEFAULT_NAME

def OpenSimObject_PrintPropertyInfo(*args) -> "bool":
    r"""
    *Overload 1:*
    Dump formatted property information to a given output stream, useful
       for creating a "help" facility for registered objects. Object name,
       property name, and property comment are output. Input is a
       class name and property name. If the property name is the empty string or
       just "*", then information for all properties in the class is printed. If
       the class name is empty, information in all properties of all registered
       classes is printed.
       :type os: std::ostream
       :param os:
               Output stream to which info is printed.
       :type classNameDotPropertyName: string
       :param classNameDotPropertyName:
               A string combining the class name and property name. The two names
               should be separated by a period (ClassName.PropertyName). If
               PropertyName is empty or "*", the information for all properties in the
               class is printed. If ClassName is empty, the information for the
               properties of all registered classes is printed.
       :type printFlagInfo: boolean, optional
       :param printFlagInfo:
               Print to the ostream some instructions for using the -PropertyInfo
               command line flag.

       Returns false if the provided names do not match known classes or
       properties; otherwise, returns true. *

    |

    *Overload 2:*
    Same as the other signature but the class name and property name are
       provided as two separate strings.
       Returns false if the provided names do not match known classes or
       properties; otherwise, returns true. *

    |

    *Overload 3:*
    Same as the other signature but the class name and property name are
       provided as two separate strings.
       Returns false if the provided names do not match known classes or
       properties; otherwise, returns true. *
    """
    return _common.OpenSimObject_PrintPropertyInfo(*args)

def OpenSimObject_registerType(defaultObject: "OpenSimObject") -> "void":
    r"""
    ** Register an instance of a class; if the class is already registered it
        will be replaced. This is normally called as part of the static
        initialization of a dynamic library (DLL). The supplied object's concrete
        class name will be used as a key, and a *copy* (via clone()) of the
        supplied %Object is used as the default value for objects of this type when
        created (typically during the deserialization process when reading an
        XML file). *
    """
    return _common.OpenSimObject_registerType(defaultObject)

def OpenSimObject_renameType(oldTypeName: "std::string const &", newTypeName: "std::string const &") -> "void":
    r"""
    Support versioning by associating the current %Object type with an
       old name. This is only allowed if *newTypeName* has already been
       registered with registerType(). Renaming is applied first prior to lookup
       so can be used both for translating now-obsolete names to their new names
       and for overriding one registered type with another. *
    """
    return _common.OpenSimObject_renameType(oldTypeName, newTypeName)

def OpenSimObject_getDefaultInstanceOfType(concreteClassName: "std::string const &") -> "OpenSim::Object const *":
    r"""
    Return a pointer to the default instance of the registered (concrete)
       %Object whose class name is given, or NULL if the type is not registered.
       Note that this refers to the default %Object instance that is stored with
       the %Object class; do not delete it! If you want a copy of this object
       instead, use newInstanceOfType(). The given *concreteClassName* will be
       mapped through the renamed type table if necessary but the returned object
       will always have the new type name, which may differ from the supplied
       one. Note that renaming is applied first, prior to looking up the name
       in the registered objects table.
       See also: registerType(), renameType() *
    """
    return _common.OpenSimObject_getDefaultInstanceOfType(concreteClassName)

def OpenSimObject_newInstanceOfType(concreteClassName: "std::string const &") -> "OpenSim::Object *":
    r"""
    Create a new instance of the concrete %Object type whose class name is
       given as *concreteClassName*. The instance is initialized to the default
       object of corresponding type, possibly after renaming to the current class
       name. Writes a message to stderr and returns null if the tag isn't
       registered. *
    """
    return _common.OpenSimObject_newInstanceOfType(concreteClassName)

def OpenSimObject_getRegisteredTypenames(typeNames: "ArrayStr") -> "void":
    r"""
    Retrieve all the typenames registered so far. This is done by traversing
       the registered objects map, so only concrete classes that have registered
       instances are returned; renamed types will not appear unless they were
       separately registered. (Note that even if one registered type has been
       renamed to another, both will appear in the returned list.) The result
       returned in *typeNames* should not be cached while more shared libraries
       or plugins are loaded, because more types may be registered as a result.
       Instead the list should be reconstructed whenever in doubt. *
    """
    return _common.OpenSimObject_getRegisteredTypenames(typeNames)

def OpenSimObject_makeObjectFromFile(fileName: "std::string const &") -> "OpenSim::Object *":
    r"""
    ** Create an %OpenSim object whose type is based on the tag at the root
        node of the XML file passed in. This is useful since the constructor of
        %Object doesn't have the proper type info. This works by using the defaults
        table so that %Object does not need to know about its derived classes. It
        uses the defaults table to get an instance. *
    """
    return _common.OpenSimObject_makeObjectFromFile(fileName)

def OpenSimObject_getClassName() -> "std::string const &":
    r"""
    ** Return the name of this class as a string; i.e., "Object". See
        getConcreteClassName() if you want the class name of the underlying concrete
        object instead. Note that this method is automatically supplied for
        every class declaration that derives from Object via the standard macro
        provided for that purpose. See introductory text for this Object class
        for more information. *
    """
    return _common.OpenSimObject_getClassName()

def OpenSimObject_setSerializeAllDefaults(shouldSerializeDefaults: "bool") -> "void":
    r"""
    Static function to control whether all registered objects and
       their properties are written to the defaults section of output files rather
       than only those values for which the default was explicitly overwritten
       when read in from an input file or set programmatically. *
    """
    return _common.OpenSimObject_setSerializeAllDefaults(shouldSerializeDefaults)

def OpenSimObject_getSerializeAllDefaults() -> "bool":
    r""" Report the value of the "serialize all defaults" flag. *"""
    return _common.OpenSimObject_getSerializeAllDefaults()

def OpenSimObject_isKindOf(type: "char const *") -> "bool":
    r"""
    Returns true if the passed-in string is "Object"; each %Object-derived
       class defines a method of this name for its own class name. *
    """
    return _common.OpenSimObject_isKindOf(type)

def OpenSimObject_setDebugLevel(newLevel: "int") -> "void":
    r"""
    %Set the amount of logging output. Higher numbers generate more logging
       output.
        - -4: Off
        - -3: Critical
        - -2: Error
        - -1: Warn
        -  0: Info
        -  1: Debug
        -  2: Trace
        -  3: Trace (for backwards compatibility).
       **(Deprecated)** Use Log::setLevel() instead. *
    """
    return _common.OpenSimObject_setDebugLevel(newLevel)

def OpenSimObject_getDebugLevel() -> "int":
    r"""
    Get the current setting of debug level.
       **(Deprecated)** Use Log::getLevel() instead. *
    """
    return _common.OpenSimObject_getDebugLevel()

def OpenSimObject_SafeCopy(aObject: "OpenSimObject") -> "OpenSim::Object *":
    r"""
    Use the clone() method to duplicate the given object unless the pointer
       is null in which case null is returned. *
    """
    return _common.OpenSimObject_SafeCopy(aObject)

def OpenSimObject_RegisterType(defaultObject: "OpenSimObject") -> "void":
    r""" OBSOLETE alternate name for registerType(). *"""
    return _common.OpenSimObject_RegisterType(defaultObject)

def OpenSimObject_RenameType(oldName: "std::string const &", newName: "std::string const &") -> "void":
    r""" OBSOLETE alternate name for renameType(). *"""
    return _common.OpenSimObject_RenameType(oldName, newName)

class ObjectGroup(OpenSimObject):
    r"""
    A class implementing an object group. For most uses, object groups are
    owned and managed by the Set that contains the object.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ObjectGroup *":
        return _common.ObjectGroup_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ObjectGroup_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ObjectGroup_getClassName()

    def clone(self) -> "OpenSim::ObjectGroup *":
        return _common.ObjectGroup_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ObjectGroup_getConcreteClassName(self)

    def __init__(self, *args):
        _common.ObjectGroup_swiginit(self, _common.new_ObjectGroup(*args))
    __swig_destroy__ = _common.delete_ObjectGroup

    def copyData(self, aGroup: "ObjectGroup") -> "void":
        return _common.ObjectGroup_copyData(self, aGroup)

    def contains(self, aName: "std::string const &") -> "bool":
        return _common.ObjectGroup_contains(self, aName)

    def add(self, aObject: "OpenSimObject") -> "void":
        return _common.ObjectGroup_add(self, aObject)

    def remove(self, aObject: "OpenSimObject") -> "void":
        return _common.ObjectGroup_remove(self, aObject)

    def replace(self, aOldObject: "OpenSimObject", aNewObject: "OpenSimObject") -> "void":
        return _common.ObjectGroup_replace(self, aOldObject, aNewObject)

    def setupGroup(self, aObjects: "ArrayPtrsObj") -> "void":
        return _common.ObjectGroup_setupGroup(self, aObjects)

    def getMembers(self) -> "OpenSim::Array< OpenSim::Object const * > const &":
        return _common.ObjectGroup_getMembers(self)

# Register ObjectGroup in _common:
_common.ObjectGroup_swigregister(ObjectGroup)

def ObjectGroup_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ObjectGroup *":
    return _common.ObjectGroup_safeDownCast(obj)

def ObjectGroup_getClassName() -> "std::string const &":
    return _common.ObjectGroup_getClassName()

class PropertyHelper(object):
    r"""
    This class allows access to property values using template-free
     methods. Note that this will work regardless of whether the given
     AbstractProperty is the deprecated kind or the new one.

     An AbstractProperty represents a (name, list-of-values) pair, possibly
     with restrictions on the minimum and maximum list length. Basic container
     methods size(), resize(), clear(), and empty() are available; use resize()
     before assigning a value to an indexed element.

     For properties that contain objects, you can obtain the values directly
     from the base class via non-templatized methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getValueBool(p: "AbstractProperty", index: "int"=-1) -> "bool":
        return _common.PropertyHelper_getValueBool(p, index)

    @staticmethod
    def setValueBool(v: "bool", p: "AbstractProperty", index: "int"=-1) -> "void":
        return _common.PropertyHelper_setValueBool(v, p, index)

    @staticmethod
    def appendValueBool(v: "bool", p: "AbstractProperty") -> "void":
        return _common.PropertyHelper_appendValueBool(v, p)

    @staticmethod
    def getValueInt(p: "AbstractProperty", index: "int"=-1) -> "int":
        return _common.PropertyHelper_getValueInt(p, index)

    @staticmethod
    def setValueInt(v: "int", p: "AbstractProperty", index: "int"=-1) -> "void":
        return _common.PropertyHelper_setValueInt(v, p, index)

    @staticmethod
    def appendValueInt(v: "int", p: "AbstractProperty") -> "void":
        return _common.PropertyHelper_appendValueInt(v, p)

    @staticmethod
    def getValueDouble(p: "AbstractProperty", index: "int"=-1) -> "double":
        return _common.PropertyHelper_getValueDouble(p, index)

    @staticmethod
    def setValueDouble(v: "double", p: "AbstractProperty", index: "int"=-1) -> "void":
        return _common.PropertyHelper_setValueDouble(v, p, index)

    @staticmethod
    def appendValueDouble(v: "double", p: "AbstractProperty") -> "void":
        return _common.PropertyHelper_appendValueDouble(v, p)

    @staticmethod
    def getValueString(p: "AbstractProperty", index: "int"=-1) -> "std::string":
        return _common.PropertyHelper_getValueString(p, index)

    @staticmethod
    def setValueString(v: "std::string const &", p: "AbstractProperty", index: "int"=-1) -> "void":
        return _common.PropertyHelper_setValueString(v, p, index)

    @staticmethod
    def appendValueString(v: "std::string const &", p: "AbstractProperty") -> "void":
        return _common.PropertyHelper_appendValueString(v, p)

    @staticmethod
    def getValueTransform(p: "AbstractProperty", index: "int") -> "double":
        return _common.PropertyHelper_getValueTransform(p, index)

    @staticmethod
    def setValueTransform(v: "double", p: "AbstractProperty", index: "int") -> "void":
        return _common.PropertyHelper_setValueTransform(v, p, index)

    @staticmethod
    def getValueVec3(p: "AbstractProperty", index: "int") -> "double":
        return _common.PropertyHelper_getValueVec3(p, index)

    @staticmethod
    def setValueVec3(v: "double", p: "AbstractProperty", index: "int") -> "void":
        return _common.PropertyHelper_setValueVec3(v, p, index)

    @staticmethod
    def getValueVec6(p: "AbstractProperty", index: "int") -> "double":
        return _common.PropertyHelper_getValueVec6(p, index)

    @staticmethod
    def setValueVec6(v: "double", p: "AbstractProperty", index: "int") -> "void":
        return _common.PropertyHelper_setValueVec6(v, p, index)

    @staticmethod
    def getValueStringArray(p: "AbstractProperty") -> "OpenSim::Array< std::string >":
        return _common.PropertyHelper_getValueStringArray(p)

    @staticmethod
    def setValueStringArray(p: "AbstractProperty", aStringArray: "ArrayStr") -> "void":
        return _common.PropertyHelper_setValueStringArray(p, aStringArray)

    @staticmethod
    def removeItem(p: "AbstractProperty", index: "int") -> "void":
        return _common.PropertyHelper_removeItem(p, index)

    def __init__(self):
        _common.PropertyHelper_swiginit(self, _common.new_PropertyHelper())
    __swig_destroy__ = _common.delete_PropertyHelper

# Register PropertyHelper in _common:
_common.PropertyHelper_swigregister(PropertyHelper)

def PropertyHelper_getValueBool(p: "AbstractProperty", index: "int"=-1) -> "bool":
    return _common.PropertyHelper_getValueBool(p, index)

def PropertyHelper_setValueBool(v: "bool", p: "AbstractProperty", index: "int"=-1) -> "void":
    return _common.PropertyHelper_setValueBool(v, p, index)

def PropertyHelper_appendValueBool(v: "bool", p: "AbstractProperty") -> "void":
    return _common.PropertyHelper_appendValueBool(v, p)

def PropertyHelper_getValueInt(p: "AbstractProperty", index: "int"=-1) -> "int":
    return _common.PropertyHelper_getValueInt(p, index)

def PropertyHelper_setValueInt(v: "int", p: "AbstractProperty", index: "int"=-1) -> "void":
    return _common.PropertyHelper_setValueInt(v, p, index)

def PropertyHelper_appendValueInt(v: "int", p: "AbstractProperty") -> "void":
    return _common.PropertyHelper_appendValueInt(v, p)

def PropertyHelper_getValueDouble(p: "AbstractProperty", index: "int"=-1) -> "double":
    return _common.PropertyHelper_getValueDouble(p, index)

def PropertyHelper_setValueDouble(v: "double", p: "AbstractProperty", index: "int"=-1) -> "void":
    return _common.PropertyHelper_setValueDouble(v, p, index)

def PropertyHelper_appendValueDouble(v: "double", p: "AbstractProperty") -> "void":
    return _common.PropertyHelper_appendValueDouble(v, p)

def PropertyHelper_getValueString(p: "AbstractProperty", index: "int"=-1) -> "std::string":
    return _common.PropertyHelper_getValueString(p, index)

def PropertyHelper_setValueString(v: "std::string const &", p: "AbstractProperty", index: "int"=-1) -> "void":
    return _common.PropertyHelper_setValueString(v, p, index)

def PropertyHelper_appendValueString(v: "std::string const &", p: "AbstractProperty") -> "void":
    return _common.PropertyHelper_appendValueString(v, p)

def PropertyHelper_getValueTransform(p: "AbstractProperty", index: "int") -> "double":
    return _common.PropertyHelper_getValueTransform(p, index)

def PropertyHelper_setValueTransform(v: "double", p: "AbstractProperty", index: "int") -> "void":
    return _common.PropertyHelper_setValueTransform(v, p, index)

def PropertyHelper_getValueVec3(p: "AbstractProperty", index: "int") -> "double":
    return _common.PropertyHelper_getValueVec3(p, index)

def PropertyHelper_setValueVec3(v: "double", p: "AbstractProperty", index: "int") -> "void":
    return _common.PropertyHelper_setValueVec3(v, p, index)

def PropertyHelper_getValueVec6(p: "AbstractProperty", index: "int") -> "double":
    return _common.PropertyHelper_getValueVec6(p, index)

def PropertyHelper_setValueVec6(v: "double", p: "AbstractProperty", index: "int") -> "void":
    return _common.PropertyHelper_setValueVec6(v, p, index)

def PropertyHelper_getValueStringArray(p: "AbstractProperty") -> "OpenSim::Array< std::string >":
    return _common.PropertyHelper_getValueStringArray(p)

def PropertyHelper_setValueStringArray(p: "AbstractProperty", aStringArray: "ArrayStr") -> "void":
    return _common.PropertyHelper_setValueStringArray(p, aStringArray)

def PropertyHelper_removeItem(p: "AbstractProperty", index: "int") -> "void":
    return _common.PropertyHelper_removeItem(p, index)

class OpenSimObjectSet(OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Object,OpenSim::Object > *":
        return _common.OpenSimObjectSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.OpenSimObjectSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.OpenSimObjectSet_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Object,OpenSim::Object > *":
        return _common.OpenSimObjectSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.OpenSimObjectSet_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_OpenSimObjectSet

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Object,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _common.OpenSimObjectSet_swiginit(self, _common.new_OpenSimObjectSet(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _common.OpenSimObjectSet_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _common.OpenSimObjectSet_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.OpenSimObjectSet_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.OpenSimObjectSet_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Object`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.OpenSimObjectSet_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _common.OpenSimObjectSet_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "OpenSimObject") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.OpenSimObjectSet_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "OpenSimObject") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Object`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.OpenSimObjectSet_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "OpenSimObject") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.OpenSimObjectSet_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Object`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.OpenSimObjectSet_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _common.OpenSimObjectSet_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "OpenSimObject", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Object`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _common.OpenSimObjectSet_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Object &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Object`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.OpenSimObjectSet_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _common.OpenSimObjectSet_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _common.OpenSimObjectSet_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _common.OpenSimObjectSet_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _common.OpenSimObjectSet_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _common.OpenSimObjectSet_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _common.OpenSimObjectSet_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _common.OpenSimObjectSet_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _common.OpenSimObjectSet_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _common.OpenSimObjectSet_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register OpenSimObjectSet in _common:
_common.OpenSimObjectSet_swigregister(OpenSimObjectSet)

def OpenSimObjectSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Object,OpenSim::Object > *":
    return _common.OpenSimObjectSet_safeDownCast(obj)

def OpenSimObjectSet_getClassName() -> "std::string const &":
    return _common.OpenSimObjectSet_getClassName()

class StateVector(object):
    r"""
    A class which stores a vector of states or data at a specified time.
    Generally, it is used to store the time histories of the states during
    an integration.

    The format of the numerical output for this class is specified by the
    settings in IO.

    Author: Frank C. Anderson
    Version: 1.0
    See also: IO
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_StateVector

    def __init__(self, *args):
        _common.StateVector_swiginit(self, _common.new_StateVector(*args))

    def setStates(self, aT: "double", data: "Vector") -> "void":
        return _common.StateVector_setStates(self, aT, data)

    def getSize(self) -> "int":
        return _common.StateVector_getSize(self)

    def setTime(self, aT: "double") -> "void":
        return _common.StateVector_setTime(self, aT)

    def getTime(self) -> "double":
        return _common.StateVector_getTime(self)

    def getDataValue(self, aIndex: "int", rValue: "double &") -> "int":
        return _common.StateVector_getDataValue(self, aIndex, rValue)

    def setDataValue(self, aIndex: "int", aValue: "double &") -> "void":
        return _common.StateVector_setDataValue(self, aIndex, aValue)

    def getData(self) -> "OpenSim::Array< double > &":
        return _common.StateVector_getData(self)

    def shiftTime(self, aValue: "double") -> "void":
        return _common.StateVector_shiftTime(self, aValue)

    def scaleTime(self, aValue: "double") -> "void":
        return _common.StateVector_scaleTime(self, aValue)

    def add(self, *args) -> "void":
        return _common.StateVector_add(self, *args)

    def subtract(self, *args) -> "void":
        return _common.StateVector_subtract(self, *args)

    def multiply(self, *args) -> "void":
        return _common.StateVector_multiply(self, *args)

    def divide(self, *args) -> "void":
        return _common.StateVector_divide(self, *args)

# Register StateVector in _common:
_common.StateVector_swigregister(StateVector)

class ArrayStateVector(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayStateVector

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`StateVector`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::StateVector >
        :param aArray: Array to be copied.
        """
        _common.ArrayStateVector_swiginit(self, _common.new_ArrayStateVector(*args))

    def arrayEquals(self, aArray: "ArrayStateVector") -> "bool":
        return _common.ArrayStateVector_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayStateVector_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayStateVector_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayStateVector_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayStateVector_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`StateVector`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::StateVector >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayStateVector_append(self, *args)

    def insert(self, aIndex: "int", aValue: "StateVector") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`StateVector`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayStateVector_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayStateVector_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "StateVector") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`StateVector`
        :param aValue: Value.
        """
        return _common.ArrayStateVector_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::StateVector const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`StateVector`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayStateVector_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::StateVector":
        return _common.ArrayStateVector_getitem(self, index)

    def setitem(self, index: "int", val: "StateVector") -> "void":
        return _common.ArrayStateVector_setitem(self, index, val)

    def getLast(self) -> "OpenSim::StateVector const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`StateVector`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayStateVector_getLast(self)

    def findIndex(self, aValue: "StateVector") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`StateVector`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayStateVector_findIndex(self, aValue)

    def rfindIndex(self, aValue: "StateVector") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`StateVector`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayStateVector_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "StateVector", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`StateVector`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayStateVector_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayStateVector in _common:
_common.ArrayStateVector_swigregister(ArrayStateVector)

class StorageInterface(OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::StorageInterface *":
        return _common.StorageInterface_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.StorageInterface_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.StorageInterface_getClassName()

    def clone(self) -> "OpenSim::StorageInterface *":
        return _common.StorageInterface_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.StorageInterface_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_StorageInterface

    def getSize(self) -> "int":
        return _common.StorageInterface_getSize(self)

    def getStateVector(self, aTimeIndex: "int") -> "OpenSim::StateVector *":
        return _common.StorageInterface_getStateVector(self, aTimeIndex)

    def getLastStateVector(self) -> "OpenSim::StateVector *":
        return _common.StorageInterface_getLastStateVector(self)

    def getFirstTime(self) -> "double":
        return _common.StorageInterface_getFirstTime(self)

    def getLastTime(self) -> "double":
        return _common.StorageInterface_getLastTime(self)

    def getTimeColumn(self, rTimes: "ArrayDouble", aStateIndex: "int"=-1) -> "int":
        return _common.StorageInterface_getTimeColumn(self, rTimes, aStateIndex)

    def getTimeColumnWithStartTime(self, rTimes: "ArrayDouble", startTime: "double"=0.0) -> "void":
        return _common.StorageInterface_getTimeColumnWithStartTime(self, rTimes, startTime)

    def getDataAtTime(self, aTime: "double", aN: "int", rData: "ArrayDouble") -> "int":
        return _common.StorageInterface_getDataAtTime(self, aTime, aN, rData)

    def getDataColumn(self, columnName: "std::string const &", data: "ArrayDouble", startTime: "double"=0.0) -> "void":
        return _common.StorageInterface_getDataColumn(self, columnName, data, startTime)

    def append(self, *args) -> "int":
        return _common.StorageInterface_append(self, *args)

    def store(self, aStep: "int", aT: "double", aN: "int", aY: "double const *") -> "int":
        return _common.StorageInterface_store(self, aStep, aT, aN, aY)

    def findIndex(self, *args) -> "int":
        return _common.StorageInterface_findIndex(self, *args)

    def setOutputFileName(self, aFileName: "std::string const &") -> "void":
        return _common.StorageInterface_setOutputFileName(self, aFileName)

# Register StorageInterface in _common:
_common.StorageInterface_swigregister(StorageInterface)

def StorageInterface_safeDownCast(obj: "OpenSimObject") -> "OpenSim::StorageInterface *":
    return _common.StorageInterface_safeDownCast(obj)

def StorageInterface_getClassName() -> "std::string const &":
    return _common.StorageInterface_getClassName()

class Storage(StorageInterface):
    r"""
    A class for storing an array of statevectors.  A statevector is an
    array of data that has an associated time stamp (see StateVector).
    Generally, it is used to store the time histories of the states during
    an integration, but may be used for a variety of applications.  Note that
    it is assumed by several methods in this class that the time stamps of
    stored statevectors are monotonically increasing.

    When stored as a file, the statevectors are stored in rows.  This first
    value in a row is the time stamp at which the states occurred.  The
    rest of the elements in a row are the states.  Therefore, each column of
    data in a file corresponds to a particular state.

    In an Storage object, statevectors (or rows) are indexed by the
    TimeIndex, and a particular state (or column) is indexed by the
    StateIndex.

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Storage *":
        return _common.Storage_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Storage_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Storage_getClassName()

    def clone(self) -> "OpenSim::Storage *":
        return _common.Storage_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Storage_getConcreteClassName(self)
    DEFAULT_HEADER_TOKEN = property(_common.Storage_DEFAULT_HEADER_TOKEN_get, _common.Storage_DEFAULT_HEADER_TOKEN_set, doc=r"""
    Default token used to mark the end of the storage description in
       a file.
    """)
    DEFAULT_HEADER_SEPARATOR = property(_common.Storage_DEFAULT_HEADER_SEPARATOR_get, _common.Storage_DEFAULT_HEADER_SEPARATOR_set)

    def __init__(self, *args):
        _common.Storage_swiginit(self, _common.new_Storage(*args))
    __swig_destroy__ = _common.delete_Storage

    def getName(self) -> "std::string const &":
        return _common.Storage_getName(self)

    def getDescription(self) -> "std::string const &":
        return _common.Storage_getDescription(self)

    def setName(self, aName: "std::string const &") -> "void":
        return _common.Storage_setName(self, aName)

    def setDescription(self, aDescription: "std::string const &") -> "void":
        return _common.Storage_setDescription(self, aDescription)

    @staticmethod
    def getLatestVersion() -> "int const &":
        return _common.Storage_getLatestVersion()

    def getFileVersion(self) -> "int const &":
        return _common.Storage_getFileVersion(self)

    def getSize(self) -> "int":
        return _common.Storage_getSize(self)

    def getSmallestNumberOfStates(self) -> "int":
        return _common.Storage_getSmallestNumberOfStates(self)

    def getStateVector(self, aTimeIndex: "int") -> "OpenSim::StateVector *":
        return _common.Storage_getStateVector(self, aTimeIndex)

    def getLastStateVector(self) -> "OpenSim::StateVector *":
        return _common.Storage_getLastStateVector(self)

    def getFirstTime(self) -> "double":
        return _common.Storage_getFirstTime(self)

    def getLastTime(self) -> "double":
        return _common.Storage_getLastTime(self)

    def getMinTimeStep(self) -> "double":
        return _common.Storage_getMinTimeStep(self)

    def getTime(self, aTimeIndex: "int", rTime: "double &", aStateIndex: "int"=-1) -> "bool":
        return _common.Storage_getTime(self, aTimeIndex, rTime, aStateIndex)

    def getTimeColumn(self, *args) -> "int":
        return _common.Storage_getTimeColumn(self, *args)

    def getTimeColumnWithStartTime(self, rTimes: "ArrayDouble", startTime: "double"=0.0) -> "void":
        return _common.Storage_getTimeColumnWithStartTime(self, rTimes, startTime)

    def addKeyValuePair(self, aKey: "std::string const &", aValue: "std::string const &") -> "void":
        return _common.Storage_addKeyValuePair(self, aKey, aValue)

    def getValueForKey(self, aKey: "std::string const &", rValue: "std::string &") -> "void":
        return _common.Storage_getValueForKey(self, aKey, rValue)

    def hasKey(self, aKey: "std::string const &") -> "bool":
        return _common.Storage_hasKey(self, aKey)

    def isInDegrees(self) -> "bool":
        return _common.Storage_isInDegrees(self)

    def setInDegrees(self, isInDegrees: "bool const") -> "void":
        return _common.Storage_setInDegrees(self, isInDegrees)

    def getData(self, *args) -> "int":
        return _common.Storage_getData(self, *args)

    def getDataAtTime(self, *args) -> "int":
        return _common.Storage_getDataAtTime(self, *args)

    def setDataColumnToFixedValue(self, columnName: "std::string const &", newValue: "double") -> "void":
        return _common.Storage_setDataColumnToFixedValue(self, columnName, newValue)

    def setDataColumn(self, aStateIndex: "int", aData: "ArrayDouble") -> "void":
        return _common.Storage_setDataColumn(self, aStateIndex, aData)

    def getDataColumn(self, *args) -> "void":
        return _common.Storage_getDataColumn(self, *args)

    def exportToTable(self) -> "TimeSeriesTable":
        r"""
        Convert to a TimeSeriesTable. This may be useful if you need to use
           parts of the API that require a TimeSeriesTable instead of a Storage.
        """
        return _common.Storage_exportToTable(self)

    def getColumnIndicesForIdentifier(self, identifier: "std::string const &") -> "OpenSim::Array< int >":
        r"""
        Get indices of columns whose labels begin with the specified "identifier"
        (prefix). Returns an empty Array if none of the column labels begin with
        the identifier.
        """
        return _common.Storage_getColumnIndicesForIdentifier(self, identifier)

    def setStepInterval(self, aStepInterval: "int") -> "void":
        return _common.Storage_setStepInterval(self, aStepInterval)

    def getStepInterval(self) -> "int":
        return _common.Storage_getStepInterval(self)

    def setCapacityIncrement(self, aIncrement: "int") -> "void":
        return _common.Storage_setCapacityIncrement(self, aIncrement)

    def getCapacityIncrement(self) -> "int":
        return _common.Storage_getCapacityIncrement(self)

    def setWriteSIMMHeader(self, aTrueFalse: "bool") -> "void":
        return _common.Storage_setWriteSIMMHeader(self, aTrueFalse)

    def getWriteSIMMHeader(self) -> "bool":
        return _common.Storage_getWriteSIMMHeader(self)

    def setHeaderToken(self, aToken: "std::string const &") -> "void":
        return _common.Storage_setHeaderToken(self, aToken)

    def getHeaderToken(self) -> "std::string const &":
        return _common.Storage_getHeaderToken(self)

    def getStateIndex(self, aColumnName: "std::string const &", startIndex: "int"=0) -> "int":
        r"""
         Get the column index corresponding to specified column name. This
        function attempts to handle the change in state variable names that
        occurred in OpenSim version 4.0; for example, if you search for
        `<coord-name>/speed` and it is not found, then this function looks for
        `<coord-name>_u`.

        :rtype: int
        :return: State index of column or -1.  Note that the returned index is
            equivalent to the state index.  For example, for the first column in a
            storage (usually time) -1 would be returned.  For the second column in a
            storage (the first state) 0 would be returned.
        """
        return _common.Storage_getStateIndex(self, aColumnName, startIndex)

    def setColumnLabels(self, aColumnLabels: "ArrayStr") -> "void":
        return _common.Storage_setColumnLabels(self, aColumnLabels)

    def getColumnLabels(self) -> "OpenSim::Array< std::string > const &":
        return _common.Storage_getColumnLabels(self)

    def reset(self, *args) -> "int":
        return _common.Storage_reset(self, *args)

    def purge(self) -> "void":
        return _common.Storage_purge(self)

    def crop(self, newStartTime: "double const", newFinalTime: "double const") -> "void":
        return _common.Storage_crop(self, newStartTime, newFinalTime)

    def append(self, *args) -> "int":
        return _common.Storage_append(self, *args)

    def store(self, aStep: "int", aT: "double", aN: "int", aY: "double const *") -> "int":
        return _common.Storage_store(self, aStep, aT, aN, aY)

    def shiftTime(self, aValue: "double") -> "void":
        return _common.Storage_shiftTime(self, aValue)

    def scaleTime(self, aValue: "double") -> "void":
        return _common.Storage_scaleTime(self, aValue)

    def add(self, *args) -> "void":
        return _common.Storage_add(self, *args)

    def subtract(self, *args) -> "void":
        return _common.Storage_subtract(self, *args)

    def multiplyColumn(self, aIndex: "int", aValue: "double") -> "void":
        return _common.Storage_multiplyColumn(self, aIndex, aValue)

    def multiply(self, *args) -> "void":
        return _common.Storage_multiply(self, *args)

    def divide(self, *args) -> "void":
        return _common.Storage_divide(self, *args)

    def integrate(self, *args) -> "OpenSim::Storage *":
        return _common.Storage_integrate(self, *args)

    def computeArea(self, *args) -> "int":
        return _common.Storage_computeArea(self, *args)

    def computeAverage(self, *args) -> "int":
        return _common.Storage_computeAverage(self, *args)

    def pad(self, aPadSize: "int") -> "void":
        return _common.Storage_pad(self, aPadSize)

    def smoothSpline(self, order: "int", cutoffFrequency: "double") -> "void":
        r"""
        Smooth spline each of the columns in the storage.  Note that as a part
        of this operation, the storage is re-sampled to obtain uniform samples
        unless its time steps are already uniform.

        :type order: int
        :param order: Order of the spline.
        :type cutoffFrequency: float
        :param cutoffFrequency: Cutoff frequency of the smoothing filter.
        """
        return _common.Storage_smoothSpline(self, order, cutoffFrequency)

    def lowpassIIR(self, cutoffFrequency: "double") -> "void":
        r"""
        Low-pass filter each of the columns in the storage using a 3rd order
        lowpass IIR Butterworth digital filter. Note that as a part of this
        operation, the storage is re-sampled to obtain uniform samples unless
        its time steps are already uniform.

        :type cutoffFrequency: float
        :param cutoffFrequency: Cutoff frequency of the lowpass filter.
        """
        return _common.Storage_lowpassIIR(self, cutoffFrequency)

    def lowpassFIR(self, order: "int", cutoffFrequency: "double") -> "void":
        r"""
        Lowpass filter each of the columns in the storage using an FIR non-
        recursive digital filter. Note that as a part of this operation, the
        storage is re-sampled to obtain uniform samples unless its time steps
        are already uniform.

        :type order: int
        :param order: Order of the FIR filter.
        :type cutoffFrequency: float
        :param cutoffFrequency: Cutoff frequency.
        """
        return _common.Storage_lowpassFIR(self, order, cutoffFrequency)

    def addToRdStorage(self, rStorage: "Storage", aStartTime: "double", aEndTime: "double") -> "void":
        return _common.Storage_addToRdStorage(self, rStorage, aStartTime, aEndTime)

    def findIndex(self, *args) -> "int":
        return _common.Storage_findIndex(self, *args)

    def findFrameRange(self, aStartTime: "double", aEndTime: "double", oStartFrame: "int &", oEndFrame: "int &") -> "void":
        return _common.Storage_findFrameRange(self, aStartTime, aEndTime, oStartFrame, oEndFrame)

    def resample(self, aDT: "double", aDegree: "int") -> "double":
        return _common.Storage_resample(self, aDT, aDegree)

    def resampleLinear(self, aDT: "double") -> "double":
        return _common.Storage_resampleLinear(self, aDT)

    def compareColumn(self, aOtherStorage: "Storage", aColumnName: "std::string const &", startTime: "double", endTime: "double"=-1.0) -> "double":
        return _common.Storage_compareColumn(self, aOtherStorage, aColumnName, startTime, endTime)

    def compareColumnRMS(self, *args) -> "double":
        return _common.Storage_compareColumnRMS(self, *args)

    def compareWithStandard(self, standard: "Storage", columnsUsed: "StdVectorString", comparisons: "StdVectorDouble") -> "void":
        return _common.Storage_compareWithStandard(self, standard, columnsUsed, comparisons)

    def makeStorageLabelsUnique(self) -> "bool":
        r"""
         Force column labels for a Storage object to become unique. This is done
        by prepending the string (n_) as needed where n=1, 2, ...

        :rtype: boolean
        :return: true if labels were already unique.
        """
        return _common.Storage_makeStorageLabelsUnique(self)

    def storageLabelsAreUnique(self) -> "bool":
        return _common.Storage_storageLabelsAreUnique(self)

    def printToXML(self, *args) -> "bool":
        return _common.Storage_printToXML(self, *args)

    def printToFile(self, *args) -> "int":
        return _common.Storage_printToFile(self, *args)

    def setOutputFileName(self, aFileName: "std::string const &") -> "void":
        return _common.Storage_setOutputFileName(self, aFileName)

    @staticmethod
    def printResult(aStorage: "Storage", aName: "std::string const &", aDir: "std::string const &", aDT: "double", aExtension: "std::string const &") -> "void":
        return _common.Storage_printResult(aStorage, aName, aDir, aDT, aExtension)

    def interpolateAt(self, targetTimes: "ArrayDouble") -> "void":
        return _common.Storage_interpolateAt(self, targetTimes)

# Register Storage in _common:
_common.Storage_swigregister(Storage)
Storage_DEFAULT_CAPACITY = cvar.Storage_DEFAULT_CAPACITY

def Storage_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Storage *":
    return _common.Storage_safeDownCast(obj)

def Storage_getClassName() -> "std::string const &":
    return _common.Storage_getClassName()
Storage.MAX_RESAMPLE_SIZE = _common.cvar.Storage_MAX_RESAMPLE_SIZE

def Storage_getLatestVersion() -> "int const &":
    return _common.Storage_getLatestVersion()

def Storage_printResult(aStorage: "Storage", aName: "std::string const &", aDir: "std::string const &", aDT: "double", aExtension: "std::string const &") -> "void":
    return _common.Storage_printResult(aStorage, aName, aDir, aDT, aExtension)

class ArrayStorage(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayStorage

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Storage >
        :param aArray: Array to be copied.
        """
        _common.ArrayStorage_swiginit(self, _common.new_ArrayStorage(*args))

    def clearAndDestroy(self) -> "void":
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _common.ArrayStorage_clearAndDestroy(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.ArrayStorage_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayStorage_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayStorage_size(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Storage >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.ArrayStorage_getIndex(self, *args)

    def append(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`Storage`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Storage >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.ArrayStorage_append(self, *args)

    def insert(self, aIndex: "int", aObject: "Storage") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Storage`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.ArrayStorage_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Storage >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.ArrayStorage_remove(self, *args)

    def set(self, aIndex: "int", aObject: "Storage") -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Storage`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _common.ArrayStorage_set(self, aIndex, aObject)

    def get(self, *args) -> "OpenSim::Storage *":
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Storage`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Storage`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Storage`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.ArrayStorage_get(self, *args)

    def getLast(self) -> "OpenSim::Storage *":
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`Storage`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`Storage`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayStorage_getLast(self)

    def searchBinary(self, aObject: "OpenSim::ArrayPtrs< OpenSim::Storage >::ConstT &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayStorage_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register ArrayStorage in _common:
_common.ArrayStorage_swigregister(ArrayStorage)

class Units(object):
    r"""
    A class implementing various units for measuring quantities.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UnknownUnits = _common.Units_UnknownUnits
    Radians = _common.Units_Radians
    Degrees = _common.Units_Degrees
    Millimeters = _common.Units_Millimeters
    Centimeters = _common.Units_Centimeters
    Meters = _common.Units_Meters
    Seconds = _common.Units_Seconds
    Milliseconds = _common.Units_Milliseconds
    Newtons = _common.Units_Newtons

    def __init__(self, *args):
        _common.Units_swiginit(self, _common.new_Units(*args))
    __swig_destroy__ = _common.delete_Units

    def convertTo(self, *args) -> "double":
        return _common.Units_convertTo(self, *args)

    def getType(self) -> "OpenSim::Units::UnitType":
        return _common.Units_getType(self)

    def getLabel(self) -> "std::string":
        return _common.Units_getLabel(self)

    def getAbbreviation(self) -> "std::string":
        return _common.Units_getAbbreviation(self)

# Register Units in _common:
_common.Units_swigregister(Units)

class IO(object):
    r"""
    A class for performing input and output with OpenSim API.

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def ConstructDateAndTimeStamp() -> "char *":
        return _common.IO_ConstructDateAndTimeStamp()

    @staticmethod
    def FixSlashesInFilePath(path: "std::string const &") -> "std::string":
        return _common.IO_FixSlashesInFilePath(path)

    @staticmethod
    def SetScientific(aTrueFalse: "bool") -> "void":
        return _common.IO_SetScientific(aTrueFalse)

    @staticmethod
    def GetScientific() -> "bool":
        return _common.IO_GetScientific()

    @staticmethod
    def SetGFormatForDoubleOutput(aTrueFalse: "bool") -> "void":
        return _common.IO_SetGFormatForDoubleOutput(aTrueFalse)

    @staticmethod
    def GetGFormatForDoubleOutput() -> "bool":
        return _common.IO_GetGFormatForDoubleOutput()

    @staticmethod
    def SetDigitsPad(aPad: "int") -> "void":
        return _common.IO_SetDigitsPad(aPad)

    @staticmethod
    def GetDigitsPad() -> "int":
        return _common.IO_GetDigitsPad()

    @staticmethod
    def SetPrecision(aPlaces: "int") -> "void":
        return _common.IO_SetPrecision(aPlaces)

    @staticmethod
    def GetPrecision() -> "int":
        return _common.IO_GetPrecision()

    @staticmethod
    def GetDoubleOutputFormat() -> "char const *":
        return _common.IO_GetDoubleOutputFormat()

    @staticmethod
    def SetPrintOfflineDocuments(aTrueFalse: "bool") -> "void":
        return _common.IO_SetPrintOfflineDocuments(aTrueFalse)

    @staticmethod
    def GetPrintOfflineDocuments() -> "bool":
        return _common.IO_GetPrintOfflineDocuments()

    @staticmethod
    def makeDir(aDirName: "std::string const &") -> "int":
        return _common.IO_makeDir(aDirName)

    @staticmethod
    def chDir(aDirName: "std::string const &") -> "int":
        return _common.IO_chDir(aDirName)

    @staticmethod
    def getCwd() -> "std::string":
        return _common.IO_getCwd()

    @staticmethod
    def getParentDirectory(fileName: "std::string const &") -> "std::string":
        return _common.IO_getParentDirectory(fileName)

    @staticmethod
    def GetFileNameFromURI(aURI: "std::string const &") -> "std::string":
        return _common.IO_GetFileNameFromURI(aURI)

    @staticmethod
    def formatText(*args) -> "std::string":
        return _common.IO_formatText(*args)

    @staticmethod
    def GetSuffix(aStr: "std::string const &", aLen: "int") -> "std::string":
        return _common.IO_GetSuffix(aStr, aLen)

    @staticmethod
    def RemoveSuffix(rStr: "std::string &", aLen: "int") -> "void":
        return _common.IO_RemoveSuffix(rStr, aLen)

    @staticmethod
    def replaceSubstring(aStr: "std::string const &", aFrom: "std::string const &", aTo: "std::string const &") -> "std::string":
        return _common.IO_replaceSubstring(aStr, aFrom, aTo)

    @staticmethod
    def TrimLeadingWhitespace(rStr: "std::string &") -> "void":
        return _common.IO_TrimLeadingWhitespace(rStr)

    @staticmethod
    def TrimTrailingWhitespace(rStr: "std::string &") -> "void":
        return _common.IO_TrimTrailingWhitespace(rStr)

    @staticmethod
    def TrimWhitespace(rStr: "std::string &") -> "void":
        return _common.IO_TrimWhitespace(rStr)

    @staticmethod
    def Lowercase(aStr: "std::string const &") -> "std::string":
        return _common.IO_Lowercase(aStr)

    @staticmethod
    def Uppercase(aStr: "std::string const &") -> "std::string":
        return _common.IO_Uppercase(aStr)

    @staticmethod
    def StartsWith(string: "std::string const &", start: "std::string const &") -> "bool":
        r""" Determine if `string` starts with the substring `start`."""
        return _common.IO_StartsWith(string, start)

    @staticmethod
    def EndsWith(string: "std::string const &", ending: "std::string const &") -> "bool":
        r""" Determine if `string` ends with the substring `ending`."""
        return _common.IO_EndsWith(string, ending)

    @staticmethod
    def StartsWithIgnoringCase(string: "std::string const &", start: "std::string const &") -> "bool":
        r"""
        Same as StartsWith() except both arguments are first converted to
        lowercase before performing the check.
        """
        return _common.IO_StartsWithIgnoringCase(string, start)

    @staticmethod
    def EndsWithIgnoringCase(string: "std::string const &", ending: "std::string const &") -> "bool":
        r"""
        Same as EndsWith() except both arguments are first converted to
        lowercase before performing the check.
        """
        return _common.IO_EndsWithIgnoringCase(string, ending)

    @staticmethod
    def eraseEmptyElements(list: "StdVectorString") -> "void":
        return _common.IO_eraseEmptyElements(list)

    def __init__(self):
        _common.IO_swiginit(self, _common.new_IO())
    __swig_destroy__ = _common.delete_IO

# Register IO in _common:
_common.IO_swigregister(IO)
IO_STRLEN = cvar.IO_STRLEN

def IO_ConstructDateAndTimeStamp() -> "char *":
    return _common.IO_ConstructDateAndTimeStamp()

def IO_FixSlashesInFilePath(path: "std::string const &") -> "std::string":
    return _common.IO_FixSlashesInFilePath(path)

def IO_SetScientific(aTrueFalse: "bool") -> "void":
    return _common.IO_SetScientific(aTrueFalse)

def IO_GetScientific() -> "bool":
    return _common.IO_GetScientific()

def IO_SetGFormatForDoubleOutput(aTrueFalse: "bool") -> "void":
    return _common.IO_SetGFormatForDoubleOutput(aTrueFalse)

def IO_GetGFormatForDoubleOutput() -> "bool":
    return _common.IO_GetGFormatForDoubleOutput()

def IO_SetDigitsPad(aPad: "int") -> "void":
    return _common.IO_SetDigitsPad(aPad)

def IO_GetDigitsPad() -> "int":
    return _common.IO_GetDigitsPad()

def IO_SetPrecision(aPlaces: "int") -> "void":
    return _common.IO_SetPrecision(aPlaces)

def IO_GetPrecision() -> "int":
    return _common.IO_GetPrecision()

def IO_GetDoubleOutputFormat() -> "char const *":
    return _common.IO_GetDoubleOutputFormat()

def IO_SetPrintOfflineDocuments(aTrueFalse: "bool") -> "void":
    return _common.IO_SetPrintOfflineDocuments(aTrueFalse)

def IO_GetPrintOfflineDocuments() -> "bool":
    return _common.IO_GetPrintOfflineDocuments()

def IO_makeDir(aDirName: "std::string const &") -> "int":
    return _common.IO_makeDir(aDirName)

def IO_chDir(aDirName: "std::string const &") -> "int":
    return _common.IO_chDir(aDirName)

def IO_getCwd() -> "std::string":
    return _common.IO_getCwd()

def IO_getParentDirectory(fileName: "std::string const &") -> "std::string":
    return _common.IO_getParentDirectory(fileName)

def IO_GetFileNameFromURI(aURI: "std::string const &") -> "std::string":
    return _common.IO_GetFileNameFromURI(aURI)

def IO_formatText(*args) -> "std::string":
    return _common.IO_formatText(*args)

def IO_GetSuffix(aStr: "std::string const &", aLen: "int") -> "std::string":
    return _common.IO_GetSuffix(aStr, aLen)

def IO_RemoveSuffix(rStr: "std::string &", aLen: "int") -> "void":
    return _common.IO_RemoveSuffix(rStr, aLen)

def IO_replaceSubstring(aStr: "std::string const &", aFrom: "std::string const &", aTo: "std::string const &") -> "std::string":
    return _common.IO_replaceSubstring(aStr, aFrom, aTo)

def IO_TrimLeadingWhitespace(rStr: "std::string &") -> "void":
    return _common.IO_TrimLeadingWhitespace(rStr)

def IO_TrimTrailingWhitespace(rStr: "std::string &") -> "void":
    return _common.IO_TrimTrailingWhitespace(rStr)

def IO_TrimWhitespace(rStr: "std::string &") -> "void":
    return _common.IO_TrimWhitespace(rStr)

def IO_Lowercase(aStr: "std::string const &") -> "std::string":
    return _common.IO_Lowercase(aStr)

def IO_Uppercase(aStr: "std::string const &") -> "std::string":
    return _common.IO_Uppercase(aStr)

def IO_StartsWith(string: "std::string const &", start: "std::string const &") -> "bool":
    r""" Determine if `string` starts with the substring `start`."""
    return _common.IO_StartsWith(string, start)

def IO_EndsWith(string: "std::string const &", ending: "std::string const &") -> "bool":
    r""" Determine if `string` ends with the substring `ending`."""
    return _common.IO_EndsWith(string, ending)

def IO_StartsWithIgnoringCase(string: "std::string const &", start: "std::string const &") -> "bool":
    r"""
    Same as StartsWith() except both arguments are first converted to
    lowercase before performing the check.
    """
    return _common.IO_StartsWithIgnoringCase(string, start)

def IO_EndsWithIgnoringCase(string: "std::string const &", ending: "std::string const &") -> "bool":
    r"""
    Same as EndsWith() except both arguments are first converted to
    lowercase before performing the check.
    """
    return _common.IO_EndsWithIgnoringCase(string, ending)

def IO_eraseEmptyElements(list: "StdVectorString") -> "void":
    return _common.IO_eraseEmptyElements(list)

class Function(OpenSimObject):
    r"""
    An abstract class for representing a function.

    A function is a relation between independent variables and a dependent
    value such that for any particular set of independent variables there is
    only one unique dependent value.  Values of the function and its derivatives
    are obtained by calling the calcValue() method.  The curve may or may not
    be finite or differentiable; the calcValue() method returns values between
    -`SimTK::Infinity` and `SimTK::Infinity`, or it returns `SimTK::NaN`
    (not a number) if the curve is not defined.
    Currently, functions of up to 3 variables (x,y,z) are supported.

    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Function *":
        return _common.Function_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Function_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Function_getClassName()

    def clone(self) -> "OpenSim::Function *":
        return _common.Function_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Function_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_Function

    def init(self, aFunction: "Function") -> "void":
        return _common.Function_init(self, aFunction)

    @staticmethod
    def makeFunctionOfType(aFunction: "Function", aNewTypeName: "std::string const &") -> "OpenSim::Function *":
        return _common.Function_makeFunctionOfType(aFunction, aNewTypeName)

    def calcValue(self, x: "Vector") -> "double":
        r"""
        Calculate the value of this function at a particular point.

        :type x: :py:class:`Vector`
        :param x: the Vector of input arguments.
                     its size must equal the value returned by getArgumentSize().
        """
        return _common.Function_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        r"""
        Calculate a partial derivative of this function at a particular point.  Which derivative to take is specified
        by listing the input components with which to take it.  For example, if derivComponents=={0}, that indicates
        a first derivative with respective to component 0.  If derivComponents=={0, 0, 0}, that indicates a third
        derivative with respective to component 0.  If derivComponents=={4, 7}, that indicates a partial second derivative with
        respect to components 4 and 7.

        :type derivComponents: std::vector< int,std::allocator< int > >
        :param derivComponents:  the input components with respect to which the derivative should be taken.  Its size must be
                                    less than or equal to the value returned by getMaxDerivativeOrder().
        :type x: :py:class:`Vector`
        :param x:                the Vector of input arguments.  Its size must equal the value returned by getArgumentSize().
        """
        return _common.Function_calcDerivative(self, derivComponents, x)

    def getArgumentSize(self) -> "int":
        r"""Get the number of components expected in the input vector."""
        return _common.Function_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        r"""Get the maximum derivative order this Function object can calculate."""
        return _common.Function_getMaxDerivativeOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        r"""
        Return a SimTK::Function that can be used natively by the
        underlying SimTK::System and its elements.
        """
        return _common.Function_createSimTKFunction(self)

# Register Function in _common:
_common.Function_swigregister(Function)

def Function_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Function *":
    return _common.Function_safeDownCast(obj)

def Function_getClassName() -> "std::string const &":
    return _common.Function_getClassName()

def Function_makeFunctionOfType(aFunction: "Function", aNewTypeName: "std::string const &") -> "OpenSim::Function *":
    return _common.Function_makeFunctionOfType(aFunction, aNewTypeName)

class SetFunctions(OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Function,OpenSim::Object > *":
        return _common.SetFunctions_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.SetFunctions_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.SetFunctions_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Function,OpenSim::Object > *":
        return _common.SetFunctions_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.SetFunctions_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_SetFunctions

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Function,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _common.SetFunctions_swiginit(self, _common.new_SetFunctions(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _common.SetFunctions_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _common.SetFunctions_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.SetFunctions_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.SetFunctions_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Function`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.SetFunctions_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _common.SetFunctions_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Function") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Function`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.SetFunctions_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Function") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Function`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.SetFunctions_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Function") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Function`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.SetFunctions_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Function`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.SetFunctions_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _common.SetFunctions_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Function", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Function`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _common.SetFunctions_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Function &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Function`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Function`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.SetFunctions_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _common.SetFunctions_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _common.SetFunctions_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _common.SetFunctions_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _common.SetFunctions_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _common.SetFunctions_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _common.SetFunctions_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _common.SetFunctions_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _common.SetFunctions_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _common.SetFunctions_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetFunctions in _common:
_common.SetFunctions_swigregister(SetFunctions)

def SetFunctions_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Function,OpenSim::Object > *":
    return _common.SetFunctions_safeDownCast(obj)

def SetFunctions_getClassName() -> "std::string const &":
    return _common.SetFunctions_getClassName()

class FunctionSet(SetFunctions):
    r"""
    A class for holding a set of functions.

    See also: Function
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::FunctionSet *":
        return _common.FunctionSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.FunctionSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.FunctionSet_getClassName()

    def clone(self) -> "OpenSim::FunctionSet *":
        return _common.FunctionSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.FunctionSet_getConcreteClassName(self)

    def __init__(self, *args):
        _common.FunctionSet_swiginit(self, _common.new_FunctionSet(*args))
    __swig_destroy__ = _common.delete_FunctionSet

    def evaluate(self, *args) -> "void":
        return _common.FunctionSet_evaluate(self, *args)

    def adoptAndAppend(self, aFunction):
        aFunction._markAdopted()
        return super(FunctionSet, self).adoptAndAppend(aFunction)


# Register FunctionSet in _common:
_common.FunctionSet_swigregister(FunctionSet)

def FunctionSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::FunctionSet *":
    return _common.FunctionSet_safeDownCast(obj)

def FunctionSet_getClassName() -> "std::string const &":
    return _common.FunctionSet_getClassName()

class Constant(Function):
    r"""
    A class for representing a constant value.

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Peter Loan, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Constant *":
        return _common.Constant_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Constant_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Constant_getClassName()

    def clone(self) -> "OpenSim::Constant *":
        return _common.Constant_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Constant_getConcreteClassName(self)

    def __init__(self, *args):
        _common.Constant_swiginit(self, _common.new_Constant(*args))
    __swig_destroy__ = _common.delete_Constant

    def setValue(self, aValue: "double") -> "void":
        return _common.Constant_setValue(self, aValue)

    def calcValue(self, xUnused: "Vector") -> "double":
        return _common.Constant_calcValue(self, xUnused)

    def getValue(self) -> "double":
        return _common.Constant_getValue(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.Constant_createSimTKFunction(self)

# Register Constant in _common:
_common.Constant_swigregister(Constant)

def Constant_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Constant *":
    return _common.Constant_safeDownCast(obj)

def Constant_getClassName() -> "std::string const &":
    return _common.Constant_getClassName()

class SimmSpline(Function):
    r"""
    A class implementing a smooth function with a cubic spline as
    implemented in SIMM. Use a SIMM Spline if you want to reproduce
    the behavior of a joint function created in SIMM.

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SimmSpline *":
        return _common.SimmSpline_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.SimmSpline_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.SimmSpline_getClassName()

    def clone(self) -> "OpenSim::SimmSpline *":
        return _common.SimmSpline_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.SimmSpline_getConcreteClassName(self)

    def __init__(self, *args):
        _common.SimmSpline_swiginit(self, _common.new_SimmSpline(*args))
    __swig_destroy__ = _common.delete_SimmSpline

    def init(self, aFunction: "Function") -> "void":
        return _common.SimmSpline_init(self, aFunction)

    def getSize(self) -> "int":
        return _common.SimmSpline_getSize(self)

    def getXValues(self) -> "double const *":
        return _common.SimmSpline_getXValues(self)

    def getYValues(self) -> "double const *":
        return _common.SimmSpline_getYValues(self)

    def getNumberOfPoints(self) -> "int":
        return _common.SimmSpline_getNumberOfPoints(self)

    def getX(self, *args) -> "double":
        return _common.SimmSpline_getX(self, *args)

    def getY(self, *args) -> "double":
        return _common.SimmSpline_getY(self, *args)

    def getZ(self, aIndex: "int") -> "double":
        return _common.SimmSpline_getZ(self, aIndex)

    def setX(self, aIndex: "int", aValue: "double") -> "void":
        return _common.SimmSpline_setX(self, aIndex, aValue)

    def setY(self, aIndex: "int", aValue: "double") -> "void":
        return _common.SimmSpline_setY(self, aIndex, aValue)

    def deletePoint(self, aIndex: "int") -> "bool":
        return _common.SimmSpline_deletePoint(self, aIndex)

    def deletePoints(self, indices: "ArrayInt") -> "bool":
        return _common.SimmSpline_deletePoints(self, indices)

    def addPoint(self, aX: "double", aY: "double") -> "int":
        return _common.SimmSpline_addPoint(self, aX, aY)

    def calcValue(self, x: "Vector") -> "double":
        return _common.SimmSpline_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        return _common.SimmSpline_calcDerivative(self, derivComponents, x)

    def getArgumentSize(self) -> "int":
        return _common.SimmSpline_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        return _common.SimmSpline_getMaxDerivativeOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.SimmSpline_createSimTKFunction(self)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _common.SimmSpline_updateFromXMLNode(self, aNode, versionNumber)

# Register SimmSpline in _common:
_common.SimmSpline_swigregister(SimmSpline)

def SimmSpline_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SimmSpline *":
    return _common.SimmSpline_safeDownCast(obj)

def SimmSpline_getClassName() -> "std::string const &":
    return _common.SimmSpline_getClassName()

class StepFunction(Function):
    r"""
    A class for representing a StepFunction.

    Defines a piecewise function (f: ), with a
    smooth "S"-shaped quintic polynomial (t):math:`from(\c startTime, \c startValue) to (\c endTime, \c endValue).The function is defined as follows:\f[f(t) =\begin{cases}startValue, & t\leq startTime\\S(t), & startTime < t \leq endTime\\endValue, & endTime < t\end{cases}The function has the following shape:html fig_StepFunction.pngThis class inherits from Function and so can be used as input toany class requiring a Function as input.Ajay Seth1.0`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::StepFunction *":
        return _common.StepFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.StepFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.StepFunction_getClassName()

    def clone(self) -> "OpenSim::StepFunction *":
        return _common.StepFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.StepFunction_getConcreteClassName(self)

    def __init__(self, *args):
        _common.StepFunction_swiginit(self, _common.new_StepFunction(*args))
    __swig_destroy__ = _common.delete_StepFunction

    def setStartTime(self, time: "double") -> "void":
        r""" %Set step transition start time"""
        return _common.StepFunction_setStartTime(self, time)

    def getStartTime(self) -> "double":
        r""" Get step transition time"""
        return _common.StepFunction_getStartTime(self)

    def setEndTime(self, time: "double") -> "void":
        r""" %Set step transition end time"""
        return _common.StepFunction_setEndTime(self, time)

    def getEndTime(self) -> "double":
        r""" Get step transition time"""
        return _common.StepFunction_getEndTime(self)

    def setStartValue(self, start: "double") -> "void":
        r""" %Set start value before step"""
        return _common.StepFunction_setStartValue(self, start)

    def getStartValue(self) -> "double":
        r""" Get start value before step"""
        return _common.StepFunction_getStartValue(self)

    def setEndValue(self, end: "double") -> "void":
        r""" %Set end value before step"""
        return _common.StepFunction_setEndValue(self, end)

    def getEndValue(self) -> "double":
        r""" Get end value before step"""
        return _common.StepFunction_getEndValue(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.StepFunction_createSimTKFunction(self)

# Register StepFunction in _common:
_common.StepFunction_swigregister(StepFunction)

def StepFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::StepFunction *":
    return _common.StepFunction_safeDownCast(obj)

def StepFunction_getClassName() -> "std::string const &":
    return _common.StepFunction_getClassName()

class PiecewiseConstantFunction(Function):
    r"""
    A class implementing a step function.

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PiecewiseConstantFunction *":
        return _common.PiecewiseConstantFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.PiecewiseConstantFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.PiecewiseConstantFunction_getClassName()

    def clone(self) -> "OpenSim::PiecewiseConstantFunction *":
        return _common.PiecewiseConstantFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.PiecewiseConstantFunction_getConcreteClassName(self)

    def __init__(self, *args):
        _common.PiecewiseConstantFunction_swiginit(self, _common.new_PiecewiseConstantFunction(*args))
    __swig_destroy__ = _common.delete_PiecewiseConstantFunction

    def init(self, aFunction: "Function") -> "void":
        return _common.PiecewiseConstantFunction_init(self, aFunction)

    def getSize(self) -> "int":
        return _common.PiecewiseConstantFunction_getSize(self)

    def getXValues(self) -> "double const *":
        return _common.PiecewiseConstantFunction_getXValues(self)

    def getYValues(self) -> "double const *":
        return _common.PiecewiseConstantFunction_getYValues(self)

    def getNumberOfPoints(self) -> "int":
        return _common.PiecewiseConstantFunction_getNumberOfPoints(self)

    def getX(self, *args) -> "double":
        return _common.PiecewiseConstantFunction_getX(self, *args)

    def getY(self, *args) -> "double":
        return _common.PiecewiseConstantFunction_getY(self, *args)

    def getZ(self, aIndex: "int") -> "double":
        return _common.PiecewiseConstantFunction_getZ(self, aIndex)

    def setX(self, aIndex: "int", aValue: "double") -> "void":
        return _common.PiecewiseConstantFunction_setX(self, aIndex, aValue)

    def setY(self, aIndex: "int", aValue: "double") -> "void":
        return _common.PiecewiseConstantFunction_setY(self, aIndex, aValue)

    def deletePoint(self, aIndex: "int") -> "bool":
        return _common.PiecewiseConstantFunction_deletePoint(self, aIndex)

    def deletePoints(self, indices: "ArrayInt") -> "bool":
        return _common.PiecewiseConstantFunction_deletePoints(self, indices)

    def addPoint(self, aX: "double", aY: "double") -> "int":
        return _common.PiecewiseConstantFunction_addPoint(self, aX, aY)

    def evaluateTotalFirstDerivative(self, aX: "double", aDxdt: "double") -> "double":
        return _common.PiecewiseConstantFunction_evaluateTotalFirstDerivative(self, aX, aDxdt)

    def evaluateTotalSecondDerivative(self, aX: "double", aDxdt: "double", aD2xdt2: "double") -> "double":
        return _common.PiecewiseConstantFunction_evaluateTotalSecondDerivative(self, aX, aDxdt, aD2xdt2)

    def calcValue(self, x: "Vector") -> "double":
        return _common.PiecewiseConstantFunction_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        return _common.PiecewiseConstantFunction_calcDerivative(self, derivComponents, x)

    def getArgumentSize(self) -> "int":
        return _common.PiecewiseConstantFunction_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        return _common.PiecewiseConstantFunction_getMaxDerivativeOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.PiecewiseConstantFunction_createSimTKFunction(self)

# Register PiecewiseConstantFunction in _common:
_common.PiecewiseConstantFunction_swigregister(PiecewiseConstantFunction)

def PiecewiseConstantFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PiecewiseConstantFunction *":
    return _common.PiecewiseConstantFunction_safeDownCast(obj)

def PiecewiseConstantFunction_getClassName() -> "std::string const &":
    return _common.PiecewiseConstantFunction_getClassName()

class LinearFunction(Function):
    r"""
    A class for representing a LinearFunction.

    dependent = slope*independent + intercept

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::LinearFunction *":
        return _common.LinearFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.LinearFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.LinearFunction_getClassName()

    def clone(self) -> "OpenSim::LinearFunction *":
        return _common.LinearFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.LinearFunction_getConcreteClassName(self)

    def __init__(self, *args):
        _common.LinearFunction_swiginit(self, _common.new_LinearFunction(*args))
    __swig_destroy__ = _common.delete_LinearFunction

    def setCoefficients(self, coefficients: "ArrayDouble") -> "void":
        r""" %Set Coefficients for slope and intercept"""
        return _common.LinearFunction_setCoefficients(self, coefficients)

    def setSlope(self, slope: "double") -> "void":
        r""" %Set slope"""
        return _common.LinearFunction_setSlope(self, slope)

    def setIntercept(self, intercept: "double") -> "void":
        r""" %Set intercept"""
        return _common.LinearFunction_setIntercept(self, intercept)

    def getCoefficients(self) -> "OpenSim::Array< double > const":
        r""" Get Coefficients"""
        return _common.LinearFunction_getCoefficients(self)

    def getSlope(self) -> "double":
        r""" Get Slope"""
        return _common.LinearFunction_getSlope(self)

    def getIntercept(self) -> "double":
        r""" Get Intercept"""
        return _common.LinearFunction_getIntercept(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.LinearFunction_createSimTKFunction(self)

# Register LinearFunction in _common:
_common.LinearFunction_swigregister(LinearFunction)

def LinearFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::LinearFunction *":
    return _common.LinearFunction_safeDownCast(obj)

def LinearFunction_getClassName() -> "std::string const &":
    return _common.LinearFunction_getClassName()

class PiecewiseLinearFunction(Function):
    r"""
    A class implementing a linear function.

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PiecewiseLinearFunction *":
        return _common.PiecewiseLinearFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.PiecewiseLinearFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.PiecewiseLinearFunction_getClassName()

    def clone(self) -> "OpenSim::PiecewiseLinearFunction *":
        return _common.PiecewiseLinearFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.PiecewiseLinearFunction_getConcreteClassName(self)

    def __init__(self, *args):
        _common.PiecewiseLinearFunction_swiginit(self, _common.new_PiecewiseLinearFunction(*args))
    __swig_destroy__ = _common.delete_PiecewiseLinearFunction

    def init(self, aFunction: "Function") -> "void":
        return _common.PiecewiseLinearFunction_init(self, aFunction)

    def getSize(self) -> "int":
        return _common.PiecewiseLinearFunction_getSize(self)

    def getXValues(self) -> "double const *":
        return _common.PiecewiseLinearFunction_getXValues(self)

    def getYValues(self) -> "double const *":
        return _common.PiecewiseLinearFunction_getYValues(self)

    def getNumberOfPoints(self) -> "int":
        return _common.PiecewiseLinearFunction_getNumberOfPoints(self)

    def getX(self, *args) -> "double":
        return _common.PiecewiseLinearFunction_getX(self, *args)

    def getY(self, *args) -> "double":
        return _common.PiecewiseLinearFunction_getY(self, *args)

    def getZ(self, aIndex: "int") -> "double":
        return _common.PiecewiseLinearFunction_getZ(self, aIndex)

    def setX(self, aIndex: "int", aValue: "double") -> "void":
        return _common.PiecewiseLinearFunction_setX(self, aIndex, aValue)

    def setY(self, aIndex: "int", aValue: "double") -> "void":
        return _common.PiecewiseLinearFunction_setY(self, aIndex, aValue)

    def deletePoint(self, aIndex: "int") -> "bool":
        return _common.PiecewiseLinearFunction_deletePoint(self, aIndex)

    def deletePoints(self, indices: "ArrayInt") -> "bool":
        return _common.PiecewiseLinearFunction_deletePoints(self, indices)

    def addPoint(self, aX: "double", aY: "double") -> "int":
        return _common.PiecewiseLinearFunction_addPoint(self, aX, aY)

    def calcValue(self, x: "Vector") -> "double":
        return _common.PiecewiseLinearFunction_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        return _common.PiecewiseLinearFunction_calcDerivative(self, derivComponents, x)

    def getArgumentSize(self) -> "int":
        return _common.PiecewiseLinearFunction_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        return _common.PiecewiseLinearFunction_getMaxDerivativeOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.PiecewiseLinearFunction_createSimTKFunction(self)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _common.PiecewiseLinearFunction_updateFromXMLNode(self, aNode, versionNumber)

# Register PiecewiseLinearFunction in _common:
_common.PiecewiseLinearFunction_swigregister(PiecewiseLinearFunction)

def PiecewiseLinearFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PiecewiseLinearFunction *":
    return _common.PiecewiseLinearFunction_safeDownCast(obj)

def PiecewiseLinearFunction_getClassName() -> "std::string const &":
    return _common.PiecewiseLinearFunction_getClassName()

class MultiplierFunction(Function):
    r"""
    A class implementing a Function and a scale factor for the function's value.

    This class inherits from Function and so can be used as input to
    any class requiring a Function as input.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MultiplierFunction *":
        return _common.MultiplierFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.MultiplierFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.MultiplierFunction_getClassName()

    def clone(self) -> "OpenSim::MultiplierFunction *":
        return _common.MultiplierFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.MultiplierFunction_getConcreteClassName(self)

    def __init__(self, *args):
        _common.MultiplierFunction_swiginit(self, _common.new_MultiplierFunction(*args))
    __swig_destroy__ = _common.delete_MultiplierFunction

    def init(self, aFunction: "Function") -> "void":
        return _common.MultiplierFunction_init(self, aFunction)

    def setFunction(self, aFunction: "Function") -> "void":
        return _common.MultiplierFunction_setFunction(self, aFunction)

    def setScale(self, aScaleFactor: "double") -> "void":
        return _common.MultiplierFunction_setScale(self, aScaleFactor)

    def getFunction(self) -> "OpenSim::Function *":
        return _common.MultiplierFunction_getFunction(self)

    def getScale(self) -> "double":
        return _common.MultiplierFunction_getScale(self)

    def calcValue(self, x: "Vector") -> "double":
        return _common.MultiplierFunction_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        return _common.MultiplierFunction_calcDerivative(self, derivComponents, x)

    def getArgumentSize(self) -> "int":
        return _common.MultiplierFunction_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        return _common.MultiplierFunction_getMaxDerivativeOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.MultiplierFunction_createSimTKFunction(self)

# Register MultiplierFunction in _common:
_common.MultiplierFunction_swigregister(MultiplierFunction)

def MultiplierFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MultiplierFunction *":
    return _common.MultiplierFunction_safeDownCast(obj)

def MultiplierFunction_getClassName() -> "std::string const &":
    return _common.MultiplierFunction_getClassName()

class GCVSpline(Function):
    r"""
    A class for representing a smooth function with a generalized
    cross-validation spline.  Linear, cubic, quintic, and heptic splines
    are supported:

    .. code-block:: c++

           m (half-order)     order         degree         description
           1                    2             1              linear
           2                    4             3              cubic
           3                    6             5              quintic
           4                    8             7              heptic

    This class wraps the gcvspl.c source code written by D. Twisk in 1994,
    which is based on the GCVSPL code written in Fortran by Woltring
    in 1985_07_04.

    See the following source for details on how the GCV spline is fit:
    Woltring, H.J. (1986).  A Fortran package for generalized,
    cross-validatory spline smoothing and differentiation.  Advances in
    Engineering Software, Vol. 8, No. 2, 104-113.

    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::GCVSpline *":
        return _common.GCVSpline_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.GCVSpline_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.GCVSpline_getClassName()

    def clone(self) -> "OpenSim::GCVSpline *":
        return _common.GCVSpline_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.GCVSpline_getConcreteClassName(self)

    def __init__(self, *args):
        _common.GCVSpline_swiginit(self, _common.new_GCVSpline(*args))
    __swig_destroy__ = _common.delete_GCVSpline

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _common.GCVSpline_updateFromXMLNode(self, aNode, versionNumber)

    def setDegree(self, aDegree: "int") -> "void":
        r"""
        %Set the degree of this spline.

        :type aDegree: int
        :param aDegree: Degree of spline.  Legal values: 1 = linear, 3 = cubic,
            5 = quintic, 7 = heptic.
        """
        return _common.GCVSpline_setDegree(self, aDegree)

    def getDegree(self) -> "int":
        return _common.GCVSpline_getDegree(self)

    def getOrder(self) -> "int":
        r"""
        Get the order of this spline.

        :rtype: int
        :return: Order of spline: 2 = linear, 4 = cubic, 6 = quintic, 8 = heptic.
        """
        return _common.GCVSpline_getOrder(self)

    def getHalfOrder(self) -> "int":
        r"""
        Get the half order of this spline.

        :rtype: int
        :return: Half order of spline: 1 = linear, 2 = cubic, 3 = quintic, 4 = heptic.
        """
        return _common.GCVSpline_getHalfOrder(self)

    def getSize(self) -> "int":
        r"""
        Get size or number of independent data points (or number of coefficients)
        used to construct the spline.

        :rtype: int
        :return: Number of data points (or number of coefficients).
        """
        return _common.GCVSpline_getSize(self)

    def getXValues(self) -> "double const *":
        r"""
        Get the array of independent variables used to construct the spline.

        :rtype: float
        :return: Pointer to the independent variable data points.
        """
        return _common.GCVSpline_getXValues(self)

    def getYValues(self) -> "double const *":
        r"""
        Get the array of dependent variables used to construct the spline.

        :rtype: float
        :return: Pointer to the dependent variable data points.
        """
        return _common.GCVSpline_getYValues(self)

    def getCoefficients(self) -> "OpenSim::Array< double > const &":
        r"""
        Get the array of coefficients for the spline.

        :rtype: OpenSim::Array< double >
        :return: Pointer to the coefficients.
        """
        return _common.GCVSpline_getCoefficients(self)

    def getNumberOfPoints(self) -> "int":
        return _common.GCVSpline_getNumberOfPoints(self)

    def getX(self, *args) -> "double":
        r"""
        Get the array of independent variables used to construct the spline.

        :rtype: float
        :return: Reference to the independent variable data points.
        """
        return _common.GCVSpline_getX(self, *args)

    def getY(self, aIndex: "int") -> "double":
        return _common.GCVSpline_getY(self, aIndex)

    def getZ(self, aIndex: "int") -> "double":
        return _common.GCVSpline_getZ(self, aIndex)

    def setX(self, aIndex: "int", aValue: "double") -> "void":
        return _common.GCVSpline_setX(self, aIndex, aValue)

    def setY(self, aIndex: "int", aValue: "double") -> "void":
        return _common.GCVSpline_setY(self, aIndex, aValue)

    def getMinX(self) -> "double":
        r"""
        Get the minimum value of the independent variable.

        :rtype: float
        :return: Minimum value of the independent variable.
        """
        return _common.GCVSpline_getMinX(self)

    def getMaxX(self) -> "double":
        r"""
        Get the maximum value of the independent variable.

        :rtype: float
        :return: Maximum value of the independent variable.
        """
        return _common.GCVSpline_getMaxX(self)

    def deletePoint(self, aIndex: "int") -> "bool":
        return _common.GCVSpline_deletePoint(self, aIndex)

    def deletePoints(self, indices: "ArrayInt") -> "bool":
        return _common.GCVSpline_deletePoints(self, indices)

    def addPoint(self, aX: "double", aY: "double") -> "int":
        return _common.GCVSpline_addPoint(self, aX, aY)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.GCVSpline_createSimTKFunction(self)

# Register GCVSpline in _common:
_common.GCVSpline_swigregister(GCVSpline)

def GCVSpline_safeDownCast(obj: "OpenSimObject") -> "OpenSim::GCVSpline *":
    return _common.GCVSpline_safeDownCast(obj)

def GCVSpline_getClassName() -> "std::string const &":
    return _common.GCVSpline_getClassName()

class Sine(Function):
    r"""
    A class for representing a Sine function.

    This class inherits from Function and can be used as input to
    any Component requiring a Function as input. Implements:
     f(x) = amplitude*sin(omega*x+phase)+offset;

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Sine *":
        return _common.Sine_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Sine_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Sine_getClassName()

    def clone(self) -> "OpenSim::Sine *":
        return _common.Sine_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Sine_getConcreteClassName(self)

    def __init__(self, *args):
        _common.Sine_swiginit(self, _common.new_Sine(*args))
    __swig_destroy__ = _common.delete_Sine

    def calcValue(self, x: "Vector") -> "double":
        return _common.Sine_calcValue(self, x)

    def calcDerivative(self, derivComponents: "StdVectorInt", x: "Vector") -> "double":
        return _common.Sine_calcDerivative(self, derivComponents, x)

    def createSimTKFunction(self) -> "SimTK::Function *":
        return _common.Sine_createSimTKFunction(self)

    def getArgumentSize(self) -> "int":
        return _common.Sine_getArgumentSize(self)

    def getMaxDerivativeOrder(self) -> "int":
        return _common.Sine_getMaxDerivativeOrder(self)

# Register Sine in _common:
_common.Sine_swigregister(Sine)

def Sine_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Sine *":
    return _common.Sine_safeDownCast(obj)

def Sine_getClassName() -> "std::string const &":
    return _common.Sine_getClassName()

class PolynomialFunction(Function):
    r"""
    A class for representing a Polynomial of x.

    f(x) = a*x^n + b*x^(n-1) + ... + c

    Order of the coefficients corresponds to decreasing powers.

    Author: Carmichael Ong
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PolynomialFunction *":
        return _common.PolynomialFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.PolynomialFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.PolynomialFunction_getClassName()

    def clone(self) -> "OpenSim::PolynomialFunction *":
        return _common.PolynomialFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.PolynomialFunction_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a polynomial with default coefficients of {1}

        |

        *Overload 2:*
         Construct a polynomial with provided Vector of coefficients
        {a, b, ..., c} where the polynomial order, n = size-1
        """
        _common.PolynomialFunction_swiginit(self, _common.new_PolynomialFunction(*args))
    __swig_destroy__ = _common.delete_PolynomialFunction

    def setCoefficients(self, coefficients: "Vector") -> "void":
        r"""
         %Set coefficients for the polynomial f of variable x:
        f(x) = a*x^n + b*x^(n-1) + ... + c
        The size of the coefficient vector determines the order of the polynomial.
        n = size-1;
        :type coefficients: :py:class:`Vector`, in
        :param coefficients:      Vector of polynomial coefficients
        """
        return _common.PolynomialFunction_setCoefficients(self, coefficients)

    def getCoefficients(self) -> "SimTK::Vector const":
        r""" Get the polynomial function coefficients"""
        return _common.PolynomialFunction_getCoefficients(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        r"""
         Return the underlying SimTK::Function::Polynomial for direct use
          at the SimTK::System level
        :rtype: SimTK::Function
        :return: Pointer to the underlying SimTK::Function
        """
        return _common.PolynomialFunction_createSimTKFunction(self)

# Register PolynomialFunction in _common:
_common.PolynomialFunction_swigregister(PolynomialFunction)

def PolynomialFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PolynomialFunction *":
    return _common.PolynomialFunction_safeDownCast(obj)

def PolynomialFunction_getClassName() -> "std::string const &":
    return _common.PolynomialFunction_getClassName()

class MultivariatePolynomialFunction(Function):
    r"""
     A multivariate polynomial function.
    This implementation assumes a maximum of four input dimensions and allows
    computation of first-order derivatives only.
    :param coefficients: the polynomial coefficients in order of ascending
        powers starting from the last dependent component.
        For a polynomial of third order dependent on three components
        (X, Y, Z), the order is a follows:

        Index | X  Y  Z
        0     | 0  0  0
        1     | 0  0  1
        2     | 0  0  2
        3     | 0  0  3
        4     | 0  1  0
        5     | 0  1  1
        6     | 0  1  2
        7     | 0  2  0
        8     | 0  2  1
        9     | 0  3  0
        10    | 1  0  0
        11    | 1  0  1
        12    | 1  0  2
        13    | 1  1  0
        14    | 1  1  1
        15    | 1  2  0
        16    | 2  0  0
        17    | 2  0  1
        18    | 2  1  0
        19    | 3  0  0

        Assuming c6 the index 6 coefficient, the corresponding term is Y Z^2.
    Notes: The order of coefficients for this class is the *opposite** from the order
    used in the univariate PolynomialFunction.
    :param dimension: the number of dependent components
    :param order: the polynomial order (the largest sum of exponents in a single term)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MultivariatePolynomialFunction *":
        return _common.MultivariatePolynomialFunction_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.MultivariatePolynomialFunction_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.MultivariatePolynomialFunction_getClassName()

    def clone(self) -> "OpenSim::MultivariatePolynomialFunction *":
        return _common.MultivariatePolynomialFunction_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.MultivariatePolynomialFunction_getConcreteClassName(self)

    def copyProperty_coefficients(self, source: "MultivariatePolynomialFunction") -> "void":
        return _common.MultivariatePolynomialFunction_copyProperty_coefficients(self, source)

    def append_coefficients(self, value: "Vector") -> "int":
        return _common.MultivariatePolynomialFunction_append_coefficients(self, value)

    def constructProperty_coefficients(self, initValue: "Vector") -> "void":
        return _common.MultivariatePolynomialFunction_constructProperty_coefficients(self, initValue)

    def get_coefficients(self, *args) -> "SimTK::Vector const &":
        return _common.MultivariatePolynomialFunction_get_coefficients(self, *args)

    def upd_coefficients(self, *args) -> "SimTK::Vector &":
        return _common.MultivariatePolynomialFunction_upd_coefficients(self, *args)

    def set_coefficients(self, *args) -> "void":
        return _common.MultivariatePolynomialFunction_set_coefficients(self, *args)

    def copyProperty_dimension(self, source: "MultivariatePolynomialFunction") -> "void":
        return _common.MultivariatePolynomialFunction_copyProperty_dimension(self, source)

    def append_dimension(self, value: "int const &") -> "int":
        return _common.MultivariatePolynomialFunction_append_dimension(self, value)

    def constructProperty_dimension(self, initValue: "int const &") -> "void":
        return _common.MultivariatePolynomialFunction_constructProperty_dimension(self, initValue)

    def get_dimension(self, *args) -> "int const &":
        return _common.MultivariatePolynomialFunction_get_dimension(self, *args)

    def upd_dimension(self, *args) -> "int &":
        return _common.MultivariatePolynomialFunction_upd_dimension(self, *args)

    def set_dimension(self, *args) -> "void":
        return _common.MultivariatePolynomialFunction_set_dimension(self, *args)

    def copyProperty_order(self, source: "MultivariatePolynomialFunction") -> "void":
        return _common.MultivariatePolynomialFunction_copyProperty_order(self, source)

    def append_order(self, value: "int const &") -> "int":
        return _common.MultivariatePolynomialFunction_append_order(self, value)

    def constructProperty_order(self, initValue: "int const &") -> "void":
        return _common.MultivariatePolynomialFunction_constructProperty_order(self, initValue)

    def get_order(self, *args) -> "int const &":
        return _common.MultivariatePolynomialFunction_get_order(self, *args)

    def upd_order(self, *args) -> "int &":
        return _common.MultivariatePolynomialFunction_upd_order(self, *args)

    def set_order(self, *args) -> "void":
        return _common.MultivariatePolynomialFunction_set_order(self, *args)

    def __init__(self, *args):
        _common.MultivariatePolynomialFunction_swiginit(self, _common.new_MultivariatePolynomialFunction(*args))

    def setCoefficients(self, coefficients: "Vector") -> "void":
        r""" Set coefficients"""
        return _common.MultivariatePolynomialFunction_setCoefficients(self, coefficients)

    def getCoefficients(self) -> "SimTK::Vector const &":
        r""" Get coefficients"""
        return _common.MultivariatePolynomialFunction_getCoefficients(self)

    def setDimension(self, dimension: "int") -> "void":
        r""" Set dimension"""
        return _common.MultivariatePolynomialFunction_setDimension(self, dimension)

    def getDimension(self) -> "int":
        r""" Get dimension"""
        return _common.MultivariatePolynomialFunction_getDimension(self)

    def setOrder(self, order: "int") -> "void":
        r""" Set order (largest sum of exponents in a single term)."""
        return _common.MultivariatePolynomialFunction_setOrder(self, order)

    def getOrder(self) -> "int":
        r""" Get order"""
        return _common.MultivariatePolynomialFunction_getOrder(self)

    def createSimTKFunction(self) -> "SimTK::Function *":
        r""" Return function"""
        return _common.MultivariatePolynomialFunction_createSimTKFunction(self)
    __swig_destroy__ = _common.delete_MultivariatePolynomialFunction

# Register MultivariatePolynomialFunction in _common:
_common.MultivariatePolynomialFunction_swigregister(MultivariatePolynomialFunction)

def MultivariatePolynomialFunction_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MultivariatePolynomialFunction *":
    return _common.MultivariatePolynomialFunction_safeDownCast(obj)

def MultivariatePolynomialFunction_getClassName() -> "std::string const &":
    return _common.MultivariatePolynomialFunction_getClassName()

class SmoothSegmentedFunctionFactory(object):
    r"""
    This is a class that acts as a user friendly wrapper to QuinticBezerCurveSet
    to build specific kinds of physiologically plausible muscle curves using C2
    continuous sets of quintic Bezier curves. This class has been written there did
    not exist a set of curves describing muscle characteristics that was:

    1. Physiologically Accurate
    2. Continuous to the second derivative
    3. Parameterized in a physically meaningful manner

    For example, the curves employed by Thelen (Thelen DG(2003). Adjustment of Muscle
    Mechanics Model Parameters to Simulate Dynamic Contractions in Older Adults.
    ASME Journal of Biomechanical Engineering (125).) are parameterized in a
    physically meaningful manner, making them easy to use. However there are
    many shortcomings of these curves:

    a. The tendon and parallel element are not C2-continuous, making them slow to
    simulate and likely not physiologically accurate.
    b. The active force length curve approaches does not achieve its minimum value
    at a normalized fiber length of 0.5, and 1.5.
    c. The force velocity curve is not C2-continuous at the origin. As it is
    written in the paper the curve is impossible to use with an equilibrium model
    because it is not invertible. In addition the force-velocity curve actually
    increases in stiffness as activation drops - a very undesirable property given
    that many muscles are inactive at any one time.

    The muscle curves used in the literature until 2012 have been hugely influenced
    by Thelen's work, and thus similar comments can easily be applied to just about
    every other musculoskeletal simulation.

    Another example is from Miller (Miller,RH(2011).Optimal Control of
    Human Running. PhD Thesis). On pg 149 a physiologically plausible force velocity
    curve is specified that gives the user the ability to change the concentric
    curvature to be consistent with a slow- or a fast-twitch muscle. This curve is
    not C2-continuous at the origin, but even worse, it contains singularities in
    its parameter space. Since these parameters do not have a physical interpretation
    this model is difficult to use without accidentally creating a curve with a
    singularity.

    With this motivation I set out to develop a class that could generate muscle
    characteristic curves with the following properties:

    1. Physiologically Accurate
    2. Continuous to the second derivative
    3. Parameterized in a physically meaningful manner
    4. Monotonicity for monotonic curves
    5. Computationally efficient

    These goals were surprisingly difficult to achieve, but these goals have been
    achieved using sets of C2-continuous quintic Bezier curves. The resulting
    muscle curve functions in this class take parameters that would be intuitive to
    biomechanists who simulate human musculoskeletal systems, and returns a
    SmoothSegmentedFunction which is capable of evaluating the value, derivatives
    and optionally the integral of the desired function (or actually relation as
    the case may be).

    Each curve is made up of one or more C2 quintic Bezier curves x(u),
    and y(u), with linearly extrapolated ends as shown in the figure below. These
    quintic curves span 2 points, and achieve the desired derivative at its end
    points. The degree of curviness can be varied from 0 to 1 (0, 0.75 and 1.0 are
    shown in the figure in gray, blue and black respectively), and will make the
    curve approximate a line when set to 0 (gray), and approximate a curve that
    hugs the intersection of the lines that are defined by the end points locations
    and the slopes at the end of each curve segment (red lines). Although you do
    not need to set all of this information directly, for some of the curves it is
    useful to know that both the slope and the curviness parameter may need to be
    altered to achieve the desired shape.


    Image: fig_SmoothSegmentedFunctionFactory_quinticCornerSections.png



    **Computational Cost Details**
    All computational costs assume the following operation costs:

    Operation Type     : #flops
    ,+,-,=,Boolean Op : 1 
    : 10
                   sqrt: 20
                   trig: 40

    These relative weightings will vary processor to processor, and so any of
    the quoted computational costs are approximate.

    Author: Matt Millard
    Version: 0.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createFiberActiveForceLengthCurve(lce0: "double", lce1: "double", lce2: "double", lce3: "double", minActiveForceLengthValue: "double", plateauSlope: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This is a function that will produce a C2 (continuous to the second
        derivative) active force length curve.


        :type lce0: float
        :param lce0:   Normalized fiber length at the left-most shoulder of the
                          active force-length curve. The value of the active force
                          length curve for lce < lce0 will be equal to the value
                          set in shoulderVal. Normally lce0 is approximately 0.5

        :type lce1: float
        :param lce1:   Normalized fiber length at the transition point between
                          the ascending limb and the plateau region of the active
                          force length curve.

        :type lce2: float
        :param lce2:   Normalized fiber length at the maximum active force length
                          curve value of 1. Normally lce2 is by definition 1.

        :type lce3: float
        :param lce3:   Normalized fiber length of the at the right most shoulder
                          of the active-force length curve. The value of the active
                          force length curve for lce > lce2 will be equal to the
                          value of shoulderVal. Normally lce3 is approximately 1.5

        :type minActiveForceLengthValue: float
        :param minActiveForceLengthValue:
                                  The minimum value of the active force length
                                  curve. A physiological non-equilibrium muscle model
                                  would have this value set to 0. An equilibrium
                                  muscle model would have a non-zero lower bound on
                                  this value of 0.1 typically. shoulderVal must be
                                  greater than, or equal to 0.

        :type plateauSlope: float
        :param plateauSlope:   The slope of the plateau of the active force
                                  length curve between lce1 and lce2. This parameter
                                  can vary depending on the muscle model, but a
                                  value of 0.8616 is a good place to start.

        :type curviness: float
        :param curviness:  The dimensionless 'curviness' parameter that
                              can vary between 0 (a line) to 1 (a smooth, but
                              sharply bent elbow). A value of 0 will yield an active
                              force length curve that is composed of slightly curved
                              line segments. A value of 1 will yield an active force
                              length curve that is smoothly rounded.

        :type computeIntegral: boolean
        :param computeIntegral: If this is true, the integral for this curve
                                   is numerically calculated and splined. If false,
                                   this integral is not computed, and a call to
                                   .calcIntegral will throw an exception

        :type curveName: string
        :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it (e.g. "bicep_fiberActiveForceLengthCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception if these conditions aren't met
                -0 < lce0 < lce1 < lce2 < lce3
                -shoulderVal >= 0
                -0 <= plateauSlope < (1/(lce3-lce2))
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction*

        Image: fig_SmoothSegmentedFunctionFactory_falCurve.png


        **Conditions:**

        **Computational Costs**

            Without Integral :   ~20,500 flops
            With Integral    :  ~870,500 flops

        **Example:**

        .. code-block:: c++

                double lce0 = 0.5;
                double lce1 = 0.75;
                double lce2 = 1;
                double lce3 = 1.5;
                double shoulderVal  = 0.1;
                double plateauSlope = 0.75;
                double curviness    = 0.9;

                SmoothSegmentedFunction* fiberfalCurve = SmoothSegmentedFunctionFactory::
                    createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3,
                                  shoulderVal, plateauSlope, curviness,false,"test");
                fiberfalCurve.printMuscleCurveToFile();

        """
        return _common.SmoothSegmentedFunctionFactory_createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3, minActiveForceLengthValue, plateauSlope, curviness, computeIntegral, curveName)

    @staticmethod
    def createFiberForceVelocityCurve(fmaxE: "double", dydxC: "double", dydxNearC: "double", dydxIso: "double", dydxE: "double", dydxNearE: "double", concCurviness: "double", eccCurviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
               This function will generate a C2-continuous (continuous to the second
               derivative) force velocity curve of a single muscle fiber. The main
               function of this element is to model the amount the force enhancement or
               attenuation that is associated with contracting at a particular velocity.

               :type fmaxE: float
               :param fmaxE:  The normalized maximum force the fiber can generate when
                                 is being stretched. This value is reported to range
                                 between 1.1 and 1.8 in the literature, though all values
                                 are above 1.

               :type dydxC: float
               :param dydxC:  The slope of the fv(dlce(t)/dt) curve at the maximum
                                 normalized concentric contraction velocity. Although
                                 physiologically the value of dydxC at the maximum
                                 concentric contraction velocity is by definition 0, a value
                                 of 0 is often used. If you are using an equilibrium-type
                                 model, this term must be positive and greater than zero so
                                 that the fv curve can be inverted.

        /
        /
                                 Minimum Value: 0
                                 Maximum Value: dydxC < 1

        /
        /

               :type dydxNearC: float
               :param dydxNearC: The slope of the force velocity curve as it approaches
                                    the maximum concentric (shortening) contraction velocity.

        /
        /
                                     Minimum Value: > dydxC
                                     Maximum Value: dydxNearC < 1

        /
        /


               :type dydxIso: float
               :param dydxIso:  The slope of the fv curve when dlce(t)/dt = 0.

        /
        /
                                   Minimum Value: dydxIso > 1.0
                                   Maximum Value: dydxIso < Inf

               :type dydxE: float
               :param dydxE:    The analogous term of dydxC parameter but for the
                                   eccentric portion of the force-velocity curve. As with
                                   the dydxC term, the physiologically accurate value for
                                   this parameter is 0, though a value of 0 is rarely used
                                   in muscle models.  If you are using an equilibrium-type
                                   model, this term must be positive and greater than zero
                                   so that the fv curve can be inverted.

        /
        /
                                   Minimum Value: 0
                                   Maximum Value: dydxC < (fmaxE-1).

        /
        /
                                   As with the dydxC term,
                                   the size of this term also affects the stiffness of the
                                   integration problem for equilibrium-type muscle models:
                                   the closer to zero this term is, the stiffer the model
                                   will be (but only when (dlce(t)/dt)/vmax approaches 1.

               :type dydxNearE: float
               :param dydxNearE: The slope of the force velocity curve as it approaches
                                    the maximum eccentric (lengthening) contraction velocity.

        /
        /
                                     Minimum Value: > dydxE
                                     Maximum Value: dydxNearE < (fmaxE-1)

        /
        /


               :type concCurviness: float
               :param concCurviness:    The dimensionless 'curviness' parameter that
                                           can vary between 0 (a line) to 1 (a smooth, but
                                           sharply bent elbow). This parameter affects only
                                           the concentric side of the fv curve.

               :type eccCurviness: float
               :param eccCurviness:     The dimensionless 'curviness' parameter that
                                           can vary between 0 (a line) to 1 (a smooth, but
                                           sharply bent elbow). This parameter affects only
                                           the eccentric side of the fv curve.

               :type computeIntegral: boolean
               :param computeIntegral:  If this is true, the integral for this curve
                                           is numerically calculated and splined. If false,
                                           this integral is not computed, and a call to
                                           SmoothSegmentedFunction::calcIntegral() will throw
                                           an exception

               :type curveName: string
               :param curveName: The name of the muscle this curve applies to. This
                                     curve name should have the name of the muscle and the
                                     curve in it (e.g. "bicep_fiberForceVelocityCurve")
                                     so that, if this curve ever causes an exception, a
                                     user-friendly error message can be displayed to the
                                     end user to help them debug their model.

               :raises: SimTK::Exception unless these conditions are met

                   -0 <= dydxC < 1
                   -dydxC < dydxNearC < 1
                   -1 < dydxIso
                   -dydxE < (fmaxE-1)
                   -dydxE < dydxNearC < (fmaxE-1)
                   -0<= concCurviness <=0
                   -0 <= eccCurviness <= 0

               :rtype: SmoothSegmentedFunction
               :return: SmoothSegmentedFunction*

                       Image: fig_SmoothSegmentedFunctionFactory_fvCurve.png



               **Computational Costs**

                   Without Integral :   ~8,200 flops
                   With Integral    : ~348,200 flops

               **Example:**

               .. code-block:: c++

                       double fmaxE = 1.8;
                       double dydxC = 0.1;
                       double dydxNearC = 0.25;
                       double dydxE = 0.1;
                       double dydxNearE = 0.15;
                       double dydxIso= 5;
                       double concCurviness = 0.1;
                       double eccCurviness = 0.75;

                       SmoothSegmentedFunction fiberFVCurve = SmoothSegmentedFunctionFactory::
                           createFiberForceVelocityCurve(fmaxE,
                               dydxC, dydxNearC, dydxIso, dydxE, dydxNearE,
                               concCurviness,  eccCurviness,false,"test");
                       fiberFVCurve.printMuscleCurveToFile();
        """
        return _common.SmoothSegmentedFunctionFactory_createFiberForceVelocityCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, curveName)

    @staticmethod
    def createFiberForceVelocityInverseCurve(fmaxE: "double", dydxC: "double", dydxNearC: "double", dydxIso: "double", dydxE: "double", dydxNearE: "double", concCurviness: "double", eccCurviness: "double", computeIntegral: "bool", muscleName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This function will generate a C2-continuous (continuous to the 2nd
        derivative) inverse curve that the function
        createFiberForceVelocityCurve generates. The inverse force velocity
        curve is required by every equilibrium muscle model in order to compute
        the derivative of fiber velocity. To generate the inverse force velocity
        curve simply call this function with EXACTLY the same parameter values
        that you used to generate the force velocity curve. See the parameter
        descriptions for createFiberForceVelocityCurve, as the parameters for
        the inverse function are identical. The curve name should be different,
        however, because this is an inverse curve
        (e.g. "bicep_fiberForceVelocityInverseCurve")


        Image: fig_SmoothSegmentedFunctionFactory_fvInvCurve.png
        """
        return _common.SmoothSegmentedFunctionFactory_createFiberForceVelocityInverseCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, muscleName)

    @staticmethod
    def createFiberCompressiveForcePennationCurve(phi0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This element will generate a C2-continuous (continuous to the 2nd
        derivative) compressive force profile curve as a function of pennation.
        A muscle model with this element usually places this element parallel to
        the fiber.The main function of this element is to prevent the fiber from
        achieving a pennation angle of pi/2 radians. This type of element is
        necessary for a parallelogram pennated equilibrium muscle models because
        without it, the muscle model can deform to the point where a pennation
        angle of pi/2 radians is reached, which causes a singularity in the
        model.


        :type phi0: float
        :param phi0: The pennation angle at which the compressive force element
                        starts to engage . When the pennation angle is greater than
                        phi0, the compressive element is generating a force. When the
                        pennation angle is less than phi0, the compressive element
                        generates no force.

        :type kiso: float
        :param kiso: This is the maximum stiffness of the compressive element,
                        which occurs when the fiber is pennated by 90 degrees

        :type curviness: float
        :param curviness:    The dimensionless 'curviness' parameter that
                                can vary between 0 (a line) to 1 (a smooth, but
                                sharply bent elbow)

        :type computeIntegral: boolean
        :param computeIntegral:  If this is true, the integral for this curve
                                    is numerically calculated and splined. If false,
                                    this integral is not computed, and a call to
                                    .calcIntegral will throw an exception

        :type curveName: string
        :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it
                              (e.g. "bicep_fiberCompressiveForcePennationCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception unless the following conditions are met
                -0 < phi0 < SimTK::Pi/2
                -kiso > 1/(SimTK::Pi/2-phi0)
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction object

        Image: fig_SmoothSegmentedFunctionFactory_fcphiCurve.png





        **Computational Costs**

            Without Integral :   ~4,100 flops
            With Integral    : ~174,100 flops

        **Example:**

        .. code-block:: c++

                double phi0 = (SimTK::Pi/2)*(8.0/9.0);
                double kiso = 8.389863790885878;
                double c    = 0.0;

                SmoothSegmentedFunction fiberCEPhiCurve = SmoothSegmentedFunctionFactory::
                    createFiberCompressiveForcePennationCurve(phi0,kiso,c,
                    true,"test");
                fiberCEPhiCurve.printMuscleCurveToFile();
        """
        return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForcePennationCurve(phi0, kiso, curviness, computeIntegral, curveName)

    @staticmethod
    def createFiberCompressiveForceCosPennationCurve(cosPhi0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This element will generate a C2-continuous (continuous to the 2nd
        derivative) compressive force profile curve as a function of
        cos(pennation).

        A muscle model with this element usually places this element in line
        with the tendon. The main function of this element is to prevent the
        fiber from achieving a pennation angle of pi/2 radians. This type of
        element is necessary for a parallelogram pennated muscle models because
        without it, the muscle model can deform to the point where a pennation
        angle of pi/2 radians is reached, which causes a singularity in the
        model.


        :type cosPhi0: float
        :param cosPhi0: The cosine of the pennation angle at which the
                            compressive force element starts to engage. When the
                            cos of the pennation angle is greater than cosPhi0, the
                            compressive element generates no force. When cos of the
                            pennation angle is less than cosPhi0, the compressive
                            element generates a compressive force.

        :type kiso: float
        :param kiso: This is the maximum stiffness of the compressive element,
                        which occurs when cosPhi is zero. This parameter must be
                        negative
                        cos
        :type curviness: float
        :param curviness:    The dimensionless 'curviness' parameter that
                                can vary between 0 (a line) to 1 (a smooth, but
                                sharply bent elbow)

        :type computeIntegral: boolean
        :param computeIntegral:  If this is true, the integral for this curve
                                    is numerically calculated and splined. If false,
                                    this integral is not computed, and a call to
                                    .calcIntegral will throw an exception

        :type curveName: string
        :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it
                         (e.g. "bicep_fiberCompressiveForceCosPennationCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception unless the following conditions are met:
                -0 < cosPhi0
                -kiso > 1/(cosPhi0)
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction*

        Image: fig_SmoothSegmentedFunctionFactory_fcCosPhiCurve.png

        **Computational Costs**

            Without Integral :   ~4,100 flops
            With Integral    : ~174,100 flops

        **Example:**

        .. code-block:: c++

                double cosPhi0 = cos( (80.0/90.0)*SimTK::Pi/2);
                double kiso    = -1.2/(cosPhi0);
                double c       = 0.5;

                SmoothSegmentedFunction fiberCECosPhiCurve = SmoothSegmentedFunctionFactory::
                    createFiberCompressiveForceCosPennationCurve(cosPhi0,kiso,
                                                               c,true,"test");
                fiberCEPhiCurve.printMuscleCurveToFile();


        """
        return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForceCosPennationCurve(cosPhi0, kiso, curviness, computeIntegral, curveName)

    @staticmethod
    def createFiberCompressiveForceLengthCurve(l0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This element will generate a C2-continuous (continuous to the second
        derivative) curve that models a compressive force profile that is a
        function of fiber length. The main function of
        this element is to prevent the fiber from achieving an unrealistically
        short length. This type of element is necessary for equilibrium-type
        muscle models because of the editing that is done to the active force
        length curve that endows an equilibrium model fiber with the ability to
        to generate force when a physiological fiber cannot.



        :type l0: float
        :param l0:   The normalized fiber length at which the compressive element
                        starts to engage. When the fiber is shorter than l0, the
                        compressive element is generating a force. When the fiber
                        length is longer than l0, the compressive element generates
                        no force.

        :type kiso: float
        :param kiso: This is the maximum stiffness of the compressive element,
                        which occurs when the fiber has a length of 0, under a load
                        of 1 maximum isometric unit of force.

        :type curviness: float
        :param curviness:    The dimensionless 'curviness' parameter that
                                can vary between 0 (a line) to 1 (a smooth, but
                                sharply bent elbow)

        :type computeIntegral: boolean
        :param computeIntegral:  If this is true, the integral for this curve
                                    is numerically calculated and splined. If false,
                                    this integral is not computed, and a call to
                                    .calcIntegral will throw an exception

         :type curveName: string
         :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it
                              (e.g. "bicep_fiberCompressiveForceLengthCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception unless the following conditions are met
                -e0 > 0
                -kiso > 1/(e0)
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction*

        Image: fig_SmoothSegmentedFunctionFactory_fpeCurve.png


        **Computational Costs**

            Without Integral :   ~4,100 flops
            With Integral    : ~174,100 flops

        **Example:**

        .. code-block:: c++

                double lmax = 0.6;
                double kiso = -8.389863790885878;
                double c    = 0.1;//0.0;

                SmoothSegmentedFunction fiberCECurve = SmoothSegmentedFunctionFactory::
                    createFiberCompressiveForceLengthCurve(lmax,kiso,c,true,"test");
                fiberCECurve.printMuscleCurveToFile();
        """
        return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForceLengthCurve(l0, kiso, curviness, computeIntegral, curveName)

    @staticmethod
    def createFiberForceLengthCurve(eZero: "double", eIso: "double", kLow: "double", kIso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        This function will generate a C2-continuous curve that fits a fiber's
        tensile force length curve.

        :type eZero: float
        :param eZero: The fiber strain at which the fiber begins to develop force.
                         Thus an e0 of 0.0 means that the fiber will start to develop
                         passive force when it has a normalized length of 1.0. Note
                         that e0 can be positive or negative.

        :type eIso: float
        :param eIso: The fiber strain at which the fiber develops 1 unit of
                        normalized force (1 maximum isometric force). Note that the
                        '1' is left off. Thus an e0 of 0.6 means that the fiber
                        will develop an 1 normalized force unit when it is strained
                        by 60% of its resting length, or to a normalized length of
                        1.6

        :type kLow: float
        :param kLow:   The normalized stiffness (or slope) of the fiber curve
                          close to the location where the force-length curve
                          approaches a normalized force of 0. This is usually
                          chosen to be a small, but non-zero fraction of kIso
                          (kLow = 0.025 kIso is typical).

        :type kIso: float
        :param kIso:   The normalized stiffness (or slope) of the fiber curve
                          when the fiber is strained by eIso (or has a length of
                          1+eIso) under a load of 1 maximum isometric unit of force.


        :type curviness: float
        :param curviness:    The dimensionless 'curviness' parameter that
                                can vary between 0 (a line) to 1 (a smooth, but
                                sharply bent elbow)

        :type computeIntegral: boolean
        :param computeIntegral:  If this is true, the integral for this curve
                                    is numerically calculated and splined. If false,
                                    this integral is not computed, and a call to
                                    .calcIntegral will throw an exception

         :type curveName: string
         :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it (e.g. "bicep_fiberForceLengthCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception unless the following conditions are met
                -eIso > eZero
                -kIso > 1/(eIso-eZero)
                -0 < kLow < kIso
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction*


        Image: fig_SmoothSegmentedFunctionFactory_fcLengthCurve.png


        **Computational Costs**

            Without Integral :   ~4,100 flops
            With Integral    : ~174,100 flops

        **Example:**

        .. code-block:: c++

                double eIso      = 0.6;
                double eZero     = 0.0;
                double kIso      = 4.0/(eIso-eZero);
                double kNearZero = 0.025*kIso
                double c         = 0.5;

                SmoothSegmentedFunction fiberFLCurve
                = SmoothSegmentedFunctionFactory::
                  createFiberForceLengthCurve(eZero, eIso,
                                              kLow, kIso, c, true,"test");
                fiberFLCurve.printMuscleCurveToFile();
        """
        return _common.SmoothSegmentedFunctionFactory_createFiberForceLengthCurve(eZero, eIso, kLow, kIso, curviness, computeIntegral, curveName)

    @staticmethod
    def createTendonForceLengthCurve(eIso: "double", kIso: "double", fToe: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
        r"""
        Will generate a C2-continuous (continuous to the second derivative)
        curve in a MuscleFunctionObject object that fits a tendon's tensile
        force length curve.



        :type eIso: float
        :param eIso:   The tendon strain at which the tendon develops 1 unit
                        of normalized force (1 maximum isometric force). Note that
                        the'1' is left off. Thus an e0 of 0.04 means that the tendon
                        will develop an 1 normalized force unit when it is strained
                        by 4% of its resting length, at a normalized length of
                        1.04

        :type kIso: float
        :param kIso:    The normalized stiffness (or slope) of the tendon
                            curve when the tendon is strained by e0
                            (or has a length of 1+e0) under a load of 1 maximum
                            isometric unit of force.

        :type fToe: float
        :param fToe:    The normalized force at which the tendon smoothly
                           transitions from the curved low stiffness region to
                           the linear stiffness region.

        :type curviness: float
        :param curviness:    The dimensionless 'curviness' parameter that
                                can vary between 0 (a line) to 1 (a smooth, but
                                sharply bent elbow)

        :type computeIntegral: boolean
        :param computeIntegral:  If this is true, the integral for this curve
                                    is numerically calculated and splined. If false,
                                    this integral is not computed, and a call to
                                    .calcIntegral will throw an exception

         :type curveName: string
         :param curveName: The name of the muscle this curve applies to. This
                              curve name should have the name of the muscle and the
                              curve in it (e.g. "bicep_tendonForceLengthCurve")
                              so that, if this curve ever causes an exception, a
                              user-friendly error message can be displayed to the
                              end user to help them debug their model.

        :raises: SimTK::Exception unless the following conditions are met:
                -0 < fToe < 1
                -e0 > 0
                -kiso > 1/e0
                -0 <= curviness <= 1

        :rtype: SmoothSegmentedFunction
        :return: SmoothSegmentedFunction*

        Image: fig_SmoothSegmentedFunctionFactory_fseCurve.png


        **Computational Costs**

            Without Integral :   ~4,100 flops
            With Integral    : ~174,100 flops

        **Example:**

        .. code-block:: c++

                double e0   = 0.04;
                double kiso = 42.79679348815859;
                double fToe = 1.0/3.0
                double c    = 0.75;

                SmoothSegmentedFunction* tendonCurve = SmoothSegmentedFunctionFactory::
                                                    createTendonForceLengthCurve(
                                                      e0,kiso,fToe,c,true,"test");
                tendonCurve.printMuscleCurveToFile();

        """
        return _common.SmoothSegmentedFunctionFactory_createTendonForceLengthCurve(eIso, kIso, fToe, curviness, computeIntegral, curveName)

    def __init__(self):
        _common.SmoothSegmentedFunctionFactory_swiginit(self, _common.new_SmoothSegmentedFunctionFactory())
    __swig_destroy__ = _common.delete_SmoothSegmentedFunctionFactory

# Register SmoothSegmentedFunctionFactory in _common:
_common.SmoothSegmentedFunctionFactory_swigregister(SmoothSegmentedFunctionFactory)

def SmoothSegmentedFunctionFactory_createFiberActiveForceLengthCurve(lce0: "double", lce1: "double", lce2: "double", lce3: "double", minActiveForceLengthValue: "double", plateauSlope: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This is a function that will produce a C2 (continuous to the second
    derivative) active force length curve.


    :type lce0: float
    :param lce0:   Normalized fiber length at the left-most shoulder of the
                      active force-length curve. The value of the active force
                      length curve for lce < lce0 will be equal to the value
                      set in shoulderVal. Normally lce0 is approximately 0.5

    :type lce1: float
    :param lce1:   Normalized fiber length at the transition point between
                      the ascending limb and the plateau region of the active
                      force length curve.

    :type lce2: float
    :param lce2:   Normalized fiber length at the maximum active force length
                      curve value of 1. Normally lce2 is by definition 1.

    :type lce3: float
    :param lce3:   Normalized fiber length of the at the right most shoulder
                      of the active-force length curve. The value of the active
                      force length curve for lce > lce2 will be equal to the
                      value of shoulderVal. Normally lce3 is approximately 1.5

    :type minActiveForceLengthValue: float
    :param minActiveForceLengthValue:
                              The minimum value of the active force length
                              curve. A physiological non-equilibrium muscle model
                              would have this value set to 0. An equilibrium
                              muscle model would have a non-zero lower bound on
                              this value of 0.1 typically. shoulderVal must be
                              greater than, or equal to 0.

    :type plateauSlope: float
    :param plateauSlope:   The slope of the plateau of the active force
                              length curve between lce1 and lce2. This parameter
                              can vary depending on the muscle model, but a
                              value of 0.8616 is a good place to start.

    :type curviness: float
    :param curviness:  The dimensionless 'curviness' parameter that
                          can vary between 0 (a line) to 1 (a smooth, but
                          sharply bent elbow). A value of 0 will yield an active
                          force length curve that is composed of slightly curved
                          line segments. A value of 1 will yield an active force
                          length curve that is smoothly rounded.

    :type computeIntegral: boolean
    :param computeIntegral: If this is true, the integral for this curve
                               is numerically calculated and splined. If false,
                               this integral is not computed, and a call to
                               .calcIntegral will throw an exception

    :type curveName: string
    :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it (e.g. "bicep_fiberActiveForceLengthCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception if these conditions aren't met
            -0 < lce0 < lce1 < lce2 < lce3
            -shoulderVal >= 0
            -0 <= plateauSlope < (1/(lce3-lce2))
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction*

    Image: fig_SmoothSegmentedFunctionFactory_falCurve.png


    **Conditions:**

    **Computational Costs**

        Without Integral :   ~20,500 flops
        With Integral    :  ~870,500 flops

    **Example:**

    .. code-block:: c++

            double lce0 = 0.5;
            double lce1 = 0.75;
            double lce2 = 1;
            double lce3 = 1.5;
            double shoulderVal  = 0.1;
            double plateauSlope = 0.75;
            double curviness    = 0.9;

            SmoothSegmentedFunction* fiberfalCurve = SmoothSegmentedFunctionFactory::
                createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3,
                              shoulderVal, plateauSlope, curviness,false,"test");
            fiberfalCurve.printMuscleCurveToFile();

    """
    return _common.SmoothSegmentedFunctionFactory_createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3, minActiveForceLengthValue, plateauSlope, curviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createFiberForceVelocityCurve(fmaxE: "double", dydxC: "double", dydxNearC: "double", dydxIso: "double", dydxE: "double", dydxNearE: "double", concCurviness: "double", eccCurviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
           This function will generate a C2-continuous (continuous to the second
           derivative) force velocity curve of a single muscle fiber. The main
           function of this element is to model the amount the force enhancement or
           attenuation that is associated with contracting at a particular velocity.

           :type fmaxE: float
           :param fmaxE:  The normalized maximum force the fiber can generate when
                             is being stretched. This value is reported to range
                             between 1.1 and 1.8 in the literature, though all values
                             are above 1.

           :type dydxC: float
           :param dydxC:  The slope of the fv(dlce(t)/dt) curve at the maximum
                             normalized concentric contraction velocity. Although
                             physiologically the value of dydxC at the maximum
                             concentric contraction velocity is by definition 0, a value
                             of 0 is often used. If you are using an equilibrium-type
                             model, this term must be positive and greater than zero so
                             that the fv curve can be inverted.

    /
    /
                             Minimum Value: 0
                             Maximum Value: dydxC < 1

    /
    /

           :type dydxNearC: float
           :param dydxNearC: The slope of the force velocity curve as it approaches
                                the maximum concentric (shortening) contraction velocity.

    /
    /
                                 Minimum Value: > dydxC
                                 Maximum Value: dydxNearC < 1

    /
    /


           :type dydxIso: float
           :param dydxIso:  The slope of the fv curve when dlce(t)/dt = 0.

    /
    /
                               Minimum Value: dydxIso > 1.0
                               Maximum Value: dydxIso < Inf

           :type dydxE: float
           :param dydxE:    The analogous term of dydxC parameter but for the
                               eccentric portion of the force-velocity curve. As with
                               the dydxC term, the physiologically accurate value for
                               this parameter is 0, though a value of 0 is rarely used
                               in muscle models.  If you are using an equilibrium-type
                               model, this term must be positive and greater than zero
                               so that the fv curve can be inverted.

    /
    /
                               Minimum Value: 0
                               Maximum Value: dydxC < (fmaxE-1).

    /
    /
                               As with the dydxC term,
                               the size of this term also affects the stiffness of the
                               integration problem for equilibrium-type muscle models:
                               the closer to zero this term is, the stiffer the model
                               will be (but only when (dlce(t)/dt)/vmax approaches 1.

           :type dydxNearE: float
           :param dydxNearE: The slope of the force velocity curve as it approaches
                                the maximum eccentric (lengthening) contraction velocity.

    /
    /
                                 Minimum Value: > dydxE
                                 Maximum Value: dydxNearE < (fmaxE-1)

    /
    /


           :type concCurviness: float
           :param concCurviness:    The dimensionless 'curviness' parameter that
                                       can vary between 0 (a line) to 1 (a smooth, but
                                       sharply bent elbow). This parameter affects only
                                       the concentric side of the fv curve.

           :type eccCurviness: float
           :param eccCurviness:     The dimensionless 'curviness' parameter that
                                       can vary between 0 (a line) to 1 (a smooth, but
                                       sharply bent elbow). This parameter affects only
                                       the eccentric side of the fv curve.

           :type computeIntegral: boolean
           :param computeIntegral:  If this is true, the integral for this curve
                                       is numerically calculated and splined. If false,
                                       this integral is not computed, and a call to
                                       SmoothSegmentedFunction::calcIntegral() will throw
                                       an exception

           :type curveName: string
           :param curveName: The name of the muscle this curve applies to. This
                                 curve name should have the name of the muscle and the
                                 curve in it (e.g. "bicep_fiberForceVelocityCurve")
                                 so that, if this curve ever causes an exception, a
                                 user-friendly error message can be displayed to the
                                 end user to help them debug their model.

           :raises: SimTK::Exception unless these conditions are met

               -0 <= dydxC < 1
               -dydxC < dydxNearC < 1
               -1 < dydxIso
               -dydxE < (fmaxE-1)
               -dydxE < dydxNearC < (fmaxE-1)
               -0<= concCurviness <=0
               -0 <= eccCurviness <= 0

           :rtype: SmoothSegmentedFunction
           :return: SmoothSegmentedFunction*

                   Image: fig_SmoothSegmentedFunctionFactory_fvCurve.png



           **Computational Costs**

               Without Integral :   ~8,200 flops
               With Integral    : ~348,200 flops

           **Example:**

           .. code-block:: c++

                   double fmaxE = 1.8;
                   double dydxC = 0.1;
                   double dydxNearC = 0.25;
                   double dydxE = 0.1;
                   double dydxNearE = 0.15;
                   double dydxIso= 5;
                   double concCurviness = 0.1;
                   double eccCurviness = 0.75;

                   SmoothSegmentedFunction fiberFVCurve = SmoothSegmentedFunctionFactory::
                       createFiberForceVelocityCurve(fmaxE,
                           dydxC, dydxNearC, dydxIso, dydxE, dydxNearE,
                           concCurviness,  eccCurviness,false,"test");
                   fiberFVCurve.printMuscleCurveToFile();
    """
    return _common.SmoothSegmentedFunctionFactory_createFiberForceVelocityCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createFiberForceVelocityInverseCurve(fmaxE: "double", dydxC: "double", dydxNearC: "double", dydxIso: "double", dydxE: "double", dydxNearE: "double", concCurviness: "double", eccCurviness: "double", computeIntegral: "bool", muscleName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This function will generate a C2-continuous (continuous to the 2nd
    derivative) inverse curve that the function
    createFiberForceVelocityCurve generates. The inverse force velocity
    curve is required by every equilibrium muscle model in order to compute
    the derivative of fiber velocity. To generate the inverse force velocity
    curve simply call this function with EXACTLY the same parameter values
    that you used to generate the force velocity curve. See the parameter
    descriptions for createFiberForceVelocityCurve, as the parameters for
    the inverse function are identical. The curve name should be different,
    however, because this is an inverse curve
    (e.g. "bicep_fiberForceVelocityInverseCurve")


    Image: fig_SmoothSegmentedFunctionFactory_fvInvCurve.png
    """
    return _common.SmoothSegmentedFunctionFactory_createFiberForceVelocityInverseCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, muscleName)

def SmoothSegmentedFunctionFactory_createFiberCompressiveForcePennationCurve(phi0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This element will generate a C2-continuous (continuous to the 2nd
    derivative) compressive force profile curve as a function of pennation.
    A muscle model with this element usually places this element parallel to
    the fiber.The main function of this element is to prevent the fiber from
    achieving a pennation angle of pi/2 radians. This type of element is
    necessary for a parallelogram pennated equilibrium muscle models because
    without it, the muscle model can deform to the point where a pennation
    angle of pi/2 radians is reached, which causes a singularity in the
    model.


    :type phi0: float
    :param phi0: The pennation angle at which the compressive force element
                    starts to engage . When the pennation angle is greater than
                    phi0, the compressive element is generating a force. When the
                    pennation angle is less than phi0, the compressive element
                    generates no force.

    :type kiso: float
    :param kiso: This is the maximum stiffness of the compressive element,
                    which occurs when the fiber is pennated by 90 degrees

    :type curviness: float
    :param curviness:    The dimensionless 'curviness' parameter that
                            can vary between 0 (a line) to 1 (a smooth, but
                            sharply bent elbow)

    :type computeIntegral: boolean
    :param computeIntegral:  If this is true, the integral for this curve
                                is numerically calculated and splined. If false,
                                this integral is not computed, and a call to
                                .calcIntegral will throw an exception

    :type curveName: string
    :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it
                          (e.g. "bicep_fiberCompressiveForcePennationCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception unless the following conditions are met
            -0 < phi0 < SimTK::Pi/2
            -kiso > 1/(SimTK::Pi/2-phi0)
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction object

    Image: fig_SmoothSegmentedFunctionFactory_fcphiCurve.png





    **Computational Costs**

        Without Integral :   ~4,100 flops
        With Integral    : ~174,100 flops

    **Example:**

    .. code-block:: c++

            double phi0 = (SimTK::Pi/2)*(8.0/9.0);
            double kiso = 8.389863790885878;
            double c    = 0.0;

            SmoothSegmentedFunction fiberCEPhiCurve = SmoothSegmentedFunctionFactory::
                createFiberCompressiveForcePennationCurve(phi0,kiso,c,
                true,"test");
            fiberCEPhiCurve.printMuscleCurveToFile();
    """
    return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForcePennationCurve(phi0, kiso, curviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createFiberCompressiveForceCosPennationCurve(cosPhi0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This element will generate a C2-continuous (continuous to the 2nd
    derivative) compressive force profile curve as a function of
    cos(pennation).

    A muscle model with this element usually places this element in line
    with the tendon. The main function of this element is to prevent the
    fiber from achieving a pennation angle of pi/2 radians. This type of
    element is necessary for a parallelogram pennated muscle models because
    without it, the muscle model can deform to the point where a pennation
    angle of pi/2 radians is reached, which causes a singularity in the
    model.


    :type cosPhi0: float
    :param cosPhi0: The cosine of the pennation angle at which the
                        compressive force element starts to engage. When the
                        cos of the pennation angle is greater than cosPhi0, the
                        compressive element generates no force. When cos of the
                        pennation angle is less than cosPhi0, the compressive
                        element generates a compressive force.

    :type kiso: float
    :param kiso: This is the maximum stiffness of the compressive element,
                    which occurs when cosPhi is zero. This parameter must be
                    negative
                    cos
    :type curviness: float
    :param curviness:    The dimensionless 'curviness' parameter that
                            can vary between 0 (a line) to 1 (a smooth, but
                            sharply bent elbow)

    :type computeIntegral: boolean
    :param computeIntegral:  If this is true, the integral for this curve
                                is numerically calculated and splined. If false,
                                this integral is not computed, and a call to
                                .calcIntegral will throw an exception

    :type curveName: string
    :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it
                     (e.g. "bicep_fiberCompressiveForceCosPennationCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception unless the following conditions are met:
            -0 < cosPhi0
            -kiso > 1/(cosPhi0)
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction*

    Image: fig_SmoothSegmentedFunctionFactory_fcCosPhiCurve.png

    **Computational Costs**

        Without Integral :   ~4,100 flops
        With Integral    : ~174,100 flops

    **Example:**

    .. code-block:: c++

            double cosPhi0 = cos( (80.0/90.0)*SimTK::Pi/2);
            double kiso    = -1.2/(cosPhi0);
            double c       = 0.5;

            SmoothSegmentedFunction fiberCECosPhiCurve = SmoothSegmentedFunctionFactory::
                createFiberCompressiveForceCosPennationCurve(cosPhi0,kiso,
                                                           c,true,"test");
            fiberCEPhiCurve.printMuscleCurveToFile();


    """
    return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForceCosPennationCurve(cosPhi0, kiso, curviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createFiberCompressiveForceLengthCurve(l0: "double", kiso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This element will generate a C2-continuous (continuous to the second
    derivative) curve that models a compressive force profile that is a
    function of fiber length. The main function of
    this element is to prevent the fiber from achieving an unrealistically
    short length. This type of element is necessary for equilibrium-type
    muscle models because of the editing that is done to the active force
    length curve that endows an equilibrium model fiber with the ability to
    to generate force when a physiological fiber cannot.



    :type l0: float
    :param l0:   The normalized fiber length at which the compressive element
                    starts to engage. When the fiber is shorter than l0, the
                    compressive element is generating a force. When the fiber
                    length is longer than l0, the compressive element generates
                    no force.

    :type kiso: float
    :param kiso: This is the maximum stiffness of the compressive element,
                    which occurs when the fiber has a length of 0, under a load
                    of 1 maximum isometric unit of force.

    :type curviness: float
    :param curviness:    The dimensionless 'curviness' parameter that
                            can vary between 0 (a line) to 1 (a smooth, but
                            sharply bent elbow)

    :type computeIntegral: boolean
    :param computeIntegral:  If this is true, the integral for this curve
                                is numerically calculated and splined. If false,
                                this integral is not computed, and a call to
                                .calcIntegral will throw an exception

     :type curveName: string
     :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it
                          (e.g. "bicep_fiberCompressiveForceLengthCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception unless the following conditions are met
            -e0 > 0
            -kiso > 1/(e0)
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction*

    Image: fig_SmoothSegmentedFunctionFactory_fpeCurve.png


    **Computational Costs**

        Without Integral :   ~4,100 flops
        With Integral    : ~174,100 flops

    **Example:**

    .. code-block:: c++

            double lmax = 0.6;
            double kiso = -8.389863790885878;
            double c    = 0.1;//0.0;

            SmoothSegmentedFunction fiberCECurve = SmoothSegmentedFunctionFactory::
                createFiberCompressiveForceLengthCurve(lmax,kiso,c,true,"test");
            fiberCECurve.printMuscleCurveToFile();
    """
    return _common.SmoothSegmentedFunctionFactory_createFiberCompressiveForceLengthCurve(l0, kiso, curviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createFiberForceLengthCurve(eZero: "double", eIso: "double", kLow: "double", kIso: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    This function will generate a C2-continuous curve that fits a fiber's
    tensile force length curve.

    :type eZero: float
    :param eZero: The fiber strain at which the fiber begins to develop force.
                     Thus an e0 of 0.0 means that the fiber will start to develop
                     passive force when it has a normalized length of 1.0. Note
                     that e0 can be positive or negative.

    :type eIso: float
    :param eIso: The fiber strain at which the fiber develops 1 unit of
                    normalized force (1 maximum isometric force). Note that the
                    '1' is left off. Thus an e0 of 0.6 means that the fiber
                    will develop an 1 normalized force unit when it is strained
                    by 60% of its resting length, or to a normalized length of
                    1.6

    :type kLow: float
    :param kLow:   The normalized stiffness (or slope) of the fiber curve
                      close to the location where the force-length curve
                      approaches a normalized force of 0. This is usually
                      chosen to be a small, but non-zero fraction of kIso
                      (kLow = 0.025 kIso is typical).

    :type kIso: float
    :param kIso:   The normalized stiffness (or slope) of the fiber curve
                      when the fiber is strained by eIso (or has a length of
                      1+eIso) under a load of 1 maximum isometric unit of force.


    :type curviness: float
    :param curviness:    The dimensionless 'curviness' parameter that
                            can vary between 0 (a line) to 1 (a smooth, but
                            sharply bent elbow)

    :type computeIntegral: boolean
    :param computeIntegral:  If this is true, the integral for this curve
                                is numerically calculated and splined. If false,
                                this integral is not computed, and a call to
                                .calcIntegral will throw an exception

     :type curveName: string
     :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it (e.g. "bicep_fiberForceLengthCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception unless the following conditions are met
            -eIso > eZero
            -kIso > 1/(eIso-eZero)
            -0 < kLow < kIso
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction*


    Image: fig_SmoothSegmentedFunctionFactory_fcLengthCurve.png


    **Computational Costs**

        Without Integral :   ~4,100 flops
        With Integral    : ~174,100 flops

    **Example:**

    .. code-block:: c++

            double eIso      = 0.6;
            double eZero     = 0.0;
            double kIso      = 4.0/(eIso-eZero);
            double kNearZero = 0.025*kIso
            double c         = 0.5;

            SmoothSegmentedFunction fiberFLCurve
            = SmoothSegmentedFunctionFactory::
              createFiberForceLengthCurve(eZero, eIso,
                                          kLow, kIso, c, true,"test");
            fiberFLCurve.printMuscleCurveToFile();
    """
    return _common.SmoothSegmentedFunctionFactory_createFiberForceLengthCurve(eZero, eIso, kLow, kIso, curviness, computeIntegral, curveName)

def SmoothSegmentedFunctionFactory_createTendonForceLengthCurve(eIso: "double", kIso: "double", fToe: "double", curviness: "double", computeIntegral: "bool", curveName: "std::string const &") -> "SmoothSegmentedFunction *":
    r"""
    Will generate a C2-continuous (continuous to the second derivative)
    curve in a MuscleFunctionObject object that fits a tendon's tensile
    force length curve.



    :type eIso: float
    :param eIso:   The tendon strain at which the tendon develops 1 unit
                    of normalized force (1 maximum isometric force). Note that
                    the'1' is left off. Thus an e0 of 0.04 means that the tendon
                    will develop an 1 normalized force unit when it is strained
                    by 4% of its resting length, at a normalized length of
                    1.04

    :type kIso: float
    :param kIso:    The normalized stiffness (or slope) of the tendon
                        curve when the tendon is strained by e0
                        (or has a length of 1+e0) under a load of 1 maximum
                        isometric unit of force.

    :type fToe: float
    :param fToe:    The normalized force at which the tendon smoothly
                       transitions from the curved low stiffness region to
                       the linear stiffness region.

    :type curviness: float
    :param curviness:    The dimensionless 'curviness' parameter that
                            can vary between 0 (a line) to 1 (a smooth, but
                            sharply bent elbow)

    :type computeIntegral: boolean
    :param computeIntegral:  If this is true, the integral for this curve
                                is numerically calculated and splined. If false,
                                this integral is not computed, and a call to
                                .calcIntegral will throw an exception

     :type curveName: string
     :param curveName: The name of the muscle this curve applies to. This
                          curve name should have the name of the muscle and the
                          curve in it (e.g. "bicep_tendonForceLengthCurve")
                          so that, if this curve ever causes an exception, a
                          user-friendly error message can be displayed to the
                          end user to help them debug their model.

    :raises: SimTK::Exception unless the following conditions are met:
            -0 < fToe < 1
            -e0 > 0
            -kiso > 1/e0
            -0 <= curviness <= 1

    :rtype: SmoothSegmentedFunction
    :return: SmoothSegmentedFunction*

    Image: fig_SmoothSegmentedFunctionFactory_fseCurve.png


    **Computational Costs**

        Without Integral :   ~4,100 flops
        With Integral    : ~174,100 flops

    **Example:**

    .. code-block:: c++

            double e0   = 0.04;
            double kiso = 42.79679348815859;
            double fToe = 1.0/3.0
            double c    = 0.75;

            SmoothSegmentedFunction* tendonCurve = SmoothSegmentedFunctionFactory::
                                                createTendonForceLengthCurve(
                                                  e0,kiso,fToe,c,true,"test");
            tendonCurve.printMuscleCurveToFile();

    """
    return _common.SmoothSegmentedFunctionFactory_createTendonForceLengthCurve(eIso, kIso, fToe, curviness, computeIntegral, curveName)

class SmoothSegmentedFunction(object):
    r"""
        This class contains the quintic Bezier curves, x(u) and y(u), that have been
        created by SmoothSegmentedFunctionFactory to follow a physiologically meaningful
        muscle characteristic. A SmoothSegmentedFunction cannot be created directly,
        you must use SmoothSegmentedFunctionFactory to create the muscle curve of
        interest.

        **Future Upgrades**
        1. Add a hint object to keep the last u that corresponded to the location of
           interest to prevent unnecessary redundant evaluations of u. This hint
           could be similar in form to the used by the SimTK::BicubicSurface class

           **Computational Cost Details**
            All computational costs assume the following operation costs:

                    Operation Type   : #flops
            +,-,=,Boolean Op : 1 
    : 10
                         sqrt: 20
                         trig: 40

            These relative weightings will vary processor to processor, and so any of
            the quoted computational costs are approximate.

            Author: Matt Millard
            Version: 0.0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        The default constructor, which populates the member data fields with
        NaN's
        """
        _common.SmoothSegmentedFunction_swiginit(self, _common.new_SmoothSegmentedFunction())

    def calcValue(self, x: "double") -> "double":
        r"""
        Calculates the value of the curve this object represents.

               :type x: float
               :param x: The domain point of interest
               :raises: OpenSim::Exception
                    -If ax does not have a size of 1
               :rtype: float
               :return: The value of the curve


               The curve is parameterized as a set of Bezier curves. If x is within the
               domain of these Bezier curves they will be evaluated. If x is outside
               of the domain of these Bezier curves a linear extrapolation will be
               evaluated


               **Computational Costs**
                           x in curve domain  : ~282 flops
                    x in linear section:   ~5 flops
        """
        return _common.SmoothSegmentedFunction_calcValue(self, x)

    def calcDerivative(self, x: "double", order: "int") -> "double":
        r"""
        Calculates the value of the derivative of the curve this object
               represents.

               :type x: float
               :param x:     The domain point of interest.

               :type order: int
               :param order: The order of the derivative to compute. Note that order must
                                be between 0 and 2. Calling 0 just calls calcValue.

               :raises: OpenSim::Exception
                    -If anything but 0's are stored in derivComponents
                    -If more than the 6th derivative is asked for
                    -If ax has a size other than 1

               :rtype: float
               :return: The value of the d^ny/dx^n th derivative evaluated at x



               **Computational Costs**
                           x in curve domain  : ~391 flops
                    x in linear section:   ~2 flops
        """
        return _common.SmoothSegmentedFunction_calcDerivative(self, x, order)

    def calcIntegral(self, x: "double") -> "double":
        r"""
        This will return the value of the integral of this objects curve
               evaluated at x.

               :type x: float
               :param x: the domain point of interest
               :raises: OpenSim::Exception
                    -If the function does not have a pre-computed integral
               :rtype: float
               :return: the value of the functions integral evaluated at x

               The integral is approximate, though its errors are small.
               The integral is computed by numerically integrating the function when
               the constructor for this class is called (if computeIntegral is true) and
               then splining the result, thus the regions between the knot points may
               have some error in them. A very fine mesh of points is used to create the
               spline so the errors will be small

               **Computational Costs**
                           x in curve domain  : ~13 flops
                    x in linear section: ~19 flops
        """
        return _common.SmoothSegmentedFunction_calcIntegral(self, x)

    def isIntegralAvailable(self) -> "bool":
        r"""
        Returns a bool that indicates if the integral curve has been computed.

        :rtype: boolean
        :return: true if the integral of this function is available, false if
                    it has not been computed.
        """
        return _common.SmoothSegmentedFunction_isIntegralAvailable(self)

    def isIntegralComputedLeftToRight(self) -> "bool":
        r"""
        Returns a bool that indicates if the integral computed is computed left
        to right, or right to left.

        :rtype: boolean
        :return: true if the integral was computed left to right, and false if the
                    integral was computed right to left. Note that the output of
                    this function is only valid if isIntegralAvailable() returns
                    true.
        """
        return _common.SmoothSegmentedFunction_isIntegralComputedLeftToRight(self)

    def getName(self) -> "std::string":
        r"""
        Returns a string that is the name for this curve, which is set at the
        time of construction and cannot be changed after construction.

        :rtype: string
        :return: The string name this object was given during construction
        """
        return _common.SmoothSegmentedFunction_getName(self)

    def setName(self, name: "std::string &") -> "void":
        return _common.SmoothSegmentedFunction_setName(self, name)

    def getCurveDomain(self) -> "SimTK::Vec2":
        r"""
        This function returns a SimTK::Vec2 that contains in its 0th element
        the lowest value of the curve domain, and in its 1st element the highest
        value in the curve domain of the curve. Outside of this domain the curve
        is approximated using linear extrapolation.

        :rtype: :py:class:`Vec2`
        :return: The minimum and maximum value of the domain, x, of the curve
                       y(x). Within this range y(x) is a curve, outside of this range
                       the function y(x) is a C2 (continuous to the second
                       derivative) linear extrapolation
        """
        return _common.SmoothSegmentedFunction_getCurveDomain(self)

    def printMuscleCurveToCSVFile(self, path: "std::string const &", domainMin: "double", domainMax: "double") -> "void":
        r"""
        This function will generate a csv file (of 'name_curveName.csv', where
               name is the one used in the constructor) of the muscle curve, and
               'curveName' corresponds to the function that was called from
               SmoothSegmentedFunctionFactory to create the curve.

               :type path: string
               :param path: The full path to the location. Note '/' slashes must be used,
                        and do not put a '/' after the last folder.
               :type domainMin: float
               :param domainMin:
                             the left most domain point of the curve to print. The curve
                             will extend to at least this point.
               :type domainMax: float
               :param domainMax:
                             the right most domain point of the curve to print. The
                             printed curve will extend at least to this point, perhaps
                             beyond.
                :raises: OpenSim::Exception
                        -If the filename is empty

               For example the tendon
               curve for a muscle named 'glutmax' will be:

               'glutmax_tendonForceLengthCurve.csv'

               The file will contain the following columns:

                      Col# 1, 2,     3,       4,  5
                    x, y, dy/dx, d2y/dx2,  iy

               Where iy is the integral of y(x). If the curve has been set not to have
               an integral, this column will not exist.

               The curve will be sampled from its linear extrapolation region, through
               the curve, out to the other linear extrapolation region. The width of
               each linear extrapolation region is 10% of the entire range of x, or
               0.1*(x1-x0).

               The number of rows used will vary from curve to curve. Each quintic
               Bezier curve section will have 100 samples. Each linearly extrapolated
               region will have 10 samples each. Some muscle curves (the tendon,
               parallel elements, compressive elements) consist of only 1 elbow, and so
               these matrices will have only 100+20 rows. The force velocity curve is
               made up of 2 elbows and will have 200+20 rows. The active force length
               curve has 5 elbows, and so its sampled matrix will have 500+20 rows

               **Computational Costs**
               This varies depending on the curve (as mentioned above).
                           ~97,400 to 487,000 flops

               **Example**
               To read the csv file with a header in from Matlab, you need to use
               csvread set so that it will ignore the header row. This is accomplished
               by using the extra two numerical arguments for csvread to tell the
               function to begin reading from the 1st row, and the 0th index (csvread
               is 0 indexed).
                       data=csvread('test_tendonForceLengthCurve.csv',1,0);
        """
        return _common.SmoothSegmentedFunction_printMuscleCurveToCSVFile(self, path, domainMin, domainMax)

    def calcSampledMuscleCurve(self, maxOrder: "int", domainMin: "double", domainMax: "double") -> "SimTK::Matrix":
        r"""
        Conditional comment:
               THIS FUNCTION IS PUBLIC FOR TESTING ONLY
                           DO NOT USE THIS!

               :type maxOrder: int
               :param maxOrder: The maximum derivative order to compute
               :raises: OpenSim::Exception
                    -If the requested derivative order is greater than getMaxDerivativeOrder()
               :rtype: :py:class:`Matrix`
               :return: a matrix populated with x,y,dy/dx ... d^ny/dx^n,iy


               This function will generate a SimTK::Matrix populated with samples of
               the muscle curves values, derivatives (up to 6) and its first integral.
               The matrix has the following columns:

                      Col# 1, 2,     3,       4,       5,       6,       7,       8, 9,
                    x, y, dy/dx, d2y/dx2, d3y/dx3, d4y/dx4, d5y/dx5, d6y/dx6, iy

               Where iy is the integral of y(x). If the curve has been set not to have
               an integral, this column will not exist.

               The curve will be sampled from its
               linear extrapolation region, through the curve, out to the other linear
               extrapolation region. The width of each linear extrapolation region is
               10% of the entire range of x, or 0.1*(x1-x0).

               The rows used will vary from curve to curve. Each quintic Bezier curve
               section will have 100 samples + 20 samples for the linear extrapolation
               region. Some muscle curves (the tendon, parallel elements, compressive
               elements) consist of only 1 elbow, and so these matrices will have only
               100+20 rows. The force velocity curve is made up of 2 elbows and will
               have 200+20 rows. The active force length curve has 5 elbows, and so its
               sampled matrix will have 500+20 rows
        """
        return _common.SmoothSegmentedFunction_calcSampledMuscleCurve(self, maxOrder, domainMin, domainMax)
    __swig_destroy__ = _common.delete_SmoothSegmentedFunction

# Register SmoothSegmentedFunction in _common:
_common.SmoothSegmentedFunction_swigregister(SmoothSegmentedFunction)

class XYPoint(object):
    r""" Conditional comment:"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _x = property(_common.XYPoint__x_get, _common.XYPoint__x_set)
    _y = property(_common.XYPoint__y_get, _common.XYPoint__y_set)

    def __init__(self, *args):
        _common.XYPoint_swiginit(self, _common.new_XYPoint(*args))
    __swig_destroy__ = _common.delete_XYPoint

# Register XYPoint in _common:
_common.XYPoint_swigregister(XYPoint)

class XYFunctionInterface(OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::XYFunctionInterface *":
        return _common.XYFunctionInterface_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.XYFunctionInterface_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.XYFunctionInterface_getClassName()

    def clone(self) -> "OpenSim::XYFunctionInterface *":
        return _common.XYFunctionInterface_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.XYFunctionInterface_getConcreteClassName(self)
    typeConstant = _common.XYFunctionInterface_typeConstant
    typeStepFunction = _common.XYFunctionInterface_typeStepFunction
    typePiecewiseConstantFunction = _common.XYFunctionInterface_typePiecewiseConstantFunction
    typePiecewiseLinearFunction = _common.XYFunctionInterface_typePiecewiseLinearFunction
    typeLinearFunction = _common.XYFunctionInterface_typeLinearFunction
    typeNatCubicSpline = _common.XYFunctionInterface_typeNatCubicSpline
    typeGCVSpline = _common.XYFunctionInterface_typeGCVSpline
    typeUndefined = _common.XYFunctionInterface_typeUndefined

    @staticmethod
    def isXYFunction(f: "Function") -> "bool":
        return _common.XYFunctionInterface_isXYFunction(f)

    def __init__(self, f: "Function"):
        _common.XYFunctionInterface_swiginit(self, _common.new_XYFunctionInterface(f))

    def isSpecifiedByControlPoints(self) -> "bool":
        return _common.XYFunctionInterface_isSpecifiedByControlPoints(self)

    def getNumberOfPoints(self) -> "int":
        return _common.XYFunctionInterface_getNumberOfPoints(self)

    def getXValues(self) -> "double const *":
        return _common.XYFunctionInterface_getXValues(self)

    def getYValues(self) -> "double const *":
        return _common.XYFunctionInterface_getYValues(self)

    def getX(self, aIndex: "int") -> "double":
        return _common.XYFunctionInterface_getX(self, aIndex)

    def getY(self, aIndex: "int") -> "double":
        return _common.XYFunctionInterface_getY(self, aIndex)

    def setX(self, aIndex: "int", aValue: "double") -> "void":
        return _common.XYFunctionInterface_setX(self, aIndex, aValue)

    def setY(self, aIndex: "int", aValue: "double") -> "void":
        return _common.XYFunctionInterface_setY(self, aIndex, aValue)

    def deletePoint(self, aIndex: "int") -> "bool":
        return _common.XYFunctionInterface_deletePoint(self, aIndex)

    def deletePoints(self, indices: "ArrayInt") -> "bool":
        return _common.XYFunctionInterface_deletePoints(self, indices)

    def addPoint(self, aX: "double", aY: "double") -> "int":
        return _common.XYFunctionInterface_addPoint(self, aX, aY)

    def renderAsLineSegments(self, aIndex: "int") -> "OpenSim::Array< OpenSim::XYPoint > *":
        return _common.XYFunctionInterface_renderAsLineSegments(self, aIndex)

    @staticmethod
    def deleteXYPointArray(aArray: "ArrayXYPoint") -> "void":
        return _common.XYFunctionInterface_deleteXYPointArray(aArray)

    def getFunctionType(self) -> "OpenSim::XYFunctionInterface::FunctionType":
        return _common.XYFunctionInterface_getFunctionType(self)

    def getScale(self) -> "double":
        return _common.XYFunctionInterface_getScale(self)

    def getConstant(self) -> "OpenSim::Constant *":
        return _common.XYFunctionInterface_getConstant(self)

    def getStepFunction(self) -> "OpenSim::StepFunction *":
        return _common.XYFunctionInterface_getStepFunction(self)

    def getMultiStepFunction(self) -> "OpenSim::PiecewiseConstantFunction *":
        return _common.XYFunctionInterface_getMultiStepFunction(self)

    def getPiecewiseLinearFunction(self) -> "OpenSim::PiecewiseLinearFunction *":
        return _common.XYFunctionInterface_getPiecewiseLinearFunction(self)

    def getLinearFunction(self) -> "OpenSim::LinearFunction *":
        return _common.XYFunctionInterface_getLinearFunction(self)

    def getSimmSpline(self) -> "OpenSim::SimmSpline *":
        return _common.XYFunctionInterface_getSimmSpline(self)

    def getGCVSpline(self) -> "OpenSim::GCVSpline *":
        return _common.XYFunctionInterface_getGCVSpline(self)
    __swig_destroy__ = _common.delete_XYFunctionInterface

# Register XYFunctionInterface in _common:
_common.XYFunctionInterface_swigregister(XYFunctionInterface)

def XYFunctionInterface_safeDownCast(obj: "OpenSimObject") -> "OpenSim::XYFunctionInterface *":
    return _common.XYFunctionInterface_safeDownCast(obj)

def XYFunctionInterface_getClassName() -> "std::string const &":
    return _common.XYFunctionInterface_getClassName()

def XYFunctionInterface_isXYFunction(f: "Function") -> "bool":
    return _common.XYFunctionInterface_isXYFunction(f)

def XYFunctionInterface_deleteXYPointArray(aArray: "ArrayXYPoint") -> "void":
    return _common.XYFunctionInterface_deleteXYPointArray(aArray)

class ArrayXYPoint(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayXYPoint

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`XYPoint`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::XYPoint >
        :param aArray: Array to be copied.
        """
        _common.ArrayXYPoint_swiginit(self, _common.new_ArrayXYPoint(*args))

    def arrayEquals(self, aArray: "ArrayXYPoint") -> "bool":
        return _common.ArrayXYPoint_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayXYPoint_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayXYPoint_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayXYPoint_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayXYPoint_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`XYPoint`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::XYPoint >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayXYPoint_append(self, *args)

    def insert(self, aIndex: "int", aValue: "XYPoint") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`XYPoint`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayXYPoint_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayXYPoint_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "XYPoint") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`XYPoint`
        :param aValue: Value.
        """
        return _common.ArrayXYPoint_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::XYPoint const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`XYPoint`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayXYPoint_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::XYPoint":
        return _common.ArrayXYPoint_getitem(self, index)

    def setitem(self, index: "int", val: "XYPoint") -> "void":
        return _common.ArrayXYPoint_setitem(self, index, val)

    def getLast(self) -> "OpenSim::XYPoint const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`XYPoint`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayXYPoint_getLast(self)

    def findIndex(self, aValue: "XYPoint") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`XYPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayXYPoint_findIndex(self, aValue)

    def rfindIndex(self, aValue: "XYPoint") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`XYPoint`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayXYPoint_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "XYPoint", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`XYPoint`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayXYPoint_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayXYPoint in _common:
_common.ArrayXYPoint_swigregister(ArrayXYPoint)

class ArrayBool(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayBool

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: boolean, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< bool >
        :param aArray: Array to be copied.
        """
        _common.ArrayBool_swiginit(self, _common.new_ArrayBool(*args))

    def arrayEquals(self, aArray: "ArrayBool") -> "bool":
        return _common.ArrayBool_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayBool_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayBool_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayBool_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayBool_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: boolean
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< bool >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayBool_append(self, *args)

    def insert(self, aIndex: "int", aValue: "bool const &") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: boolean
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayBool_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayBool_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "bool const &") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: boolean
        :param aValue: Value.
        """
        return _common.ArrayBool_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "bool const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: boolean
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayBool_get(self, aIndex)

    def getitem(self, index: "int") -> "bool":
        return _common.ArrayBool_getitem(self, index)

    def setitem(self, index: "int", val: "bool") -> "void":
        return _common.ArrayBool_setitem(self, index, val)

    def getLast(self) -> "bool const &":
        r"""
        Get the last value in the array.

        :rtype: boolean
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayBool_getLast(self)

    def findIndex(self, aValue: "bool const &") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: boolean
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayBool_findIndex(self, aValue)

    def rfindIndex(self, aValue: "bool const &") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: boolean
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayBool_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "bool const &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: boolean
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayBool_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayBool in _common:
_common.ArrayBool_swigregister(ArrayBool)

class ArrayDouble(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayDouble

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: float, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< double >
        :param aArray: Array to be copied.
        """
        _common.ArrayDouble_swiginit(self, _common.new_ArrayDouble(*args))

    def arrayEquals(self, aArray: "ArrayDouble") -> "bool":
        return _common.ArrayDouble_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayDouble_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayDouble_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayDouble_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayDouble_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: float
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< double >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayDouble_append(self, *args)

    def insert(self, aIndex: "int", aValue: "double const &") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: float
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayDouble_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayDouble_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "double const &") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: float
        :param aValue: Value.
        """
        return _common.ArrayDouble_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "double const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: float
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayDouble_get(self, aIndex)

    def getitem(self, index: "int") -> "double":
        return _common.ArrayDouble_getitem(self, index)

    def setitem(self, index: "int", val: "double") -> "void":
        return _common.ArrayDouble_setitem(self, index, val)

    def getLast(self) -> "double const &":
        r"""
        Get the last value in the array.

        :rtype: float
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayDouble_getLast(self)

    def findIndex(self, aValue: "double const &") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: float
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayDouble_findIndex(self, aValue)

    def rfindIndex(self, aValue: "double const &") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: float
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayDouble_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "double const &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: float
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayDouble_searchBinary(self, aValue, aFindFirst, aLo, aHi)

    def appendVec3(self, vec3: "Vec3") -> "void":
        return _common.ArrayDouble_appendVec3(self, vec3)

    def appendVector(self, vec: "Vector") -> "void":
        return _common.ArrayDouble_appendVector(self, vec)

    def getAsVec3(self) -> "SimTK::Vec3":
        return _common.ArrayDouble_getAsVec3(self)

    @staticmethod
    def createVec3(*args) -> "SimTK::Vec3":
        return _common.ArrayDouble_createVec3(*args)

    def getAsVector(self) -> "SimTK::Vector_< double >":
        return _common.ArrayDouble_getAsVector(self)

    def populateFromVector(self, aVector: "Vector") -> "void":
        return _common.ArrayDouble_populateFromVector(self, aVector)

    @staticmethod
    def getValuesFromVec3(vec3: "Vec3") -> "OpenSim::Array< double >":
        return _common.ArrayDouble_getValuesFromVec3(vec3)

    def toString(self) -> "std::string":
        return _common.ArrayDouble_toString(self)

    def setFromPyArray(self, dValues: "double *", size: "int") -> "void":
        return _common.ArrayDouble_setFromPyArray(self, dValues, size)

# Register ArrayDouble in _common:
_common.ArrayDouble_swigregister(ArrayDouble)

def ArrayDouble_createVec3(*args) -> "SimTK::Vec3":
    return _common.ArrayDouble_createVec3(*args)

def ArrayDouble_getValuesFromVec3(vec3: "Vec3") -> "OpenSim::Array< double >":
    return _common.ArrayDouble_getValuesFromVec3(vec3)

class ArrayInt(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayInt

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: int, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< int >
        :param aArray: Array to be copied.
        """
        _common.ArrayInt_swiginit(self, _common.new_ArrayInt(*args))

    def arrayEquals(self, aArray: "ArrayInt") -> "bool":
        return _common.ArrayInt_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayInt_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayInt_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayInt_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayInt_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: int
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< int >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayInt_append(self, *args)

    def insert(self, aIndex: "int", aValue: "int const &") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: int
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayInt_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayInt_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "int const &") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: int
        :param aValue: Value.
        """
        return _common.ArrayInt_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "int const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: int
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayInt_get(self, aIndex)

    def getitem(self, index: "int") -> "int":
        return _common.ArrayInt_getitem(self, index)

    def setitem(self, index: "int", val: "int") -> "void":
        return _common.ArrayInt_setitem(self, index, val)

    def getLast(self) -> "int const &":
        r"""
        Get the last value in the array.

        :rtype: int
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayInt_getLast(self)

    def findIndex(self, aValue: "int const &") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: int
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayInt_findIndex(self, aValue)

    def rfindIndex(self, aValue: "int const &") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: int
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayInt_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "int const &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: int
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayInt_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayInt in _common:
_common.ArrayInt_swigregister(ArrayInt)

class ArrayStr(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayStr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: string, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< std::string >
        :param aArray: Array to be copied.
        """
        _common.ArrayStr_swiginit(self, _common.new_ArrayStr(*args))

    def arrayEquals(self, aArray: "ArrayStr") -> "bool":
        return _common.ArrayStr_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayStr_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayStr_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayStr_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayStr_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: string
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< std::string >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayStr_append(self, *args)

    def insert(self, aIndex: "int", aValue: "std::string const &") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: string
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayStr_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayStr_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "std::string const &") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: string
        :param aValue: Value.
        """
        return _common.ArrayStr_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "std::string const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: string
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayStr_get(self, aIndex)

    def getitem(self, index: "int") -> "std::string":
        return _common.ArrayStr_getitem(self, index)

    def setitem(self, index: "int", val: "std::string") -> "void":
        return _common.ArrayStr_setitem(self, index, val)

    def getLast(self) -> "std::string const &":
        r"""
        Get the last value in the array.

        :rtype: string
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayStr_getLast(self)

    def findIndex(self, aValue: "std::string const &") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: string
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayStr_findIndex(self, aValue)

    def rfindIndex(self, aValue: "std::string const &") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: string
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayStr_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "std::string const &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: string
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayStr_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayStr in _common:
_common.ArrayStr_swigregister(ArrayStr)

class ArrayVec3(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayVec3

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: SimTK::Vec< 3,double,1 >, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< SimTK::Vec< 3,double,1 > >
        :param aArray: Array to be copied.
        """
        _common.ArrayVec3_swiginit(self, _common.new_ArrayVec3(*args))

    def arrayEquals(self, aArray: "ArrayVec3") -> "bool":
        return _common.ArrayVec3_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayVec3_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayVec3_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayVec3_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayVec3_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< SimTK::Vec< 3,double,1 > >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayVec3_append(self, *args)

    def insert(self, aIndex: "int", aValue: "Vec3") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayVec3_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayVec3_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "Vec3") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value.
        """
        return _common.ArrayVec3_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "SimTK::Vec< 3,double,1 > const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: SimTK::Vec< 3,double,1 >
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayVec3_get(self, aIndex)

    def getitem(self, index: "int") -> "SimTK::Vec< 3,double,1 >":
        return _common.ArrayVec3_getitem(self, index)

    def setitem(self, index: "int", val: "Vec3") -> "void":
        return _common.ArrayVec3_setitem(self, index, val)

    def getLast(self) -> "SimTK::Vec< 3,double,1 > const &":
        r"""
        Get the last value in the array.

        :rtype: SimTK::Vec< 3,double,1 >
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayVec3_getLast(self)

    def findIndex(self, aValue: "Vec3") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayVec3_findIndex(self, aValue)

    def rfindIndex(self, aValue: "Vec3") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayVec3_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "Vec3", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: SimTK::Vec< 3,double,1 >
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayVec3_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayVec3 in _common:
_common.ArrayVec3_swigregister(ArrayVec3)

class ArrayObjPtr(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayObjPtr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`Object`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::Object * >
        :param aArray: Array to be copied.
        """
        _common.ArrayObjPtr_swiginit(self, _common.new_ArrayObjPtr(*args))

    def arrayEquals(self, aArray: "ArrayObjPtr") -> "bool":
        return _common.ArrayObjPtr_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayObjPtr_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayObjPtr_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayObjPtr_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayObjPtr_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`Object`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::Object * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayObjPtr_append(self, *args)

    def insert(self, aIndex: "int", aValue: "OpenSimObject") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`Object`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayObjPtr_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayObjPtr_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "OpenSimObject") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`Object`
        :param aValue: Value.
        """
        return _common.ArrayObjPtr_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::Object *const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Object`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayObjPtr_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::Object *":
        return _common.ArrayObjPtr_getitem(self, index)

    def setitem(self, index: "int", val: "OpenSimObject") -> "void":
        return _common.ArrayObjPtr_setitem(self, index, val)

    def getLast(self) -> "OpenSim::Object *const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`Object`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayObjPtr_getLast(self)

    def findIndex(self, aValue: "OpenSimObject") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayObjPtr_findIndex(self, aValue)

    def rfindIndex(self, aValue: "OpenSimObject") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayObjPtr_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "OpenSimObject", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayObjPtr_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayObjPtr in _common:
_common.ArrayObjPtr_swigregister(ArrayObjPtr)

class ArrayPtrsObj(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayPtrsObj

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Object >
        :param aArray: Array to be copied.
        """
        _common.ArrayPtrsObj_swiginit(self, _common.new_ArrayPtrsObj(*args))

    def clearAndDestroy(self) -> "void":
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsObj_clearAndDestroy(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.ArrayPtrsObj_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayPtrsObj_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayPtrsObj_size(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Object >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.ArrayPtrsObj_getIndex(self, *args)

    def append(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Object >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.ArrayPtrsObj_append(self, *args)

    def insert(self, aIndex: "int", aObject: "OpenSimObject") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.ArrayPtrsObj_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Object >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.ArrayPtrsObj_remove(self, *args)

    def set(self, aIndex: "int", aObject: "OpenSimObject") -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Object`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsObj_set(self, aIndex, aObject)

    def get(self, *args) -> "OpenSim::Object *":
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.ArrayPtrsObj_get(self, *args)

    def getLast(self) -> "OpenSim::Object *":
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`Object`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayPtrsObj_getLast(self)

    def searchBinary(self, aObject: "OpenSim::ArrayPtrs< OpenSim::Object >::ConstT &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayPtrsObj_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register ArrayPtrsObj in _common:
_common.ArrayPtrsObj_swigregister(ArrayPtrsObj)

class ArrayConstObjPtr(object):
    r"""
    A class for storing an array of values of type T.  The capacity of the class
    grows as needed.  To use this template for a class of type T, class T should
    implement the following methods:  default constructor, copy constructor,
    assignment operator (=), equality operator (==), and less than
    operator (<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayConstObjPtr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aDefaultValue: :py:class:`Object`, optional
        :param aDefaultValue: Default value of an array element.  This value
            is used to initialize array elements as the size of the array is
            changed.
        :type aSize: int, optional
        :param aSize: Initial size of the array.  The array elements are
            initialized to aDefaultValue.
        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The initial capacity
            is guaranteed to be at least as large as aSize + 1.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::Array< OpenSim::Object const * >
        :param aArray: Array to be copied.
        """
        _common.ArrayConstObjPtr_swiginit(self, _common.new_ArrayConstObjPtr(*args))

    def arrayEquals(self, aArray: "ArrayConstObjPtr") -> "bool":
        return _common.ArrayConstObjPtr_arrayEquals(self, aArray)

    def trim(self) -> "void":
        r"""
        Trim the capacity of this array so that it is one larger than the size
        of this array.  This is useful for reducing the amount of memory used
        by this array.  This capacity is kept at one larger than the size so
        that, for example, an array of characters can be treated as a NULL
        terminated string.
        """
        return _common.ArrayConstObjPtr_trim(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used to either increase
        or decrease the size of the array.  If this size of the array is
        increased, the new elements are initialized to the default value
        that was specified at the time of construction.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero.
        """
        return _common.ArrayConstObjPtr_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayConstObjPtr_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayConstObjPtr_size(self)

    def append(self, *args) -> "int":
        r"""
        *Overload 1:*

        Append a value onto the array.

        :type aValue: :py:class:`Object`
        :param aValue: Value to be appended.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.

        |

        *Overload 2:*

        Append an array of values.

        :type aArray: OpenSim::Array< OpenSim::Object const * >
        :param aArray: Array of values to append.
        :rtype: int
        :return: New size of the array, or, equivalently, the index to the new
            first empty element of the array.
        """
        return _common.ArrayConstObjPtr_append(self, *args)

    def insert(self, aIndex: "int", aValue: "OpenSimObject") -> "int":
        r"""
        Insert a value into the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aValue: :py:class:`Object`
        :param aValue: Value to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new value.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  If the specified index is greater than the
            current size of the array, the size of the array is increased to aIndex+1
            and the intervening new elements are initialized to the default value that
            was specified at the time of construction.
        :rtype: int
        :return: Size of the array after the insertion.
        """
        return _common.ArrayConstObjPtr_insert(self, aIndex, aValue)

    def remove(self, aIndex: "int") -> "int":
        r"""
        Remove a value from the array at a specified index.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: int
        :return: Size of the array after the removal.
        """
        return _common.ArrayConstObjPtr_remove(self, aIndex)

    def set(self, aIndex: "int", aValue: "OpenSimObject") -> "void":
        r"""
        %Set the value at a specified index.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  It is permissible
            for aIndex to be past the current end of the array- the capacity will
            be increased if necessary.  Values between the current end of the array
            and aIndex are not initialized.
        :type aValue: :py:class:`Object`
        :param aValue: Value.
        """
        return _common.ArrayConstObjPtr_set(self, aIndex, aValue)

    def get(self, aIndex: "int") -> "OpenSim::Object const *const &":
        r"""
        Get a const reference to the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Object`
        :return: const reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size).
        See also: operator[].
        """
        return _common.ArrayConstObjPtr_get(self, aIndex)

    def getitem(self, index: "int") -> "OpenSim::Object const *":
        return _common.ArrayConstObjPtr_getitem(self, index)

    def setitem(self, index: "int", val: "OpenSimObject") -> "void":
        return _common.ArrayConstObjPtr_setitem(self, index, val)

    def getLast(self) -> "OpenSim::Object const *const &":
        r"""
        Get the last value in the array.

        :rtype: :py:class:`Object`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayConstObjPtr_getLast(self)

    def findIndex(self, aValue: "OpenSimObject") -> "int":
        r"""
        Linear search for an element matching a given value.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the first of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayConstObjPtr_findIndex(self, aValue)

    def rfindIndex(self, aValue: "OpenSimObject") -> "int":
        r"""
        Linear search in reverse for an element matching a given value.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :rtype: int
        :return: Index of the array element matching aValue. If there is more than
            one such elements with the same value the index of the last of these elements
            is returned.  If no match is found, -1 is returned.
        """
        return _common.ArrayConstObjPtr_rfindIndex(self, aValue)

    def searchBinary(self, aValue: "OpenSimObject", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for elements to

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :type aValue: :py:class:`Object`
        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayConstObjPtr_searchBinary(self, aValue, aFindFirst, aLo, aHi)

# Register ArrayConstObjPtr in _common:
_common.ArrayConstObjPtr_swigregister(ArrayConstObjPtr)

class ArrayPtrsConstObj(object):
    r"""
    A class for storing an array of pointers to objects of type T.

    In contrast to class Array<T>, when an object is added to this array
    a copy is not made.  Rather, a pointer to the added object is
    stored in the array.

    When an ArrayPtrs object falls out of scope or is deleted, all objects
    pointed to by the pointers in the array are deleted unless the array
    is set not to own the memory associated with the objects to which its
    array points.

    The capacity of the class grows as needed.  To use this template for a
    class of type T, class T should implement the following methods:
    default constructor, copy constructor, T* clone(),
    assignment operator (=), equality operator (==), less than
    operator (<), and the output operator (<<).

    Version: 1.0
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ArrayPtrsConstObj

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        :type aCapacity: int, optional
        :param aCapacity: Initial capacity of the array.  The capacity
            must be 1 or greater.

        |

        *Overload 2:*

        Copy constructor.

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Object const >
        :param aArray: Array to be copied.
        """
        _common.ArrayPtrsConstObj_swiginit(self, _common.new_ArrayPtrsConstObj(*args))

    def clearAndDestroy(self) -> "void":
        r"""
        Destroy all objects pointed to by this array and set the size of the
        array to zero.  When this method is called, the objects pointed to by
        this array are destroyed (deleted) even if this array is not set as
        the memory owner.

        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsConstObj_clearAndDestroy(self)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        Assign this array to a specified array.
        This operator makes a complete copy of the specified array; all member
        variables and objects in the array are copied.  Because all objects are
        copied, this object takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical arrays, with the possible exception of the _memoryOwner flag.

        :param aArray: Array to be copied.
        :rtype: boolean
        :return: Reference to this array.

        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.ArrayPtrsConstObj_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.ArrayPtrsConstObj_getSize(self)

    def size(self) -> "int":
        r""" Alternate name for getSize(). *"""
        return _common.ArrayPtrsConstObj_size(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object by specifying its name.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Object const >::ConstT
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.ArrayPtrsConstObj_getIndex(self, *args)

    def append(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Append to the array.  A copy of the specified object is NOT made.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.

        |

        *Overload 2:*

        Append an array of objects.  Copies of the objects are NOT made

        :type aArray: OpenSim::ArrayPtrs< OpenSim::Object const >
        :param aArray: Array of objects to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.ArrayPtrsConstObj_append(self, *args)

    def insert(self, aIndex: "int", aObject: "OpenSimObject") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Object`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.ArrayPtrsConstObj_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        If this array is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: OpenSim::ArrayPtrs< OpenSim::Object const >::ConstT
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.ArrayPtrsConstObj_remove(self, *args)

    def set(self, aIndex: "int", aObject: "OpenSimObject") -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.

        If the set method is successful and the array is set as the memory
        owner, the previous object stored at the specified index is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Object`
        :param aObject: Object to be set.
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        See also: setMemoryOwner()
        """
        return _common.ArrayPtrsConstObj_set(self, aIndex, aObject)

    def get(self, *args) -> "OpenSim::Object const *":
        r"""
        *Overload 1:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the object at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :param aIndex: Array index of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the desired object.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.ArrayPtrsConstObj_get(self, *args)

    def getLast(self) -> "OpenSim::Object const *":
        r"""
        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :param aName: Name of the desired object.
        :rtype: :py:class:`Object`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()

        Get the last value in the array.

        :rtype: :py:class:`Object`
        :return: Last value in the array.
        :raises: Exception if the array is empty.
        """
        return _common.ArrayPtrsConstObj_getLast(self)

    def searchBinary(self, aObject: "OpenSim::ArrayPtrs< OpenSim::Object const >::ConstT &", aFindFirst: "bool"=False, aLo: "int"=-1, aHi: "int"=-1) -> "int":
        r"""
        Search for the largest value in the array that is less than or
        equal to a specified value.  If there is more than one element with this
        largest value, the index of the first of these elements can optionally be
        found, but this can be up to twice as costly.

        This method assumes that the array element values monotonically
        increase as the array index increases.  Note that monotonically
        increase means never decrease, so it is permissible for adjacent elements
        to have the same value.

        A binary search is performed (i.e., the array is repeatedly subdivided
        into two bins one of which must contain the specified until the
        appropriate element is identified), so the performance of this method
        is approximately ln(n), where n is the size of the array.

        :param aValue: Value to which the array elements are compared.
        :type aFindFirst: boolean, optional
        :param aFindFirst: If true, find the first element that satisfies
            the search.  If false, the index of any element that satisfies the
            search can be returned- which index will be returned depends on the
            length of the array and is therefore somewhat arbitrary. By default,
            this flag is false.
        :type aLo: int, optional
        :param aLo: Lowest array index to consider in the search.
        :type aHi: int, optional
        :param aHi: Highest array index to consider in the search.
        :rtype: int
        :return: Index of the array element that has the largest value that is less
            than or equal to aValue.  If there is more than one such elements with the
            same value and aFindFirst is set to true, the index of the first of
            these elements is returned.  If an error is encountered (e.g., the array
            is empty), or the array contains no element that is less than or equal
            to aValue, -1 is returned.
        """
        return _common.ArrayPtrsConstObj_searchBinary(self, aObject, aFindFirst, aLo, aHi)

# Register ArrayPtrsConstObj in _common:
_common.ArrayPtrsConstObj_swigregister(ArrayPtrsConstObj)


def LoadOpenSimLibrary(*args) -> "void":
    r"""
    *Overload 1:*
     Load an OpenSim (plugin) library, using a path to a library (relative or
    absolute) but *without* the file extension (.dll, .so, .dylib). This method
    will prefer a debug variant of the library if OpenSim was built in debug.

    In MATLAB/Python, we suggest you use LoadOpenSimLibraryExact instead of this
    function. If you insist on using this variant, see the examples below.

    To load a plugin in MATLAB, use the following:

    .. code-block:: c++

        import org.opensim.modeling.*;
        opensimCommon.LoadOpenSimLibrary('<path>/osimMyPlugin');
    Do NOT use MATLAB's `loadlibrary()`.

    To load a plugin in Python, use the following:

    .. code-block:: python

        import opensim
        opensim.LoadOpenSimLibrary('<path>/osimMyPlugin')

    |

    *Overload 2:*
     Uses LoadOpenSimLibrary(const std::string&, bool), with verbosity.
    """
    return _common.LoadOpenSimLibrary(*args)

def LoadOpenSimLibraryExact(exactPath: "std::string const &", verbose: "bool"=True) -> "bool":
    r"""
     Load an OpenSim (plugin) library using the exact path specified. Therefore,
    you must supply an exact path to the library (either relative or absolute),
    including the file extension (.dll, .so, .dylib). The only change that may
    be made to the path is to convert forward slashes to backslashes on Windows
    (and vice versa on UNIX).

    To load a plugin in MATLAB, use the following:

    .. code-block:: c++

        import org.opensim.modeling.*;
        opensimCommon.LoadOpenSimLibraryExact('<path>/osimMyPlugin.dll');
    Do NOT use MATLAB's `loadlibrary()`.

    To load a plugin in Python, use the following:

    .. code-block:: python

        import opensim
        opensim.LoadOpenSimLibraryExact('<path>/osimMyPlugin.dll')

    Notes: If your (plugin) library depends on other libraries, make sure they
    are available as well (e.g., by setting the appropriate values for
    environment variables like `PATH` (Windows), `LD_LIBRARY_PATH` (Linux), and
    `DYLD_LIBRARY_PATH` (macOS)).

    :rtype: boolean
    :return: true if the library was successfully loaded; false otherwise.
    """
    return _common.LoadOpenSimLibraryExact(exactPath, verbose)
class ModelDisplayHints(OpenSimObject):
    r"""
     This class captures information indicating user or programmer preferences
    to guide automatic display geometry generation by a Model. Fields here may be
    set programmatically or as a result of user choices made in the GUI or
    ModelVisualizer. Any display-generating code including the GUI, ModelVisualizer,
    and any geometry-generating ModelComponent will be supplied with one of these
    so that it can modify its behavior if there are any fields it recognizes.

    If you are writing a ModelComponent that generates some of its own geometry,
    and you would like people to consider it well-behaved, you should check whether
    any of the flags here might reasonably be expected to affect the geometry that
    your component produces. The currently-supported flags are:
      - show wrap geometry
      - show contact geometry
      - show muscle paths (should apply to other path objects too)
      - show path points
      - show markers
      - show forces
      - show frames
      - show labels
      - show debug geometry

    This class is intended to provide some minimal user control over generated
    geometry in a form that is easy for a ModelComponent author to deal with, since
    the OpenSim user interface won't know anything about that component or its
    geometry. Nothing prevents a user interface from providing much more
    sophisticated control of display features that it understands and the OpenSim
    GUI does that.

    If you would like to see some additional generally-useful flags or options
    supported here, please file a feature request or post to the OpenSim forum on
    SimTK.org.

    Notes: The "set" methods here return a reference to the object so they can
    be chained for convenience like assignment statements.

    See also: ModelComponent::generateDecorations(), ModelVisualizer
    Author: Michael Sherman *
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelDisplayHints *":
        return _common.ModelDisplayHints_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ModelDisplayHints_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ModelDisplayHints_getClassName()

    def clone(self) -> "OpenSim::ModelDisplayHints *":
        return _common.ModelDisplayHints_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ModelDisplayHints_getConcreteClassName(self)

    def copyProperty_show_wrap_geometry(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_wrap_geometry(self, source)

    def append_show_wrap_geometry(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_wrap_geometry(self, value)

    def constructProperty_show_wrap_geometry(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_wrap_geometry(self, initValue)

    def get_show_wrap_geometry(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_wrap_geometry(self, *args)

    def upd_show_wrap_geometry(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_wrap_geometry(self, *args)

    def set_show_wrap_geometry(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_wrap_geometry(self, *args)

    def copyProperty_show_contact_geometry(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_contact_geometry(self, source)

    def append_show_contact_geometry(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_contact_geometry(self, value)

    def constructProperty_show_contact_geometry(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_contact_geometry(self, initValue)

    def get_show_contact_geometry(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_contact_geometry(self, *args)

    def upd_show_contact_geometry(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_contact_geometry(self, *args)

    def set_show_contact_geometry(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_contact_geometry(self, *args)

    def copyProperty_show_path_geometry(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_path_geometry(self, source)

    def append_show_path_geometry(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_path_geometry(self, value)

    def constructProperty_show_path_geometry(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_path_geometry(self, initValue)

    def get_show_path_geometry(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_path_geometry(self, *args)

    def upd_show_path_geometry(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_path_geometry(self, *args)

    def set_show_path_geometry(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_path_geometry(self, *args)

    def copyProperty_show_path_points(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_path_points(self, source)

    def append_show_path_points(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_path_points(self, value)

    def constructProperty_show_path_points(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_path_points(self, initValue)

    def get_show_path_points(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_path_points(self, *args)

    def upd_show_path_points(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_path_points(self, *args)

    def set_show_path_points(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_path_points(self, *args)

    def copyProperty_show_markers(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_markers(self, source)

    def append_show_markers(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_markers(self, value)

    def constructProperty_show_markers(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_markers(self, initValue)

    def get_show_markers(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_markers(self, *args)

    def upd_show_markers(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_markers(self, *args)

    def set_show_markers(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_markers(self, *args)

    def copyProperty_marker_color(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_marker_color(self, source)

    def append_marker_color(self, value: "Vec3") -> "int":
        return _common.ModelDisplayHints_append_marker_color(self, value)

    def constructProperty_marker_color(self, initValue: "Vec3") -> "void":
        return _common.ModelDisplayHints_constructProperty_marker_color(self, initValue)

    def get_marker_color(self, *args) -> "SimTK::Vec3 const &":
        return _common.ModelDisplayHints_get_marker_color(self, *args)

    def upd_marker_color(self, *args) -> "SimTK::Vec3 &":
        return _common.ModelDisplayHints_upd_marker_color(self, *args)

    def set_marker_color(self, *args) -> "void":
        return _common.ModelDisplayHints_set_marker_color(self, *args)

    def copyProperty_show_forces(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_forces(self, source)

    def append_show_forces(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_forces(self, value)

    def constructProperty_show_forces(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_forces(self, initValue)

    def get_show_forces(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_forces(self, *args)

    def upd_show_forces(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_forces(self, *args)

    def set_show_forces(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_forces(self, *args)

    def copyProperty_show_frames(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_frames(self, source)

    def append_show_frames(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_frames(self, value)

    def constructProperty_show_frames(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_frames(self, initValue)

    def get_show_frames(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_frames(self, *args)

    def upd_show_frames(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_frames(self, *args)

    def set_show_frames(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_frames(self, *args)

    def copyProperty_show_labels(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_labels(self, source)

    def append_show_labels(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_labels(self, value)

    def constructProperty_show_labels(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_labels(self, initValue)

    def get_show_labels(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_labels(self, *args)

    def upd_show_labels(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_labels(self, *args)

    def set_show_labels(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_labels(self, *args)

    def copyProperty_show_debug_geometry(self, source: "ModelDisplayHints") -> "void":
        return _common.ModelDisplayHints_copyProperty_show_debug_geometry(self, source)

    def append_show_debug_geometry(self, value: "bool const &") -> "int":
        return _common.ModelDisplayHints_append_show_debug_geometry(self, value)

    def constructProperty_show_debug_geometry(self, initValue: "bool const &") -> "void":
        return _common.ModelDisplayHints_constructProperty_show_debug_geometry(self, initValue)

    def get_show_debug_geometry(self, *args) -> "bool const &":
        return _common.ModelDisplayHints_get_show_debug_geometry(self, *args)

    def upd_show_debug_geometry(self, *args) -> "bool &":
        return _common.ModelDisplayHints_upd_show_debug_geometry(self, *args)

    def set_show_debug_geometry(self, *args) -> "void":
        return _common.ModelDisplayHints_set_show_debug_geometry(self, *args)

    def __init__(self):
        r"""
        Default construction creates a valid display hints object with all
           hints set to their default values. *
        """
        _common.ModelDisplayHints_swiginit(self, _common.new_ModelDisplayHints())

    def disableVisualization(self) -> "void":
        r"""
        Turn off visualization completely, only use for API/modeling.
           Meshes will not be loaded, path-wrapping intermediate points will
           not be computed, MomentArm computations are not affected however.
           Intentionally there's no reverse API to turn on visualization downstream.
        """
        return _common.ModelDisplayHints_disableVisualization(self)

    def isVisualizationEnabled(self) -> "bool":
        return _common.ModelDisplayHints_isVisualizationEnabled(self)
    __swig_destroy__ = _common.delete_ModelDisplayHints

# Register ModelDisplayHints in _common:
_common.ModelDisplayHints_swigregister(ModelDisplayHints)

def ModelDisplayHints_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelDisplayHints *":
    return _common.ModelDisplayHints_safeDownCast(obj)

def ModelDisplayHints_getClassName() -> "std::string const &":
    return _common.ModelDisplayHints_getClassName()

class AbstractChannel(object):
    r""" One of the values of an Output."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_AbstractChannel

    def getChannelName(self) -> "std::string const &":
        r"""
        The name of this channel, or the name of the output that
           contains this Channel if it's in a single-value Output.
        """
        return _common.AbstractChannel_getChannelName(self)

    def getTypeName(self) -> "std::string":
        r""" The name of the value type (e.g., `double`) produced by this channel."""
        return _common.AbstractChannel_getTypeName(self)

    def getName(self) -> "std::string":
        r"""
         The name of this channel appended to the name of the output that
        contains this channel. The output name and channel name are separated by
        a colon (e.g., "markers:medial_knee"). If the output that contains
        this channel is a single-value Output, then this is just the Output's
        name.
        """
        return _common.AbstractChannel_getName(self)

    def getPathName(self) -> "std::string":
        r"""
         This returns the absolute path name of the component to which this channel
        belongs prepended to the channel's name. For example, this
        method might return something like "/model/metabolics|heat_rate:soleus_r".
        """
        return _common.AbstractChannel_getPathName(self)

# Register AbstractChannel in _common:
_common.AbstractChannel_swigregister(AbstractChannel)

class AbstractOutput(object):
    r"""
    Output formalizes the access to a value of interest computed by the
    owning Component. The value is then exposed and easily accessible for use by
    other components (e.g. to satisfy an Input).
    The purpose of an Output is to bind a value of interest to a component's
    member function (generator), and provide a generic interface to the value,
    its type and label so it can be easily identified. It also specifies the
    realization (computational) stage at which the value is valid, so that a
    caller can provide adequate error handling.

    For example, a Body can have its position transformation with respect to
    ground as an Output, which is only accessible when the model has been
    realized to the Position stage or beyond, in which case it depends on the
    Position stage. The validity of data flow can be checked prior to
    initiating a simulation.

    An Output is intended to lightweight and adds no computational overhead
    if the output goes unused. When an Output's value is called upon,
    the overhead is a single redirect to the corresponding member function
    for the value.

    An Output can either be a single-value Output or a list Output. A list Output
    is one that can have multiple Channels. The Channels are what get connected
    to Inputs.
    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_AbstractOutput

    def getName(self) -> "std::string const &":
        r""" Output's name"""
        return _common.AbstractOutput_getName(self)

    def getDependsOnStage(self) -> "SimTK::Stage const &":
        r""" Output's dependence on System being realized to at least this System::Stage"""
        return _common.AbstractOutput_getDependsOnStage(self)

    def isListOutput(self) -> "bool":
        r""" Can this Output have more than one channel?"""
        return _common.AbstractOutput_isListOutput(self)

    def getOwner(self) -> "OpenSim::Component const &":
        r""" Output's owning Component"""
        return _common.AbstractOutput_getOwner(self)

    def getPathName(self) -> "std::string":
        r""" This returns <absolute-path-to-component>|<output-name>."""
        return _common.AbstractOutput_getPathName(self)

    def clearChannels(self) -> "void":
        r""" Output Interface  Remove all channels from this Output (for list Outputs)."""
        return _common.AbstractOutput_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        r"""
         Add a channel to this Output. This should be called within the
        component's extendFinalizeFromProperties() .
        """
        return _common.AbstractOutput_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        return _common.AbstractOutput_getChannel(self, name)

    def getTypeName(self) -> "std::string":
        r""" The name of the value type (e.g., `double`) produced by this output."""
        return _common.AbstractOutput_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.AbstractOutput_getValueAsString(self, state)

    def isCompatible(self, arg2: "AbstractOutput") -> "bool":
        return _common.AbstractOutput_isCompatible(self, arg2)

    def compatibleAssign(self, arg2: "AbstractOutput") -> "void":
        return _common.AbstractOutput_compatibleAssign(self, arg2)

    def clone(self) -> "OpenSim::AbstractOutput *":
        return _common.AbstractOutput_clone(self)

    def getNumberOfSignificantDigits(self) -> "unsigned int":
        r""" Specification for number of significant figures in string value."""
        return _common.AbstractOutput_getNumberOfSignificantDigits(self)

    def setNumberOfSignificantDigits(self, numSigFigs: "unsigned int") -> "void":
        return _common.AbstractOutput_setNumberOfSignificantDigits(self, numSigFigs)

# Register AbstractOutput in _common:
_common.AbstractOutput_swigregister(AbstractOutput)

class OutputDouble(AbstractOutput):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Convenience constructor
            Create a Component::Output bound to a specific method of the Component and
            valid at a given realization Stage.
            :type name: string
            :param name:             The name of the output.
            :type outputFunction: std::function< void (OpenSim::Component const *,SimTK::State const &,std::string const &,double &) >
            :param outputFunction:   The output function to be invoked (returns Output T)
            :type dependsOnStage: :py:class:`Stage`
            :param dependsOnStage:   Stage at which Output can be evaluated.
            :type isList: boolean
            :param isList:           Can this Output have more than one channel?

        |

        *Overload 2:*
         Custom copy constructor is for setting the Channel's pointer
        back to this Output.
        """
        _common.OutputDouble_swiginit(self, _common.new_OutputDouble(*args))
    __swig_destroy__ = _common.delete_OutputDouble

    def isCompatible(self, o: "AbstractOutput") -> "bool":
        return _common.OutputDouble_isCompatible(self, o)

    def compatibleAssign(self, o: "AbstractOutput") -> "void":
        return _common.OutputDouble_compatibleAssign(self, o)

    def clearChannels(self) -> "void":
        return _common.OutputDouble_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        return _common.OutputDouble_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        r"""
         For a single-value output, name must be empty or must be the output's
        name.
        """
        return _common.OutputDouble_getChannel(self, name)

    def getChannels(self) -> "OpenSim::Output< double >::ChannelMap const &":
        r"""
        Use this to iterate through this Output's channels
            (even for single-value Channels).

            .. code-block:: c++

                for (const auto& chan : getChannels()) {
                   std::cout << chan.second->getName() << std::endl;
                }
        """
        return _common.OutputDouble_getChannels(self)

    def getValue(self, state: "State") -> "double const &":
        r"""
        Return the Value of this output if the state is appropriately realized
               to a stage at or beyond the dependsOnStage, otherwise expect an
               Exception.
        """
        return _common.OutputDouble_getValue(self, state)

    def getTypeName(self) -> "std::string":
        return _common.OutputDouble_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.OutputDouble_getValueAsString(self, state)

    def clone(self) -> "OpenSim::Output< double > *":
        return _common.OutputDouble_clone(self)

    @staticmethod
    def isA(p: "AbstractOutput") -> "bool":
        return _common.OutputDouble_isA(p)

    @staticmethod
    def downcast(p: "AbstractOutput") -> "OpenSim::Output< double > const &":
        return _common.OutputDouble_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractOutput") -> "OpenSim::Output< double > &":
        return _common.OutputDouble_updDowncast(p)

    @staticmethod
    def safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< double > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.OutputDouble_safeDownCast(parent)

# Register OutputDouble in _common:
_common.OutputDouble_swigregister(OutputDouble)

def OutputDouble_isA(p: "AbstractOutput") -> "bool":
    return _common.OutputDouble_isA(p)

def OutputDouble_downcast(p: "AbstractOutput") -> "OpenSim::Output< double > const &":
    return _common.OutputDouble_downcast(p)

def OutputDouble_updDowncast(p: "AbstractOutput") -> "OpenSim::Output< double > &":
    return _common.OutputDouble_updDowncast(p)

def OutputDouble_safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< double > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.OutputDouble_safeDownCast(parent)

class OutputVec3(AbstractOutput):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Convenience constructor
            Create a Component::Output bound to a specific method of the Component and
            valid at a given realization Stage.
            :type name: string
            :param name:             The name of the output.
            :type outputFunction: std::function< void (OpenSim::Component const *,SimTK::State const &,std::string const &,SimTK::Vec< 3,double,1 > &) >
            :param outputFunction:   The output function to be invoked (returns Output T)
            :type dependsOnStage: :py:class:`Stage`
            :param dependsOnStage:   Stage at which Output can be evaluated.
            :type isList: boolean
            :param isList:           Can this Output have more than one channel?

        |

        *Overload 2:*
         Custom copy constructor is for setting the Channel's pointer
        back to this Output.
        """
        _common.OutputVec3_swiginit(self, _common.new_OutputVec3(*args))
    __swig_destroy__ = _common.delete_OutputVec3

    def isCompatible(self, o: "AbstractOutput") -> "bool":
        return _common.OutputVec3_isCompatible(self, o)

    def compatibleAssign(self, o: "AbstractOutput") -> "void":
        return _common.OutputVec3_compatibleAssign(self, o)

    def clearChannels(self) -> "void":
        return _common.OutputVec3_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        return _common.OutputVec3_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        r"""
         For a single-value output, name must be empty or must be the output's
        name.
        """
        return _common.OutputVec3_getChannel(self, name)

    def getChannels(self) -> "OpenSim::Output< SimTK::Vec< 3,double,1 > >::ChannelMap const &":
        r"""
        Use this to iterate through this Output's channels
            (even for single-value Channels).

            .. code-block:: c++

                for (const auto& chan : getChannels()) {
                   std::cout << chan.second->getName() << std::endl;
                }
        """
        return _common.OutputVec3_getChannels(self)

    def getValue(self, state: "State") -> "SimTK::Vec< 3,double,1 > const &":
        r"""
        Return the Value of this output if the state is appropriately realized
               to a stage at or beyond the dependsOnStage, otherwise expect an
               Exception.
        """
        return _common.OutputVec3_getValue(self, state)

    def getTypeName(self) -> "std::string":
        return _common.OutputVec3_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.OutputVec3_getValueAsString(self, state)

    def clone(self) -> "OpenSim::Output< SimTK::Vec< 3,double,1 > > *":
        return _common.OutputVec3_clone(self)

    @staticmethod
    def isA(p: "AbstractOutput") -> "bool":
        return _common.OutputVec3_isA(p)

    @staticmethod
    def downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec3 > const &":
        return _common.OutputVec3_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec3 > &":
        return _common.OutputVec3_updDowncast(p)

    @staticmethod
    def safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec< 3,double,1 > > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.OutputVec3_safeDownCast(parent)

# Register OutputVec3 in _common:
_common.OutputVec3_swigregister(OutputVec3)

def OutputVec3_isA(p: "AbstractOutput") -> "bool":
    return _common.OutputVec3_isA(p)

def OutputVec3_downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec3 > const &":
    return _common.OutputVec3_downcast(p)

def OutputVec3_updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec3 > &":
    return _common.OutputVec3_updDowncast(p)

def OutputVec3_safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec< 3,double,1 > > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.OutputVec3_safeDownCast(parent)

class OutputTransform(AbstractOutput):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Convenience constructor
            Create a Component::Output bound to a specific method of the Component and
            valid at a given realization Stage.
            :type name: string
            :param name:             The name of the output.
            :type outputFunction: std::function< void (OpenSim::Component const *,SimTK::State const &,std::string const &,SimTK::Transform_< double > &) >
            :param outputFunction:   The output function to be invoked (returns Output T)
            :type dependsOnStage: :py:class:`Stage`
            :param dependsOnStage:   Stage at which Output can be evaluated.
            :type isList: boolean
            :param isList:           Can this Output have more than one channel?

        |

        *Overload 2:*
         Custom copy constructor is for setting the Channel's pointer
        back to this Output.
        """
        _common.OutputTransform_swiginit(self, _common.new_OutputTransform(*args))
    __swig_destroy__ = _common.delete_OutputTransform

    def isCompatible(self, o: "AbstractOutput") -> "bool":
        return _common.OutputTransform_isCompatible(self, o)

    def compatibleAssign(self, o: "AbstractOutput") -> "void":
        return _common.OutputTransform_compatibleAssign(self, o)

    def clearChannels(self) -> "void":
        return _common.OutputTransform_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        return _common.OutputTransform_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        r"""
         For a single-value output, name must be empty or must be the output's
        name.
        """
        return _common.OutputTransform_getChannel(self, name)

    def getChannels(self) -> "OpenSim::Output< SimTK::Transform_< double > >::ChannelMap const &":
        r"""
        Use this to iterate through this Output's channels
            (even for single-value Channels).

            .. code-block:: c++

                for (const auto& chan : getChannels()) {
                   std::cout << chan.second->getName() << std::endl;
                }
        """
        return _common.OutputTransform_getChannels(self)

    def getValue(self, state: "State") -> "SimTK::Transform_< double > const &":
        r"""
        Return the Value of this output if the state is appropriately realized
               to a stage at or beyond the dependsOnStage, otherwise expect an
               Exception.
        """
        return _common.OutputTransform_getValue(self, state)

    def getTypeName(self) -> "std::string":
        return _common.OutputTransform_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.OutputTransform_getValueAsString(self, state)

    def clone(self) -> "OpenSim::Output< SimTK::Transform_< double > > *":
        return _common.OutputTransform_clone(self)

    @staticmethod
    def isA(p: "AbstractOutput") -> "bool":
        return _common.OutputTransform_isA(p)

    @staticmethod
    def downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform > const &":
        return _common.OutputTransform_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform > &":
        return _common.OutputTransform_updDowncast(p)

    @staticmethod
    def safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform_< double > > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.OutputTransform_safeDownCast(parent)

# Register OutputTransform in _common:
_common.OutputTransform_swigregister(OutputTransform)

def OutputTransform_isA(p: "AbstractOutput") -> "bool":
    return _common.OutputTransform_isA(p)

def OutputTransform_downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform > const &":
    return _common.OutputTransform_downcast(p)

def OutputTransform_updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform > &":
    return _common.OutputTransform_updDowncast(p)

def OutputTransform_safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Transform_< double > > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.OutputTransform_safeDownCast(parent)

class OutputVector(AbstractOutput):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Convenience constructor
            Create a Component::Output bound to a specific method of the Component and
            valid at a given realization Stage.
            :type name: string
            :param name:             The name of the output.
            :type outputFunction: std::function< void (OpenSim::Component const *,SimTK::State const &,std::string const &,SimTK::Vector_< double > &) >
            :param outputFunction:   The output function to be invoked (returns Output T)
            :type dependsOnStage: :py:class:`Stage`
            :param dependsOnStage:   Stage at which Output can be evaluated.
            :type isList: boolean
            :param isList:           Can this Output have more than one channel?

        |

        *Overload 2:*
         Custom copy constructor is for setting the Channel's pointer
        back to this Output.
        """
        _common.OutputVector_swiginit(self, _common.new_OutputVector(*args))
    __swig_destroy__ = _common.delete_OutputVector

    def isCompatible(self, o: "AbstractOutput") -> "bool":
        return _common.OutputVector_isCompatible(self, o)

    def compatibleAssign(self, o: "AbstractOutput") -> "void":
        return _common.OutputVector_compatibleAssign(self, o)

    def clearChannels(self) -> "void":
        return _common.OutputVector_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        return _common.OutputVector_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        r"""
         For a single-value output, name must be empty or must be the output's
        name.
        """
        return _common.OutputVector_getChannel(self, name)

    def getChannels(self) -> "OpenSim::Output< SimTK::Vector_< double > >::ChannelMap const &":
        r"""
        Use this to iterate through this Output's channels
            (even for single-value Channels).

            .. code-block:: c++

                for (const auto& chan : getChannels()) {
                   std::cout << chan.second->getName() << std::endl;
                }
        """
        return _common.OutputVector_getChannels(self)

    def getValue(self, state: "State") -> "SimTK::Vector_< double > const &":
        r"""
        Return the Value of this output if the state is appropriately realized
               to a stage at or beyond the dependsOnStage, otherwise expect an
               Exception.
        """
        return _common.OutputVector_getValue(self, state)

    def getTypeName(self) -> "std::string":
        return _common.OutputVector_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.OutputVector_getValueAsString(self, state)

    def clone(self) -> "OpenSim::Output< SimTK::Vector_< double > > *":
        return _common.OutputVector_clone(self)

    @staticmethod
    def isA(p: "AbstractOutput") -> "bool":
        return _common.OutputVector_isA(p)

    @staticmethod
    def downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector > const &":
        return _common.OutputVector_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector > &":
        return _common.OutputVector_updDowncast(p)

    @staticmethod
    def safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector_< double > > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.OutputVector_safeDownCast(parent)

# Register OutputVector in _common:
_common.OutputVector_swigregister(OutputVector)

def OutputVector_isA(p: "AbstractOutput") -> "bool":
    return _common.OutputVector_isA(p)

def OutputVector_downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector > const &":
    return _common.OutputVector_downcast(p)

def OutputVector_updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector > &":
    return _common.OutputVector_updDowncast(p)

def OutputVector_safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vector_< double > > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.OutputVector_safeDownCast(parent)

class OutputSpatialVec(AbstractOutput):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Convenience constructor
            Create a Component::Output bound to a specific method of the Component and
            valid at a given realization Stage.
            :type name: string
            :param name:             The name of the output.
            :type outputFunction: std::function< void (OpenSim::Component const *,SimTK::State const &,std::string const &,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > &) >
            :param outputFunction:   The output function to be invoked (returns Output T)
            :type dependsOnStage: :py:class:`Stage`
            :param dependsOnStage:   Stage at which Output can be evaluated.
            :type isList: boolean
            :param isList:           Can this Output have more than one channel?

        |

        *Overload 2:*
         Custom copy constructor is for setting the Channel's pointer
        back to this Output.
        """
        _common.OutputSpatialVec_swiginit(self, _common.new_OutputSpatialVec(*args))
    __swig_destroy__ = _common.delete_OutputSpatialVec

    def isCompatible(self, o: "AbstractOutput") -> "bool":
        return _common.OutputSpatialVec_isCompatible(self, o)

    def compatibleAssign(self, o: "AbstractOutput") -> "void":
        return _common.OutputSpatialVec_compatibleAssign(self, o)

    def clearChannels(self) -> "void":
        return _common.OutputSpatialVec_clearChannels(self)

    def addChannel(self, channelName: "std::string const &") -> "void":
        return _common.OutputSpatialVec_addChannel(self, channelName)

    def getChannel(self, name: "std::string const &") -> "OpenSim::AbstractChannel const &":
        r"""
         For a single-value output, name must be empty or must be the output's
        name.
        """
        return _common.OutputSpatialVec_getChannel(self, name)

    def getChannels(self) -> "OpenSim::Output< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::ChannelMap const &":
        r"""
        Use this to iterate through this Output's channels
            (even for single-value Channels).

            .. code-block:: c++

                for (const auto& chan : getChannels()) {
                   std::cout << chan.second->getName() << std::endl;
                }
        """
        return _common.OutputSpatialVec_getChannels(self)

    def getValue(self, state: "State") -> "SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > const &":
        r"""
        Return the Value of this output if the state is appropriately realized
               to a stage at or beyond the dependsOnStage, otherwise expect an
               Exception.
        """
        return _common.OutputSpatialVec_getValue(self, state)

    def getTypeName(self) -> "std::string":
        return _common.OutputSpatialVec_getTypeName(self)

    def getValueAsString(self, state: "State") -> "std::string":
        return _common.OutputSpatialVec_getValueAsString(self, state)

    def clone(self) -> "OpenSim::Output< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > > *":
        return _common.OutputSpatialVec_clone(self)

    @staticmethod
    def isA(p: "AbstractOutput") -> "bool":
        return _common.OutputSpatialVec_isA(p)

    @staticmethod
    def downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::SpatialVec > const &":
        return _common.OutputSpatialVec_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::SpatialVec > &":
        return _common.OutputSpatialVec_updDowncast(p)

    @staticmethod
    def safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.OutputSpatialVec_safeDownCast(parent)

# Register OutputSpatialVec in _common:
_common.OutputSpatialVec_swigregister(OutputSpatialVec)

def OutputSpatialVec_isA(p: "AbstractOutput") -> "bool":
    return _common.OutputSpatialVec_isA(p)

def OutputSpatialVec_downcast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::SpatialVec > const &":
    return _common.OutputSpatialVec_downcast(p)

def OutputSpatialVec_updDowncast(p: "AbstractOutput") -> "OpenSim::Output< SimTK::SpatialVec > &":
    return _common.OutputSpatialVec_updDowncast(p)

def OutputSpatialVec_safeDownCast(parent: "AbstractOutput") -> "OpenSim::Output< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.OutputSpatialVec_safeDownCast(parent)

class InputNotConnected(OpenSimException):
    r""" ComponentSocket Exceptions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", inputName: "std::string const &"):
        _common.InputNotConnected_swiginit(self, _common.new_InputNotConnected(file, line, func, inputName))
    __swig_destroy__ = _common.delete_InputNotConnected

# Register InputNotConnected in _common:
_common.InputNotConnected_swigregister(InputNotConnected)

class AbstractSocket(object):
    r"""
    A Socket formalizes the dependency between a Component and another object
    (typically another Component) without owning that object. While Components
    can be composites (of multiple components) they often depend on unrelated
    objects/components that are defined and owned elsewhere. The object that
    satisfies the requirements of the Socket we term the "connectee". When a
    Socket is satisfied by a connectee we have a successful "connection" or is
    said to be connected.

    The purpose of a Socket is to specify: 1) the connectee type that the
    Component is dependent on, 2) by when (what stage) the socket must be
    connected in order for the component to function, 3) the name of a connectee
    that can be found at run-time to satisfy the socket, and 4) whether or
    not it is connected. A Socket maintains a reference to the instance
    (connectee) until it is disconnected.

    For example, a Joint has two Sockets for the parent and child Bodies that
    it joins. The type for the socket is a PhysicalFrame and any attempt to
    connect to a non-Body (or frame rigidly attached to a Body) will throw an
    exception. The connectAt Stage is Topology. That is, the Joint's connection
    to a Body must be performed at the Topology system stage, and any attempt to
    change the connection status will invalidate that Stage and above.

    Other Components like a Marker or a Probe that do not change the system
    topology or add new states could potentially be connected at later stages
    like Model or Instance.

    Programmatically, the connectee can be specified as an object reference
    or via a connectee path:

    .. code-block:: c++

        // Specifying the connectee using an object reference.
        socket.connect(myConnectee);
        // Specifying the connectee via a path.
        socket.setConnecteePath("/path/to/connectee");

    Use finalizeConnection() to synchronize the object reference and connectee
    name. It is preferable to use connect() instead of setConnecteePath().
    If *both* are set, then the object reference overrides the connectee path.

    The connectee path appears in XML files and is how a connection is maintained
    across serialization (writing to an XML file) and deserialization (reading
    from an XML file).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_AbstractSocket

    def clone(self) -> "OpenSim::AbstractSocket *":
        r"""
        Create a dynamically-allocated copy. You must manage the memory
        for the returned pointer.
        This function exists to facilitate the use of
        SimTK::ClonePtr<AbstractSocket>.
        """
        return _common.AbstractSocket_clone(self)

    def getName(self) -> "std::string const &":
        return _common.AbstractSocket_getName(self)

    def getConnectAtStage(self) -> "SimTK::Stage":
        r""" Get the system Stage when the connection should be made."""
        return _common.AbstractSocket_getConnectAtStage(self)

    def isListSocket(self) -> "bool":
        r""" Can this Socket have more than one connectee?"""
        return _common.AbstractSocket_isListSocket(self)

    def getNumConnectees(self) -> "unsigned int":
        r"""
         The number of slots to fill in order to satisfy this socket.
        This is 1 for a non-list socket. This is the number of elements in the
        connectee path property; to sync this with the number of connectee
        objects, call finalizeConnection().
        """
        return _common.AbstractSocket_getNumConnectees(self)

    def isConnected(self) -> "bool":
        r"""
        Derived classes must satisfy this Interface  Is the Socket connected to its connectee(s)? For a list socket,
           this is only true if this socket is connected to all its connectees.
        """
        return _common.AbstractSocket_isConnected(self)

    def getConnecteeTypeName(self) -> "std::string":
        r""" Get the type of object this socket connects to."""
        return _common.AbstractSocket_getConnecteeTypeName(self)

    def getConnecteeAsObject(self) -> "OpenSim::Object const &":
        r"""
         Generic access to the connectee. Not all sockets support this method
        (e.g., the connectee for an Input is not an Object).
        """
        return _common.AbstractSocket_getConnecteeAsObject(self)

    def connect(self, connectee: "OpenSimObject") -> "void":
        r"""
        Connect this %Socket to the provided connectee object. If this is a
               list socket, the connectee is appended to the list of connectees;
               otherwise, the provided connectee replaces the single connectee.
        """
        return _common.AbstractSocket_connect(self, connectee)

    def findAndConnect(self, *args) -> "void":
        r"""
        *Overload 1:*
         Find the connectee using a search with a partial path. Use this if you
        do not want to specify an exact path (maybe you don't quite know where
        the connectee is located).


        |

        *Overload 2:*
         Same as findAndConnect(const ComponentPath&), but using a string
        argument.
        """
        return _common.AbstractSocket_findAndConnect(self, *args)

    def finalizeConnection(self, root: "Component") -> "void":
        r"""
        Connect this %Socket according to its connectee path property
               given a root %Component to search its subcomponents for the connect_to
               Component.
        """
        return _common.AbstractSocket_finalizeConnection(self, root)

    def disconnect(self) -> "void":
        r"""
         Clear references to connectees. The connectee path property is not
        affected. Calling finalizeConnection() will use the connectee path
        property to satisfy the socket.
        """
        return _common.AbstractSocket_disconnect(self)

    def setConnecteePath(self, *args) -> "void":
        r"""
        *Overload 1:*
         %Set connectee path. This function can only be used if this socket is
        not a list socket. If a connectee reference is set (with connect()) the
        connectee path is ignored; call disconnect() if you want the socket to be
        connected using the connectee path.

        It is preferable to use connect() instead of this function.

        |

        *Overload 2:*
         %Set connectee path of a connectee among a list of connectees. This
        function is used if this socket is a list socket. If a connectee
        reference is set (with connect()) the connectee path is ignored; call
        disconnect() if you want the socket to be connected using the connectee
        name.

        It is preferable to use connect() instead of this function.
        """
        return _common.AbstractSocket_setConnecteePath(self, *args)

    def getConnecteePath(self, *args) -> "std::string const &":
        r"""
        *Overload 1:*
        Get connectee path. This function can only be used if this socket is
           not a list socket.

        |

        *Overload 2:*
        Get connectee path of a connectee among a list of connectees.
        """
        return _common.AbstractSocket_getConnecteePath(self, *args)

    def appendConnecteePath(self, name: "std::string const &") -> "void":
        return _common.AbstractSocket_appendConnecteePath(self, name)

    def clearConnecteePath(self) -> "void":
        r""" Clear all connectee paths in the connectee path property."""
        return _common.AbstractSocket_clearConnecteePath(self)

    def getOwner(self) -> "OpenSim::Component const &":
        r""" Get owner component of this socket"""
        return _common.AbstractSocket_getOwner(self)

# Register AbstractSocket in _common:
_common.AbstractSocket_swigregister(AbstractSocket)

class AbstractInput(AbstractSocket):
    r"""
     A specialized Socket that connects to an Output signal is an Input.
    An AbstractInput enables maintenance of a list of unconnected Inputs.
    An Input can either be a single-value Input or a list Input. A list Input
    can connect to multiple (Output) Channels.

    #### XML Syntax of a connectee path

    For every %Input that a component has, the XML representation of the component
    contains an element named `input_<input_name>`. For example, a component
    that has an Input named `desired_angle` might look like the following in XML:

    .. code-block:: c++

            <MyComponent name="my_comp">
                <input_desired_angle>
                    ../foo/angle
                </input_desired_angle>
                ...
            </MyComponent>
    You use this field to specify the outputs/channels that should be connected to
    this input (that is, the connectees). The syntax for the connectee path
    property is as follows:

    .. code-block:: c++

        <path/to/component>|<output_name>[:<channel_name>][(<alias>)]
    Angle brackets indicate fields that one would fill in, and square brackets
    indicate optional fields. The `<path/to/component>` can be relative or
    absolute, and describes the location of the Component that contains the
    desired Output relative to the location of the Component that contains this
    Input. The `<path/to/component>` and `<output_name>` must always be specified.
    The `<channel_name>` should only be specified if the %Output is a list output
    (i.e., it has multiple channels). The `<alias>` is a name for the
    output/channel that is specific to this input, and it is optional.
    All fields should contain only letters, numbers, and underscores (the path
    to the component can contain slashes and periods); fields must *not* contain
    spaces.
    Here are some examples:
     - `../marker_data|column:left_ankle`: The TableSourceVec3 component
       `../marker_data` has a list output `column`, and we want to connect to its
       `left_ankle` channel.
     - `../averager|output(knee_joint_center)`: The component `../averager`
       (presumably a component that averages its inputs) has an output named
       `output`, and we are aliasing this output as `knee_joint_center`.
     - `/leg_model/soleus|activation`: This connectee path uses the absolute path
       to component `soleus`, which has an output named `activation`.

    List inputs can contain multiple entries in its connectee path, with the
    entries separated by a space. For example:

    .. code-block:: c++

        <input_experimental_markers>
            ../marker_data|column:left_ankle ../marker_data|column:right_ankle ../averager|output(knee_joint_center)
        </input_experimental_markers>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_AbstractInput

    def clone(self) -> "OpenSim::AbstractInput *":
        return _common.AbstractInput_clone(self)

    def connect(self, *args) -> "void":
        r"""
        *Overload 1:*
        TODO  Connect this Input to a single-valued (single-channel) Output or, if
           this is a list %Input and the %Output is a list %Output, connect to all the
           channels of the %Output. You can optionally provide an alias that will be
           used by the Component owning this %Input to refer to the %Output. If this
           method connects to multiple channels, the alias will be used for all
           channels.

        |

        *Overload 2:*
        TODO  Connect this Input to a single-valued (single-channel) Output or, if
           this is a list %Input and the %Output is a list %Output, connect to all the
           channels of the %Output. You can optionally provide an alias that will be
           used by the Component owning this %Input to refer to the %Output. If this
           method connects to multiple channels, the alias will be used for all
           channels.

        |

        *Overload 3:*
        Connect this Input to a single output channel. This
           method can be used with both single-valued and list %Inputs. You can
           optionally provide an alias that will be used by the Component owning this
           %Input to refer to the %Channel.

        |

        *Overload 4:*
        Connect this Input to a single output channel. This
           method can be used with both single-valued and list %Inputs. You can
           optionally provide an alias that will be used by the Component owning this
           %Input to refer to the %Channel.
        """
        return _common.AbstractInput_connect(self, *args)

    def getAlias(self, *args) -> "std::string const &":
        r"""
        *Overload 1:*
        Get the alias for a Channel. An alias is a description for a %Channel
           that is specific to how the Input will use the %Channel. For example, the
           Component that owns this %Input might expect the aliases to be the names of
           markers in the model. This method can be used only for non-list %Inputs; for
           list %Inputs, use the overload that takes an index.
           You must finalize connections (Component::finalizeConnections()) first.

        |

        *Overload 2:*
        Get the alias for the Channel indicated by the provided index. An alias
           is a description for a %Channel that is specific to how the Input will use
           the %Channel. For example, the Component that owns this %Input might expect
           the aliases to be the names of markers in the model.
           You must finalize connections (Component::finalizeConnections()) first.
        """
        return _common.AbstractInput_getAlias(self, *args)

    def setAlias(self, *args) -> "void":
        r"""
        *Overload 1:*
        %Set the alias for a Channel. If this is a list Input, the aliases of all
           %Channels will be set to the provided string. If you wish to set the alias
           of only one %Channel, use the two-argument overload.
           You must finalize connections (Component::finalizeConnections()) first.

        |

        *Overload 2:*
        %Set the alias for the Channel indicated by the provided index.
           You must finalize connections (Component::finalizeConnections()) first.
        """
        return _common.AbstractInput_setAlias(self, *args)

    def getLabel(self, *args) -> "std::string":
        r"""
        *Overload 1:*
        Get the label for this Channel. If an alias has been set, the label is
           the alias; otherwise, the label is the full path of the Output that has been
           connected to this Input. This method can be used only for non-list %Inputs;
           for list %Inputs, use the single-argument overload.
           You must finalize connections (Component::finalizeConnections()) first.

        |

        *Overload 2:*
        Get the label for the Channel indicated by the provided index. If an
           alias has been set, the label is the alias; otherwise, the label is the full
           path of the %Channel that has been connected to this Input.
           You must finalize connections (Component::finalizeConnections()) first.
        """
        return _common.AbstractInput_getLabel(self, *args)

    @staticmethod
    def parseConnecteePath(connecteePath: "std::string const &", componentPath: "std::string &", outputName: "std::string &", channelName: "std::string &", alias: "std::string &") -> "bool":
        r"""
         Break up a connectee path into its output path, channel name
             (empty for single-value outputs), and alias. This function writes
             to the passed-in outputPath, channelName, and alias.

             Examples:
             foo/bar|output
             outputPath is "/foo/bar/output"
             channelName is ""
             alias is ""

        foo/bar|output:channel
             outputPath is "/foo/bar/output"
             channelName is "channel"
             alias is ""

        foo/bar|output(baz)
             outputPath is "/foo/bar/output"
             channelName is ""
             alias is "baz"

        foo/bar|output:channel(baz)
             outputPath is "/foo/bar|output"
             channelName is "channel"
             alias is "baz"
        """
        return _common.AbstractInput_parseConnecteePath(connecteePath, componentPath, outputName, channelName, alias)

    @staticmethod
    def composeConnecteePath(componentPath: "std::string const &", outputName: "std::string const &", channelName: "std::string const &", alias: "std::string const &") -> "std::string":
        r"""
        Compose the connectee path from its constituents. This is the opposite
           operation of parseConnecteePath().
           Example:
                if inputs are
              componentPath --> "/foo/bar"
              outputName    --> "output"
              channelName   --> "channel"
              alias         --> "baz"
            then result --> /foo/bar|output:channel(baz)
        """
        return _common.AbstractInput_composeConnecteePath(componentPath, outputName, channelName, alias)

# Register AbstractInput in _common:
_common.AbstractInput_swigregister(AbstractInput)

def AbstractInput_parseConnecteePath(connecteePath: "std::string const &", componentPath: "std::string &", outputName: "std::string &", channelName: "std::string &", alias: "std::string &") -> "bool":
    r"""
     Break up a connectee path into its output path, channel name
         (empty for single-value outputs), and alias. This function writes
         to the passed-in outputPath, channelName, and alias.

         Examples:
         foo/bar|output
         outputPath is "/foo/bar/output"
         channelName is ""
         alias is ""

    foo/bar|output:channel
         outputPath is "/foo/bar/output"
         channelName is "channel"
         alias is ""

    foo/bar|output(baz)
         outputPath is "/foo/bar/output"
         channelName is ""
         alias is "baz"

    foo/bar|output:channel(baz)
         outputPath is "/foo/bar|output"
         channelName is "channel"
         alias is "baz"
    """
    return _common.AbstractInput_parseConnecteePath(connecteePath, componentPath, outputName, channelName, alias)

def AbstractInput_composeConnecteePath(componentPath: "std::string const &", outputName: "std::string const &", channelName: "std::string const &", alias: "std::string const &") -> "std::string":
    r"""
    Compose the connectee path from its constituents. This is the opposite
       operation of parseConnecteePath().
       Example:
            if inputs are
          componentPath --> "/foo/bar"
          outputName    --> "output"
          channelName   --> "channel"
          alias         --> "baz"
        then result --> /foo/bar|output:channel(baz)
    """
    return _common.AbstractInput_composeConnecteePath(componentPath, outputName, channelName, alias)

class InputDouble(AbstractInput):
    r""" An Input<Y> must be connected by an Output<Y>"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clone(self) -> "OpenSim::Input< double > *":
        return _common.InputDouble_clone(self)

    def connect(self, *args) -> "void":
        return _common.InputDouble_connect(self, *args)

    def finalizeConnection(self, root: "Component") -> "void":
        r"""
        Connect this Input given a root Component to search for
           the Output according to the connectee path of this Input
        """
        return _common.InputDouble_finalizeConnection(self, root)

    def disconnect(self) -> "void":
        return _common.InputDouble_disconnect(self)

    def isConnected(self) -> "bool":
        return _common.InputDouble_isConnected(self)

    def getValue(self, *args) -> "double const &":
        r"""
        *Overload 1:*
         Get the value of this Input when it is connected. Redirects to connected
            Output<T>'s getValue() with minimal overhead. This method can be used only
            for non-list Input(s). For list Input(s), use the other overload.

        |

        *Overload 2:*
        Get the value of this Input when it is connected. Redirects to connected
            Output<T>'s getValue() with minimal overhead. Specify the index of the
            Channel whose value is desired.
        """
        return _common.InputDouble_getValue(self, *args)

    def getChannel(self, *args) -> "OpenSim::Input< double >::Channel const &":
        r"""
        *Overload 1:*
        Get the Channel associated with this Input. This method can only be
           used for non-list Input(s). For list Input(s), use the other overload.

        |

        *Overload 2:*
        Get the Channel associated with this Input. Specify the index of the
           channel desired.
        """
        return _common.InputDouble_getChannel(self, *args)

    def getAlias(self, *args) -> "std::string const &":
        return _common.InputDouble_getAlias(self, *args)

    def setAlias(self, *args) -> "void":
        return _common.InputDouble_setAlias(self, *args)

    def getLabel(self, *args) -> "std::string":
        return _common.InputDouble_getLabel(self, *args)

    def getVector(self, state: "State") -> "SimTK::Vector_< double >":
        r"""
        Access the values of all the channels connected to this Input as a
           SimTK::Vector_<T>. The elements are in the same order as the channels.
        """
        return _common.InputDouble_getVector(self, state)

    def getChannels(self) -> "OpenSim::Input< double >::ChannelList const &":
        r"""
        Get const access to the channels connected to this input.
               You can use this to iterate through the channels.

               .. code-block:: c++

                   for (const auto& chan : getChannels()) {
                       std::cout << chan.getValue(state) << std::endl;
                   }
        """
        return _common.InputDouble_getChannels(self)

    def getConnecteeTypeName(self) -> "std::string":
        r"""
        Return the typename of the Output value, T, that satisfies
               this Input<T>. No reason to return Output<T> since it is a
               given that only an Output can satisfy an Input.
        """
        return _common.InputDouble_getConnecteeTypeName(self)

    @staticmethod
    def isA(p: "AbstractInput") -> "bool":
        return _common.InputDouble_isA(p)

    @staticmethod
    def downcast(p: "AbstractInput") -> "OpenSim::Input< double > const &":
        return _common.InputDouble_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractInput") -> "OpenSim::Input< double > &":
        return _common.InputDouble_updDowncast(p)

    @staticmethod
    def safeDownCast(base: "AbstractInput") -> "OpenSim::Input< double > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.InputDouble_safeDownCast(base)
    __swig_destroy__ = _common.delete_InputDouble

# Register InputDouble in _common:
_common.InputDouble_swigregister(InputDouble)

def InputDouble_isA(p: "AbstractInput") -> "bool":
    return _common.InputDouble_isA(p)

def InputDouble_downcast(p: "AbstractInput") -> "OpenSim::Input< double > const &":
    return _common.InputDouble_downcast(p)

def InputDouble_updDowncast(p: "AbstractInput") -> "OpenSim::Input< double > &":
    return _common.InputDouble_updDowncast(p)

def InputDouble_safeDownCast(base: "AbstractInput") -> "OpenSim::Input< double > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.InputDouble_safeDownCast(base)

class InputVec3(AbstractInput):
    r""" An Input<Y> must be connected by an Output<Y>"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clone(self) -> "OpenSim::Input< SimTK::Vec< 3,double,1 > > *":
        return _common.InputVec3_clone(self)

    def connect(self, *args) -> "void":
        return _common.InputVec3_connect(self, *args)

    def finalizeConnection(self, root: "Component") -> "void":
        r"""
        Connect this Input given a root Component to search for
           the Output according to the connectee path of this Input
        """
        return _common.InputVec3_finalizeConnection(self, root)

    def disconnect(self) -> "void":
        return _common.InputVec3_disconnect(self)

    def isConnected(self) -> "bool":
        return _common.InputVec3_isConnected(self)

    def getValue(self, *args) -> "SimTK::Vec< 3,double,1 > const &":
        r"""
        *Overload 1:*
         Get the value of this Input when it is connected. Redirects to connected
            Output<T>'s getValue() with minimal overhead. This method can be used only
            for non-list Input(s). For list Input(s), use the other overload.

        |

        *Overload 2:*
        Get the value of this Input when it is connected. Redirects to connected
            Output<T>'s getValue() with minimal overhead. Specify the index of the
            Channel whose value is desired.
        """
        return _common.InputVec3_getValue(self, *args)

    def getChannel(self, *args) -> "OpenSim::Input< SimTK::Vec< 3,double,1 > >::Channel const &":
        r"""
        *Overload 1:*
        Get the Channel associated with this Input. This method can only be
           used for non-list Input(s). For list Input(s), use the other overload.

        |

        *Overload 2:*
        Get the Channel associated with this Input. Specify the index of the
           channel desired.
        """
        return _common.InputVec3_getChannel(self, *args)

    def getAlias(self, *args) -> "std::string const &":
        return _common.InputVec3_getAlias(self, *args)

    def setAlias(self, *args) -> "void":
        return _common.InputVec3_setAlias(self, *args)

    def getLabel(self, *args) -> "std::string":
        return _common.InputVec3_getLabel(self, *args)

    def getVector(self, state: "State") -> "SimTK::Vector_< SimTK::Vec< 3,double,1 > >":
        r"""
        Access the values of all the channels connected to this Input as a
           SimTK::Vector_<T>. The elements are in the same order as the channels.
        """
        return _common.InputVec3_getVector(self, state)

    def getChannels(self) -> "OpenSim::Input< SimTK::Vec< 3,double,1 > >::ChannelList const &":
        r"""
        Get const access to the channels connected to this input.
               You can use this to iterate through the channels.

               .. code-block:: c++

                   for (const auto& chan : getChannels()) {
                       std::cout << chan.getValue(state) << std::endl;
                   }
        """
        return _common.InputVec3_getChannels(self)

    def getConnecteeTypeName(self) -> "std::string":
        r"""
        Return the typename of the Output value, T, that satisfies
               this Input<T>. No reason to return Output<T> since it is a
               given that only an Output can satisfy an Input.
        """
        return _common.InputVec3_getConnecteeTypeName(self)

    @staticmethod
    def isA(p: "AbstractInput") -> "bool":
        return _common.InputVec3_isA(p)

    @staticmethod
    def downcast(p: "AbstractInput") -> "OpenSim::Input< SimTK::Vec3 > const &":
        return _common.InputVec3_downcast(p)

    @staticmethod
    def updDowncast(p: "AbstractInput") -> "OpenSim::Input< SimTK::Vec3 > &":
        return _common.InputVec3_updDowncast(p)

    @staticmethod
    def safeDownCast(base: "AbstractInput") -> "OpenSim::Input< SimTK::Vec< 3,double,1 > > *":
        r""" For use in python/java/MATLAB bindings."""
        return _common.InputVec3_safeDownCast(base)
    __swig_destroy__ = _common.delete_InputVec3

# Register InputVec3 in _common:
_common.InputVec3_swigregister(InputVec3)

def InputVec3_isA(p: "AbstractInput") -> "bool":
    return _common.InputVec3_isA(p)

def InputVec3_downcast(p: "AbstractInput") -> "OpenSim::Input< SimTK::Vec3 > const &":
    return _common.InputVec3_downcast(p)

def InputVec3_updDowncast(p: "AbstractInput") -> "OpenSim::Input< SimTK::Vec3 > &":
    return _common.InputVec3_updDowncast(p)

def InputVec3_safeDownCast(base: "AbstractInput") -> "OpenSim::Input< SimTK::Vec< 3,double,1 > > *":
    r""" For use in python/java/MATLAB bindings."""
    return _common.InputVec3_safeDownCast(base)

class ComponentFilter(object):
    r"""
    A class to specify a filter to be used to iterate through components. More
    flexible than filtering based on Type only. To write your custom filter,
    extend this class and implement the isMatch() and clone() methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ComponentFilter

    def isMatch(self, comp: "Component") -> "bool":
        r"""
        This is the meat of the ComponentFilter, returns false if the passed in
           component should be skipped over.
        """
        return _common.ComponentFilter_isMatch(self, comp)

    def clone(self) -> "OpenSim::ComponentFilter *":
        r""" clone() method needed to make a copy of the filter."""
        return _common.ComponentFilter_clone(self)

# Register ComponentFilter in _common:
_common.ComponentFilter_swigregister(ComponentFilter)

class ComponentFilterMatchAll(ComponentFilter):
    r""" ComponentFilterMatchAll is a trivial Filter that matches all components."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Construct a ComponentFilter that selects all Components."""
        _common.ComponentFilterMatchAll_swiginit(self, _common.new_ComponentFilterMatchAll())

    def isMatch(self, comp: "Component") -> "bool":
        r""" The method isMatch() returns true always."""
        return _common.ComponentFilterMatchAll_isMatch(self, comp)
    __swig_destroy__ = _common.delete_ComponentFilterMatchAll

    def clone(self) -> "OpenSim::ComponentFilterMatchAll *":
        r""" Method to clone the filter."""
        return _common.ComponentFilterMatchAll_clone(self)

# Register ComponentFilterMatchAll in _common:
_common.ComponentFilterMatchAll_swigregister(ComponentFilterMatchAll)

class ComponentFilterAbsolutePathNameContainsString(ComponentFilter):
    r"""
     A component is considered a match if its absolute path name contains the
    given string.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, substring: "std::string const &"):
        _common.ComponentFilterAbsolutePathNameContainsString_swiginit(self, _common.new_ComponentFilterAbsolutePathNameContainsString(substring))

    def isMatch(self, comp: "Component") -> "bool":
        return _common.ComponentFilterAbsolutePathNameContainsString_isMatch(self, comp)

    def clone(self) -> "OpenSim::ComponentFilterAbsolutePathNameContainsString *":
        return _common.ComponentFilterAbsolutePathNameContainsString_clone(self)
    __swig_destroy__ = _common.delete_ComponentFilterAbsolutePathNameContainsString

# Register ComponentFilterAbsolutePathNameContainsString in _common:
_common.ComponentFilterAbsolutePathNameContainsString_swigregister(ComponentFilterAbsolutePathNameContainsString)

class ComponentPath(object):
    r"""
    A representation of a path within a Component tree.

    This class is effectively a wrapper around a normalized path string. A path
    string is a sequence of path elements interspersed with '/' as a separator.
    path elements cannot contain:

    - back-slash ('\')
    - forward-slash ('/')
    - asterisk ('*')
    - plus-sign ('+')

    An empty path, "", is allowed. Adjacent separators in a path (e.g. "//") are
    combined into one separator.

    Author: Carmichael Ong
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor that constructs an empty path ("").

        |

        *Overload 2:*

        Construct a ComponentPath from a path string (e.g. "/a/b/component").

        |

        *Overload 3:*

        Construct a ComponentPath from a vector of its elements.

        Throws if any element in `pathVec` contains an invalid character.
        """
        _common.ComponentPath_swiginit(self, _common.new_ComponentPath(*args))

    def __eq__(self, arg2: "ComponentPath") -> "bool":
        return _common.ComponentPath___eq__(self, arg2)

    def __ne__(self, arg2: "ComponentPath") -> "bool":
        return _common.ComponentPath___ne__(self, arg2)

    def getSeparator(self) -> "char":
        return _common.ComponentPath_getSeparator(self)

    def getInvalidChars(self) -> "std::string const &":
        r"""Returns a string containing a sequence of all invalid characters."""
        return _common.ComponentPath_getInvalidChars(self)

    def formAbsolutePath(self, otherPath: "ComponentPath") -> "OpenSim::ComponentPath":
        r"""
        Returns a path that is the result of resolving `this` from `otherPath`.

        - `otherPath` must be an absolute path; otherwise, an exception will be
          thrown
        - if `this` is absolute, then this function just returns a copy of `this`

        Examples:

            ComponentPath{"b/c"}.formAbsolutePath("/a") == "/a/b/c"
            ComponentPath{"/b/c"}.formAbsolutePath("/a") == "/b/c"
            ComponentPath{"b/c"}.formAbsolutePath("a")  // throws
        """
        return _common.ComponentPath_formAbsolutePath(self, otherPath)

    def formRelativePath(self, otherPath: "ComponentPath") -> "OpenSim::ComponentPath":
        r"""
        Find the relative Path between this Path and another Path (otherPath)
        (i.e. the Path to go FROM otherPath TO this Path). Both Paths must be
        absolute.
        """
        return _common.ComponentPath_formRelativePath(self, otherPath)

    def getParentPath(self) -> "OpenSim::ComponentPath":
        r"""
        Returns the sub-path that contains all subdirectory levels except for
        the last one.
        """
        return _common.ComponentPath_getParentPath(self)

    def getParentPathString(self) -> "std::string":
        r"""Returns the parent path as a string."""
        return _common.ComponentPath_getParentPathString(self)

    def getSubcomponentNameAtLevel(self, index: "size_t") -> "std::string":
        r"""
        Returns the name of a subdirectory in the path at the specified level
        (0-indexed).
        """
        return _common.ComponentPath_getSubcomponentNameAtLevel(self, index)

    def getComponentName(self) -> "std::string":
        r"""
        Returns the name of the Component in the path (effectively, the last
        element in the path).
        """
        return _common.ComponentPath_getComponentName(self)

    def toString(self) -> "std::string const &":
        r"""
        Returns a string representation of the ComponentPath
        (e.g. "/a/b/component").
        """
        return _common.ComponentPath_toString(self)

    def isAbsolute(self) -> "bool":
        r"""
        Returns true if the path is absolute (effectively, if it begins
        with '/').
        """
        return _common.ComponentPath_isAbsolute(self)

    def getNumPathLevels(self) -> "size_t":
        r"""Returns the number of levels in the path (e.g. "/a/b/c" == 3)."""
        return _common.ComponentPath_getNumPathLevels(self)

    def pushBack(self, pathElement: "std::string const &") -> "void":
        r"""
        Push a string onto the end of the path.

        Throws if the argument contains invalid characters.
        """
        return _common.ComponentPath_pushBack(self, pathElement)

    def isLegalPathElement(self, pathElement: "std::string const &") -> "bool":
        r"""Returns true if the argument does not contain any invalid characters."""
        return _common.ComponentPath_isLegalPathElement(self, pathElement)

    def trimDotAndDotDotElements(self) -> "void":
        r"""
        Resolves '.' and ".." elements in the path if possible. Leading ".."
        elements are allowed only in relative paths (throws if found at the
        start of an absolute path). Also checks for invalid characters.

        Effectively, this is the same as internally `normalize`ing the path.
        """
        return _common.ComponentPath_trimDotAndDotDotElements(self)
    __swig_destroy__ = _common.delete_ComponentPath

# Register ComponentPath in _common:
_common.ComponentPath_swigregister(ComponentPath)

class ComponentHasNoName(OpenSimException):
    r""" Component Exceptions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", componentConcreteClassName: "std::string const &"):
        _common.ComponentHasNoName_swiginit(self, _common.new_ComponentHasNoName(file, line, func, componentConcreteClassName))
    __swig_destroy__ = _common.delete_ComponentHasNoName

# Register ComponentHasNoName in _common:
_common.ComponentHasNoName_swigregister(ComponentHasNoName)

class InvalidComponentName(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", invalidChars: "std::string const &", componentConcreteClassName: "std::string const &"):
        _common.InvalidComponentName_swiginit(self, _common.new_InvalidComponentName(file, line, func, thisName, invalidChars, componentConcreteClassName))
    __swig_destroy__ = _common.delete_InvalidComponentName

# Register InvalidComponentName in _common:
_common.InvalidComponentName_swigregister(InvalidComponentName)

class ComponentNotFoundOnSpecifiedPath(ComponentNotFound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", toFindName: "std::string const &", toFindClassName: "std::string const &", thisName: "std::string const &"):
        _common.ComponentNotFoundOnSpecifiedPath_swiginit(self, _common.new_ComponentNotFoundOnSpecifiedPath(file, line, func, toFindName, toFindClassName, thisName))
    __swig_destroy__ = _common.delete_ComponentNotFoundOnSpecifiedPath

# Register ComponentNotFoundOnSpecifiedPath in _common:
_common.ComponentNotFoundOnSpecifiedPath_swigregister(ComponentNotFoundOnSpecifiedPath)

class ComponentIsAnOrphan(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", componentConcreteClassName: "std::string const &"):
        _common.ComponentIsAnOrphan_swiginit(self, _common.new_ComponentIsAnOrphan(file, line, func, thisName, componentConcreteClassName))
    __swig_destroy__ = _common.delete_ComponentIsAnOrphan

# Register ComponentIsAnOrphan in _common:
_common.ComponentIsAnOrphan_swigregister(ComponentIsAnOrphan)

class SubcomponentsWithDuplicateName(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", duplicateName: "std::string const &"):
        _common.SubcomponentsWithDuplicateName_swiginit(self, _common.new_SubcomponentsWithDuplicateName(file, line, func, thisName, duplicateName))
    __swig_destroy__ = _common.delete_SubcomponentsWithDuplicateName

# Register SubcomponentsWithDuplicateName in _common:
_common.SubcomponentsWithDuplicateName_swigregister(SubcomponentsWithDuplicateName)

class ComponentIsRootWithNoSubcomponents(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", thisName: "std::string const &", componentConcreteClassName: "std::string const &"):
        _common.ComponentIsRootWithNoSubcomponents_swiginit(self, _common.new_ComponentIsRootWithNoSubcomponents(file, line, func, thisName, componentConcreteClassName))
    __swig_destroy__ = _common.delete_ComponentIsRootWithNoSubcomponents

# Register ComponentIsRootWithNoSubcomponents in _common:
_common.ComponentIsRootWithNoSubcomponents_swigregister(ComponentIsRootWithNoSubcomponents)

class ComponentAlreadyPartOfOwnershipTree(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", compName: "std::string const &", thisName: "std::string const &"):
        _common.ComponentAlreadyPartOfOwnershipTree_swiginit(self, _common.new_ComponentAlreadyPartOfOwnershipTree(file, line, func, compName, thisName))
    __swig_destroy__ = _common.delete_ComponentAlreadyPartOfOwnershipTree

# Register ComponentAlreadyPartOfOwnershipTree in _common:
_common.ComponentAlreadyPartOfOwnershipTree_swigregister(ComponentAlreadyPartOfOwnershipTree)

class ComponentHasNoSystem(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject"):
        _common.ComponentHasNoSystem_swiginit(self, _common.new_ComponentHasNoSystem(file, line, func, obj))
    __swig_destroy__ = _common.delete_ComponentHasNoSystem

# Register ComponentHasNoSystem in _common:
_common.ComponentHasNoSystem_swigregister(ComponentHasNoSystem)

class SocketNotFound(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", socketName: "std::string const &"):
        _common.SocketNotFound_swiginit(self, _common.new_SocketNotFound(file, line, func, obj, socketName))
    __swig_destroy__ = _common.delete_SocketNotFound

# Register SocketNotFound in _common:
_common.SocketNotFound_swigregister(SocketNotFound)

class InputNotFound(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", inputName: "std::string const &"):
        _common.InputNotFound_swiginit(self, _common.new_InputNotFound(file, line, func, obj, inputName))
    __swig_destroy__ = _common.delete_InputNotFound

# Register InputNotFound in _common:
_common.InputNotFound_swigregister(InputNotFound)

class OutputNotFound(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", obj: "OpenSimObject", outputName: "std::string const &"):
        _common.OutputNotFound_swiginit(self, _common.new_OutputNotFound(file, line, func, obj, outputName))
    __swig_destroy__ = _common.delete_OutputNotFound

# Register OutputNotFound in _common:
_common.OutputNotFound_swigregister(OutputNotFound)

class Component(OpenSimObject):
    r"""
    The abstract Component class defines the interface used to add computational
    elements to the underlying SimTK::System (MultibodySystem). It specifies
    the interface that components must satisfy in order to be part of the system
    and provides a series of helper methods for adding variables
    (state, discrete, cache, ...) to the underlying system. As such, Component
    handles all of the bookkeeping of system indices and provides convenience
    access to variable values (incl. derivatives) via their names as strings.

    # Component's Interfaces
    ## System and State

    The MultibodySystem and its State are defined by Simbody (ref ...). Briefly,
    a System represents the mathematical equations that specify the behavior
    of a computational model. The State is a collection of all the variables
    that uniquely define the unknowns in the system equations. Consider a single
    differential equation as a system, while a single set of variable values that
    satisfy the equation is a state of that system. These could be values for
    joint coordinates, their speeds, as well other variables that govern
    the system dynamics (e.g. muscle activation and fiber-length variables
    that dictate muscle force). These variables are called continuous state
    variables in Simbody, but are more simply referred to as **StateVariables**
    in OpenSim. Component provides services to define and access its
    StateVariables and specify their dynamics (derivatives with respect to time)
    that are automatically and simultaneously integrated with the MultibodySystem
    dynamics. Common operations to integrate, take the max or min, or to delay a
    signal, etc. require internal variables to perform their calculations and
    these are also held in the State. Simbody provides the infrastructure to
    ensure that calculations are kept up-to-date with the state variable values.

    There are other types of "State" variables such as a flag (or options) that
    enables a component to be disabled or for a muscle force to be overridden and
    and these are identified as **ModelingOptions** since they may change
    the modeled dynamics of the component. Component provides services
    that enable developers of components to define additional ModelingOptions.

    ## Discrete variables

    Often a component requires input from an outside source (precomputed data
    from a file, another program, or interaction from a user) in which case these
    variables do not have dynamics (differential eqns.) known to the component,
    but are necessary to describe the dynamical "state" of the system. An example,
    is a throttle component (a "controller" that provides an actuator, e.g. a
    motor, with a control signal like a voltage or current) which it gets as direct
    input from the user (via a joystick, key press, etc..). The throttle controls
    the motor torque output and therefore the behavior of the model. The input by
    the user to the throttle the motor (the controls) is necessary to specify the
    model dynamics at any instant and therefore are considered part of the State.
    In OpenSim they are simply referred to as DiscreteVariables. The Component
    provides services to enable developers of components to define and access its
    DiscreteVariables.

    ## Cache variables

    Fast and efficient simulations also require computationally expensive
    calculations to be performed only when necessary. Often the result of an
    expensive calculation can be reused many times over, while the variables it
    is dependent on remain fixed. The concept of holding onto these values is
    called caching and the variables that hold these values are call
    **CacheVariables**. It is important to note, that cache variables are
    not state variables. Cache variables can always be recomputed exactly
    from the State. OpenSim uses the Simbody infrastructure to manage cache
    variables and their validity. Component provides a simplified interface to
    define and access CacheVariables.

    ## Stages

    Many modeling and simulation codes put the onus on users and component
    creators to manage the validity of cache variables, which is likely to lead
    to undetectable errors where cache values are stale (calculated based on past
    state variable values). Simbody, on the other hand, provides a more strict
    infrastructure to make it easy to exploit the efficiencies of caching while
    reducing the risks of validity errors. To do this, Simbody employs the concept
    of computational stages to "realize" (or compute) a model's system to a
    particular stage requires cached quantities up to and including the stage to
    to computed/specified. Simbody utilizes nine realization stages
    (SimTK::Stage::)

    -# ``Topology``       finalize System with "slots" for most variables (above)
    -# ``%Model``         specify modeling choices
    -# ``Instance``       specify modifiable model parameters
    -# ``Time``           compute time dependent quantities
    -# ``Position``       compute position dependent quantities
    -# ``Velocity``       compute velocity dependent quantities
    -# ``Dynamics``       compute system applied forces and dependent quantities
    -# ``Acceleration``   compute system accelerations and all other derivatives
    -# ``Report``         compute quantities for reporting/output

    The Component interface is automatically invoked by the System and its
    realizations. Component users and most developers need not concern themselves
    with ``Topology``, ``%Model`` or ``Instance`` stages. That interaction is managed
    by Component when component creators implement extendAddToSystem() and use the
    services provided by Component. Component creators do need to determine and
    specify stage dependencies for Discrete and CacheVariables that they add to
    their components. For example, the throttle controller reads its value from
    user input and it is valid for all calculations as long as time does not
    change. If the simulation (via numerical integration) steps forward (or
    backward for a trial step) and updates the state, the control from a previous
    state (time) should be invalid and an error generated for trying to access
    the DiscreteVariable for the control value. To do this one specifies the
    "invalidates" stage (e.g. SimTK::Stage::Time) for a DiscreteVariable
    when the variable is added to the Component. A subsequent change to that
    variable will invalidate all state cache entries at that stage or higher. For
    example, if a DiscreteVariable is declared to invalidate Stage::Position
    then changing it will invalidate cache entries that depend on positions,
    velocities, forces, and accelerations.

    Similar principles apply to CacheVariables, which requires a "dependsOn" stage to
    be specified when a CacheVariable is added to the component. In this case,
    the cache variable "shadows" the State (unlike a DiscreteVariable, which is a
    part of the State) holding already-computed state-dependent values so that
    they do not need to be recomputed until the state changes.
    Accessing the CacheVariable in a State whose current stage is lower than
    that CacheVariable's specified dependsOn stage will trigger an exception.
    It is up to the component to update the value of the cache variable.
    Component provides methods to check if the cache is valid, update its value
    and then to mark it as valid.

    ## The interface of this class

    The primary responsibility of a Component is to add its computational
    representation(s) to the underlying SimTK::System by implementing
    extendAddToSystem().

    Additional methods provide support for adding modeling options, state and
    cache variables.

    Public methods enable access to component variables via their names.

    ## Subcomponents

    A %Component can have any number of %Components within it; we call these
    subcomponents. Subcomponents can also contain their own subcomponents as
    well. There are three categories of subcomponents, which vary in whether
    they are *configurable* and *fixed in number*:

    - **property subcomponents** Any Property in a Component that is of type
      Component is a subcomponent. This includes list properties and Set%s. This
      is the most common category of subcomponent, and its distinguishing
      feature is that these subcomponents are *configurable* by the user of this
      component. These subcomponents appear in the XML for this component, and
      can be modified in XML or through the API. They are also not fixed in
      number; users can add more property subcomponents to an existing
      component (though it is possible to enforce a fixed number by using
      one-value properties or limiting the size of a list property). The bodies,
      joints, forces, etc. in a Model's BodySet, JointSet, ForceSet, etc. are
      all examples of property subcomponents. This category of subcomponent is
      the most similar to what was available pre-v4.0.
    - **member subcomponents** These are *not* configurable by the user of this
      Component, and can only be modified by this Component. You can
      still access member subcomponents through the API, but only the component
      containing the subcomponents can modify them. Any Component class can have
      any number of member subcomponents, but this number is *fixed* for every
      instance of the component.
    - **adopted subcomponents** These are *not* configurable (does not appear in
      XML) and *not* fixed in number. For example, a component can decide,
      based on other aspects of the model, that it needs to create a new
      subcomponent. This can be done using adopted subcomponents.

    Also, any specific Component can end up in any of these three categories.
    That is, if you have a MySpecialForce Component, any other Component can
    have it as a property subcomponent, a member subcomponent, or as an adopted
    subcomponent.

    Author: Ajay Seth, Michael Sherman, Chris Dembia
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Component *":
        return _common.Component_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Component_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Component_getClassName()

    def clone(self) -> "OpenSim::Component *":
        return _common.Component_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Component_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_Component

    def finalizeFromProperties(self) -> "void":
        r"""
        Define a Component's internal data members and structure according to
                its properties. This includes its subcomponents as part of the component
                ownership tree and identifies its owner (if present) in the tree.
                finalizeFromProperties propagates to all of the component's subcomponents
                prior to invoking the virtual extendFinalizeFromProperties() on itself.
                Note that if the Component has already been added to a System (result of
                addToSystem(); e.g., Model::initSystem()) when finalizeFromProperties()
                is called, then finalizeFromProperties() disassociates the component from
                that System.
        """
        return _common.Component_finalizeFromProperties(self)

    def finalizeConnections(self, root: "Component") -> "void":
        r"""
        Satisfy the Component's connections specified by its Sockets and Inputs.
               Locate Components and their Outputs to satisfy the connections in an
               aggregate Component (e.g. Model), which is the root of a tree of
               Components.
        """
        return _common.Component_finalizeConnections(self, root)

    def clearConnections(self) -> "void":
        r"""
        Disconnect/clear this Component from its aggregate component. Empties
               all component's sockets and sets them as disconnected.
        """
        return _common.Component_clearConnections(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _common.Component_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _common.Component_initStateFromProperties(self, state)

    def setPropertiesFromState(self, state: "State") -> "void":
        r""" %Set Component's properties given a state."""
        return _common.Component_setPropertiesFromState(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _common.Component_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _common.Component_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _common.Component_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _common.Component_isComponentInOwnershipTree(self, component)

    def addComponent(self, subcomponent: "Component") -> "void":
        r"""
        Add a Component (as a subcomponent) of this component.
        This component takes ownership of the subcomponent and it will be
        serialized (appear in XML) as part of this component. Specifically,
        it will appear in the `<components>` list for this Component.
        If the subcomponent is already owned by this component or exists
        in the same hierarchy (tree) as this component, an Exception
        is thrown.
        Notes: addComponent is intended to replace existing addBody(), addJoint,
              ... on Model or the requirement for specific add###() methods to
              subcomponents to a Component.

        Typical usage is:

            .. code-block:: c++

            Start with an empty Model (which is a Component)
                    Model myModel;
            Create any Component type on the heap
                    Body* newBody = new Body();
            Customize the Component by setting its properties
                    newBody->setName("newBody");
                    newBody->setMass(10.0);
                    newBody->setMassCenter(SimTK::Vec3(0));
            ...
            Now add it to your model, which will take ownership of it
                    myModel.addComponent(newBody);

            Keep creating and adding new components, like Joints, Forces, etc..

        :raises: ComponentAlreadyPartOfOwnershipTree
        :type subcomponent: :py:class:`Component`
        :param subcomponent: is the Component to be added.
        """
        val = _common.Component_addComponent(self, subcomponent)

        subcomponent._markAdopted()


        return val


    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _common.Component_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _common.Component_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _common.Component_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _common.Component_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _common.Component_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _common.Component_getComponent(self, pathname)

    def updComponent(self, pathname: "std::string const &") -> "OpenSim::Component &":
        r"""
         Similar to the templatized updComponent(), except this returns the
        component as the generic Component type. As with the non-templatized
        getComponent(), though, this will give the concrete type in Python in
        most cases.
        See also: getComponent()
        """
        return _common.Component_updComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _common.Component_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _common.Component_getNumSockets(self)

    def getSocketNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of the sockets in this component. You
        can use this to iterate through the sockets:

        .. code-block:: c++

            for (std::string name : comp.getSocketNames()) {
                const AbstractSocket& socket = getSocket(name);
            }
        """
        return _common.Component_getSocketNames(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _common.Component_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _common.Component_getSocket(self, name)

    def updSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket &":
        r"""
         Get a writable reference to the AbstractSocket for the given
        socket name. Use this method to connect the Socket to something.

        **C++ example**

        .. code-block:: c++

            joint.updSocket("parent_frame").connect(model.getGround());

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Socket (to tell it which
        component it's in) before providing it to you.
        """
        return _common.Component_updSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _common.Component_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _common.Component_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _common.Component_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _common.Component_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _common.Component_getInput(self, name)

    def updInput(self, name: "std::string const &") -> "OpenSim::AbstractInput &":
        r"""
        Get a writable reference to an Input provided by this Component by name.

        **C++ example:** get a writable reference to an Input of a
        Component in a model

        .. code-block:: c++

            model.updComponent("/path/to/component").updInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: reference to the AbstractInput
        """
        return _common.Component_updInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _common.Component_getOutput(self, name)

    def updOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput &":
        r"""
        Get a writable reference to an Output provided by this Component by name.

        **C++ example:** get a writable reference to an Output of a
        Component in a model

        .. code-block:: c++

            model.updComponent("/path/to/component").updOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: reference to the AbstractOutput
        """
        return _common.Component_updOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _common.Component_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _common.Component_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.Component_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _common.Component_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.Component_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.Component_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.Component_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _common.Component_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _common.Component_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _common.Component_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _common.Component_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _common.Component_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _common.Component_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _common.Component_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _common.Component_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _common.Component_getComponentsList(self)

# Register Component in _common:
_common.Component_swigregister(Component)

def Component_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Component *":
    return _common.Component_safeDownCast(obj)

def Component_getClassName() -> "std::string const &":
    return _common.Component_getClassName()

class ConnecteeNotSpecified(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", socket: "AbstractSocket", owner: "Component"):
        _common.ConnecteeNotSpecified_swiginit(self, _common.new_ConnecteeNotSpecified(file, line, func, socket, owner))
    __swig_destroy__ = _common.delete_ConnecteeNotSpecified

# Register ConnecteeNotSpecified in _common:
_common.ConnecteeNotSpecified_swigregister(ConnecteeNotSpecified)

class ComponentsList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that takes a Component to iterate over (itself and its
           descendants) and a ComponentFilter. You can change the filter later
           using the setFilter() method. The filter is cloned on
           construction and can only be changed using setFilter().

        |

        *Overload 2:*
        Constructor that takes only a Component to iterate over (itself and its
           descendants). ComponentFilterMatchAll is used internally. You can
           change the filter using setFilter() method.
        """
        _common.ComponentsList_swiginit(self, _common.new_ComponentsList(*args))
    __swig_destroy__ = _common.delete_ComponentsList

    def begin(self, *args) -> "OpenSim::ComponentList< OpenSim::Component const >::const_iterator":
        r"""
        *Overload 1:*
        Return an iterator pointing to the first component in the tree
           traversal of components under and including the root component passed
           to the ComponentList constructor. If T is non-const, then this iterator
           allows you to modify the elements of this list.

        |

        *Overload 2:*
        Same as cbegin().
        """
        return _common.ComponentsList_begin(self, *args)

    def cbegin(self) -> "OpenSim::ComponentList< OpenSim::Component const >::const_iterator":
        r"""
        Similar to begin(), except it does not permit
           modifying the elements of the list, even if T is non-const (e.g.,
           ComponentList).
        """
        return _common.ComponentsList_cbegin(self)

    def end(self, *args) -> "OpenSim::ComponentList< OpenSim::Component const >::const_iterator":
        r"""
        *Overload 1:*
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list.

        |

        *Overload 2:*
        Same as cend().
        """
        return _common.ComponentsList_end(self, *args)

    def cend(self) -> "OpenSim::ComponentList< OpenSim::Component const >::const_iterator":
        r"""
        Use this method to check if you have reached the end of the list.
           This points past the end of the list, *not* to the last item in the
           list. Use this if you used cbegin().
        """
        return _common.ComponentsList_cend(self)

    def setFilter(self, filter: "ComponentFilter") -> "void":
        r"""
        Allow users to specify a custom ComponentFilter. This object makes a
           clone of the passed in filter.
        """
        return _common.ComponentsList_setFilter(self, filter)


    def __iter__(self):
        """Get an iterator for this ComponentList, to be used as such::

            for c in model.getComponentsList():
                c.getName()
        """
        import sys
        opensim_pkg = sys.modules[__name__.partition('.')[0]]
        it = self.begin()
        while it != self.end():
            component = it.__deref__()
            try:
                ConcreteClass = getattr(opensim_pkg, component.getConcreteClassName())
                concrete_component = ConcreteClass.safeDownCast(component)
                yield concrete_component 
            except:
                yield component
            it.next()


# Register ComponentsList in _common:
_common.ComponentsList_swigregister(ComponentsList)

class ComponentIterator(object):
    r"""
     Class used to iterate over subcomponents of a specific type (by default,
    any Component).
    This iterator is can either be a const_iterator or non-const iterator, depending
    on how you got it. If this is a const_iterator, it returns only a const
    reference to a component. If this is a non-const iterator, then it returns
    a non-const reference to a component, and thus you can modify the component.

    If you got this iterator from something like a ComponentList<const Body>, then
    it is necessarily a const_iterator. If you got this iterator from something like
    ComponentList, then this may be either a const_iterator (e.g., from
    ComponentList::cbegin()) or non-const iterator (e.g.,
    from ComponentList::begin()).

    If you have a non-const iterator, you should *not* add (sub)components to any
    components.

    This iterator works only in the forward direction (not bidirectional).

    Here is an example of using this iterator with a range for loop (const_iterator):

    .. code-block:: c++

        ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
        for (const GeometryPath& gpath : geomPathList) {
        do something with gpath
        }

    Here is a similar example, but where you can modify the components:

    .. code-block:: c++

        ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
        for (GeometryPath& gpath : geomPathList) {
        do something with gpath
        }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def equals(self, other: "ComponentIterator") -> "bool":
        r"""
        @ Comparison operators for scripting
        These variants accept only an iterator with the same template parameter.

        Check for (non)equality using a normal method rather than an operator.
        """
        return _common.ComponentIterator_equals(self, other)

    def __eq__(self, other: "ComponentIterator") -> "bool":
        return _common.ComponentIterator___eq__(self, other)

    def __ne__(self, other: "ComponentIterator") -> "bool":
        return _common.ComponentIterator___ne__(self, other)

    def __ref__(self) -> "OpenSim::Component const &":
        r"""
        Dereference the iterator to get a reference to Component of proper
           type (matching Filter if specified). If you have a const iterator, then
           this returns a const reference; otherwise, this returns a non-const
           reference.
        """
        return _common.ComponentIterator___ref__(self)

    def deref(self) -> "OpenSim::Component const &":
        return _common.ComponentIterator_deref(self)

    def __deref__(self) -> "OpenSim::Component const *":
        r""" Another dereferencing operator that returns a pointer."""
        return _common.ComponentIterator___deref__(self)

    def next(self) -> "OpenSim::ComponentListIterator< OpenSim::Component const > &":
        r"""
        Method equivalent to pre-increment operator for operator-deficient
            languages.
        """
        return _common.ComponentIterator_next(self)
    __swig_destroy__ = _common.delete_ComponentIterator

    def clone(self) -> "OpenSim::Component *":
        return _common.ComponentIterator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ComponentIterator_getConcreteClassName(self)

    def addToSystem(self, system: "SimTK::MultibodySystem &") -> "void":
        r""" Have the Component add itself to the underlying computational System"""
        return _common.ComponentIterator_addToSystem(self, system)

    def initStateFromProperties(self, state: "State") -> "void":
        r""" Initialize Component's state variable values from its properties"""
        return _common.ComponentIterator_initStateFromProperties(self, state)

    def generateDecorations(self, fixed: "bool", hints: "ModelDisplayHints", state: "State", appendToThis: "ArrayDecorativeGeometry") -> "void":
        r"""
        Optional method for generating arbitrary display geometry that reflects
            this %Component at the specified *state*. This will be called once to
            obtain ground- and body-fixed geometry (with *fixed=*``true)``, and then
            once per frame (with *fixed=*``false)`` to generate on-the-fly geometry such
            as rubber band lines, force arrows, labels, or debugging aids.

            Please note that there is a precondition that the state passed in to
            generateDecorations be realized to Stage::Position. If your component can
            visualize quantities realized at Velocity, Dynamics or Acceleration stages,
            then you must check that the stage has been realized before using/requesting
            stage dependent values. It is forbidden to realize the model to a higher
            stage within generateDecorations, because this can trigger costly side-
            effects such as evaluating all model forces even when performing a purely
            kinematic study.

            If you override this method, be sure to invoke the base class method first,
            using code like this:

            .. code-block:: c++

                void MyComponent::generateDecorations
                   (bool                                        fixed,
                    const ModelDisplayHints&                    hints,
                    const SimTK::State&                         state,
                    SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
                {
            invoke parent class method
                    Super::generateDecorations(fixed,hints,state,appendToThis);
            ... your code goes here
            can render velocity dependent quanities if stage is Velocity or higher
                    if(state.getSystemStage() >= Stage::Velocity) {
            draw velocity vector for model COM
                    }
            can render computed forces if stage is Dynamics or higher
                    if(state.getSystemStage() >= Stage::Dynamics) {
            change the length of a force arrow based on the force in N
                    }
                }

            :type fixed: boolean, in
            :param fixed:
                    If ``true``, generate only geometry that is fixed to a PhysicalFrame,
                    configuration, and velocity. Otherwise generate only such dependent
                    geometry.
            :type hints: :py:class:`ModelDisplayHints`, in
            :param hints:
                    See documentation for ModelDisplayHints; you may want to alter the
                    geometry you generate depending on what you find there. For example,
                    you can determine whether the user wants to see debug geometry.
            :type state: :py:class:`State`, in
            :param state:
                    The State for which geometry should be produced. See below for more
                    information.
            :type appendToThis: SimTK::Array_< SimTK::DecorativeGeometry,unsigned int >, in/out
            :param appendToThis:
                    %Array to which generated geometry should be *appended* via the
                    ``push_back()`` method.

            When called with *fixed=*``true`` only modeling options and parameters
            (Instance variables) should affect geometry; time, position, and velocity
            should not. In that case OpenSim will already have realized the *state*
            through Instance stage. When called with *fixed=*``false``, you may
            consult any relevant value in *state*. However, to avoid unnecessary
            computation, OpenSim guarantees only that *state* will have been realized
            through Position stage; if you need anything higher than that (reaction
            forces, for example) you should make sure the *state* is realized through
            Acceleration stage. *
        """
        return _common.ComponentIterator_generateDecorations(self, fixed, hints, state, appendToThis)

    def getSystem(self) -> "SimTK::MultibodySystem const &":
        r"""
        Get the underlying MultibodySystem that this component is connected to.
        Make sure you have called Model::initSystem() prior to accessing the System.
        Throws an Exception if the System has not been created or the Component
        has not added itself to the System.
        See also: hasSystem().
        """
        return _common.ComponentIterator_getSystem(self)

    def hasSystem(self) -> "bool":
        r"""
        Check if this component has an underlying MultibodySystem.
        Returns false if the System has not been created OR if this
        Component has not added itself to the System.
        """
        return _common.ComponentIterator_hasSystem(self)

    def isComponentInOwnershipTree(self, component: "Component") -> "bool":
        r"""
         Does the provided component already exist anywhere in the ownership
        tree (not just subcomponents of this component)?
        """
        return _common.ComponentIterator_isComponentInOwnershipTree(self, component)

    def getAbsolutePathString(self) -> "std::string":
        r"""
         Get the complete (absolute) pathname for this Component to its ancestral
        Component, which is the root of the tree to which this Component belongs.
        For example: a Coordinate Component would have an absolute path name
        like: `/arm26/elbow_r/flexion`. Accessing a Component by its
        absolutePathName from root is guaranteed to be unique. The
        absolutePathName is generated on-the-fly by traversing the ownership tree
        and, therefore, calling this method is not "free".
        """
        return _common.ComponentIterator_getAbsolutePathString(self)

    def getAbsolutePath(self) -> "OpenSim::ComponentPath":
        r"""
         Return a ComponentPath of the absolute path of this Component.
        Note that this has more overhead than calling `getName()` because
        it traverses up the tree to generate the absolute pathname (and its
        computational cost is thus a function of depth). Consider other
        options if this is repeatedly called and efficiency is important.
        For instance, `getAbsolutePathString()` is faster if you only
        need the path as a string.
        """
        return _common.ComponentIterator_getAbsolutePath(self)

    def getRelativePathString(self, wrt: "Component") -> "std::string":
        r"""
         Get the relative path of this Component with respect to another
        Component, as a string.
        """
        return _common.ComponentIterator_getRelativePathString(self, wrt)

    def getRelativePath(self, wrt: "Component") -> "OpenSim::ComponentPath":
        r"""
         Get the relative path of this Component with respect to another
        Component.
        """
        return _common.ComponentIterator_getRelativePath(self, wrt)

    def hasComponent(self, pathname: "std::string const &") -> "bool":
        r"""
         Query if there is a component (of any type) at the specified
        path name. For example,

        .. code-block:: c++

            bool exists = model.hasComponent("right_elbow/elbow_flexion");
        checks if `model` has a subcomponent "right_elbow," which has a
        subcomponent "elbow_flexion."
        """
        return _common.ComponentIterator_hasComponent(self, pathname)

    def getComponent(self, pathname: "std::string const &") -> "OpenSim::Component const &":
        r"""
         Similar to the templatized getComponent(), except this returns the
        component as the generic Component type. This can be used in
        Python/Java/MATLAB. Here is an example of using this in MATLAB:

        .. code-block:: c++

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getNumConnectees() % okay; this is a Component method.
            coord.getDefaultClamped() % inaccessible; method on Coordinate.
            Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.

        %Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            coord = model.getComponent('right_elbow/elbow_flexion')
            coord.getDefaultClamped() # works; no downcasting necessary.
        """
        return _common.ComponentIterator_getComponent(self, pathname)

    def printComponentsMatching(self, substring: "std::string const &") -> "unsigned int":
        r"""
         Print a list to the console of all components whose absolute path name
        contains the given string. You might use this if (a) you know the name
        of a component in your model but don't know its absolute path, (b) if
        you want to find all components with a given name, or (c) to get a list
        of all components on the right leg of a model (if all components on the
        right side have "_r" in their name).

        A function call like:

        .. code-block:: c++

            unsigned num = comp.printComponentsMatching("rotation");
        may produce output like:
        /leg_model/right_hip/rotation
        /leg_model/left_hip/rotation

        :rtype: int
        :return: The number of matches.
        """
        return _common.ComponentIterator_printComponentsMatching(self, substring)

    def getNumStateVariables(self) -> "int":
        r"""
        Get the number of "continuous" state variables maintained by the
        Component and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getNumStateVariables(self)

    def getStateVariableNames(self) -> "OpenSim::Array< std::string >":
        r"""
        Get the names of "continuous" state variables maintained by the Component
        and its subcomponents.
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getStateVariableNames(self)

    def getNumSockets(self) -> "int":
        r""" Get the number of Sockets in this Component."""
        return _common.ComponentIterator_getNumSockets(self)

    def getConnectee(self, name: "std::string const &") -> "OpenSim::Object const &":
        r"""
         Get the connectee as an Object. This means you will not have
        access to the methods on the concrete connectee. This is the method you
        must use in MATLAB to access the connectee.

        Example:

        .. code-block:: c++

            const Object& obj = joint.getConnectee("parent_frame");
            obj.getName(); // method on Object works.
            obj.getMobilizedBody(); // error: not available.

        In MATLAB, if you want the concrete type, you need to downcast the
        Object. Here is an example where you know the "parent_frame" is a Body:

        .. code-block:: c++

            f = joint.getConnectee('parent_frame');
            m = Body.safeDownCast(f).getMass();

        Exception: in Python, you will get the concrete type (in most cases):

        .. code-block:: python

            f = joint.getConnectee("parent_frame");
            m = f.getMass() # works (if the parent frame is a body)
        """
        return _common.ComponentIterator_getConnectee(self, name)

    def getSocket(self, name: "std::string const &") -> "OpenSim::AbstractSocket const &":
        return _common.ComponentIterator_getSocket(self, name)

    def getNumInputs(self) -> "int":
        r""" Access the number of Inputs that this component has."""
        return _common.ComponentIterator_getNumInputs(self)

    def getNumOutputs(self) -> "int":
        r""" Access the number of Outputs that this component has."""
        return _common.ComponentIterator_getNumOutputs(self)

    def getInputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Inputs in this component as an
        std::vector.
        """
        return _common.ComponentIterator_getInputNames(self)

    def getOutputNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
         Collect and return the names of Outputs in this component as an
        std::vector.
        """
        return _common.ComponentIterator_getOutputNames(self)

    def getInput(self, name: "std::string const &") -> "OpenSim::AbstractInput const &":
        r"""
        Get an Input provided by this Component by name.

        **C++ example:** get an Input from a Component in the model

        .. code-block:: c++

            model.getComponent("/path/to/component").getInput("inputName");

        If you have not yet called finalizeFromProperties() on this
        component, this function will update the Input (to tell it which
        component it's in) before providing it to you.

        :type name: string
        :param name:   the name of the Input
        :rtype: :py:class:`AbstractInput`
        :return: const reference to the AbstractInput
        """
        return _common.ComponentIterator_getInput(self, name)

    def getOutput(self, name: "std::string const &") -> "OpenSim::AbstractOutput const &":
        r"""
        Get the Output provided by this Component by name.

        **C++ example:** get an Output from a Component in a model

        .. code-block:: c++

            model.getComponent("/path/to/component").getOutput("outputName");

        :type name: string
        :param name:   the name of the Output
        :rtype: :py:class:`AbstractOutput`
        :return: const reference to the AbstractOutput
        """
        return _common.ComponentIterator_getOutput(self, name)

    def getModelingOption(self, state: "State", name: "std::string const &") -> "int":
        r"""
        Get a ModelingOption flag for this Component by name.
        The flag is an integer corresponding to the index of modelingOptionNames used
        add the modeling option to the component. See also: addModelingOption

        :type state: :py:class:`State`
        :param state:  the State in which to set the modeling option
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :rtype: int
        :return: flag  integer value for modeling option
        """
        return _common.ComponentIterator_getModelingOption(self, state, name)

    def setModelingOption(self, state: "State", name: "std::string const &", flag: "int") -> "void":
        r"""
        %Set the value of a ModelingOption flag for this Component.
        if the integer value exceeds the number of option names used to
        define the options, an exception is thrown. The SimTK::State
        Stage will be reverted back to Stage::Instance.

        :type state: :py:class:`State`
        :param state:  the State in which to set the flag
        :type name: string
        :param name:   the name (string) of the modeling option of interest
        :type flag: int
        :param flag:   the desired flag (int) value specifying the modeling option
        """
        return _common.ComponentIterator_setModelingOption(self, state, name, flag)

    def getStateVariableValue(self, *args) -> "double":
        r"""
        *Overload 1:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)

        |

        *Overload 2:*

        Get the value of a state variable allocated by this Component.

        To connect this StateVariable as an input to another component (such as
        a Reporter), use getOutput(name); each state variable has a
        corresponding Output:

         .. code-block:: c++

             foo.getInput("input1").connect(bar.getOutput(name));

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :param name:    path to the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getStateVariableValue(self, *args)

    def setStateVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a state variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the state variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_setStateVariableValue(self, state, name, value)

    def getStateVariableValues(self, state: "State") -> "SimTK::Vector":
        r"""
        Get all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents.

        :type state: :py:class:`State`
        :param state:   the State for which to get the value
        :rtype: :py:class:`Vector`
        :return: Vector of state variable values of length getNumStateVariables()
                           in the order returned by getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getStateVariableValues(self, state)

    def setStateVariableValues(self, state: "State", values: "Vector") -> "void":
        r"""
        %Set all values of the state variables allocated by this Component.
        Includes state variables allocated by its subcomponents. Note, this
        method simply sets the values on the input State. If other conditions
        must be met (such as satisfying kinematic constraints for Coordinates,
        or fiber and tendon equilibrium for muscles) you must invoke the
        appropriate methods on Model (e.g. assemble() to satisfy constraints or
        equilibrateMuscles()) to satisfy these conditions starting from the
        State values provided by setStateVariableValues.

        :type state: :py:class:`State`
        :param state:   the State whose values are set
        :type values: :py:class:`Vector`
        :param values:  Vector of state variable values of length
                           getNumStateVariables() in the order returned by
                           getStateVariableNames()
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_setStateVariableValues(self, state, values)

    def getStateVariableDerivativeValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a state variable derivative computed by this Component.

        :type state: :py:class:`State`
        :param state:   the State for which to get the derivative value
        :type name: string
        :param name:    the name (string) of the state variable of interest
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getStateVariableDerivativeValue(self, state, name)

    def getDiscreteVariableValue(self, state: "State", name: "std::string const &") -> "double":
        r"""
        Get the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:   the State from which to get the value
        :type name: string
        :param name:    the name of the state variable
        :rtype: float
        :return: value  the discrete variable value
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_getDiscreteVariableValue(self, state, name)

    def setDiscreteVariableValue(self, state: "State", name: "std::string const &", value: "double") -> "void":
        r"""
        %Set the value of a discrete variable allocated by this Component by name.

        :type state: :py:class:`State`
        :param state:  the State for which to set the value
        :type name: string
        :param name:   the name of the discrete variable
        :type value: float
        :param value:  the value to set
        :raises: ComponentHasNoSystem if this Component has not been added to a
                    System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_setDiscreteVariableValue(self, state, name, value)

    def getCacheVariableIndex(self, name: "std::string const &") -> "SimTK::CacheEntryIndex":
        r"""
        Get the index of a Component's cache variable in the Subsystem for allocations.

        :param T:
              Type of value held in the cache variable
        :type name: string
        :param name:
              Name of the cache variable, as provided to Component::addCacheVariable
        :rtype: SimTK::CacheEntryIndex
        :return: 
              A valid SimTK::CacheEntryIndex, which callers can use with simbody methods
              (e.g. markCacheValueRealized)
        """
        return _common.ComponentIterator_getCacheVariableIndex(self, name)

    def isCacheVariableValid(self, state: "State", name: "std::string const &") -> "bool":
        r"""
        Returns true if the cache variable, identified by `name`, is valid.

        This method enables callers to monitor the validity of the cache variable,
        which enables the caller to decide whether to update the cache variable's
        value (or not). When computing an update is costly, use this method to check
        whether computing the value is necessary.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :rtype: boolean
        :return: bool
                whether the cache variable's value is valid or not
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_isCacheVariableValid(self, state, name)

    def markCacheVariableValid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as valid.

        Upon marking a cache variable's value as valid, the cache variable will remain
        valid until either:

        - the realization stage falls below the minimum realization stage set
          when the cache variable was initialized with `Component::addCacheVariable`

        - the cache variable is explicitly invalidated by calling
          `Component::markCacheVariableInvalid`

        This method causes `Component::isCacheVariableValid` to return true.
        `Component::isCacheVariableValid` is commonly used by value-getting
        methods to decide on whether to return the value as-is or recompute the
        value. Therefore, if a cache variable is not marked as valid then the
        cache variable's value may be recomputed more than necessary, which may
        be costly.

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_markCacheVariableValid(self, state, name)

    def markCacheVariableInvalid(self, state: "State", name: "std::string const &") -> "void":
        r"""
        Marks the value of a cache variable, identified by `name`, as invalid.

        Upon marking a cache variable's value as invalid, it will remain invalid
        until `Component::markCacheVariableValid` is called (or a method which
        uses that, such as `Component::setCacheVariableValue`, is called).

        - Cache variables are automatically marked as invalid when the realization stage
          falls below the minimum realization stage set when the cache variable was
          initialized with `Component::addCacheVariable`.

        - Cache variables *may* be indirectly marked as invalid by other methods. For
          example, a component-added state variable may invalidate a cache variable at
          a lower stage. Concretely:

          - A (hypothetical) component has a `length` state variable
          - There are cache variables that are computed from `length` (e.g.
          `strain`)
          - So changing the `length` may invalidate the `strain` indirectly
            (depending on how the state variable is handled)

        :type state: :py:class:`State`
        :param state:
                the State in which the cache variable's value resides
        :type name: string
        :param name:
                the name of the cache variable
        :raises: ComponentHasNoSystem
                if this Component has not been added to a System (i.e., if initSystem has not been called)
        """
        return _common.ComponentIterator_markCacheVariableInvalid(self, state, name)

    def printSubcomponentInfo(self) -> "void":
        r"""
        List all subcomponents by name and recurse into these components to
           list their subcomponents, and so on.
        """
        return _common.ComponentIterator_printSubcomponentInfo(self)

    def printSocketInfo(self) -> "void":
        r"""
        List all the Sockets of this component and whether or not they are
           connected. Also list the connectee paths for sockets that are connected.
        """
        return _common.ComponentIterator_printSocketInfo(self)

    def printInputInfo(self) -> "void":
        r"""
        List all the inputs of this component and whether or not they are
           connected. Also list the (desired) connectee paths for the inputs.
        """
        return _common.ComponentIterator_printInputInfo(self)

    def printOutputInfo(self, includeDescendants: "bool const"=True) -> "void":
        r"""
        Print outputs of this component and optionally, those of all
           subcomponents.
        """
        return _common.ComponentIterator_printOutputInfo(self, includeDescendants)

    def getOwner(self) -> "OpenSim::Component const &":
        r"""
         Access the owner of this Component.
        An exception is thrown if the %Component has no owner; in this case, the
        component is the root component, or is orphaned.
        See also: hasOwner()
        """
        return _common.ComponentIterator_getOwner(self)

    def hasOwner(self) -> "bool":
        r"""
         (For advanced users) Check if this %Component has an owner.
        A component may not have an owner if it:
        (1) is the root component, or
        (2) has not been added to another component
        """
        return _common.ComponentIterator_hasOwner(self)

    def getRoot(self) -> "OpenSim::Component const &":
        r""" Obtain the root %Component, which is this component if it is orphaned."""
        return _common.ComponentIterator_getRoot(self)

    def findComponent(self, *args) -> "OpenSim::Component const *":
        r"""
        *Overload 1:*
        Find a Component to which this Component is an ancestor---in other
           words, a Component that is directly owned by this Component or is owned
           by one of its sub-components, sub-sub-components, etc. The Component can
           be found by type (by specifying a template argument) and either path or
           name.

           Here is an example of searching for a component of any type with the name
           'elbow_flexion':

           .. code-block:: c++

               if (const Component* found =
                       model.findComponent(ComponentPath("elbow_flexion"))) {
                   std::cout << found.getName() << std::endl;
               }

           Here, we require that 'elbow_flexion' is of type Coordinate.

           .. code-block:: c++

               if (const Coordinate* found =
                       model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
                   std::cout << "Coordinate " << found.getName() << std::endl;
               }

           The search can be sped up considerably if the path or even partial path
           name is known. For example, "forearm/elbow/elbow_flexion" will find
           the Coordinate component of the elbow joint that connects the forearm body
           in linear time (linear search for name at each component level). Whereas
           supplying "elbow_flexion" requires a tree search. Returns nullptr (None in
           Python, empty array in Matlab) if Component of that specified name cannot
           be found.

           NOTE: If the component name is ambiguous, an exception is thrown. To
           disambiguate, more information must be provided, such as the template
           argument to specify the type and/or a path rather than just the name.

        |

        *Overload 2:*
        Same as findComponent(const ComponentPath&), but accepting a string (a
           path or just a name) as input.
        """
        return _common.ComponentIterator_findComponent(self, *args)

    def getComponentsList(self) -> "OpenSim::ComponentList< OpenSim::Component const >":
        r"""
        Get an iterator through the underlying subcomponents that this component is
        composed of. The hierarchy of Components/subComponents forms a tree.
        The order of the Components is that of tree preorder traversal so that a
        component is traversed before its subcomponents.

        .. code-block:: c++

            for (const auto& muscle : model.getComponentList<Muscle>()) {
                muscle.get_max_isometric_force();
            }

        The returned ComponentList does not permit modifying any components; if
        you want to modify the components, see updComponentList().

        :param T: A subclass of Component (e.g., Body, Muscle).
        """
        return _common.ComponentIterator_getComponentsList(self)

    def isEqualTo(self, aObject: "OpenSimObject") -> "bool":
        r"""
         End of conditional comment.
        Equality operator wrapper for use from languages not supporting operator
        overloading.
        """
        return _common.ComponentIterator_isEqualTo(self, aObject)

    def getName(self) -> "std::string const &":
        r""" Get the name of this Object."""
        return _common.ComponentIterator_getName(self)

    def getDescription(self) -> "std::string const &":
        r""" Get description, a one-liner summary."""
        return _common.ComponentIterator_getDescription(self)

    def getAuthors(self) -> "std::string const &":
        r""" Get Authors of this Object"""
        return _common.ComponentIterator_getAuthors(self)

    def getReferences(self) -> "std::string const &":
        r""" Get references or publications to cite if using this object."""
        return _common.ComponentIterator_getReferences(self)

    def getNumProperties(self) -> "int":
        r"""
        * Determine how many properties are stored with this %Object. These
            are numbered 0..n-1 in the order they were created. *
        """
        return _common.ComponentIterator_getNumProperties(self)

    def getPropertyByIndex(self, propertyIndex: "int") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its index number, returned as
           an AbstractProperty. *
        """
        return _common.ComponentIterator_getPropertyByIndex(self, propertyIndex)

    def hasProperty(self, name: "std::string const &") -> "bool":
        r"""
        Return true if this %Object has a property of any type with the
           given *name*, which must not be empty. *
        """
        return _common.ComponentIterator_hasProperty(self, name)

    def getPropertyByName(self, name: "std::string const &") -> "OpenSim::AbstractProperty const &":
        r"""
        Get a const reference to a property by its name, returned as
           an AbstractProperty. An exception is thrown if no property by this name
           is present in this %Object. *
        """
        return _common.ComponentIterator_getPropertyByName(self, name)

    def isObjectUpToDateWithProperties(self) -> "bool":
        r"""
        Returns ``true`` if no property's value has changed since the last time
           setObjectIsUpToDateWithProperties() was called. *
        """
        return _common.ComponentIterator_isObjectUpToDateWithProperties(self)

    def updateXMLNode(self, parent: "SimTK::Xml::Element &", prop: "AbstractProperty"=None) -> "void":
        r"""
        Serialize this object into the XML node that represents it.
           :type parent: SimTK::Xml::Element
           :param parent:
                   Parent XML node of this object. Sending in a parent node allows an XML
                   node to be generated for this object if it doesn't already have one. If
                   no parent node is supplied and this object doesn't already have an XML
                   node, this object will become the root node for a new XML document. If
                   this object already has an XML node associated with it, no new nodes
                   are ever generated and the parent node is not used.
           :type prop: :py:class:`AbstractProperty`, optional
           :param prop: (optional)
                   The pointer to the property that contains this object. If it is
                   present, check if the property is unnamed and if NOT, use the property
                   name as its name when updating the XML node. *
        """
        return _common.ComponentIterator_updateXMLNode(self, parent, prop)

    def getInlined(self) -> "bool":
        r"""
        Inlined means an in-memory Object that is not associated with
           an XMLDocument. *
        """
        return _common.ComponentIterator_getInlined(self)

    def getDocumentFileName(self) -> "std::string":
        r"""
        If there is a document associated with this object then return the
           file name maintained by the document. Otherwise return an empty string. *
        """
        return _common.ComponentIterator_getDocumentFileName(self)

    def getDocumentFileVersion(self) -> "int":
        r"""
        If there is a document associated with this object then return its
               version number. For example this is 30000 for OpenSim 3.x documents
               and is 305xx for OpenSim 4.0 beta and above. If there is no document
               associated with the object, the method returns -1.
        """
        return _common.ComponentIterator_getDocumentFileVersion(self)

    def printToXML(self, fileName: "std::string const &") -> "bool":
        r"""
        Write this %Object into an XML file of the given name; conventionally
           the suffix to use is ".osim". This is useful for writing out a Model that
           has been created programmatically, and also very useful for testing and
           debugging. If object has invalid connections, then printing is aborted.
           You can override this behavior by setting the debug level to at least 1
           (e.g., Object::setDebugLevel(1)) prior to printing. *
        """
        return _common.ComponentIterator_printToXML(self, fileName)

    def dump(self) -> "std::string":
        r"""
        dump the XML representation of this %Object into an std::string and return it.
           Mainly intended for debugging and for use by the XML browser in the GUI. *
        """
        return _common.ComponentIterator_dump(self)

    def isA(self, type: "char const *") -> "bool":
        r"""
        The default implementation returns true only if the supplied string
           is "Object"; each %Object-derived class overrides this to match its own
           class name. *
        """
        return _common.ComponentIterator_isA(self, type)

    def toString(self) -> "std::string const &":
        r"""
        Wrapper to be used on Java side to display objects in tree; this returns
           just the object's name. *
        """
        return _common.ComponentIterator_toString(self)

# Register ComponentIterator in _common:
_common.ComponentIterator_swigregister(ComponentIterator)

class Scale(OpenSimObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Scale *":
        return _common.Scale_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.Scale_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.Scale_getClassName()

    def clone(self) -> "OpenSim::Scale *":
        return _common.Scale_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.Scale_getConcreteClassName(self)

    def __init__(self, *args):
        _common.Scale_swiginit(self, _common.new_Scale(*args))
    __swig_destroy__ = _common.delete_Scale

    def getSegmentName(self) -> "std::string const &":
        return _common.Scale_getSegmentName(self)

    def setSegmentName(self, aSegmentName: "std::string const &") -> "void":
        return _common.Scale_setSegmentName(self, aSegmentName)

    def getScaleFactors(self, *args) -> "SimTK::Vec3 &":
        return _common.Scale_getScaleFactors(self, *args)

    def setScaleFactors(self, aScaleFactors: "Vec3") -> "void":
        return _common.Scale_setScaleFactors(self, aScaleFactors)

    def getApply(self) -> "bool":
        return _common.Scale_getApply(self)

    def setApply(self, state: "bool") -> "void":
        return _common.Scale_setApply(self, state)

# Register Scale in _common:
_common.Scale_swigregister(Scale)

def Scale_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Scale *":
    return _common.Scale_safeDownCast(obj)

def Scale_getClassName() -> "std::string const &":
    return _common.Scale_getClassName()

class SetScales(OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Scale,OpenSim::Object > *":
        return _common.SetScales_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.SetScales_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.SetScales_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Scale,OpenSim::Object > *":
        return _common.SetScales_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.SetScales_getConcreteClassName(self)
    __swig_destroy__ = _common.delete_SetScales

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Scale,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _common.SetScales_swiginit(self, _common.new_SetScales(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _common.SetScales_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _common.SetScales_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _common.SetScales_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _common.SetScales_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Scale`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _common.SetScales_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _common.SetScales_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Scale") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Scale`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.SetScales_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Scale") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Scale`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _common.SetScales_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Scale") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Scale`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _common.SetScales_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Scale`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _common.SetScales_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _common.SetScales_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Scale", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Scale`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _common.SetScales_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Scale &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Scale`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Scale`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _common.SetScales_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _common.SetScales_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _common.SetScales_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _common.SetScales_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _common.SetScales_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _common.SetScales_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _common.SetScales_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _common.SetScales_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _common.SetScales_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _common.SetScales_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetScales in _common:
_common.SetScales_swigregister(SetScales)

def SetScales_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Scale,OpenSim::Object > *":
    return _common.SetScales_safeDownCast(obj)

def SetScales_getClassName() -> "std::string const &":
    return _common.SetScales_getClassName()

class ScaleSet(SetScales):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScaleSet *":
        return _common.ScaleSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ScaleSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ScaleSet_getClassName()

    def clone(self) -> "OpenSim::ScaleSet *":
        return _common.ScaleSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ScaleSet_getConcreteClassName(self)

    def __init__(self, *args):
        _common.ScaleSet_swiginit(self, _common.new_ScaleSet(*args))
    __swig_destroy__ = _common.delete_ScaleSet

    def adoptAndAppend(self, aScale):
        aScale._markAdopted()
        return super(ScaleSet, self).adoptAndAppend(aScale)


# Register ScaleSet in _common:
_common.ScaleSet_swigregister(ScaleSet)

def ScaleSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScaleSet *":
    return _common.ScaleSet_safeDownCast(obj)

def ScaleSet_getClassName() -> "std::string const &":
    return _common.ScaleSet_getClassName()

class MarkerFrame(OpenSimObject):
    r"""
    A class implementing a frame of marker data from a TRC/TRB file.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerFrame *":
        return _common.MarkerFrame_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.MarkerFrame_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.MarkerFrame_getClassName()

    def clone(self) -> "OpenSim::MarkerFrame *":
        return _common.MarkerFrame_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.MarkerFrame_getConcreteClassName(self)

    def __init__(self, *args):
        _common.MarkerFrame_swiginit(self, _common.new_MarkerFrame(*args))
    __swig_destroy__ = _common.delete_MarkerFrame

    def addMarker(self, aCoords: "Vec3") -> "void":
        return _common.MarkerFrame_addMarker(self, aCoords)

    def getMarker(self, aIndex: "int") -> "SimTK::Vec3":
        return _common.MarkerFrame_getMarker(self, aIndex)

    def updMarker(self, aIndex: "int") -> "SimTK::Vec3 &":
        return _common.MarkerFrame_updMarker(self, aIndex)

    def getFrameNumber(self) -> "int":
        return _common.MarkerFrame_getFrameNumber(self)

    def setFrameNumber(self, aNumber: "int") -> "void":
        return _common.MarkerFrame_setFrameNumber(self, aNumber)

    def getFrameTime(self) -> "double":
        return _common.MarkerFrame_getFrameTime(self)

    def scale(self, aScaleFactor: "double") -> "void":
        return _common.MarkerFrame_scale(self, aScaleFactor)

    def getMarkers(self) -> "SimTK::Array_< SimTK::Vec3,unsigned int > const &":
        return _common.MarkerFrame_getMarkers(self)

# Register MarkerFrame in _common:
_common.MarkerFrame_swigregister(MarkerFrame)

def MarkerFrame_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerFrame *":
    return _common.MarkerFrame_safeDownCast(obj)

def MarkerFrame_getClassName() -> "std::string const &":
    return _common.MarkerFrame_getClassName()

class MarkerData(OpenSimObject):
    r"""
    A class implementing a sequence of marker frames from a TRC/TRB file.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerData *":
        return _common.MarkerData_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.MarkerData_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.MarkerData_getClassName()

    def clone(self) -> "OpenSim::MarkerData *":
        return _common.MarkerData_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.MarkerData_getConcreteClassName(self)

    def __init__(self, *args):
        _common.MarkerData_swiginit(self, _common.new_MarkerData(*args))
    __swig_destroy__ = _common.delete_MarkerData

    def findFrameRange(self, aStartTime: "double", aEndTime: "double", rStartFrame: "int &", rEndFrame: "int &") -> "void":
        return _common.MarkerData_findFrameRange(self, aStartTime, aEndTime, rStartFrame, rEndFrame)

    def averageFrames(self, *args) -> "void":
        return _common.MarkerData_averageFrames(self, *args)

    def getFileName(self) -> "std::string const &":
        return _common.MarkerData_getFileName(self)

    def makeRdStorage(self, rStorage: "Storage") -> "void":
        return _common.MarkerData_makeRdStorage(self, rStorage)

    def getFrame(self, aIndex: "int") -> "OpenSim::MarkerFrame const &":
        return _common.MarkerData_getFrame(self, aIndex)

    def getMarkerIndex(self, aName: "std::string const &") -> "int":
        return _common.MarkerData_getMarkerIndex(self, aName)

    def getUnits(self) -> "OpenSim::Units const &":
        return _common.MarkerData_getUnits(self)

    def convertToUnits(self, aUnits: "Units") -> "void":
        return _common.MarkerData_convertToUnits(self, aUnits)

    def getMarkerNames(self) -> "OpenSim::Array< std::string > const &":
        return _common.MarkerData_getMarkerNames(self)

    def getNumMarkers(self) -> "int":
        return _common.MarkerData_getNumMarkers(self)

    def getNumFrames(self) -> "int":
        return _common.MarkerData_getNumFrames(self)

    def getStartFrameTime(self) -> "double":
        return _common.MarkerData_getStartFrameTime(self)

    def getLastFrameTime(self) -> "double":
        return _common.MarkerData_getLastFrameTime(self)

    def getDataRate(self) -> "double":
        return _common.MarkerData_getDataRate(self)

    def getCameraRate(self) -> "double":
        return _common.MarkerData_getCameraRate(self)

# Register MarkerData in _common:
_common.MarkerData_swigregister(MarkerData)

def MarkerData_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerData *":
    return _common.MarkerData_safeDownCast(obj)

def MarkerData_getClassName() -> "std::string const &":
    return _common.MarkerData_getClassName()

class StdVectorMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdVectorMatrix_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _common.StdVectorMatrix___nonzero__(self)

    def __bool__(self) -> "bool":
        return _common.StdVectorMatrix___bool__(self)

    def __len__(self) -> "std::vector< SimTK::Matrix_< double > >::size_type":
        return _common.StdVectorMatrix___len__(self)

    def __getslice__(self, i: "std::vector< SimTK::Matrix_< double > >::difference_type", j: "std::vector< SimTK::Matrix_< double > >::difference_type") -> "std::vector< SimTK::Matrix_< double >,std::allocator< SimTK::Matrix_< double > > > *":
        return _common.StdVectorMatrix___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _common.StdVectorMatrix___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< SimTK::Matrix_< double > >::difference_type", j: "std::vector< SimTK::Matrix_< double > >::difference_type") -> "void":
        return _common.StdVectorMatrix___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _common.StdVectorMatrix___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SimTK::Matrix_< double > >::value_type const &":
        return _common.StdVectorMatrix___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _common.StdVectorMatrix___setitem__(self, *args)

    def pop(self) -> "std::vector< SimTK::Matrix_< double > >::value_type":
        return _common.StdVectorMatrix_pop(self)

    def append(self, x: "Matrix") -> "void":
        return _common.StdVectorMatrix_append(self, x)

    def empty(self) -> "bool":
        return _common.StdVectorMatrix_empty(self)

    def size(self) -> "std::vector< SimTK::Matrix_< double > >::size_type":
        return _common.StdVectorMatrix_size(self)

    def swap(self, v: "StdVectorMatrix") -> "void":
        return _common.StdVectorMatrix_swap(self, v)

    def begin(self) -> "std::vector< SimTK::Matrix_< double > >::iterator":
        return _common.StdVectorMatrix_begin(self)

    def end(self) -> "std::vector< SimTK::Matrix_< double > >::iterator":
        return _common.StdVectorMatrix_end(self)

    def rbegin(self) -> "std::vector< SimTK::Matrix_< double > >::reverse_iterator":
        return _common.StdVectorMatrix_rbegin(self)

    def rend(self) -> "std::vector< SimTK::Matrix_< double > >::reverse_iterator":
        return _common.StdVectorMatrix_rend(self)

    def clear(self) -> "void":
        return _common.StdVectorMatrix_clear(self)

    def get_allocator(self) -> "std::vector< SimTK::Matrix_< double > >::allocator_type":
        return _common.StdVectorMatrix_get_allocator(self)

    def pop_back(self) -> "void":
        return _common.StdVectorMatrix_pop_back(self)

    def erase(self, *args) -> "std::vector< SimTK::Matrix_< double > >::iterator":
        return _common.StdVectorMatrix_erase(self, *args)

    def __init__(self, *args):
        _common.StdVectorMatrix_swiginit(self, _common.new_StdVectorMatrix(*args))

    def push_back(self, x: "Matrix") -> "void":
        return _common.StdVectorMatrix_push_back(self, x)

    def front(self) -> "std::vector< SimTK::Matrix_< double > >::value_type const &":
        return _common.StdVectorMatrix_front(self)

    def back(self) -> "std::vector< SimTK::Matrix_< double > >::value_type const &":
        return _common.StdVectorMatrix_back(self)

    def assign(self, n: "std::vector< SimTK::Matrix_< double > >::size_type", x: "Matrix") -> "void":
        return _common.StdVectorMatrix_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _common.StdVectorMatrix_resize(self, *args)

    def insert(self, *args) -> "void":
        return _common.StdVectorMatrix_insert(self, *args)

    def reserve(self, n: "std::vector< SimTK::Matrix_< double > >::size_type") -> "void":
        return _common.StdVectorMatrix_reserve(self, n)

    def capacity(self) -> "std::vector< SimTK::Matrix_< double > >::size_type":
        return _common.StdVectorMatrix_capacity(self)
    __swig_destroy__ = _common.delete_StdVectorMatrix

# Register StdVectorMatrix in _common:
_common.StdVectorMatrix_swigregister(StdVectorMatrix)

class InvalidRow(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.InvalidRow_swiginit(self, _common.new_InvalidRow())
    __swig_destroy__ = _common.delete_InvalidRow

# Register InvalidRow in _common:
_common.InvalidRow_swigregister(InvalidRow)

class InvalidColumn(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.InvalidColumn_swiginit(self, _common.new_InvalidColumn())
    __swig_destroy__ = _common.delete_InvalidColumn

# Register InvalidColumn in _common:
_common.InvalidColumn_swigregister(InvalidColumn)

class InvalidColumnLabel(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.InvalidColumnLabel_swiginit(self, _common.new_InvalidColumnLabel())
    __swig_destroy__ = _common.delete_InvalidColumnLabel

# Register InvalidColumnLabel in _common:
_common.InvalidColumnLabel_swigregister(InvalidColumnLabel)

class IncorrectNumColumns(InvalidRow):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", expected: "size_t", received: "size_t"):
        _common.IncorrectNumColumns_swiginit(self, _common.new_IncorrectNumColumns(file, line, func, expected, received))
    __swig_destroy__ = _common.delete_IncorrectNumColumns

# Register IncorrectNumColumns in _common:
_common.IncorrectNumColumns_swigregister(IncorrectNumColumns)

class IncorrectNumRows(InvalidColumn):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", expected: "size_t", received: "size_t"):
        _common.IncorrectNumRows_swiginit(self, _common.new_IncorrectNumRows(file, line, func, expected, received))
    __swig_destroy__ = _common.delete_IncorrectNumRows

# Register IncorrectNumRows in _common:
_common.IncorrectNumRows_swigregister(IncorrectNumRows)

class RowIndexOutOfRange(IndexOutOfRange):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_RowIndexOutOfRange

# Register RowIndexOutOfRange in _common:
_common.RowIndexOutOfRange_swigregister(RowIndexOutOfRange)

class ColumnIndexOutOfRange(IndexOutOfRange):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_ColumnIndexOutOfRange

# Register ColumnIndexOutOfRange in _common:
_common.ColumnIndexOutOfRange_swigregister(ColumnIndexOutOfRange)

class MissingMetaData(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.MissingMetaData_swiginit(self, _common.new_MissingMetaData(file, line, func, key))
    __swig_destroy__ = _common.delete_MissingMetaData

# Register MissingMetaData in _common:
_common.MissingMetaData_swigregister(MissingMetaData)

class NoColumnLabels(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.NoColumnLabels_swiginit(self, _common.new_NoColumnLabels(file, line, func))
    __swig_destroy__ = _common.delete_NoColumnLabels

# Register NoColumnLabels in _common:
_common.NoColumnLabels_swigregister(NoColumnLabels)

class IncorrectMetaDataLength(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &", expected: "size_t", received: "size_t"):
        _common.IncorrectMetaDataLength_swiginit(self, _common.new_IncorrectMetaDataLength(file, line, func, key, expected, received))
    __swig_destroy__ = _common.delete_IncorrectMetaDataLength

# Register IncorrectMetaDataLength in _common:
_common.IncorrectMetaDataLength_swigregister(IncorrectMetaDataLength)

class EmptyTable(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.EmptyTable_swiginit(self, _common.new_EmptyTable(file, line, func))
    __swig_destroy__ = _common.delete_EmptyTable

# Register EmptyTable in _common:
_common.EmptyTable_swigregister(EmptyTable)

class KeyExists(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.KeyExists_swiginit(self, _common.new_KeyExists(file, line, func, key))
    __swig_destroy__ = _common.delete_KeyExists

# Register KeyExists in _common:
_common.KeyExists_swigregister(KeyExists)

class AbstractDataTable(object):
    r"""
     AbstractDataTable is the base-class of all DataTable_(templated) allowing
    storage of DataTable_ templated on different types to be stored in a container
    like std::vector. DataTable_ represents a matrix and an additional column. The
    columns of the matrix are dependent columns. The additional column is the
    independent column. All dependent columns and the independent column can have
    metadata. AbstractDataTable offers:
    - Interface to access metadata of independent column and dependent columns.
    - A heterogeneous container to store metadata associated with the DataTable_ in
      the form of key-value pairs where key is of type std::string and value can be
      of any type.

    This class is abstract and cannot be used directly. Create instances of
    DataTable_ instead. See DataTable_ for details on usage.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_AbstractDataTable

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Get number of components per element of the DataTable. See documentation
           for DataTable on possible return values.
        """
        return _common.AbstractDataTable_numComponentsPerElement(self)

    def getNumRows(self) -> "size_t":
        r""" Get number of rows."""
        return _common.AbstractDataTable_getNumRows(self)

    def getNumColumns(self) -> "size_t":
        r""" Get number of dependent columns."""
        return _common.AbstractDataTable_getNumColumns(self)

    def hasTableMetaDataKey(self, key: "std::string const &") -> "bool":
        r""" Whether or not table metadata for the given key exists."""
        return _common.AbstractDataTable_hasTableMetaDataKey(self, key)

    def getTableMetaDataAsString(self, key: "std::string const &") -> "std::string":
        r"""
        Get table metadata for a given key as a string.

           :raises: KeyNotFound If the key provided is not found in table metadata.
        """
        return _common.AbstractDataTable_getTableMetaDataAsString(self, key)

    def removeTableMetaDataKey(self, key: "std::string const &") -> "void":
        r"""
        Remove key-value pair associated with the given key from table
           metadata.
        """
        return _common.AbstractDataTable_removeTableMetaDataKey(self, key)

    def getTableMetaDataKeys(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r""" Get table metadata keys."""
        return _common.AbstractDataTable_getTableMetaDataKeys(self)

    def removeDependentsMetaDataForKey(self, key: "std::string const &") -> "void":
        r"""
        Remove key-value pair associated with the given key from dependents
           metadata.
        """
        return _common.AbstractDataTable_removeDependentsMetaDataForKey(self, key)

    def hasColumnLabels(self) -> "bool":
        r"""
        End of MetaData accessors/mutators.
        Following functions operate on column labels of dependent columns only
        excluding the independent column.
        Following are examples on using setColumnLabels(). If you have a
        sequence of strings, you can pretty much call setColumnLabels() on it.

        .. code-block:: c++

           Simplest way to set column labels is to provide them directly to
           setColumnLabels.
            table.setColumnLabels({"col1", "col2", "col3"});

        .. code-block:: c++

           if you have a sequence container like std::vector or std::list of
           std::string holding column labels, pass the container directly to
           setColumnLabels.
            std::list<std::string> columnLabels{"col1", "col2", "col3"};
            table.setColumnLabels(columnLabels);

        .. code-block:: c++

           If you have a sequence container like std::vector or std::list of
           std::string holding column labels but you want to use only a subset
           of them to set column labels of the table, use iterators like below.
            std::vector<std::string> columnLabels{"col-not-used1",
                                                  "col1", "col2", "col3",
                                                  "col-not-used2"};
            table.setColumnLabels(columnLabels.begin() + 1,
                                  columnLabels.end() - 1);
        Does the table have non-zero number of column labels.
        """
        return _common.AbstractDataTable_hasColumnLabels(self)

    def getColumnLabels(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get column labels.

           :raises: NoColumnLabels If column labels have not be set for the table.
        """
        return _common.AbstractDataTable_getColumnLabels(self)

    def getColumnLabel(self, columnIndex: "size_t const") -> "std::string const &":
        r"""
        Get column label of a given column.

           :raises: ColumnIndexOutOfRange If columnIndex is out of range of number of
                                             columns.
           :raises: NoColumnLabels If column labels have not be set for the table.
        """
        return _common.AbstractDataTable_getColumnLabel(self, columnIndex)

    def setColumnLabel(self, columnIndex: "size_t const", columnLabel: "std::string const &") -> "void":
        r"""
        %Set the label for a column.

           :raises: NoColumnLabels If table has no column labels.
           :raises: ColumnIndexOutOfRange If columnIndex is out of range for number of
                                             columns in the table.
        """
        return _common.AbstractDataTable_setColumnLabel(self, columnIndex, columnLabel)

    def getColumnIndex(self, columnLabel: "std::string const &") -> "size_t":
        r"""
        Get index of a column label.

           :raises: NoColumnLabels If table has no column labels.
           :raises: KeyNotFound If columnLabel is not found to be label for any column.
        """
        return _common.AbstractDataTable_getColumnIndex(self, columnLabel)

    def hasColumn(self, *args) -> "bool":
        r"""
        *Overload 1:*
        Check if the table has a column with the given label.

           :raises: NoColumnLabels If table has no column labels.

        |

        *Overload 2:*
        End of Column-labels related accessors/mutators. Check if the table has a column with the given index.
        """
        return _common.AbstractDataTable_hasColumn(self, *args)

    def setColumnLabels(self, columnLabels: "StdVectorString") -> "void":
        return _common.AbstractDataTable_setColumnLabels(self, columnLabels)

    def addTableMetaDataString(self, key: "std::string const &", value: "std::string const &") -> "void":
        return _common.AbstractDataTable_addTableMetaDataString(self, key, value)

    def getTableMetaDataVectorMatrix(self, key: "std::string const &") -> "std::vector< SimTK::Matrix_< double >,std::allocator< SimTK::Matrix_< double > > >":
        return _common.AbstractDataTable_getTableMetaDataVectorMatrix(self, key)

    def getTableMetaDataVectorUnsigned(self, key: "std::string const &") -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        return _common.AbstractDataTable_getTableMetaDataVectorUnsigned(self, key)

    def getTableMetaDataString(self, key: "std::string const &") -> "std::string":
        return _common.AbstractDataTable_getTableMetaDataString(self, key)

    def getDependentsMetaDataString(self, key: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        return _common.AbstractDataTable_getDependentsMetaDataString(self, key)

# Register AbstractDataTable in _common:
_common.AbstractDataTable_swigregister(AbstractDataTable)

class InvalidTable(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.InvalidTable_swiginit(self, _common.new_InvalidTable())
    __swig_destroy__ = _common.delete_InvalidTable

# Register InvalidTable in _common:
_common.InvalidTable_swigregister(InvalidTable)

class TimeColumnNotIncreasing(InvalidTable):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.TimeColumnNotIncreasing_swiginit(self, _common.new_TimeColumnNotIncreasing(file, line, func))
    __swig_destroy__ = _common.delete_TimeColumnNotIncreasing

# Register TimeColumnNotIncreasing in _common:
_common.TimeColumnNotIncreasing_swigregister(TimeColumnNotIncreasing)

class InvalidTimestamp(InvalidRow):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.InvalidTimestamp_swiginit(self, _common.new_InvalidTimestamp())
    __swig_destroy__ = _common.delete_InvalidTimestamp

# Register InvalidTimestamp in _common:
_common.InvalidTimestamp_swigregister(InvalidTimestamp)

class TimestampLessThanEqualToPrevious(InvalidTimestamp):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", rowIndex: "size_t", new_timestamp: "double", prev_timestamp: "double"):
        _common.TimestampLessThanEqualToPrevious_swiginit(self, _common.new_TimestampLessThanEqualToPrevious(file, line, func, rowIndex, new_timestamp, prev_timestamp))
    __swig_destroy__ = _common.delete_TimestampLessThanEqualToPrevious

# Register TimestampLessThanEqualToPrevious in _common:
_common.TimestampLessThanEqualToPrevious_swigregister(TimestampLessThanEqualToPrevious)

class TimestampGreaterThanEqualToNext(InvalidTimestamp):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", rowIndex: "size_t", new_timestamp: "double", next_timestamp: "double"):
        _common.TimestampGreaterThanEqualToNext_swiginit(self, _common.new_TimestampGreaterThanEqualToNext(file, line, func, rowIndex, new_timestamp, next_timestamp))
    __swig_destroy__ = _common.delete_TimestampGreaterThanEqualToNext

# Register TimestampGreaterThanEqualToNext in _common:
_common.TimestampGreaterThanEqualToNext_swigregister(TimestampGreaterThanEqualToNext)

class TimeOutOfRange(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", time: "double const", min: "double const", max: "double const"):
        _common.TimeOutOfRange_swiginit(self, _common.new_TimeOutOfRange(file, line, func, time, min, max))
    __swig_destroy__ = _common.delete_TimeOutOfRange

# Register TimeOutOfRange in _common:
_common.TimeOutOfRange_swigregister(TimeOutOfRange)

class InvalidTimeRange(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", begTime: "double const", endTime: "double const"):
        _common.InvalidTimeRange_swiginit(self, _common.new_InvalidTimeRange(file, line, func, begTime, endTime))
    __swig_destroy__ = _common.delete_InvalidTimeRange

# Register InvalidTimeRange in _common:
_common.InvalidTimeRange_swigregister(InvalidTimeRange)

class TableUtilities(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def checkNonUniqueLabels(labels: "StdVectorString") -> "void":
        r"""
        Throws an exception if the same label appears more than once in the list
        of labels.
        :raises: NonUniqueLabels
        """
        return _common.TableUtilities_checkNonUniqueLabels(labels)

    @staticmethod
    def isInDegrees(table: "TimeSeriesTable") -> "bool":
        r"""
        Returns true if the table contains 'inDegrees' metadata set to 'yes',
        and returns false if the table contains 'inDegrees' metadata set to
        'no'.
        :raises: Exception if table does not have 'inDegrees' table metadata.
        :raises: Exception if the 'inDegrees' metadata is neither 'yes' or 'no'.
        """
        return _common.TableUtilities_isInDegrees(table)

    @staticmethod
    def findStateLabelIndex(*args) -> "int":
        r"""
        *Overload 1:*
        Get the index in the provided array of labels that corresponds to the
        desired label. This function attempts to handle the change in
        state variable names that occurred in OpenSim version 4.0; for example,
        if you search for `<coord-name>/speed` and it is not found, then this
        function looks for `<coord-name>_u`. If you search for
        `<muscle>/activation` and it is not found, then this function looks for
        `<muscle>.activation`. This function returns -1 if the desired label is
        not found.

        |

        *Overload 2:*
        """
        return _common.TableUtilities_findStateLabelIndex(*args)

    @staticmethod
    def filterLowpass(table: "TimeSeriesTable", cutoffFreq: "double", padData: "bool"=False) -> "void":
        r"""
        Lowpass filter the data in a TimeSeriesTable at a provided cutoff
        frequency. If padData is true, then the data is first padded with pad()
        using numRowsToPrependAndAppend = table.getNumRows() / 2.
        The filtering is performed with Signal::LowpassIIR()
        """
        return _common.TableUtilities_filterLowpass(table, cutoffFreq, padData)

    @staticmethod
    def pad(table: "TimeSeriesTable", numRowsToPrependAndAppend: "int") -> "void":
        r"""
        Pad each column by the number of rows specified. The padded data is
        obtained by reflecting and negating the data in the table.
        Postcondition: the number of rows is table.getNumRows() + 2 *
        numRowsToPrependAndAppend.
        """
        return _common.TableUtilities_pad(table, numRowsToPrependAndAppend)

    @staticmethod
    def convertRotationsToEulerAngles(rotTable: "OpenSim::TimeSeriesTable_< SimTK::Rotation > const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 >":
        return _common.TableUtilities_convertRotationsToEulerAngles(rotTable)

    def __init__(self):
        _common.TableUtilities_swiginit(self, _common.new_TableUtilities())
    __swig_destroy__ = _common.delete_TableUtilities

# Register TableUtilities in _common:
_common.TableUtilities_swigregister(TableUtilities)

def TableUtilities_checkNonUniqueLabels(labels: "StdVectorString") -> "void":
    r"""
    Throws an exception if the same label appears more than once in the list
    of labels.
    :raises: NonUniqueLabels
    """
    return _common.TableUtilities_checkNonUniqueLabels(labels)

def TableUtilities_isInDegrees(table: "TimeSeriesTable") -> "bool":
    r"""
    Returns true if the table contains 'inDegrees' metadata set to 'yes',
    and returns false if the table contains 'inDegrees' metadata set to
    'no'.
    :raises: Exception if table does not have 'inDegrees' table metadata.
    :raises: Exception if the 'inDegrees' metadata is neither 'yes' or 'no'.
    """
    return _common.TableUtilities_isInDegrees(table)

def TableUtilities_findStateLabelIndex(*args) -> "int":
    r"""
    *Overload 1:*
    Get the index in the provided array of labels that corresponds to the
    desired label. This function attempts to handle the change in
    state variable names that occurred in OpenSim version 4.0; for example,
    if you search for `<coord-name>/speed` and it is not found, then this
    function looks for `<coord-name>_u`. If you search for
    `<muscle>/activation` and it is not found, then this function looks for
    `<muscle>.activation`. This function returns -1 if the desired label is
    not found.

    |

    *Overload 2:*
    """
    return _common.TableUtilities_findStateLabelIndex(*args)

def TableUtilities_filterLowpass(table: "TimeSeriesTable", cutoffFreq: "double", padData: "bool"=False) -> "void":
    r"""
    Lowpass filter the data in a TimeSeriesTable at a provided cutoff
    frequency. If padData is true, then the data is first padded with pad()
    using numRowsToPrependAndAppend = table.getNumRows() / 2.
    The filtering is performed with Signal::LowpassIIR()
    """
    return _common.TableUtilities_filterLowpass(table, cutoffFreq, padData)

def TableUtilities_pad(table: "TimeSeriesTable", numRowsToPrependAndAppend: "int") -> "void":
    r"""
    Pad each column by the number of rows specified. The padded data is
    obtained by reflecting and negating the data in the table.
    Postcondition: the number of rows is table.getNumRows() + 2 *
    numRowsToPrependAndAppend.
    """
    return _common.TableUtilities_pad(table, numRowsToPrependAndAppend)

def TableUtilities_convertRotationsToEulerAngles(rotTable: "OpenSim::TimeSeriesTable_< SimTK::Rotation > const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 >":
    return _common.TableUtilities_convertRotationsToEulerAngles(rotTable)

class DataTable(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTable

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTable_swiginit(self, _common.new_DataTable(*args))

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTable_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< double >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTable_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,double >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTable_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,double >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTable_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,double >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTable_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,double >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTable_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTable_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTable_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTable_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTable_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTable_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< double >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,double >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,double >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTable_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTable_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTable_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,double >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTable_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,double >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTable_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,double >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTable_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,double >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTable_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTable_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,double >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTable_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,double >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTable_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,double >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTable_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,double >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTable_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTable_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTable___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,double > *":
        return _common.DataTable_clone(self)

    def packVec3(self, *args) -> "OpenSim::DataTable_< double,SimTK::Vec3 >":
        return _common.DataTable_packVec3(self, *args)

    def packUnitVec3(self, *args) -> "OpenSim::DataTable_< double,SimTK::UnitVec3 >":
        return _common.DataTable_packUnitVec3(self, *args)

    def packQuaternion(self, *args) -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >":
        return _common.DataTable_packQuaternion(self, *args)

    def packSpatialVec(self, *args) -> "OpenSim::DataTable_< double,SimTK::SpatialVec >":
        return _common.DataTable_packSpatialVec(self, *args)

# Register DataTable in _common:
_common.DataTable_swigregister(DataTable)

class DataTableVec3(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableVec3

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableVec3_swiginit(self, _common.new_DataTableVec3(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableVec3_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableVec3_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Vec< 3,double,1 > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableVec3_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableVec3_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec3_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec3_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec3_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec3_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec3_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec3_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableVec3_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableVec3_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Vec< 3,double,1 > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableVec3_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec3_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableVec3_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableVec3_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableVec3_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableVec3_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableVec3_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableVec3_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableVec3_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableVec3_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableVec3_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 3,double,1 > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableVec3_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableVec3_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableVec3___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::Vec3 > *":
        return _common.DataTableVec3_clone(self)

# Register DataTableVec3 in _common:
_common.DataTableVec3_swigregister(DataTableVec3)

class DataTableUnitVec3(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableUnitVec3

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableUnitVec3_swiginit(self, _common.new_DataTableUnitVec3(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableUnitVec3_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableUnitVec3_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::UnitVec< double,1 > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableUnitVec3_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableUnitVec3_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableUnitVec3_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableUnitVec3_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableUnitVec3_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableUnitVec3_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableUnitVec3_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableUnitVec3_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableUnitVec3_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableUnitVec3_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::UnitVec< double,1 > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableUnitVec3_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableUnitVec3_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableUnitVec3_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableUnitVec3_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableUnitVec3_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableUnitVec3_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableUnitVec3_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableUnitVec3_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableUnitVec3_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableUnitVec3_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableUnitVec3_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::UnitVec< double,1 > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableUnitVec3_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableUnitVec3_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableUnitVec3___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::UnitVec3 > *":
        return _common.DataTableUnitVec3_clone(self)

# Register DataTableUnitVec3 in _common:
_common.DataTableUnitVec3_swigregister(DataTableUnitVec3)

class DataTableQuaternion(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableQuaternion

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableQuaternion_swiginit(self, _common.new_DataTableQuaternion(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableQuaternion_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableQuaternion_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Quaternion_< double > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableQuaternion_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableQuaternion_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableQuaternion_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableQuaternion_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableQuaternion_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableQuaternion_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableQuaternion_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableQuaternion_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableQuaternion_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableQuaternion_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Quaternion_< double > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableQuaternion_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableQuaternion_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableQuaternion_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableQuaternion_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableQuaternion_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableQuaternion_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableQuaternion_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableQuaternion_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableQuaternion_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableQuaternion_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableQuaternion_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableQuaternion_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableQuaternion_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableQuaternion___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::Quaternion_< double > > *":
        return _common.DataTableQuaternion_clone(self)

# Register DataTableQuaternion in _common:
_common.DataTableQuaternion_swigregister(DataTableQuaternion)

class DataTableVec6(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableVec6

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableVec6_swiginit(self, _common.new_DataTableVec6(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableVec6_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableVec6_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Vec< 6,double,1 > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableVec6_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableVec6_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec6_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec6_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec6_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec6_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableVec6_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec6_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableVec6_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableVec6_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Vec< 6,double,1 > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableVec6_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableVec6_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableVec6_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableVec6_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableVec6_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableVec6_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableVec6_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableVec6_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableVec6_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableVec6_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableVec6_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 6,double,1 > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableVec6_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableVec6_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableVec6___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::Vec6 > *":
        return _common.DataTableVec6_clone(self)

# Register DataTableVec6 in _common:
_common.DataTableVec6_swigregister(DataTableVec6)

class DataTableSpatialVec(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableSpatialVec

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableSpatialVec_swiginit(self, _common.new_DataTableSpatialVec(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableSpatialVec_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableSpatialVec_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Vec< 2,SimTK::Vec3,1 > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableSpatialVec_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableSpatialVec_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableSpatialVec_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableSpatialVec_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableSpatialVec_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableSpatialVec_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableSpatialVec_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableSpatialVec_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableSpatialVec_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableSpatialVec_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Vec< 2,SimTK::Vec3,1 > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableSpatialVec_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableSpatialVec_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableSpatialVec_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableSpatialVec_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableSpatialVec_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableSpatialVec_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableSpatialVec_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableSpatialVec_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableSpatialVec_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableSpatialVec_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableSpatialVec_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableSpatialVec_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableSpatialVec_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableSpatialVec___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::SpatialVec > *":
        return _common.DataTableSpatialVec_clone(self)

# Register DataTableSpatialVec in _common:
_common.DataTableSpatialVec_swigregister(DataTableSpatialVec)

class DataTableMat33(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableMat33

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableMat33_swiginit(self, _common.new_DataTableMat33(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableMat33_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableMat33_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Mat< 3,3,double,3,1 > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableMat33_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableMat33_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableMat33_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableMat33_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableMat33_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableMat33_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableMat33_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableMat33_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableMat33_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableMat33_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Mat< 3,3,double,3,1 > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableMat33_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableMat33_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableMat33_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableMat33_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableMat33_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableMat33_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableMat33_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableMat33_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableMat33_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableMat33_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableMat33_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Mat< 3,3,double,3,1 > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableMat33_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableMat33_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableMat33___str__(self)

# Register DataTableMat33 in _common:
_common.DataTableMat33_swigregister(DataTableMat33)

class DataTableRotation(AbstractDataTable):
    r"""
     DataTable_ is an in-memory storage container for data with support for
    holding metadata (using the base class AbstractDataTable). Data contains an
    independent column and a set of dependent columns. The type of the independent
    column can be configured using ETX (template param). The type of the dependent
    columns, which together form a matrix, can be configured using ETY (template
    param). Independent and dependent columns can contain metadata. DataTable_ as a
    whole can contain metadata.

    :param ETX: Type of each element of the column holding independent data.
    :param ETY: Type of each element of the underlying matrix holding dependent
                    data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_DataTableRotation

    def __init__(self, *args):
        r"""
        Construct DataTable_ from a file.

           :type filename: string
           :param filename: Name of the file. File should contain only one table. For
                               example, trc, csv & sto files contain one table whereas a
                               c3d file can contain more than.
           :type tablename: string
           :param tablename: Name of the table in file to construct this DataTable_
                                from. For example, a c3d file contains tables named
                                'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this DataTable_ type.
        """
        _common.DataTableRotation_swiginit(self, _common.new_DataTableRotation(*args))

    def flatten(self, *args) -> "OpenSim::DataTable_< double,double >":
        r"""
        *Overload 1:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be suffixed "_1", "_2", "_3" and so on. See
           documentation for constructor DataTable_::DataTable_().

        |

        *Overload 2:*
        Flatten the columns of this table to create a
           DataTable_<double, double>. Each column will be split into its
           constituent components. For example, each column of a
           DataTable_<double, Vec3> will be split into 3 columns. The column-labels of
           the resulting columns will be appended with 'suffixes' provided. See
           documentation for constructor DataTable_::DataTable_().
        """
        return _common.DataTableRotation_flatten(self, *args)

    def numComponentsPerElement(self) -> "unsigned int":
        r"""
        Retrieve the number of components each element (of type ETY) of the
           table is made of. Some examples:

           Table Type                    | Element Type | Num of Components
           ------------------------------|--------------|------------------
           DataTable<double, double>     | double       | 1
           DataTable<double, Vec3>       | Vec3         | 3
           DataTable<double, Quaternion> | Quaternion   | 4
        """
        return _common.DataTableRotation_numComponentsPerElement(self)

    def appendRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append row to the DataTable_.

           :type indRow: float
           :param indRow: Entry for the independent column corresponding to the row to
                             be appended.
           :type container: std::initializer_list< SimTK::Rotation_< double > >
           :param container: std::initializer_list containing elements of the row to be
                                appended.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 2:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.

        |

        *Overload 3:*
        Append row to the DataTable_.

           :raises: IncorrectNumColumns If the row added is invalid. Validity of the
               row added is decided by the derived class.
        """
        return _common.DataTableRotation_appendRow(self, *args)

    def getRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::RowVectorView const":
        r"""
        Get row at index.

           :raises: RowIndexOutOfRange If index is out of range.
        """
        return _common.DataTableRotation_getRowAtIndex(self, index)

    def getRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::RowVectorView const":
        r"""
        Get row corresponding to the given entry in the independent column. This
           function searches the independent column for exact equality, which may not
           be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::getNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableRotation_getRow(self, ind)

    def updRowAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::RowVectorView":
        r"""
        Update row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableRotation_updRowAtIndex(self, index)

    def updRow(self, ind: "double const &") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::RowVectorView":
        r"""
        Update row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableRotation_updRow(self, ind)

    def setRowAtIndex(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.

        |

        *Overload 2:*
        Set row at index. Equivalent to
           ```
           updRowAtIndex(index) = depRow;
           ```

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableRotation_setRowAtIndex(self, *args)

    def setRow(self, *args) -> "void":
        r"""
        *Overload 1:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.

        |

        *Overload 2:*
        Set row corresponding to the given entry in the independent column.
           This function searches the independent column for exact equality, which may
           not be appropriate if `ETX` is of type `double`. See
           TimeSeriesTable_::updNearestRow().
           Equivalent to
           ```
           updRow(ind) = depRow;
           ```

           :raises: KeyNotFound If the independent column has no entry with given
                                   value.
        """
        return _common.DataTableRotation_setRow(self, *args)

    def removeRowAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove row at index.

           :raises: RowIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableRotation_removeRowAtIndex(self, index)

    def removeRow(self, ind: "double const &") -> "void":
        r"""
        Remove row corresponding to the given entry in the independent column.

           :raises: KeyNotFound If the independent column has no entry with the given
                                   value.
        """
        return _common.DataTableRotation_removeRow(self, ind)

    def getIndependentColumn(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""
        End of Row accessors/mutators.
        Get independent column.
        """
        return _common.DataTableRotation_getIndependentColumn(self)

    def appendColumn(self, *args) -> "void":
        r"""
        *Overload 1:*
        Append column to the DataTable_ using an initializer list.

           .. code-block:: c++

               table.appendColumn("new-column", {1, 2, 3, 4});

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type container: std::initializer_list< SimTK::Rotation_< double > >
           :param container: Sequence container holding the elements of the column to be
                                appended.
           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 2:*
        Append column to the DataTable_ using a SimTK::Vector.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Rotation_< double > >::Vector
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.

        |

        *Overload 3:*
        Append column to the DataTable_ using a SimTK::VectorView.

           :type columnLabel: string
           :param columnLabel: Label of the column to be added. Must not be same as the
                                  label of an existing column.
           :type depCol: OpenSim::DataTable_< double,SimTK::Rotation_< double > >::VectorView
           :param depCol: Column vector to be appended to the table.

           :raises: InvalidCall If DataTable_ contains no rows at the time of this call.
           :raises: InvalidArgument If columnLabel specified already exists in the
                                       DataTable_.
           :raises: InvalidColumn If the input column contains incorrect number of
                                     rows.
        """
        return _common.DataTableRotation_appendColumn(self, *args)

    def removeColumnAtIndex(self, index: "size_t") -> "void":
        r"""
        Remove column corresponding to the given column index.

           :raises: ColumnIndexOutOfRange If the index is out of range.
        """
        return _common.DataTableRotation_removeColumnAtIndex(self, index)

    def removeColumn(self, columnLabel: "std::string const &") -> "void":
        r"""
        Remove column corresponding to the given dependent column label. The
           independent column cannot be removed.

           :raises: KeyNotFound If the independent column has no entry with the given
               value.
        """
        return _common.DataTableRotation_removeColumn(self, columnLabel)

    def getDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::VectorView":
        r"""
        Get dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableRotation_getDependentColumnAtIndex(self, index)

    def getDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::VectorView":
        r"""
        Get dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableRotation_getDependentColumn(self, columnLabel)

    def updDependentColumnAtIndex(self, index: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::VectorView":
        r"""
        Update dependent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: ColumnIndexOutOfRange If index is out of range for number of columns
                                             in the table.
        """
        return _common.DataTableRotation_updDependentColumnAtIndex(self, index)

    def updDependentColumn(self, columnLabel: "std::string const &") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::VectorView":
        r"""
        Update dependent Column which has the given column label.

           :raises: KeyNotFound If columnLabel is not found to be label of any existing
                                   column.
        """
        return _common.DataTableRotation_updDependentColumn(self, columnLabel)

    def setIndependentValueAtIndex(self, rowIndex: "size_t", value: "double const &") -> "void":
        r"""
        %Set value of the independent column at index.

           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If rowIndex is out of range.
           :raises: InvalidRow If this operation invalidates the row. Validation is
                                  performed by derived classes.
        """
        return _common.DataTableRotation_setIndependentValueAtIndex(self, rowIndex, value)

    def getMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::MatrixView const &":
        r"""
        Following functions operate on the matrix not including the independent
        column.
        Get a read-only view to the underlying matrix.
        """
        return _common.DataTableRotation_getMatrix(self)

    def getMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::MatrixView":
        r"""
        Get a read-only view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableRotation_getMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def updMatrix(self) -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::MatrixView &":
        r""" Get a writable view to the underlying matrix."""
        return _common.DataTableRotation_updMatrix(self)

    def updMatrixBlock(self, rowStart: "size_t", columnStart: "size_t", numRows: "size_t", numColumns: "size_t") -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > >::MatrixView":
        r"""
        Get a writable view of a block of the underlying matrix.

           :raises: InvalidArgument If numRows or numColumns is zero.
           :raises: EmptyTable If the table is empty.
           :raises: RowIndexOutOfRange If one or more rows of the desired block is out
                                          of range of the matrix.
           :raises: ColumnIndexOutOfRange If one or more columns of the desired block is
                                             out of range of the matrix.
        """
        return _common.DataTableRotation_updMatrixBlock(self, rowStart, columnStart, numRows, numColumns)

    def toString(self, *args) -> "std::string":
        r"""
        Get a string representation of the table, including the key-value pairs
           in the table metadata. Table metadata will be of the form:

           .. code-block:: c++

               key => value-converted-to-string
           For example:

           .. code-block:: c++

               DataRate => 2000.00000
               Units => mm
           For values in the table metadata that do not support the operation of stream
           insertion (operator<<), the value for metadata will be:

           .. code-block:: c++

               key => <cannot-convert-to-string>
           Some examples to call this function:

           .. code-block:: c++

           All rows, all columns.
               auto tableAsString = table.toString();
           First 5 rows, all columns.
               auto tableAsString = table.toString({0, 1, 2, 3, 4});
           All rows, 3 columns with specified labels.
               auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
           Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in
           that order).
               auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
           Lets say the table has 10 rows. Following will get last 3 rows in the
           order specified. All columns.
               auto tableAsString = table.toString({-1, -2, -3})

           :type rows: std::vector< int,std::allocator< int > >, optional
           :param rows: **[Default = all rows]** Sequence of indices of rows to be
                           printed. Rows will be printed exactly in the order specified in
                           the sequence. Index begins at 0 (i.e. first row is 0). Negative
                           indices refer to rows starting from last row. Index -1 refers to
                           last row, -2 refers to row previous to last row and so on.
                           Default behavior is to print all rows.
           :type columnLabels: std::vector< std::string,std::allocator< std::string > >, optional
           :param columnLabels: **[Default = all rows]** Sequence of labels of columns
                                   to be printed. Columns will be printed exactly in the
                                   order specified in the sequence. Default behavior is to
                                   print all columns.
           :type withMetaData: boolean, optional
           :param withMetaData: **[Default = true]** Whether or not table metadata
                                   should be printed. Default behavior is to print table
                                   metadata.
           :type splitSize: int, optional
           :param splitSize: **[Default = 25]** Number of rows to print at a time.
                                Default behavior is to print 25 rows at a time.
           :type maxWidth: int, optional
           :param maxWidth: **[Default = 80]** Maximum number of characters to print per
                               line. The columns are split accordingly to make the table
                               readable. This is useful in terminals/consoles with narrow
                               width. Default behavior is to limit number characters per
                               line to 80.
           :type precision: int, optional
           :param precision: **[Default = 4]** Precision of the floating-point numbers
                                printed. Default behavior is to print floating-point
                                numbers with 4 places to the right of decimal point.
        """
        return _common.DataTableRotation_toString(self, *args)

    def __str__(self) -> "std::string":
        return _common.DataTableRotation___str__(self)

    def clone(self) -> "OpenSim::DataTable_< double,SimTK::Rotation_< double > > *":
        return _common.DataTableRotation_clone(self)

# Register DataTableRotation in _common:
_common.DataTableRotation_swigregister(DataTableRotation)

class TimeSeriesTable(DataTable):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTable

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTable_swiginit(self, _common.new_TimeSeriesTable(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTable_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTable_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTable_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< double >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTable_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< double >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTable_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< double >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTable_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTable_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTable_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTable_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< double > *":
        return _common.TimeSeriesTable_clone(self)

    def packVec3(self, *args) -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 >":
        return _common.TimeSeriesTable_packVec3(self, *args)

    def packUnitVec3(self, *args) -> "OpenSim::TimeSeriesTable_< SimTK::UnitVec3 >":
        return _common.TimeSeriesTable_packUnitVec3(self, *args)

    def packQuaternion(self, *args) -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >":
        return _common.TimeSeriesTable_packQuaternion(self, *args)

    def packSpatialVec(self, *args) -> "OpenSim::TimeSeriesTable_< SimTK::SpatialVec >":
        return _common.TimeSeriesTable_packSpatialVec(self, *args)

# Register TimeSeriesTable in _common:
_common.TimeSeriesTable_swigregister(TimeSeriesTable)

class TimeSeriesTableVec3(DataTableVec3):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableVec3

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableVec3_swiginit(self, _common.new_TimeSeriesTableVec3(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec3_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableVec3_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableVec3_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec3_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec3_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableVec3_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableVec3_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableVec3_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableVec3_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > > *":
        return _common.TimeSeriesTableVec3_clone(self)

    def flatten(self, *args) -> "OpenSim::TimeSeriesTable_< double >":
        return _common.TimeSeriesTableVec3_flatten(self, *args)

# Register TimeSeriesTableVec3 in _common:
_common.TimeSeriesTableVec3_swigregister(TimeSeriesTableVec3)

class TimeSeriesTableUnitVec3(DataTableUnitVec3):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableUnitVec3

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableUnitVec3_swiginit(self, _common.new_TimeSeriesTableUnitVec3(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableUnitVec3_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableUnitVec3_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableUnitVec3_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::UnitVec< double,1 > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableUnitVec3_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::UnitVec< double,1 > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableUnitVec3_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::UnitVec< double,1 > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableUnitVec3_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableUnitVec3_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableUnitVec3_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableUnitVec3_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::UnitVec< double,1 > > *":
        return _common.TimeSeriesTableUnitVec3_clone(self)

    def flatten(self, *args) -> "OpenSim::TimeSeriesTable_< double >":
        return _common.TimeSeriesTableUnitVec3_flatten(self, *args)

# Register TimeSeriesTableUnitVec3 in _common:
_common.TimeSeriesTableUnitVec3_swigregister(TimeSeriesTableUnitVec3)

class TimeSeriesTableQuaternion(DataTableQuaternion):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableQuaternion

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableQuaternion_swiginit(self, _common.new_TimeSeriesTableQuaternion(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableQuaternion_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableQuaternion_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableQuaternion_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableQuaternion_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableQuaternion_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableQuaternion_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableQuaternion_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableQuaternion_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableQuaternion_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > > *":
        return _common.TimeSeriesTableQuaternion_clone(self)

# Register TimeSeriesTableQuaternion in _common:
_common.TimeSeriesTableQuaternion_swigregister(TimeSeriesTableQuaternion)

class TimeSeriesTableVec6(DataTableVec6):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableVec6

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableVec6_swiginit(self, _common.new_TimeSeriesTableVec6(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec6_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableVec6_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableVec6_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 6,double,1 > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec6_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 6,double,1 > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableVec6_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 6,double,1 > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableVec6_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableVec6_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableVec6_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableVec6_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 6,double,1 > > *":
        return _common.TimeSeriesTableVec6_clone(self)

    def flatten(self, *args) -> "OpenSim::TimeSeriesTable_< double >":
        return _common.TimeSeriesTableVec6_flatten(self, *args)

# Register TimeSeriesTableVec6 in _common:
_common.TimeSeriesTableVec6_swigregister(TimeSeriesTableVec6)

class TimeSeriesTableSpatialVec(DataTableSpatialVec):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableSpatialVec

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableSpatialVec_swiginit(self, _common.new_TimeSeriesTableSpatialVec(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableSpatialVec_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableSpatialVec_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableSpatialVec_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableSpatialVec_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableSpatialVec_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableSpatialVec_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableSpatialVec_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableSpatialVec_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableSpatialVec_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec3,1 > > *":
        return _common.TimeSeriesTableSpatialVec_clone(self)

    def flatten(self, *args) -> "OpenSim::TimeSeriesTable_< double >":
        return _common.TimeSeriesTableSpatialVec_flatten(self, *args)

# Register TimeSeriesTableSpatialVec in _common:
_common.TimeSeriesTableSpatialVec_swigregister(TimeSeriesTableSpatialVec)

class TimeSeriesTableMat33(DataTableMat33):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableMat33

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableMat33_swiginit(self, _common.new_TimeSeriesTableMat33(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableMat33_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableMat33_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableMat33_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Mat< 3,3,double,3,1 > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableMat33_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Mat< 3,3,double,3,1 > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableMat33_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Mat< 3,3,double,3,1 > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableMat33_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableMat33_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableMat33_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableMat33_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Mat< 3,3,double,3,1 > > *":
        return _common.TimeSeriesTableMat33_clone(self)

# Register TimeSeriesTableMat33 in _common:
_common.TimeSeriesTableMat33_swigregister(TimeSeriesTableMat33)

class TimeSeriesTableRotation(DataTableRotation):
    r"""
     TimeSeriesTable_ is a DataTable_ where the independent column is time of
    type double. The time column is enforced to be strictly increasing.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_TimeSeriesTableRotation

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Convenience constructor to efficiently populate a time series table
           from available data. This is primarily useful for constructing with large
           data read in from file without having to reallocate and copy memory.

        |

        *Overload 2:*
        Construct a table with only the independent (time) column and 0
           dependent columns. This constructor is useful if you want to populate the
           table by appending columns rather than by appending rows.

        |

        *Overload 3:*
        Construct a TimeSeriesTable_ from a DataTable_.

           :raises: InvalidTable If the input table's independent column is not strictly
                                    increasing.

        |

        *Overload 4:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: InvalidArgument If the input file contains more than one table.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.

        |

        *Overload 5:*
        Construct TimeSeriesTable_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct this
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidArgument If the input file contains more than one table and
                                       tablename was not specified.
           :raises: InvalidArgument If the input file contains a table that is not of
                                       this TimeSeriesTable_ type.
        """
        _common.TimeSeriesTableRotation_swiginit(self, _common.new_TimeSeriesTableRotation(*args))

    def getNearestRowIndexForTime(self, time: "double const", restrictToTimeRange: "bool const"=True) -> "size_t":
        r"""
        Get index of row whose time is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange:  When true -- Exception is thrown if the given
                                           value is out-of-range of the time column. A value
                                           within SimTK::SignifcantReal of a time column
                                           bound is considered to be equal to the bound.
                                           When false -- If the given value is less than or
                                           equal to the first value in the time column, the
                                           index returned is of the first row. If the given
                                           value is greater than or equal to the last value
                                           in the time column, the index of the last row is
                                           returned. Defaults to 'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableRotation_getNearestRowIndexForTime(self, time, restrictToTimeRange)

    def getRowIndexAfterTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is first to be higher than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableRotation_getRowIndexAfterTime(self, time)

    def getRowIndexBeforeTime(self, time: "double const &") -> "size_t":
        r"""
        Get index of row whose time is the largest time less than the given value.

            :type time: float
            :param time: Value to search for.
        """
        return _common.TimeSeriesTableRotation_getRowIndexBeforeTime(self, time)

    def getNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > >::RowVectorView":
        r"""
        Get row whose time column is nearest/closest to the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableRotation_getNearestRow(self, time, restrictToTimeRange)

    def updNearestRow(self, time: "double const &", restrictToTimeRange: "bool const"=True) -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > >::RowVectorView":
        r"""
        Get writable reference to row whose time column is nearest/closest to
           the given value.

           :type time: float
           :param time: Value to search for.
           :type restrictToTimeRange: boolean, optional
           :param restrictToTimeRange: When true -- Exception is thrown if the given
                                          value is out-of-range of the time column.
                                          When false -- If the given value is less than or
                                          equal to the first value in the time column, the
                                          row returned is the first row. If the given value
                                          is greater than or equal to the last value in the
                                          time column, the row returned is the last row.
                                          This operation only returns existing rows and
                                          does not perform any interpolation. Defaults to
                                          'true'.

           :raises: TimeOutOfRange If the given value is out-of-range of time column.
           :raises: EmptyTable If the table is empty.
        """
        return _common.TimeSeriesTableRotation_updNearestRow(self, time, restrictToTimeRange)

    def averageRow(self, beginTime: "double const &", endTime: "double const &") -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > >::RowVector":
        r"""
        Compute the average row in the time range (inclusive) given. This
           operation does not modify the table. It just computes and returns an average
           row.

           :raises: InvalidTimeRange If beginTime is greater than or equal to endTime.
           :raises: TimeOutOfRange If beginTime or endTime is out of range of time
                                      column.
        """
        return _common.TimeSeriesTableRotation_averageRow(self, beginTime, endTime)

    def trim(self, newStartTime: "double const &", newFinalTime: "double const &") -> "void":
        r"""
        Trim TimeSeriesTable to rows that have times that lies between
        newStartTime, newFinalTime. The trimming is done in place, no copy is made.
        Uses getRowIndexAfterTime to locate first row and
        getNearestRowIndexForTime method to locate last row.
        """
        return _common.TimeSeriesTableRotation_trim(self, newStartTime, newFinalTime)

    def trimFrom(self, newStartTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows at newStartTime to the end."""
        return _common.TimeSeriesTableRotation_trimFrom(self, newStartTime)

    def trimTo(self, newFinalTime: "double const &") -> "void":
        r"""trim TimeSeriesTable, keeping rows up to newFinalTime"""
        return _common.TimeSeriesTableRotation_trimTo(self, newFinalTime)

    def clone(self) -> "OpenSim::TimeSeriesTable_< SimTK::Rotation_< double > > *":
        return _common.TimeSeriesTableRotation_clone(self)

# Register TimeSeriesTableRotation in _common:
_common.TimeSeriesTableRotation_swigregister(TimeSeriesTableRotation)

class Event(object):
    r""" Struct representing an event extracted from a C3D file."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    label = property(_common.Event_label_get, _common.Event_label_set)
    time = property(_common.Event_time_get, _common.Event_time_set)
    frame = property(_common.Event_frame_get, _common.Event_frame_set)
    description = property(_common.Event_description_get, _common.Event_description_set)

    def __init__(self):
        _common.Event_swiginit(self, _common.new_Event())
    __swig_destroy__ = _common.delete_Event

# Register Event in _common:
_common.Event_swigregister(Event)

class StdVectorEvent(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdVectorEvent_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _common.StdVectorEvent___nonzero__(self)

    def __bool__(self) -> "bool":
        return _common.StdVectorEvent___bool__(self)

    def __len__(self) -> "std::vector< OpenSim::Event >::size_type":
        return _common.StdVectorEvent___len__(self)

    def __getslice__(self, i: "std::vector< OpenSim::Event >::difference_type", j: "std::vector< OpenSim::Event >::difference_type") -> "std::vector< OpenSim::Event,std::allocator< OpenSim::Event > > *":
        return _common.StdVectorEvent___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _common.StdVectorEvent___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< OpenSim::Event >::difference_type", j: "std::vector< OpenSim::Event >::difference_type") -> "void":
        return _common.StdVectorEvent___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _common.StdVectorEvent___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< OpenSim::Event >::value_type const &":
        return _common.StdVectorEvent___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _common.StdVectorEvent___setitem__(self, *args)

    def pop(self) -> "std::vector< OpenSim::Event >::value_type":
        return _common.StdVectorEvent_pop(self)

    def append(self, x: "Event") -> "void":
        return _common.StdVectorEvent_append(self, x)

    def empty(self) -> "bool":
        return _common.StdVectorEvent_empty(self)

    def size(self) -> "std::vector< OpenSim::Event >::size_type":
        return _common.StdVectorEvent_size(self)

    def swap(self, v: "StdVectorEvent") -> "void":
        return _common.StdVectorEvent_swap(self, v)

    def begin(self) -> "std::vector< OpenSim::Event >::iterator":
        return _common.StdVectorEvent_begin(self)

    def end(self) -> "std::vector< OpenSim::Event >::iterator":
        return _common.StdVectorEvent_end(self)

    def rbegin(self) -> "std::vector< OpenSim::Event >::reverse_iterator":
        return _common.StdVectorEvent_rbegin(self)

    def rend(self) -> "std::vector< OpenSim::Event >::reverse_iterator":
        return _common.StdVectorEvent_rend(self)

    def clear(self) -> "void":
        return _common.StdVectorEvent_clear(self)

    def get_allocator(self) -> "std::vector< OpenSim::Event >::allocator_type":
        return _common.StdVectorEvent_get_allocator(self)

    def pop_back(self) -> "void":
        return _common.StdVectorEvent_pop_back(self)

    def erase(self, *args) -> "std::vector< OpenSim::Event >::iterator":
        return _common.StdVectorEvent_erase(self, *args)

    def __init__(self, *args):
        _common.StdVectorEvent_swiginit(self, _common.new_StdVectorEvent(*args))

    def push_back(self, x: "Event") -> "void":
        return _common.StdVectorEvent_push_back(self, x)

    def front(self) -> "std::vector< OpenSim::Event >::value_type const &":
        return _common.StdVectorEvent_front(self)

    def back(self) -> "std::vector< OpenSim::Event >::value_type const &":
        return _common.StdVectorEvent_back(self)

    def assign(self, n: "std::vector< OpenSim::Event >::size_type", x: "Event") -> "void":
        return _common.StdVectorEvent_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _common.StdVectorEvent_resize(self, *args)

    def insert(self, *args) -> "void":
        return _common.StdVectorEvent_insert(self, *args)

    def reserve(self, n: "std::vector< OpenSim::Event >::size_type") -> "void":
        return _common.StdVectorEvent_reserve(self, n)

    def capacity(self) -> "std::vector< OpenSim::Event >::size_type":
        return _common.StdVectorEvent_capacity(self)
    __swig_destroy__ = _common.delete_StdVectorEvent

# Register StdVectorEvent in _common:
_common.StdVectorEvent_swigregister(StdVectorEvent)

class StdMapStringDataAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringDataAdapter_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _common.StdMapStringDataAdapter___nonzero__(self)

    def __bool__(self) -> "bool":
        return _common.StdMapStringDataAdapter___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::size_type":
        return _common.StdMapStringDataAdapter___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::mapped_type const &":
        return _common.StdMapStringDataAdapter___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "void":
        return _common.StdMapStringDataAdapter___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "bool":
        return _common.StdMapStringDataAdapter_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _common.StdMapStringDataAdapter_keys(self)

    def values(self) -> "PyObject *":
        return _common.StdMapStringDataAdapter_values(self)

    def items(self) -> "PyObject *":
        return _common.StdMapStringDataAdapter_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "bool":
        return _common.StdMapStringDataAdapter___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringDataAdapter_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringDataAdapter_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _common.StdMapStringDataAdapter___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _common.StdMapStringDataAdapter_asdict(self)

    def __init__(self, *args):
        _common.StdMapStringDataAdapter_swiginit(self, _common.new_StdMapStringDataAdapter(*args))

    def empty(self) -> "bool":
        return _common.StdMapStringDataAdapter_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::size_type":
        return _common.StdMapStringDataAdapter_size(self)

    def swap(self, v: "StdMapStringDataAdapter") -> "void":
        return _common.StdMapStringDataAdapter_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::iterator":
        return _common.StdMapStringDataAdapter_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::iterator":
        return _common.StdMapStringDataAdapter_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::reverse_iterator":
        return _common.StdMapStringDataAdapter_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::reverse_iterator":
        return _common.StdMapStringDataAdapter_rend(self)

    def clear(self) -> "void":
        return _common.StdMapStringDataAdapter_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::allocator_type":
        return _common.StdMapStringDataAdapter_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::size_type":
        return _common.StdMapStringDataAdapter_count(self, x)

    def erase(self, *args) -> "void":
        return _common.StdMapStringDataAdapter_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::iterator":
        return _common.StdMapStringDataAdapter_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::iterator":
        return _common.StdMapStringDataAdapter_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::DataAdapter > >::iterator":
        return _common.StdMapStringDataAdapter_upper_bound(self, x)
    __swig_destroy__ = _common.delete_StdMapStringDataAdapter

# Register StdMapStringDataAdapter in _common:
_common.StdMapStringDataAdapter_swigregister(StdMapStringDataAdapter)

class StdMapStringAbstractDataTable(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringAbstractDataTable_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _common.StdMapStringAbstractDataTable___nonzero__(self)

    def __bool__(self) -> "bool":
        return _common.StdMapStringAbstractDataTable___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::size_type":
        return _common.StdMapStringAbstractDataTable___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::mapped_type const &":
        return _common.StdMapStringAbstractDataTable___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "void":
        return _common.StdMapStringAbstractDataTable___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "bool":
        return _common.StdMapStringAbstractDataTable_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _common.StdMapStringAbstractDataTable_keys(self)

    def values(self) -> "PyObject *":
        return _common.StdMapStringAbstractDataTable_values(self)

    def items(self) -> "PyObject *":
        return _common.StdMapStringAbstractDataTable_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "bool":
        return _common.StdMapStringAbstractDataTable___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringAbstractDataTable_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _common.StdMapStringAbstractDataTable_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _common.StdMapStringAbstractDataTable___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _common.StdMapStringAbstractDataTable_asdict(self)

    def __init__(self, *args):
        _common.StdMapStringAbstractDataTable_swiginit(self, _common.new_StdMapStringAbstractDataTable(*args))

    def empty(self) -> "bool":
        return _common.StdMapStringAbstractDataTable_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::size_type":
        return _common.StdMapStringAbstractDataTable_size(self)

    def swap(self, v: "StdMapStringAbstractDataTable") -> "void":
        return _common.StdMapStringAbstractDataTable_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::iterator":
        return _common.StdMapStringAbstractDataTable_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::iterator":
        return _common.StdMapStringAbstractDataTable_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::reverse_iterator":
        return _common.StdMapStringAbstractDataTable_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::reverse_iterator":
        return _common.StdMapStringAbstractDataTable_rend(self)

    def clear(self) -> "void":
        return _common.StdMapStringAbstractDataTable_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::allocator_type":
        return _common.StdMapStringAbstractDataTable_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::size_type":
        return _common.StdMapStringAbstractDataTable_count(self, x)

    def erase(self, *args) -> "void":
        return _common.StdMapStringAbstractDataTable_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::iterator":
        return _common.StdMapStringAbstractDataTable_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::iterator":
        return _common.StdMapStringAbstractDataTable_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::key_type const &") -> "std::map< std::string,std::shared_ptr< OpenSim::AbstractDataTable > >::iterator":
        return _common.StdMapStringAbstractDataTable_upper_bound(self, x)
    __swig_destroy__ = _common.delete_StdMapStringAbstractDataTable

# Register StdMapStringAbstractDataTable in _common:
_common.StdMapStringAbstractDataTable_swigregister(StdMapStringAbstractDataTable)

class DataAdapterAlreadyRegistered(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.DataAdapterAlreadyRegistered_swiginit(self, _common.new_DataAdapterAlreadyRegistered(file, line, func, key))
    __swig_destroy__ = _common.delete_DataAdapterAlreadyRegistered

# Register DataAdapterAlreadyRegistered in _common:
_common.DataAdapterAlreadyRegistered_swigregister(DataAdapterAlreadyRegistered)

class NoRegisteredDataAdapter(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.NoRegisteredDataAdapter_swiginit(self, _common.new_NoRegisteredDataAdapter(file, line, func, key))
    __swig_destroy__ = _common.delete_NoRegisteredDataAdapter

# Register NoRegisteredDataAdapter in _common:
_common.NoRegisteredDataAdapter_swigregister(NoRegisteredDataAdapter)

class TableNotFoundException(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string const &"):
        _common.TableNotFoundException_swiginit(self, _common.new_TableNotFoundException(name))
    __swig_destroy__ = _common.delete_TableNotFoundException

# Register TableNotFoundException in _common:
_common.TableNotFoundException_swigregister(TableNotFoundException)

class DataAdapter(object):
    r"""
     DataAdapter is an abstract class defining an interface for reading/writing
    in/out the contents of a DataTable. It enables access to/from various data
    sources/sinks such as: streams, files, databases and devices. The DataTable
    is independent of the form and format of the data in/out of the source/sink.
    Concrete classes handle the details (e.g. format, sequential access, etc...)
    associated with a particular data source/sink.
    The base DataAdapter contains a static registry to serve as a factory for
    concrete DataAdpaters, given a string identifier of the type of adapter.
    The adapter knows the source format and data flow (read, write, both).
    String identifiers can be associated with file formats according to known
    file extensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self) -> "OpenSim::DataAdapter *":
        return _common.DataAdapter_clone(self)
    __swig_destroy__ = _common.delete_DataAdapter

    @staticmethod
    def registerDataAdapter(identifier: "std::string const &", adapter: "DataAdapter") -> "bool":
        r"""
        Register a concrete DataAdapter by its unique string identifier.
           Registration permits access to the required concrete adapter by
           identifier lookup. As such, identifiers must be unique, but adapters may
           be registered with multiple identifiers. For example, a data file may
           have multiple valid extensions (e.g. ".jpg: and ".jpeg") in which case
           both extensions would be valid identifiers for the same adapter. If an
           identifier is already in use an Exception is thrown.
           All OpenSim data adapters are automatically registered at start of the
           program.
        """
        return _common.DataAdapter_registerDataAdapter(identifier, adapter)

    def read(self, dataSourceSpecification: "std::string const &") -> "OpenSim::DataAdapter::OutputTables":
        r""" Public interface to read data from a dataSourceSpecification, typically a file or folder"""
        return _common.DataAdapter_read(self, dataSourceSpecification)

    def getDataTable(self, tables: "StdMapStringAbstractDataTable", tableName: "std::string const") -> "std::shared_ptr< OpenSim::AbstractDataTable > const":
        r""" Generic interface to retrieve a specific table by name from read result"""
        return _common.DataAdapter_getDataTable(self, tables, tableName)

# Register DataAdapter in _common:
_common.DataAdapter_swigregister(DataAdapter)

def DataAdapter_registerDataAdapter(identifier: "std::string const &", adapter: "DataAdapter") -> "bool":
    r"""
    Register a concrete DataAdapter by its unique string identifier.
       Registration permits access to the required concrete adapter by
       identifier lookup. As such, identifiers must be unique, but adapters may
       be registered with multiple identifiers. For example, a data file may
       have multiple valid extensions (e.g. ".jpg: and ".jpeg") in which case
       both extensions would be valid identifiers for the same adapter. If an
       identifier is already in use an Exception is thrown.
       All OpenSim data adapters are automatically registered at start of the
       program.
    """
    return _common.DataAdapter_registerDataAdapter(identifier, adapter)

class ExperimentalSensor(OpenSimObject):
    r"""
    A class representing the experimental sensor, such as IMU, and its association
    to a model (component) in OpenSim.

    Author: Ayman Habib
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExperimentalSensor *":
        return _common.ExperimentalSensor_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ExperimentalSensor_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ExperimentalSensor_getClassName()

    def clone(self) -> "OpenSim::ExperimentalSensor *":
        return _common.ExperimentalSensor_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ExperimentalSensor_getConcreteClassName(self)

    def copyProperty_name_in_model(self, source: "ExperimentalSensor") -> "void":
        return _common.ExperimentalSensor_copyProperty_name_in_model(self, source)

    def append_name_in_model(self, value: "std::string const &") -> "int":
        return _common.ExperimentalSensor_append_name_in_model(self, value)

    def constructProperty_name_in_model(self, initValue: "std::string const &") -> "void":
        return _common.ExperimentalSensor_constructProperty_name_in_model(self, initValue)

    def get_name_in_model(self, *args) -> "std::string const &":
        return _common.ExperimentalSensor_get_name_in_model(self, *args)

    def upd_name_in_model(self, *args) -> "std::string &":
        return _common.ExperimentalSensor_upd_name_in_model(self, *args)

    def set_name_in_model(self, *args) -> "void":
        return _common.ExperimentalSensor_set_name_in_model(self, *args)

    def __init__(self, *args):
        _common.ExperimentalSensor_swiginit(self, _common.new_ExperimentalSensor(*args))
    __swig_destroy__ = _common.delete_ExperimentalSensor

# Register ExperimentalSensor in _common:
_common.ExperimentalSensor_swigregister(ExperimentalSensor)

def ExperimentalSensor_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ExperimentalSensor *":
    return _common.ExperimentalSensor_safeDownCast(obj)

def ExperimentalSensor_getClassName() -> "std::string const &":
    return _common.ExperimentalSensor_getClassName()

class IMUDataReader(DataAdapter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_IMUDataReader

    @staticmethod
    def getOrientationsTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > > const &":
        r"""
        Custom accessors to retrieve tables of proper types without requiring users/scripters to cast.
        Scripting friendly  get table of Orientations as TimeSeriesTableQuaternion
        """
        return _common.IMUDataReader_getOrientationsTable(tables)

    @staticmethod
    def getLinearAccelerationsTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
        r""" get table of LinearAccelerations as TimeSeriesTableVec3"""
        return _common.IMUDataReader_getLinearAccelerationsTable(tables)

    @staticmethod
    def getMagneticHeadingTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
        r""" get table of MagneticHeading as TimeSeriesTableVec3"""
        return _common.IMUDataReader_getMagneticHeadingTable(tables)

    @staticmethod
    def getAngularVelocityTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
        r""" get table of AngularVelocity as TimeSeriesTableVec3"""
        return _common.IMUDataReader_getAngularVelocityTable(tables)

# Register IMUDataReader in _common:
_common.IMUDataReader_swigregister(IMUDataReader)
IMUDataReader.Orientations = _common.cvar.IMUDataReader_Orientations
IMUDataReader.LinearAccelerations = _common.cvar.IMUDataReader_LinearAccelerations
IMUDataReader.MagneticHeading = _common.cvar.IMUDataReader_MagneticHeading
IMUDataReader.AngularVelocity = _common.cvar.IMUDataReader_AngularVelocity

def IMUDataReader_getOrientationsTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTable_< SimTK::Quaternion_< double > > const &":
    r"""
    Custom accessors to retrieve tables of proper types without requiring users/scripters to cast.
    Scripting friendly  get table of Orientations as TimeSeriesTableQuaternion
    """
    return _common.IMUDataReader_getOrientationsTable(tables)

def IMUDataReader_getLinearAccelerationsTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
    r""" get table of LinearAccelerations as TimeSeriesTableVec3"""
    return _common.IMUDataReader_getLinearAccelerationsTable(tables)

def IMUDataReader_getMagneticHeadingTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
    r""" get table of MagneticHeading as TimeSeriesTableVec3"""
    return _common.IMUDataReader_getMagneticHeadingTable(tables)

def IMUDataReader_getAngularVelocityTable(tables: "StdMapStringAbstractDataTable") -> "OpenSim::TimeSeriesTableVec3 const &":
    r""" get table of AngularVelocity as TimeSeriesTableVec3"""
    return _common.IMUDataReader_getAngularVelocityTable(tables)

class XsensDataReaderSettings(OpenSimObject):
    r"""
    XsensDataReaderSettings is a class that reads files produced by IMU
      manufacturer Xsens and produces datatables from them. This is intended to
      help consume IMU outputs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::XsensDataReaderSettings *":
        return _common.XsensDataReaderSettings_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.XsensDataReaderSettings_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.XsensDataReaderSettings_getClassName()

    def clone(self) -> "OpenSim::XsensDataReaderSettings *":
        return _common.XsensDataReaderSettings_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.XsensDataReaderSettings_getConcreteClassName(self)

    def copyProperty_data_folder(self, source: "XsensDataReaderSettings") -> "void":
        return _common.XsensDataReaderSettings_copyProperty_data_folder(self, source)

    def append_data_folder(self, value: "std::string const &") -> "int":
        return _common.XsensDataReaderSettings_append_data_folder(self, value)

    def constructProperty_data_folder(self, initValue: "std::string const &") -> "void":
        return _common.XsensDataReaderSettings_constructProperty_data_folder(self, initValue)

    def get_data_folder(self, *args) -> "std::string const &":
        return _common.XsensDataReaderSettings_get_data_folder(self, *args)

    def upd_data_folder(self, *args) -> "std::string &":
        return _common.XsensDataReaderSettings_upd_data_folder(self, *args)

    def set_data_folder(self, *args) -> "void":
        return _common.XsensDataReaderSettings_set_data_folder(self, *args)

    def copyProperty_trial_prefix(self, source: "XsensDataReaderSettings") -> "void":
        return _common.XsensDataReaderSettings_copyProperty_trial_prefix(self, source)

    def append_trial_prefix(self, value: "std::string const &") -> "int":
        return _common.XsensDataReaderSettings_append_trial_prefix(self, value)

    def constructProperty_trial_prefix(self, initValue: "std::string const &") -> "void":
        return _common.XsensDataReaderSettings_constructProperty_trial_prefix(self, initValue)

    def get_trial_prefix(self, *args) -> "std::string const &":
        return _common.XsensDataReaderSettings_get_trial_prefix(self, *args)

    def upd_trial_prefix(self, *args) -> "std::string &":
        return _common.XsensDataReaderSettings_upd_trial_prefix(self, *args)

    def set_trial_prefix(self, *args) -> "void":
        return _common.XsensDataReaderSettings_set_trial_prefix(self, *args)

    def copyProperty_ExperimentalSensors(self, source: "XsensDataReaderSettings") -> "void":
        return _common.XsensDataReaderSettings_copyProperty_ExperimentalSensors(self, source)

    def get_ExperimentalSensors(self, i: "int") -> "OpenSim::ExperimentalSensor const &":
        return _common.XsensDataReaderSettings_get_ExperimentalSensors(self, i)

    def upd_ExperimentalSensors(self, i: "int") -> "OpenSim::ExperimentalSensor &":
        return _common.XsensDataReaderSettings_upd_ExperimentalSensors(self, i)

    def set_ExperimentalSensors(self, i: "int", value: "ExperimentalSensor") -> "void":
        return _common.XsensDataReaderSettings_set_ExperimentalSensors(self, i, value)

    def append_ExperimentalSensors(self, value: "ExperimentalSensor") -> "int":
        return _common.XsensDataReaderSettings_append_ExperimentalSensors(self, value)

    def constructProperty_ExperimentalSensors(self) -> "void":
        return _common.XsensDataReaderSettings_constructProperty_ExperimentalSensors(self)

    def __init__(self, *args):
        _common.XsensDataReaderSettings_swiginit(self, _common.new_XsensDataReaderSettings(*args))
    __swig_destroy__ = _common.delete_XsensDataReaderSettings

# Register XsensDataReaderSettings in _common:
_common.XsensDataReaderSettings_swigregister(XsensDataReaderSettings)

def XsensDataReaderSettings_safeDownCast(obj: "OpenSimObject") -> "OpenSim::XsensDataReaderSettings *":
    return _common.XsensDataReaderSettings_safeDownCast(obj)

def XsensDataReaderSettings_getClassName() -> "std::string const &":
    return _common.XsensDataReaderSettings_getClassName()

class XsensDataReader(IMUDataReader):
    r"""
    XsensDataReader is a class that reads files produced by IMU manufacturer
      Xsens and produces datatables from them. This is intended to help consume IMU
      outputs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.XsensDataReader_swiginit(self, _common.new_XsensDataReader(*args))
    __swig_destroy__ = _common.delete_XsensDataReader

    def clone(self) -> "OpenSim::XsensDataReader *":
        return _common.XsensDataReader_clone(self)

    def getSettings(self) -> "OpenSim::XsensDataReaderSettings const &":
        r"""
        Method to get const reference to the internal XsensDataReaderSettings object
        maintained by this reader.
        """
        return _common.XsensDataReader_getSettings(self)

    def updSettings(self) -> "OpenSim::XsensDataReaderSettings &":
        r"""
        Method to get writable reference to the internal XsensDataReaderSettings object
        maintained by this reader, to allow modification after construction.
        """
        return _common.XsensDataReader_updSettings(self)

# Register XsensDataReader in _common:
_common.XsensDataReader_swigregister(XsensDataReader)

class EmptyFileName(InvalidArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.EmptyFileName_swiginit(self, _common.new_EmptyFileName(file, line, func))
    __swig_destroy__ = _common.delete_EmptyFileName

# Register EmptyFileName in _common:
_common.EmptyFileName_swigregister(EmptyFileName)

class FileDoesNotExist(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const"):
        _common.FileDoesNotExist_swiginit(self, _common.new_FileDoesNotExist(file, line, func, filename))
    __swig_destroy__ = _common.delete_FileDoesNotExist

# Register FileDoesNotExist in _common:
_common.FileDoesNotExist_swigregister(FileDoesNotExist)

class FileIsEmpty(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &"):
        _common.FileIsEmpty_swiginit(self, _common.new_FileIsEmpty(file, line, func, filename))
    __swig_destroy__ = _common.delete_FileIsEmpty

# Register FileIsEmpty in _common:
_common.FileIsEmpty_swigregister(FileIsEmpty)

class FileExtensionNotFound(InvalidArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &"):
        _common.FileExtensionNotFound_swiginit(self, _common.new_FileExtensionNotFound(file, line, func, filename))
    __swig_destroy__ = _common.delete_FileExtensionNotFound

# Register FileExtensionNotFound in _common:
_common.FileExtensionNotFound_swigregister(FileExtensionNotFound)

class UnexpectedColumnLabel(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", expected: "std::string const &", received: "std::string const &"):
        _common.UnexpectedColumnLabel_swiginit(self, _common.new_UnexpectedColumnLabel(file, line, func, filename, expected, received))
    __swig_destroy__ = _common.delete_UnexpectedColumnLabel

# Register UnexpectedColumnLabel in _common:
_common.UnexpectedColumnLabel_swigregister(UnexpectedColumnLabel)

class RowLengthMismatch(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", line_num: "size_t", expected: "size_t", received: "size_t"):
        _common.RowLengthMismatch_swiginit(self, _common.new_RowLengthMismatch(file, line, func, filename, line_num, expected, received))
    __swig_destroy__ = _common.delete_RowLengthMismatch

# Register RowLengthMismatch in _common:
_common.RowLengthMismatch_swigregister(RowLengthMismatch)

class NoTableFound(InvalidArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.NoTableFound_swiginit(self, _common.new_NoTableFound(file, line, func))
    __swig_destroy__ = _common.delete_NoTableFound

# Register NoTableFound in _common:
_common.NoTableFound_swigregister(NoTableFound)

class KeyMissing(InvalidArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", key: "std::string const &"):
        _common.KeyMissing_swiginit(self, _common.new_KeyMissing(file, line, func, key))
    __swig_destroy__ = _common.delete_KeyMissing

# Register KeyMissing in _common:
_common.KeyMissing_swigregister(KeyMissing)

class IncorrectTableType(InvalidArgument):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.IncorrectTableType_swiginit(self, _common.new_IncorrectTableType(*args))
    __swig_destroy__ = _common.delete_IncorrectTableType

# Register IncorrectTableType in _common:
_common.IncorrectTableType_swigregister(IncorrectTableType)

class TableMissingHeader(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &"):
        _common.TableMissingHeader_swiginit(self, _common.new_TableMissingHeader(file, line, func))
    __swig_destroy__ = _common.delete_TableMissingHeader

# Register TableMissingHeader in _common:
_common.TableMissingHeader_swigregister(TableMissingHeader)

class FileAdapter(DataAdapter):
    r"""
     FileAdapter is a DataAdapter that reads and writes files with methods
    read and writeFile respectively. The read method is implemented in the base class and it
    calls the virtual extendRead method implemented by format specific subclasses.
    Typically you don't need to call read explicitly if reading one DataTable from file, instead use
    a constructor of the table from the specific file. e.g.

    .. code-block:: c++

        TimeSeriesTableVec3 table(filename);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _common.delete_FileAdapter

    @staticmethod
    def writeFile(tables: "OpenSim::DataAdapter::InputTables const &", fileName: "std::string const &") -> "void":
        r"""
        Write a collection of tables to the given file. Different file formats
           require different number/type of tables. See specific adapter's
           documentation to see what is required.
        """
        return _common.FileAdapter_writeFile(tables, fileName)

    @staticmethod
    def findExtension(filename: "std::string const &") -> "std::string":
        r""" Find the extension from a filename."""
        return _common.FileAdapter_findExtension(filename)

    @staticmethod
    def getNextLine(stream: "std::istream &", delims: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Get the next line from the stream and tokenize/split the line using
           the given delimiters.
        """
        return _common.FileAdapter_getNextLine(stream, delims)

    @staticmethod
    def tokenize(str: "std::string const &", delims: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Tokenize/split a given string using the given delimiters. The delimiters
           are each required to be one character and the string is split if/when any
           of those characters are found. For example, a delimiter string " \t"
           specifies that either a space or a tab can act as the delimiter.
        """
        return _common.FileAdapter_tokenize(str, delims)

    @staticmethod
    def createAdapterFromExtension(fileName: "std::string const &") -> "std::shared_ptr< OpenSim::DataAdapter >":
        r"""
        Create a concerte FileAdapter based on the extension of the passed in file and return it.
            This serves as a Factory of FileAdapters so clients don't need to know specific concrete
            subclasses, as long as the generic base class read interface is used
        """
        return _common.FileAdapter_createAdapterFromExtension(fileName)

# Register FileAdapter in _common:
_common.FileAdapter_swigregister(FileAdapter)

def FileAdapter_writeFile(tables: "OpenSim::DataAdapter::InputTables const &", fileName: "std::string const &") -> "void":
    r"""
    Write a collection of tables to the given file. Different file formats
       require different number/type of tables. See specific adapter's
       documentation to see what is required.
    """
    return _common.FileAdapter_writeFile(tables, fileName)

def FileAdapter_findExtension(filename: "std::string const &") -> "std::string":
    r""" Find the extension from a filename."""
    return _common.FileAdapter_findExtension(filename)

def FileAdapter_getNextLine(stream: "std::istream &", delims: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    Get the next line from the stream and tokenize/split the line using
       the given delimiters.
    """
    return _common.FileAdapter_getNextLine(stream, delims)

def FileAdapter_tokenize(str: "std::string const &", delims: "std::string const &") -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    Tokenize/split a given string using the given delimiters. The delimiters
       are each required to be one character and the string is split if/when any
       of those characters are found. For example, a delimiter string " \t"
       specifies that either a space or a tab can act as the delimiter.
    """
    return _common.FileAdapter_tokenize(str, delims)

def FileAdapter_createAdapterFromExtension(fileName: "std::string const &") -> "std::shared_ptr< OpenSim::DataAdapter >":
    r"""
    Create a concerte FileAdapter based on the extension of the passed in file and return it.
        This serves as a Factory of FileAdapters so clients don't need to know specific concrete
        subclasses, as long as the generic base class read interface is used
    """
    return _common.FileAdapter_createAdapterFromExtension(fileName)

class MissingHeader(IOError):
    r"""
    TRCFileAdapter is a concrete FileAdpater for reading and writing TRC format
    files. A TRC file is a Motion Analysis Trace file that contains a time trace
    or trajectory of 3D markers location with respect to a lab or Ground reference
    frame. A TRC file contains a structured header with information for the file
    type, filename, number of markers, sampling rate, units and several others.
    Data are tab-delimited rows with the same number of elements. Missing values
    can be blank and/or NaN. Blank values are interpreted as NaN. Here is an
    example of a valid TRC file:

       .. code-block:: c++

        PathFileType<tab>4<tab>(X/Y/Z)<tab>example.trc
        DataRate<tab>CameraRate<tab>NumFrames<tab>NumMarkers<tab>Units<tab>OrigDataRate<tab>OrigDataStartFrame<tab>OrigNumFrames
        100<tab>100<tab>5<tab>3<tab>m<tab>100<tab>1<tab>5
        Frame#<tab>Time<tab>marker1<tab><tab><tab>marker2<tab><tab><tab>marker3<tab><tab>
        <tab><tab>X1<tab>Y1<tab>Z1<tab>X2<tab>Y2<tab>Z2<tab>X3<tab>Y3<tab>Z3
        1<tab>0.01<tab><tab><tab><tab>-0.152<tab>0.245<tab>-1.71<tab>-0.0517<tab>0.305<tab>-1.7
        2<tab>0.02<tab>-0.273<tab>0.0745<tab>-1.57<tab>-0.152<tab>0.245<tab>-1.71<tab>-0.0517<tab>0.305<tab>-1.7
        3<tab>0.03<tab>-0.273<tab>0.0745<tab>-1.57<tab>Nan<tab>nan<tab>NAN<tab>-0.0517<tab>0.305<tab>-1.7
        4<tab>0.04<tab>-0.273<tab>0.0745<tab>-1.57<tab>-0.152<tab>0.245<tab>-1.71<tab>-0.0517<tab>0.305<tab>-1.7
        5<tab>0.05<tab>-0.273<tab>0.0745<tab>-1.57<tab>-0.152<tab>0.245<tab>-1.71<tab>-0.0517<tab>0.305<tab>-1.7

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _common.MissingHeader_swiginit(self, _common.new_MissingHeader())
    __swig_destroy__ = _common.delete_MissingHeader

# Register MissingHeader in _common:
_common.MissingHeader_swigregister(MissingHeader)

class IncorrectNumMetaDataKeys(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", expected: "size_t", received: "size_t"):
        _common.IncorrectNumMetaDataKeys_swiginit(self, _common.new_IncorrectNumMetaDataKeys(file, line, func, filename, expected, received))
    __swig_destroy__ = _common.delete_IncorrectNumMetaDataKeys

# Register IncorrectNumMetaDataKeys in _common:
_common.IncorrectNumMetaDataKeys_swigregister(IncorrectNumMetaDataKeys)

class UnexpectedMetaDataKey(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", expected: "std::string const &", received: "std::string const &"):
        _common.UnexpectedMetaDataKey_swiginit(self, _common.new_UnexpectedMetaDataKey(file, line, func, filename, expected, received))
    __swig_destroy__ = _common.delete_UnexpectedMetaDataKey

# Register UnexpectedMetaDataKey in _common:
_common.UnexpectedMetaDataKey_swigregister(UnexpectedMetaDataKey)

class MetaDataLengthMismatch(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", keys_len: "size_t", values_len: "size_t"):
        _common.MetaDataLengthMismatch_swiginit(self, _common.new_MetaDataLengthMismatch(file, line, func, filename, keys_len, values_len))
    __swig_destroy__ = _common.delete_MetaDataLengthMismatch

# Register MetaDataLengthMismatch in _common:
_common.MetaDataLengthMismatch_swigregister(MetaDataLengthMismatch)

class IncorrectNumColumnLabels(IOError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", filename: "std::string const &", expected: "size_t", received: "size_t"):
        _common.IncorrectNumColumnLabels_swiginit(self, _common.new_IncorrectNumColumnLabels(file, line, func, filename, expected, received))
    __swig_destroy__ = _common.delete_IncorrectNumColumnLabels

# Register IncorrectNumColumnLabels in _common:
_common.IncorrectNumColumnLabels_swigregister(IncorrectNumColumnLabels)

class TRCFileAdapter(FileAdapter):
    r"""
     TRCFileAdapter is a FileAdapter that reads and writes TRC files. It accepts
    (when writing) and returns (when reading) a specific type of DataTable referred
    to as Table in this class. Be sure to expect/provide that table when working
    with this adapter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.TRCFileAdapter_swiginit(self, _common.new_TRCFileAdapter(*args))
    __swig_destroy__ = _common.delete_TRCFileAdapter

    def clone(self) -> "OpenSim::TRCFileAdapter *":
        return _common.TRCFileAdapter_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableVec3", filename: "std::string const &") -> "void":
        r"""
        Write a table to a TRC file. The filename provided need not contain
           ".trc".
        """
        return _common.TRCFileAdapter_write(table, filename)

# Register TRCFileAdapter in _common:
_common.TRCFileAdapter_swigregister(TRCFileAdapter)

def TRCFileAdapter_write(table: "TimeSeriesTableVec3", filename: "std::string const &") -> "void":
    r"""
    Write a table to a TRC file. The filename provided need not contain
       ".trc".
    """
    return _common.TRCFileAdapter_write(table, filename)
TRCFileAdapter._markers = _common.cvar.TRCFileAdapter__markers

class IncorrectNumTokens(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", msg: "std::string const &"):
        _common.IncorrectNumTokens_swiginit(self, _common.new_IncorrectNumTokens(file, line, func, msg))
    __swig_destroy__ = _common.delete_IncorrectNumTokens

# Register IncorrectNumTokens in _common:
_common.IncorrectNumTokens_swigregister(IncorrectNumTokens)

class DataTypeMismatch(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", expected: "std::string const &", received: "std::string const &"):
        _common.DataTypeMismatch_swiginit(self, _common.new_DataTypeMismatch(file, line, func, expected, received))
    __swig_destroy__ = _common.delete_DataTypeMismatch

# Register DataTypeMismatch in _common:
_common.DataTypeMismatch_swigregister(DataTypeMismatch)

class APDMDataReaderSettings(OpenSimObject):
    r"""
    APDMDataReaderSettings is a class that reads files produced by IMU manufacturer APDM
       and produces datatables from them. This is intended to help consume IMU outputs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::APDMDataReaderSettings *":
        return _common.APDMDataReaderSettings_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.APDMDataReaderSettings_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.APDMDataReaderSettings_getClassName()

    def clone(self) -> "OpenSim::APDMDataReaderSettings *":
        return _common.APDMDataReaderSettings_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.APDMDataReaderSettings_getConcreteClassName(self)

    def copyProperty_ExperimentalSensors(self, source: "APDMDataReaderSettings") -> "void":
        return _common.APDMDataReaderSettings_copyProperty_ExperimentalSensors(self, source)

    def get_ExperimentalSensors(self, i: "int") -> "OpenSim::ExperimentalSensor const &":
        return _common.APDMDataReaderSettings_get_ExperimentalSensors(self, i)

    def upd_ExperimentalSensors(self, i: "int") -> "OpenSim::ExperimentalSensor &":
        return _common.APDMDataReaderSettings_upd_ExperimentalSensors(self, i)

    def set_ExperimentalSensors(self, i: "int", value: "ExperimentalSensor") -> "void":
        return _common.APDMDataReaderSettings_set_ExperimentalSensors(self, i, value)

    def append_ExperimentalSensors(self, value: "ExperimentalSensor") -> "int":
        return _common.APDMDataReaderSettings_append_ExperimentalSensors(self, value)

    def constructProperty_ExperimentalSensors(self) -> "void":
        return _common.APDMDataReaderSettings_constructProperty_ExperimentalSensors(self)

    def __init__(self, *args):
        _common.APDMDataReaderSettings_swiginit(self, _common.new_APDMDataReaderSettings(*args))
    __swig_destroy__ = _common.delete_APDMDataReaderSettings

# Register APDMDataReaderSettings in _common:
_common.APDMDataReaderSettings_swigregister(APDMDataReaderSettings)

def APDMDataReaderSettings_safeDownCast(obj: "OpenSimObject") -> "OpenSim::APDMDataReaderSettings *":
    return _common.APDMDataReaderSettings_safeDownCast(obj)

def APDMDataReaderSettings_getClassName() -> "std::string const &":
    return _common.APDMDataReaderSettings_getClassName()

class APDMDataReader(IMUDataReader):
    r"""
    APDMDataReader is a class that reads files produced by IMU manufacturer APDM
       and produces datatables from them. This is intended to help consume IMU outputs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.APDMDataReader_swiginit(self, _common.new_APDMDataReader(*args))
    __swig_destroy__ = _common.delete_APDMDataReader

    def clone(self) -> "OpenSim::APDMDataReader *":
        return _common.APDMDataReader_clone(self)

# Register APDMDataReader in _common:
_common.APDMDataReader_swigregister(APDMDataReader)
APDMDataReader.acceleration_labels = _common.cvar.APDMDataReader_acceleration_labels
APDMDataReader.angular_velocity_labels = _common.cvar.APDMDataReader_angular_velocity_labels
APDMDataReader.magnetic_heading_labels = _common.cvar.APDMDataReader_magnetic_heading_labels
APDMDataReader.orientation_labels = _common.cvar.APDMDataReader_orientation_labels
APDMDataReader.TimeLabel = _common.cvar.APDMDataReader_TimeLabel

class STODataTypeNotSupported(OpenSimException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, file: "std::string const &", line: "size_t", func: "std::string const &", datatype: "std::string const &"):
        _common.STODataTypeNotSupported_swiginit(self, _common.new_STODataTypeNotSupported(file, line, func, datatype))
    __swig_destroy__ = _common.delete_STODataTypeNotSupported

# Register STODataTypeNotSupported in _common:
_common.STODataTypeNotSupported_swigregister(STODataTypeNotSupported)

class STOFileAdapter(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapter_swiginit(self, _common.new_STOFileAdapter(*args))
    __swig_destroy__ = _common.delete_STOFileAdapter

    def clone(self) -> "OpenSim::STOFileAdapter_< double > *":
        return _common.STOFileAdapter_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTable", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapter_write(table, fileName)

# Register STOFileAdapter in _common:
_common.STOFileAdapter_swigregister(STOFileAdapter)

def STOFileAdapter_write(table: "TimeSeriesTable", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapter_write(table, fileName)

class STOFileAdapterVec3(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapterVec3_swiginit(self, _common.new_STOFileAdapterVec3(*args))
    __swig_destroy__ = _common.delete_STOFileAdapterVec3

    def clone(self) -> "OpenSim::STOFileAdapter_< SimTK::Vec3 > *":
        return _common.STOFileAdapterVec3_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableVec3", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapterVec3_write(table, fileName)

# Register STOFileAdapterVec3 in _common:
_common.STOFileAdapterVec3_swigregister(STOFileAdapterVec3)

def STOFileAdapterVec3_write(table: "TimeSeriesTableVec3", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapterVec3_write(table, fileName)

class STOFileAdapterUnitVec3(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapterUnitVec3_swiginit(self, _common.new_STOFileAdapterUnitVec3(*args))
    __swig_destroy__ = _common.delete_STOFileAdapterUnitVec3

    def clone(self) -> "OpenSim::STOFileAdapter_< SimTK::UnitVec3 > *":
        return _common.STOFileAdapterUnitVec3_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableUnitVec3", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapterUnitVec3_write(table, fileName)

# Register STOFileAdapterUnitVec3 in _common:
_common.STOFileAdapterUnitVec3_swigregister(STOFileAdapterUnitVec3)

def STOFileAdapterUnitVec3_write(table: "TimeSeriesTableUnitVec3", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapterUnitVec3_write(table, fileName)

class STOFileAdapterQuaternion(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapterQuaternion_swiginit(self, _common.new_STOFileAdapterQuaternion(*args))
    __swig_destroy__ = _common.delete_STOFileAdapterQuaternion

    def clone(self) -> "OpenSim::STOFileAdapter_< SimTK::Quaternion > *":
        return _common.STOFileAdapterQuaternion_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableQuaternion", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapterQuaternion_write(table, fileName)

# Register STOFileAdapterQuaternion in _common:
_common.STOFileAdapterQuaternion_swigregister(STOFileAdapterQuaternion)

def STOFileAdapterQuaternion_write(table: "TimeSeriesTableQuaternion", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapterQuaternion_write(table, fileName)

class STOFileAdapterVec6(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapterVec6_swiginit(self, _common.new_STOFileAdapterVec6(*args))
    __swig_destroy__ = _common.delete_STOFileAdapterVec6

    def clone(self) -> "OpenSim::STOFileAdapter_< SimTK::Vec6 > *":
        return _common.STOFileAdapterVec6_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableVec6", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapterVec6_write(table, fileName)

# Register STOFileAdapterVec6 in _common:
_common.STOFileAdapterVec6_swigregister(STOFileAdapterVec6)

def STOFileAdapterVec6_write(table: "TimeSeriesTableVec6", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapterVec6_write(table, fileName)

class STOFileAdapterSpatialVec(object):
    r"""
     STOFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for STO files. The format of the file is as follows:

    .. code-block:: c++

        .................................
        .................................
        ........ <metadata> .............
        .................................
        .................................
        endheader
        time colname1 colname2 ..........
        .................................
        .................................
        ............ <data-rows> ........
        .................................
        .................................
    For example a TimeSeriesTable_<SimTK::Vec3> could look like:

    .. code-block:: c++

        units=m
        DataType=Vec3
        endheader
        time  r_shoulder      l_shoulder      r_leg           l_leg
        0.1   0.11,0.22,0.33  0.44,0.55,0.66  0.77,0.88,0.99  0.10,0.11,0.12
        0.2   0.22,0.44,0.66  0.88,0.99,0.35  0.75,0.65,0.43  0.47,0.57,0.67
    Columns are delimited by tab character. Elements within a column are delimited
    by comma character. STOFileAdapter allows reading/writing following
    tables:

    |TimeSeriesTable_<double>
    |DataType=double|
    |TimeSeriesTable_<SimTK::Vec2>
    |DataType=Vec2|
    |TimeSeriesTable_<SimTK::Vec3>
    |DataType=Vec3|
    |TimeSeriesTable_<SimTK::Vec4>
    |DataType=Vec4|
    |TimeSeriesTable_<SimTK::Vec5>
    |DataType=Vec5|
    |TimeSeriesTable_<SimTK::Vec6>
    |DataType=Vec6|
    |TimeSeriesTable_<SimTK::Vec7>
    |DataType=Vec7|
    |TimeSeriesTable_<SimTK::Vec8>
    |DataType=Vec8|
    |TimeSeriesTable_<SimTK::Vec9>
    |DataType=Vec9|
    |TimeSeriesTable_<SimTK::Vec<10>>
    |DataType=Vec10|
    |TimeSeriesTable_<SimTK::Vec<11>>
    |DataType=Vec11|
    |TimeSeriesTable_<SimTK::Vec<12>>
    |DataType=Vec12|
    |TimeSeriesTable_<SimTK::UnitVec3>
    |DataType=UnitVec3|
    |TimeSeriesTable_<SimTK::Quaternion>
    |DataType=Quaternion|
    |TimeSeriesTable_<SimTK::SpatialVec>
    |DataType=SpatialVec|

    Files contain metadata (in form of "DataType=<something>" as shown above)
    indicating the type of the table they contain.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.STOFileAdapterSpatialVec_swiginit(self, _common.new_STOFileAdapterSpatialVec(*args))
    __swig_destroy__ = _common.delete_STOFileAdapterSpatialVec

    def clone(self) -> "OpenSim::STOFileAdapter_< SimTK::SpatialVec > *":
        return _common.STOFileAdapterSpatialVec_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTableSpatialVec", fileName: "std::string const &") -> "void":
        r""" Write a STO file."""
        return _common.STOFileAdapterSpatialVec_write(table, fileName)

# Register STOFileAdapterSpatialVec in _common:
_common.STOFileAdapterSpatialVec_swigregister(STOFileAdapterSpatialVec)

def STOFileAdapterSpatialVec_write(table: "TimeSeriesTableSpatialVec", fileName: "std::string const &") -> "void":
    r""" Write a STO file."""
    return _common.STOFileAdapterSpatialVec_write(table, fileName)

class CSVFileAdapter(object):
    r"""
     CSVFileAdapter is a DelimFileAdapter that presets the delimiters
    appropriately for CSV files.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _common.CSVFileAdapter_swiginit(self, _common.new_CSVFileAdapter(*args))
    __swig_destroy__ = _common.delete_CSVFileAdapter

    def clone(self) -> "OpenSim::CSVFileAdapter *":
        return _common.CSVFileAdapter_clone(self)

    @staticmethod
    def write(table: "TimeSeriesTable", fileName: "std::string const &") -> "void":
        r""" Write a CSV file."""
        return _common.CSVFileAdapter_write(table, fileName)

# Register CSVFileAdapter in _common:
_common.CSVFileAdapter_swigregister(CSVFileAdapter)

def CSVFileAdapter_write(table: "TimeSeriesTable", fileName: "std::string const &") -> "void":
    r""" Write a CSV file."""
    return _common.CSVFileAdapter_write(table, fileName)

class C3DFileAdapter(FileAdapter):
    r"""
     C3DFileAdapter reads a C3D file into markers and forces tables of type
    TimeSeriesTableVec3. The markers table has each column labeled by its
    corresponding marker name. For the forces table, the data are grouped
    by sensor (force-plate #) in force, point and moment order, with the
    respective *f#*, *p#* and *m#* column labels. C3DFileAdpater provides
    options for expressing the force-plate measurements either as the
    net force and moments expressed at the ForcePlateOrigin, the
    CenterOfPressure, or the PointOfWrenchApplication.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ForceLocation_OriginOfForcePlate = _common.C3DFileAdapter_ForceLocation_OriginOfForcePlate
    r""" 0 : the origin of the force-plate"""
    ForceLocation_CenterOfPressure = _common.C3DFileAdapter_ForceLocation_CenterOfPressure
    r""" 1 : the center of pressure"""
    ForceLocation_PointOfWrenchApplication = _common.C3DFileAdapter_ForceLocation_PointOfWrenchApplication
    r""" 2 : PWA as defined by Shimba, 1984"""

    def clone(self) -> "OpenSim::C3DFileAdapter *":
        return _common.C3DFileAdapter_clone(self)

    def getLocationForForceExpression(self) -> "OpenSim::C3DFileAdapter::ForceLocation":
        r""" Retrieve the option for location for force expression"""
        return _common.C3DFileAdapter_getLocationForForceExpression(self)

    def getMarkersTable(self, tables: "StdMapStringAbstractDataTable") -> "std::shared_ptr< OpenSim::TimeSeriesTableVec3 >":
        r""" Retrieve the TimeSeriesTableVec3 of Markers"""
        return _common.C3DFileAdapter_getMarkersTable(self, tables)

    def getForcesTable(self, tables: "StdMapStringAbstractDataTable") -> "std::shared_ptr< OpenSim::TimeSeriesTableVec3 >":
        r""" Retrieve the TimeSeriesTableVec3 of Forces"""
        return _common.C3DFileAdapter_getForcesTable(self, tables)

    def setLocationForForceExpression(self, *args) -> "void":
        return _common.C3DFileAdapter_setLocationForForceExpression(self, *args)

    def __init__(self):
        _common.C3DFileAdapter_swiginit(self, _common.new_C3DFileAdapter())
    __swig_destroy__ = _common.delete_C3DFileAdapter

# Register C3DFileAdapter in _common:
_common.C3DFileAdapter_swigregister(C3DFileAdapter)
C3DFileAdapter._markers = _common.cvar.C3DFileAdapter__markers
C3DFileAdapter._forces = _common.cvar.C3DFileAdapter__forces

class TableSource(Component):
    r"""
     Component representing a source of data from a TimeSeriesTable_.

    This Component has two outputs:
    - A list output with one channel per column of the TimeSeriesTable_.
    - A non-list output for a row of the TimeSeriesTable_.

    Construct this Component by giving it a TimeSeriesTable_. Then use it by
    connecting its output to the Input of another Component that accepts compatible
    type of Input. Make sure to populate the column-labels of the TimeSeriesTable_
    before connecting this Component to the input of another Component.

    :param ET: Type of each element of the TimeSeriesTable_ this Component
                   represents.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableSource_< SimTK::Real > *":
        return _common.TableSource_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableSource_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableSource_getClassName()

    def clone(self) -> "OpenSim::TableSource_< SimTK::Real > *":
        return _common.TableSource_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableSource_getConcreteClassName(self)

    def copyProperty_filename(self, source: "TableSource") -> "void":
        return _common.TableSource_copyProperty_filename(self, source)

    def append_filename(self, value: "std::string const &") -> "int":
        return _common.TableSource_append_filename(self, value)

    def constructProperty_filename(self, initValue: "std::string const &") -> "void":
        return _common.TableSource_constructProperty_filename(self, initValue)

    def get_filename(self, *args) -> "std::string const &":
        return _common.TableSource_get_filename(self, *args)

    def upd_filename(self, *args) -> "std::string &":
        return _common.TableSource_upd_filename(self, *args)

    def set_filename(self, *args) -> "void":
        return _common.TableSource_set_filename(self, *args)

    def copyProperty_tablename(self, source: "TableSource") -> "void":
        return _common.TableSource_copyProperty_tablename(self, source)

    def append_tablename(self, value: "std::string const &") -> "int":
        return _common.TableSource_append_tablename(self, value)

    def constructProperty_tablename(self, initValue: "std::string const &") -> "void":
        return _common.TableSource_constructProperty_tablename(self, initValue)

    def get_tablename(self, *args) -> "std::string const &":
        return _common.TableSource_get_tablename(self, *args)

    def upd_tablename(self, *args) -> "std::string &":
        return _common.TableSource_upd_tablename(self, *args)

    def set_tablename(self, *args) -> "void":
        return _common.TableSource_set_tablename(self, *args)
    _has_output_all_columns = property(_common.TableSource__has_output_all_columns_get, _common.TableSource__has_output_all_columns_set)
    _has_output_column = property(_common.TableSource__has_output_column_get, _common.TableSource__has_output_column_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct the TableSource_ by giving it a TimeSeriesTable_ to hold.

        |

        *Overload 2:*
        Construct the TableSource_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: KeyNotFound If table provided does not have column-labels.

        |

        *Overload 3:*
        Construct the TableSource_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to populate the TableSource
                                with. Ex. 'markers', 'forces'.

           :raises: KeyNotFound If table provided does not have column-labels.
        """
        _common.TableSource_swiginit(self, _common.new_TableSource(*args))

    def getTable(self) -> "OpenSim::TableSource_< double >::Table const &":
        r"""
        Get a read-only reference to the TimeSeriesTable_ this TableSource_
           currently holds.
        """
        return _common.TableSource_getTable(self)

    def setTable(self, *args) -> "void":
        r"""
        *Overload 1:*
        Replace the existing TimeSeriesTable_ that this TableSource_ currently
           holds. The properties 'filename' and 'tablename' are reset to empty strings
           as a result of this operation.

           :raises: KeyNotFound If table provided does not have column labels.

        |

        *Overload 2:*
        Replace the TimeSeriesTable_ that this TableSource_ currently holds.
           Property 'filename' is reset to the value provided. Property 'tablename' is
           reset to the empty string as a result of this operation.

           :raises: InvalidCall If property `filename` is set. This call is not allowed
                                   if `filename` property is set.
           :raises: KeyNotFound If table provided does not have column labels.

        |

        *Overload 3:*
        Replace the TimeSeriesTable_ that this TableSource_ currently holds.
           Properties 'filename' and 'tablename' are reset to the values provided.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct the
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidCall If property `filename` is set. This call is not allowed
                                   if `filename` property is set.
           :raises: KeyNotFound If table provided does not have column labels.
        """
        return _common.TableSource_setTable(self, *args)
    __swig_destroy__ = _common.delete_TableSource

# Register TableSource in _common:
_common.TableSource_swigregister(TableSource)

def TableSource_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableSource_< SimTK::Real > *":
    return _common.TableSource_safeDownCast(obj)

def TableSource_getClassName() -> "std::string const &":
    return _common.TableSource_getClassName()

class TableSourceVec3(Component):
    r"""
     Component representing a source of data from a TimeSeriesTable_.

    This Component has two outputs:
    - A list output with one channel per column of the TimeSeriesTable_.
    - A non-list output for a row of the TimeSeriesTable_.

    Construct this Component by giving it a TimeSeriesTable_. Then use it by
    connecting its output to the Input of another Component that accepts compatible
    type of Input. Make sure to populate the column-labels of the TimeSeriesTable_
    before connecting this Component to the input of another Component.

    :param ET: Type of each element of the TimeSeriesTable_ this Component
                   represents.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableSource_< SimTK::Vec3 > *":
        return _common.TableSourceVec3_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableSourceVec3_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableSourceVec3_getClassName()

    def clone(self) -> "OpenSim::TableSource_< SimTK::Vec3 > *":
        return _common.TableSourceVec3_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableSourceVec3_getConcreteClassName(self)

    def copyProperty_filename(self, source: "TableSourceVec3") -> "void":
        return _common.TableSourceVec3_copyProperty_filename(self, source)

    def append_filename(self, value: "std::string const &") -> "int":
        return _common.TableSourceVec3_append_filename(self, value)

    def constructProperty_filename(self, initValue: "std::string const &") -> "void":
        return _common.TableSourceVec3_constructProperty_filename(self, initValue)

    def get_filename(self, *args) -> "std::string const &":
        return _common.TableSourceVec3_get_filename(self, *args)

    def upd_filename(self, *args) -> "std::string &":
        return _common.TableSourceVec3_upd_filename(self, *args)

    def set_filename(self, *args) -> "void":
        return _common.TableSourceVec3_set_filename(self, *args)

    def copyProperty_tablename(self, source: "TableSourceVec3") -> "void":
        return _common.TableSourceVec3_copyProperty_tablename(self, source)

    def append_tablename(self, value: "std::string const &") -> "int":
        return _common.TableSourceVec3_append_tablename(self, value)

    def constructProperty_tablename(self, initValue: "std::string const &") -> "void":
        return _common.TableSourceVec3_constructProperty_tablename(self, initValue)

    def get_tablename(self, *args) -> "std::string const &":
        return _common.TableSourceVec3_get_tablename(self, *args)

    def upd_tablename(self, *args) -> "std::string &":
        return _common.TableSourceVec3_upd_tablename(self, *args)

    def set_tablename(self, *args) -> "void":
        return _common.TableSourceVec3_set_tablename(self, *args)
    _has_output_all_columns = property(_common.TableSourceVec3__has_output_all_columns_get, _common.TableSourceVec3__has_output_all_columns_set)
    _has_output_column = property(_common.TableSourceVec3__has_output_column_get, _common.TableSourceVec3__has_output_column_set)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct the TableSource_ by giving it a TimeSeriesTable_ to hold.

        |

        *Overload 2:*
        Construct the TableSource_ from a file.

           :type filename: string
           :param filename: Name of the file.

           :raises: KeyNotFound If table provided does not have column-labels.

        |

        *Overload 3:*
        Construct the TableSource_ from a file.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to populate the TableSource
                                with. Ex. 'markers', 'forces'.

           :raises: KeyNotFound If table provided does not have column-labels.
        """
        _common.TableSourceVec3_swiginit(self, _common.new_TableSourceVec3(*args))

    def getTable(self) -> "OpenSim::TableSource_< SimTK::Vec< 3,double,1 > >::Table const &":
        r"""
        Get a read-only reference to the TimeSeriesTable_ this TableSource_
           currently holds.
        """
        return _common.TableSourceVec3_getTable(self)

    def setTable(self, *args) -> "void":
        r"""
        *Overload 1:*
        Replace the existing TimeSeriesTable_ that this TableSource_ currently
           holds. The properties 'filename' and 'tablename' are reset to empty strings
           as a result of this operation.

           :raises: KeyNotFound If table provided does not have column labels.

        |

        *Overload 2:*
        Replace the TimeSeriesTable_ that this TableSource_ currently holds.
           Property 'filename' is reset to the value provided. Property 'tablename' is
           reset to the empty string as a result of this operation.

           :raises: InvalidCall If property `filename` is set. This call is not allowed
                                   if `filename` property is set.
           :raises: KeyNotFound If table provided does not have column labels.

        |

        *Overload 3:*
        Replace the TimeSeriesTable_ that this TableSource_ currently holds.
           Properties 'filename' and 'tablename' are reset to the values provided.

           :type filename: string
           :param filename: Name of the file.
           :type tablename: string
           :param tablename: Name of the table in the file to construct the
                                TimeSeriesTable_ from. For example, a c3d file contains
                                tables named 'markers' and 'forces'.

           :raises: InvalidCall If property `filename` is set. This call is not allowed
                                   if `filename` property is set.
           :raises: KeyNotFound If table provided does not have column labels.
        """
        return _common.TableSourceVec3_setTable(self, *args)
    __swig_destroy__ = _common.delete_TableSourceVec3

# Register TableSourceVec3 in _common:
_common.TableSourceVec3_swigregister(TableSourceVec3)

def TableSourceVec3_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableSource_< SimTK::Vec3 > *":
    return _common.TableSourceVec3_safeDownCast(obj)

def TableSourceVec3_getClassName() -> "std::string const &":
    return _common.TableSourceVec3_getClassName()

class AbstractReporter(Component):
    r"""
    This abstract class represents a Reporter that generates a report from
    values generated by Components in a Model during a simulation.

    The what, how and where values are reported (e.g. to the console,
    DataTable, device, etc...) are the purview of concrete Reporters
    (e.g., TableReporter).

    Notes: These reporter classes have *no* association with some of the
    Analyses that have "reporter" in their name (like ForceReporter).



    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractReporter *":
        return _common.AbstractReporter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.AbstractReporter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.AbstractReporter_getClassName()

    def clone(self) -> "OpenSim::AbstractReporter *":
        return _common.AbstractReporter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.AbstractReporter_getConcreteClassName(self)

    def copyProperty_report_time_interval(self, source: "AbstractReporter") -> "void":
        return _common.AbstractReporter_copyProperty_report_time_interval(self, source)

    def append_report_time_interval(self, value: "double const &") -> "int":
        return _common.AbstractReporter_append_report_time_interval(self, value)

    def constructProperty_report_time_interval(self, initValue: "double const &") -> "void":
        return _common.AbstractReporter_constructProperty_report_time_interval(self, initValue)

    def get_report_time_interval(self, *args) -> "double const &":
        return _common.AbstractReporter_get_report_time_interval(self, *args)

    def upd_report_time_interval(self, *args) -> "double &":
        return _common.AbstractReporter_upd_report_time_interval(self, *args)

    def set_report_time_interval(self, *args) -> "void":
        return _common.AbstractReporter_set_report_time_interval(self, *args)

    def report(self, s: "State") -> "void":
        r""" Report values given the state and top-level Component (e.g. Model)"""
        return _common.AbstractReporter_report(self, s)

# Register AbstractReporter in _common:
_common.AbstractReporter_swigregister(AbstractReporter)

def AbstractReporter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AbstractReporter *":
    return _common.AbstractReporter_safeDownCast(obj)

def AbstractReporter_getClassName() -> "std::string const &":
    return _common.AbstractReporter_getClassName()

class ReporterDouble(AbstractReporter):
    r"""
    This is an abstract Reporter with a single list Input named "inputs" whose
    type is templated (InputT).

    Destination of reported values are left to concrete types.



    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Real > *":
        return _common.ReporterDouble_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ReporterDouble_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ReporterDouble_getClassName()

    def clone(self) -> "OpenSim::Reporter< SimTK::Real > *":
        return _common.ReporterDouble_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ReporterDouble_getConcreteClassName(self)
    PropertyIndex_input_inputs = property(_common.ReporterDouble_PropertyIndex_input_inputs_get, _common.ReporterDouble_PropertyIndex_input_inputs_set)

    def connectInput_inputs(self, *args) -> "void":
        return _common.ReporterDouble_connectInput_inputs(self, *args)

    def addToReport(self, *args) -> "void":
        r"""
        *Overload 1:*
        Connect an output (single-valued or list) to this reporter.
           The output must be of type InputT.
           If the output is a list output, this connects to all of the channels of the
           output. You can optionally provide an alias that will be used by this
           component to refer to the output; the alias will be used for all channels
           of the output.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("all_columns"));
           This method is equivalent to
           connectInput_inputs(const AbstractOutput&, const std::string&).

        |

        *Overload 2:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).

        |

        *Overload 3:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).
        """
        return _common.ReporterDouble_addToReport(self, *args)

# Register ReporterDouble in _common:
_common.ReporterDouble_swigregister(ReporterDouble)

def ReporterDouble_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Real > *":
    return _common.ReporterDouble_safeDownCast(obj)

def ReporterDouble_getClassName() -> "std::string const &":
    return _common.ReporterDouble_getClassName()

class ReporterVec3(AbstractReporter):
    r"""
    This is an abstract Reporter with a single list Input named "inputs" whose
    type is templated (InputT).

    Destination of reported values are left to concrete types.



    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Vec3 > *":
        return _common.ReporterVec3_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ReporterVec3_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ReporterVec3_getClassName()

    def clone(self) -> "OpenSim::Reporter< SimTK::Vec3 > *":
        return _common.ReporterVec3_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ReporterVec3_getConcreteClassName(self)
    PropertyIndex_input_inputs = property(_common.ReporterVec3_PropertyIndex_input_inputs_get, _common.ReporterVec3_PropertyIndex_input_inputs_set)

    def connectInput_inputs(self, *args) -> "void":
        return _common.ReporterVec3_connectInput_inputs(self, *args)

    def addToReport(self, *args) -> "void":
        r"""
        *Overload 1:*
        Connect an output (single-valued or list) to this reporter.
           The output must be of type InputT.
           If the output is a list output, this connects to all of the channels of the
           output. You can optionally provide an alias that will be used by this
           component to refer to the output; the alias will be used for all channels
           of the output.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("all_columns"));
           This method is equivalent to
           connectInput_inputs(const AbstractOutput&, const std::string&).

        |

        *Overload 2:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).

        |

        *Overload 3:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).
        """
        return _common.ReporterVec3_addToReport(self, *args)

# Register ReporterVec3 in _common:
_common.ReporterVec3_swigregister(ReporterVec3)

def ReporterVec3_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Vec3 > *":
    return _common.ReporterVec3_safeDownCast(obj)

def ReporterVec3_getClassName() -> "std::string const &":
    return _common.ReporterVec3_getClassName()

class ReporterVector(AbstractReporter):
    r"""
    This is an abstract Reporter with a single list Input named "inputs" whose
    type is templated (InputT).

    Destination of reported values are left to concrete types.



    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Vector > *":
        return _common.ReporterVector_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ReporterVector_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ReporterVector_getClassName()

    def clone(self) -> "OpenSim::Reporter< SimTK::Vector > *":
        return _common.ReporterVector_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ReporterVector_getConcreteClassName(self)
    PropertyIndex_input_inputs = property(_common.ReporterVector_PropertyIndex_input_inputs_get, _common.ReporterVector_PropertyIndex_input_inputs_set)

    def connectInput_inputs(self, *args) -> "void":
        return _common.ReporterVector_connectInput_inputs(self, *args)

    def addToReport(self, *args) -> "void":
        r"""
        *Overload 1:*
        Connect an output (single-valued or list) to this reporter.
           The output must be of type InputT.
           If the output is a list output, this connects to all of the channels of the
           output. You can optionally provide an alias that will be used by this
           component to refer to the output; the alias will be used for all channels
           of the output.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("all_columns"));
           This method is equivalent to
           connectInput_inputs(const AbstractOutput&, const std::string&).

        |

        *Overload 2:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).

        |

        *Overload 3:*
        Connect an output channel to this reporter.
           The output channel must be of type InputT.
           You can optionally provide an alias that will be used by this component to
           refer to the channel.

           .. code-block:: c++

               auto* reporter = new ConsoleReporter();
               auto* src = new TableSource();
               reporter->addToReport(src->getOutput("column").getChannel("ankle"));
           This method is equivalent to
           connectInput_inputs(const AbstractChannel&, const std::string&).
        """
        return _common.ReporterVector_addToReport(self, *args)

# Register ReporterVector in _common:
_common.ReporterVector_swigregister(ReporterVector)

def ReporterVector_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Reporter< SimTK::Vector > *":
    return _common.ReporterVector_safeDownCast(obj)

def ReporterVector_getClassName() -> "std::string const &":
    return _common.ReporterVector_getClassName()

class TableReporter(ReporterDouble):
    r"""
    This concrete Reporter class collects and reports Output<InputT>s within a
    TimeSeriesTable_. The column labels in the resulting table come from the
    names of the outputs connected to this reporter. The contents of the table are
    the Output values with each row being the value of all outputs at subsequent
    times determined by the reporting interval.



    :param InputT: The type for the Reporter's Input (i.e., Reporter<InputT>).
    :param ValueT: The type for the TimeSeriesTable (i.e., TimeSeriesTable_<ValueT>).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Real > *":
        return _common.TableReporter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableReporter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableReporter_getClassName()

    def clone(self) -> "OpenSim::TableReporter_< SimTK::Real > *":
        return _common.TableReporter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableReporter_getConcreteClassName(self)

    def __init__(self):
        _common.TableReporter_swiginit(self, _common.new_TableReporter())
    __swig_destroy__ = _common.delete_TableReporter

    def getTable(self) -> "OpenSim::TimeSeriesTable_< double > const &":
        r""" Retrieve the report as a TimeSeriesTable."""
        return _common.TableReporter_getTable(self)

    def clearTable(self) -> "void":
        r"""
        Clear the report. This can be used for example in loops performing
           simulation. Each new iteration should start with an empty report and so this
           function can be used to clear the report at the end of each iteration.
        """
        return _common.TableReporter_clearTable(self)

# Register TableReporter in _common:
_common.TableReporter_swigregister(TableReporter)

def TableReporter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Real > *":
    return _common.TableReporter_safeDownCast(obj)

def TableReporter_getClassName() -> "std::string const &":
    return _common.TableReporter_getClassName()

class TableReporterVec3(ReporterVec3):
    r"""
    This concrete Reporter class collects and reports Output<InputT>s within a
    TimeSeriesTable_. The column labels in the resulting table come from the
    names of the outputs connected to this reporter. The contents of the table are
    the Output values with each row being the value of all outputs at subsequent
    times determined by the reporting interval.



    :param InputT: The type for the Reporter's Input (i.e., Reporter<InputT>).
    :param ValueT: The type for the TimeSeriesTable (i.e., TimeSeriesTable_<ValueT>).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Vec3 > *":
        return _common.TableReporterVec3_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableReporterVec3_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableReporterVec3_getClassName()

    def clone(self) -> "OpenSim::TableReporter_< SimTK::Vec3 > *":
        return _common.TableReporterVec3_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableReporterVec3_getConcreteClassName(self)

    def __init__(self):
        _common.TableReporterVec3_swiginit(self, _common.new_TableReporterVec3())
    __swig_destroy__ = _common.delete_TableReporterVec3

    def getTable(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 3,double,1 > > const &":
        r""" Retrieve the report as a TimeSeriesTable."""
        return _common.TableReporterVec3_getTable(self)

    def clearTable(self) -> "void":
        r"""
        Clear the report. This can be used for example in loops performing
           simulation. Each new iteration should start with an empty report and so this
           function can be used to clear the report at the end of each iteration.
        """
        return _common.TableReporterVec3_clearTable(self)

# Register TableReporterVec3 in _common:
_common.TableReporterVec3_swigregister(TableReporterVec3)

def TableReporterVec3_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Vec3 > *":
    return _common.TableReporterVec3_safeDownCast(obj)

def TableReporterVec3_getClassName() -> "std::string const &":
    return _common.TableReporterVec3_getClassName()

class TableReporterSpatialVec(object):
    r"""
    This concrete Reporter class collects and reports Output<InputT>s within a
    TimeSeriesTable_. The column labels in the resulting table come from the
    names of the outputs connected to this reporter. The contents of the table are
    the Output values with each row being the value of all outputs at subsequent
    times determined by the reporting interval.



    :param InputT: The type for the Reporter's Input (i.e., Reporter<InputT>).
    :param ValueT: The type for the TimeSeriesTable (i.e., TimeSeriesTable_<ValueT>).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::SpatialVec > *":
        return _common.TableReporterSpatialVec_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableReporterSpatialVec_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableReporterSpatialVec_getClassName()

    def clone(self) -> "OpenSim::TableReporter_< SimTK::SpatialVec > *":
        return _common.TableReporterSpatialVec_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableReporterSpatialVec_getConcreteClassName(self)

    def __init__(self):
        _common.TableReporterSpatialVec_swiginit(self, _common.new_TableReporterSpatialVec())
    __swig_destroy__ = _common.delete_TableReporterSpatialVec

    def getTable(self) -> "OpenSim::TimeSeriesTable_< SimTK::Vec< 2,SimTK::Vec< 3,double,1 >,1 > > const &":
        r""" Retrieve the report as a TimeSeriesTable."""
        return _common.TableReporterSpatialVec_getTable(self)

    def clearTable(self) -> "void":
        r"""
        Clear the report. This can be used for example in loops performing
           simulation. Each new iteration should start with an empty report and so this
           function can be used to clear the report at the end of each iteration.
        """
        return _common.TableReporterSpatialVec_clearTable(self)

# Register TableReporterSpatialVec in _common:
_common.TableReporterSpatialVec_swigregister(TableReporterSpatialVec)

def TableReporterSpatialVec_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::SpatialVec > *":
    return _common.TableReporterSpatialVec_safeDownCast(obj)

def TableReporterSpatialVec_getClassName() -> "std::string const &":
    return _common.TableReporterSpatialVec_getClassName()

class TableReporterVector(ReporterVector):
    r"""
    This concrete Reporter class collects and reports Output<InputT>s within a
    TimeSeriesTable_. The column labels in the resulting table come from the
    names of the outputs connected to this reporter. The contents of the table are
    the Output values with each row being the value of all outputs at subsequent
    times determined by the reporting interval.



    :param InputT: The type for the Reporter's Input (i.e., Reporter<InputT>).
    :param ValueT: The type for the TimeSeriesTable (i.e., TimeSeriesTable_<ValueT>).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Vector,SimTK::Real > *":
        return _common.TableReporterVector_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.TableReporterVector_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.TableReporterVector_getClassName()

    def clone(self) -> "OpenSim::TableReporter_< SimTK::Vector,SimTK::Real > *":
        return _common.TableReporterVector_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.TableReporterVector_getConcreteClassName(self)

    def __init__(self):
        _common.TableReporterVector_swiginit(self, _common.new_TableReporterVector())
    __swig_destroy__ = _common.delete_TableReporterVector

    def getTable(self) -> "OpenSim::TimeSeriesTable_< double > const &":
        r""" Retrieve the report as a TimeSeriesTable."""
        return _common.TableReporterVector_getTable(self)

    def clearTable(self) -> "void":
        r"""
        Clear the report. This can be used for example in loops performing
           simulation. Each new iteration should start with an empty report and so this
           function can be used to clear the report at the end of each iteration.
        """
        return _common.TableReporterVector_clearTable(self)

# Register TableReporterVector in _common:
_common.TableReporterVector_swigregister(TableReporterVector)

def TableReporterVector_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TableReporter_< SimTK::Vector,SimTK::Real > *":
    return _common.TableReporterVector_safeDownCast(obj)

def TableReporterVector_getClassName() -> "std::string const &":
    return _common.TableReporterVector_getClassName()

class ConsoleReporter(ReporterDouble):
    r"""
    A reporter that simply prints quantities to the console
    (command window or terminal), perhaps to monitor the progress of a simulation
    as it executes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConsoleReporter_< SimTK::Real > *":
        return _common.ConsoleReporter_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ConsoleReporter_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ConsoleReporter_getClassName()

    def clone(self) -> "OpenSim::ConsoleReporter_< SimTK::Real > *":
        return _common.ConsoleReporter_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ConsoleReporter_getConcreteClassName(self)

    def __init__(self):
        _common.ConsoleReporter_swiginit(self, _common.new_ConsoleReporter())
    __swig_destroy__ = _common.delete_ConsoleReporter

# Register ConsoleReporter in _common:
_common.ConsoleReporter_swigregister(ConsoleReporter)

def ConsoleReporter_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConsoleReporter_< SimTK::Real > *":
    return _common.ConsoleReporter_safeDownCast(obj)

def ConsoleReporter_getClassName() -> "std::string const &":
    return _common.ConsoleReporter_getClassName()

class ConsoleReporterVec3(ReporterVec3):
    r"""
    A reporter that simply prints quantities to the console
    (command window or terminal), perhaps to monitor the progress of a simulation
    as it executes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConsoleReporter_< SimTK::Vec3 > *":
        return _common.ConsoleReporterVec3_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.ConsoleReporterVec3_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.ConsoleReporterVec3_getClassName()

    def clone(self) -> "OpenSim::ConsoleReporter_< SimTK::Vec3 > *":
        return _common.ConsoleReporterVec3_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.ConsoleReporterVec3_getConcreteClassName(self)

    def __init__(self):
        _common.ConsoleReporterVec3_swiginit(self, _common.new_ConsoleReporterVec3())
    __swig_destroy__ = _common.delete_ConsoleReporterVec3

# Register ConsoleReporterVec3 in _common:
_common.ConsoleReporterVec3_swigregister(ConsoleReporterVec3)

def ConsoleReporterVec3_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ConsoleReporter_< SimTK::Vec3 > *":
    return _common.ConsoleReporterVec3_safeDownCast(obj)

def ConsoleReporterVec3_getClassName() -> "std::string const &":
    return _common.ConsoleReporterVec3_getClassName()

class GCVSplineSet(FunctionSet):
    r"""
    A class for holding a set of generalized cross-validated splines.

    See also: GCVSpline
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::GCVSplineSet *":
        return _common.GCVSplineSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _common.GCVSplineSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _common.GCVSplineSet_getClassName()

    def clone(self) -> "OpenSim::GCVSplineSet *":
        return _common.GCVSplineSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _common.GCVSplineSet_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct a set of generalized cross-validated splines from file.

        :type aFileName: string
        :param aFileName: Name of the file.

        |

        *Overload 2:*

        Construct a set of generalized cross-validated splines based on the
        states stored in an Storage object.

        Each column in the Storage object is fit with a spline of the specified
        degree and is named the name of its corresponding column label. Note that
        column labels in the storage object are assumed to be tab delimited.

        :type aDegree: int
        :param aDegree: Degree of the constructed splines (1, 3, 5, or 7).
        :type aStore: :py:class:`Storage`
        :param aStore: Storage object.
        :type aErrorVariance: float, optional
        :param aErrorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the Storage.  If different
            variances should be set for the various columns, you will need to
            construct each GCVSpline individually.
        See also: Storage
        See also: GCVSpline

        |

        *Overload 3:*

        Construct a set of generalized cross-validated splines based on the
        states stored in an Storage object.

        Each column in the Storage object is fit with a spline of the specified
        degree and is named the name of its corresponding column label. Note that
        column labels in the storage object are assumed to be tab delimited.

        :type aDegree: int
        :param aDegree: Degree of the constructed splines (1, 3, 5, or 7).
        :type aStore: :py:class:`Storage`
        :param aStore: Storage object.
        :param aErrorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the Storage.  If different
            variances should be set for the various columns, you will need to
            construct each GCVSpline individually.
        See also: Storage
        See also: GCVSpline

        |

        *Overload 4:*

        Construct a set of generalized cross-validated splines based on the
        states stored in a TimeSeriesTable.

        Each column in the TimeSeriesTable is fit with a spline of the specified
        degree and is named the name of its corresponding column label.

        :type table: :py:class:`TimeSeriesTable`
        :param table: TimeSeriesTable object.
        :type labels: std::vector< std::string,std::allocator< std::string > >, optional
        :param labels: Columns to use from TimeSeriesTable.
        :type degree: int, optional
        :param degree: Degree of the constructed splines (1, 3, 5, or 7).
        :type errorVariance: float, optional
        :param errorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the TimeSeriesTable.  If
            different variances should be set for the various columns, you will need
            to construct each GCVSpline individually.
        See also: TimeSeriesTable.
        See also: GCVSpline

        |

        *Overload 5:*

        Construct a set of generalized cross-validated splines based on the
        states stored in a TimeSeriesTable.

        Each column in the TimeSeriesTable is fit with a spline of the specified
        degree and is named the name of its corresponding column label.

        :type table: :py:class:`TimeSeriesTable`
        :param table: TimeSeriesTable object.
        :type labels: std::vector< std::string,std::allocator< std::string > >, optional
        :param labels: Columns to use from TimeSeriesTable.
        :type degree: int, optional
        :param degree: Degree of the constructed splines (1, 3, 5, or 7).
        :param errorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the TimeSeriesTable.  If
            different variances should be set for the various columns, you will need
            to construct each GCVSpline individually.
        See also: TimeSeriesTable.
        See also: GCVSpline

        |

        *Overload 6:*

        Construct a set of generalized cross-validated splines based on the
        states stored in a TimeSeriesTable.

        Each column in the TimeSeriesTable is fit with a spline of the specified
        degree and is named the name of its corresponding column label.

        :type table: :py:class:`TimeSeriesTable`
        :param table: TimeSeriesTable object.
        :type labels: std::vector< std::string,std::allocator< std::string > >, optional
        :param labels: Columns to use from TimeSeriesTable.
        :param degree: Degree of the constructed splines (1, 3, 5, or 7).
        :param errorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the TimeSeriesTable.  If
            different variances should be set for the various columns, you will need
            to construct each GCVSpline individually.
        See also: TimeSeriesTable.
        See also: GCVSpline

        |

        *Overload 7:*

        Construct a set of generalized cross-validated splines based on the
        states stored in a TimeSeriesTable.

        Each column in the TimeSeriesTable is fit with a spline of the specified
        degree and is named the name of its corresponding column label.

        :type table: :py:class:`TimeSeriesTable`
        :param table: TimeSeriesTable object.
        :param labels: Columns to use from TimeSeriesTable.
        :param degree: Degree of the constructed splines (1, 3, 5, or 7).
        :param errorVariance: Estimate of the variance of the error in the data
            to be fit.  If negative, the variance will be estimated.  If 0.0, the
            fit will try to fit the data points exactly- no smoothing.  If
            positive, the fits will be smoothed according to the specified variance.
            The larger the error variance, the more the smoothing.  Note that this is
            the error variance assumed for each column in the TimeSeriesTable.  If
            different variances should be set for the various columns, you will need
            to construct each GCVSpline individually.
        See also: TimeSeriesTable.
        See also: GCVSpline
        """
        _common.GCVSplineSet_swiginit(self, _common.new_GCVSplineSet(*args))
    __swig_destroy__ = _common.delete_GCVSplineSet

    def getGCVSpline(self, aIndex: "int") -> "OpenSim::GCVSpline *":
        r"""
        Get the function at a specified index.

        :type aIndex: int
        :param aIndex: Index of the desired function:  0 <= aIndex < getSize().
        :rtype: :py:class:`GCVSpline`
        :return: Function at index aIndex.  If aIndex is not a valid value NULL is
                    returned.
        """
        return _common.GCVSplineSet_getGCVSpline(self, aIndex)

    def getMinX(self) -> "double":
        return _common.GCVSplineSet_getMinX(self)

    def getMaxX(self) -> "double":
        return _common.GCVSplineSet_getMaxX(self)

    def constructStorage(self, aDerivOrder: "int", aDX: "double"=-1) -> "OpenSim::Storage *":
        r"""
        Construct a storage object (see Storage) for this spline set or for
        some derivative of this spline set.

        :type aDerivOrder: int
        :param aDerivOrder: Derivative order.  0 constructs from the spline,
            1 constructs from the first derivative of the spline, 2 constructs from
            the second derivative of the spline, etc.
        :type aDX: float, optional
        :param aDX: Spacing of the data points in the independent variable.  If
            negative the spacing of the independent variable is taken from the
            original data, as determined from the first non-NULL spline in the set.
            aDX has a default value of -1.
        :rtype: :py:class:`Storage`
        :return: Storage object.  If a valid storage object cannot be constructed
            NULL is returned.
        See also: Storage
        """
        return _common.GCVSplineSet_constructStorage(self, aDerivOrder, aDX)

# Register GCVSplineSet in _common:
_common.GCVSplineSet_swigregister(GCVSplineSet)

def GCVSplineSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::GCVSplineSet *":
    return _common.GCVSplineSet_safeDownCast(obj)

def GCVSplineSet_getClassName() -> "std::string const &":
    return _common.GCVSplineSet_getClassName()



