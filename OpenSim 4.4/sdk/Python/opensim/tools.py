# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tools
else:
    import _tools

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tools.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _tools.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tools.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _tools.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _tools.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _tools.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _tools.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _tools.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _tools.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _tools.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tools.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _tools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _tools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _tools.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _tools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _tools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tools:
_tools.SwigPyIterator_swigregister(SwigPyIterator)

import opensim.analyses
import opensim.actuators
import opensim.simulation
import opensim.common
import opensim.simbody
class IKTask(opensim.common.OpenSimObject):
    r"""Author: Eran Guendelman, Ayman Habib"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKTask *":
        return _tools.IKTask_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.IKTask_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.IKTask_getClassName()

    def clone(self) -> "OpenSim::IKTask *":
        return _tools.IKTask_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.IKTask_getConcreteClassName(self)

    def getApply(self) -> "bool":
        return _tools.IKTask_getApply(self)

    def setApply(self, aApply: "bool") -> "void":
        return _tools.IKTask_setApply(self, aApply)

    def getWeight(self) -> "double":
        return _tools.IKTask_getWeight(self)

    def setWeight(self, weight: "double") -> "void":
        return _tools.IKTask_setWeight(self, weight)
    __swig_destroy__ = _tools.delete_IKTask

# Register IKTask in _tools:
_tools.IKTask_swigregister(IKTask)

def IKTask_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKTask *":
    return _tools.IKTask_safeDownCast(obj)

def IKTask_getClassName() -> "std::string const &":
    return _tools.IKTask_getClassName()

class SetIKTasks(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::IKTask,OpenSim::Object > *":
        return _tools.SetIKTasks_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.SetIKTasks_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.SetIKTasks_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::IKTask,OpenSim::Object > *":
        return _tools.SetIKTasks_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.SetIKTasks_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_SetIKTasks

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::IKTask,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _tools.SetIKTasks_swiginit(self, _tools.new_SetIKTasks(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _tools.SetIKTasks_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _tools.SetIKTasks_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _tools.SetIKTasks_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _tools.SetIKTasks_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`IKTask`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _tools.SetIKTasks_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _tools.SetIKTasks_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "IKTask") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`IKTask`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetIKTasks_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "IKTask") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`IKTask`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetIKTasks_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "IKTask") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`IKTask`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _tools.SetIKTasks_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`IKTask`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _tools.SetIKTasks_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _tools.SetIKTasks_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "IKTask", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`IKTask`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _tools.SetIKTasks_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::IKTask &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`IKTask`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`IKTask`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _tools.SetIKTasks_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _tools.SetIKTasks_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _tools.SetIKTasks_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _tools.SetIKTasks_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _tools.SetIKTasks_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _tools.SetIKTasks_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _tools.SetIKTasks_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _tools.SetIKTasks_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _tools.SetIKTasks_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _tools.SetIKTasks_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetIKTasks in _tools:
_tools.SetIKTasks_swigregister(SetIKTasks)

def SetIKTasks_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::IKTask,OpenSim::Object > *":
    return _tools.SetIKTasks_safeDownCast(obj)

def SetIKTasks_getClassName() -> "std::string const &":
    return _tools.SetIKTasks_getClassName()

class IKMarkerTask(IKTask):
    r"""
    Authors: Eran Guendelman, Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKMarkerTask *":
        return _tools.IKMarkerTask_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.IKMarkerTask_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.IKMarkerTask_getClassName()

    def clone(self) -> "OpenSim::IKMarkerTask *":
        return _tools.IKMarkerTask_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.IKMarkerTask_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.IKMarkerTask_swiginit(self, _tools.new_IKMarkerTask(*args))
    __swig_destroy__ = _tools.delete_IKMarkerTask

# Register IKMarkerTask in _tools:
_tools.IKMarkerTask_swigregister(IKMarkerTask)

def IKMarkerTask_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKMarkerTask *":
    return _tools.IKMarkerTask_safeDownCast(obj)

def IKMarkerTask_getClassName() -> "std::string const &":
    return _tools.IKMarkerTask_getClassName()

class IKCoordinateTask(IKTask):
    r"""
    Authors: Eran Guendelman
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKCoordinateTask *":
        return _tools.IKCoordinateTask_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.IKCoordinateTask_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.IKCoordinateTask_getClassName()

    def clone(self) -> "OpenSim::IKCoordinateTask *":
        return _tools.IKCoordinateTask_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.IKCoordinateTask_getConcreteClassName(self)
    DefaultValue = _tools.IKCoordinateTask_DefaultValue
    ManualValue = _tools.IKCoordinateTask_ManualValue
    FromFile = _tools.IKCoordinateTask_FromFile

    def __init__(self, *args):
        _tools.IKCoordinateTask_swiginit(self, _tools.new_IKCoordinateTask(*args))

    def setValueType(self, type: "OpenSim::IKCoordinateTask::ValueType") -> "void":
        return _tools.IKCoordinateTask_setValueType(self, type)

    def getValueType(self) -> "OpenSim::IKCoordinateTask::ValueType":
        return _tools.IKCoordinateTask_getValueType(self)

    def getValue(self) -> "double":
        return _tools.IKCoordinateTask_getValue(self)

    def setValue(self, value: "double") -> "void":
        return _tools.IKCoordinateTask_setValue(self, value)

    @staticmethod
    def ValueTypeToString(type: "OpenSim::IKCoordinateTask::ValueType") -> "std::string":
        return _tools.IKCoordinateTask_ValueTypeToString(type)

    @staticmethod
    def StringToValueType(str: "std::string const &") -> "OpenSim::IKCoordinateTask::ValueType":
        return _tools.IKCoordinateTask_StringToValueType(str)
    __swig_destroy__ = _tools.delete_IKCoordinateTask

# Register IKCoordinateTask in _tools:
_tools.IKCoordinateTask_swigregister(IKCoordinateTask)

def IKCoordinateTask_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKCoordinateTask *":
    return _tools.IKCoordinateTask_safeDownCast(obj)

def IKCoordinateTask_getClassName() -> "std::string const &":
    return _tools.IKCoordinateTask_getClassName()

def IKCoordinateTask_ValueTypeToString(type: "OpenSim::IKCoordinateTask::ValueType") -> "std::string":
    return _tools.IKCoordinateTask_ValueTypeToString(type)

def IKCoordinateTask_StringToValueType(str: "std::string const &") -> "OpenSim::IKCoordinateTask::ValueType":
    return _tools.IKCoordinateTask_StringToValueType(str)

class IKTaskSet(SetIKTasks):
    r"""
    Authors: Eran Guendelman
    Version: 1.0
    - Added constructor from a file for use in GUI. -Ayman 02/20/07
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKTaskSet *":
        return _tools.IKTaskSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.IKTaskSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.IKTaskSet_getClassName()

    def clone(self) -> "OpenSim::IKTaskSet *":
        return _tools.IKTaskSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.IKTaskSet_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.IKTaskSet_swiginit(self, _tools.new_IKTaskSet(*args))

    def createMarkerWeightSet(self, aWeights: "SetMarkerWeights") -> "void":
        return _tools.IKTaskSet_createMarkerWeightSet(self, aWeights)

    def adoptAndAppend(self, aIKTask):
        aIKTask._markAdopted()
        return super(IKTaskSet, self).adoptAndAppend(aIKTask)

    __swig_destroy__ = _tools.delete_IKTaskSet

# Register IKTaskSet in _tools:
_tools.IKTaskSet_swigregister(IKTaskSet)

def IKTaskSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IKTaskSet *":
    return _tools.IKTaskSet_safeDownCast(obj)

def IKTaskSet_getClassName() -> "std::string const &":
    return _tools.IKTaskSet_getClassName()

class MarkerPair(opensim.common.OpenSimObject):
    r"""
    A class for holding the names of a pair of markers (for making
    measurements on a model).

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPair *":
        return _tools.MarkerPair_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.MarkerPair_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.MarkerPair_getClassName()

    def clone(self) -> "OpenSim::MarkerPair *":
        return _tools.MarkerPair_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.MarkerPair_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.MarkerPair_swiginit(self, _tools.new_MarkerPair(*args))
    __swig_destroy__ = _tools.delete_MarkerPair

    def copyData(self, aMarkerPair: "MarkerPair") -> "void":
        return _tools.MarkerPair_copyData(self, aMarkerPair)

    def getMarkerNames(self, aName1: "std::string &", aName2: "std::string &") -> "void":
        return _tools.MarkerPair_getMarkerNames(self, aName1, aName2)

    def getMarkerName(self, i: "int") -> "std::string const &":
        return _tools.MarkerPair_getMarkerName(self, i)

    def setMarkerName(self, i: "int", aName: "std::string const &") -> "void":
        return _tools.MarkerPair_setMarkerName(self, i, aName)

# Register MarkerPair in _tools:
_tools.MarkerPair_swigregister(MarkerPair)

def MarkerPair_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPair *":
    return _tools.MarkerPair_safeDownCast(obj)

def MarkerPair_getClassName() -> "std::string const &":
    return _tools.MarkerPair_getClassName()

class SetMarkerPairs(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MarkerPair,OpenSim::Object > *":
        return _tools.SetMarkerPairs_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.SetMarkerPairs_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.SetMarkerPairs_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::MarkerPair,OpenSim::Object > *":
        return _tools.SetMarkerPairs_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.SetMarkerPairs_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_SetMarkerPairs

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::MarkerPair,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _tools.SetMarkerPairs_swiginit(self, _tools.new_SetMarkerPairs(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _tools.SetMarkerPairs_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _tools.SetMarkerPairs_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _tools.SetMarkerPairs_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _tools.SetMarkerPairs_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`MarkerPair`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _tools.SetMarkerPairs_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _tools.SetMarkerPairs_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "MarkerPair") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`MarkerPair`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetMarkerPairs_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "MarkerPair") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`MarkerPair`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetMarkerPairs_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "MarkerPair") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerPair`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _tools.SetMarkerPairs_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`MarkerPair`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _tools.SetMarkerPairs_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _tools.SetMarkerPairs_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "MarkerPair", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`MarkerPair`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _tools.SetMarkerPairs_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::MarkerPair &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`MarkerPair`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`MarkerPair`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _tools.SetMarkerPairs_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _tools.SetMarkerPairs_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _tools.SetMarkerPairs_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _tools.SetMarkerPairs_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _tools.SetMarkerPairs_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _tools.SetMarkerPairs_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _tools.SetMarkerPairs_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _tools.SetMarkerPairs_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _tools.SetMarkerPairs_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _tools.SetMarkerPairs_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMarkerPairs in _tools:
_tools.SetMarkerPairs_swigregister(SetMarkerPairs)

def SetMarkerPairs_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::MarkerPair,OpenSim::Object > *":
    return _tools.SetMarkerPairs_safeDownCast(obj)

def SetMarkerPairs_getClassName() -> "std::string const &":
    return _tools.SetMarkerPairs_getClassName()

class MarkerPairSet(SetMarkerPairs):
    r"""
    A class for holding a set of SimmMarkerPairs.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPairSet *":
        return _tools.MarkerPairSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.MarkerPairSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.MarkerPairSet_getClassName()

    def clone(self) -> "OpenSim::MarkerPairSet *":
        return _tools.MarkerPairSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.MarkerPairSet_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.MarkerPairSet_swiginit(self, _tools.new_MarkerPairSet(*args))
    __swig_destroy__ = _tools.delete_MarkerPairSet

    def adoptAndAppend(self, aMarkerPair):
        aMarkerPair._markAdopted()
        return super(MarkerPairSet, self).adoptAndAppend(aMarkerPair)


# Register MarkerPairSet in _tools:
_tools.MarkerPairSet_swigregister(MarkerPairSet)

def MarkerPairSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPairSet *":
    return _tools.MarkerPairSet_safeDownCast(obj)

def MarkerPairSet_getClassName() -> "std::string const &":
    return _tools.MarkerPairSet_getClassName()

class Measurement(opensim.common.OpenSimObject):
    r"""
    A class implementing a measurement (the distance between one or more pairs
    of markers, used to scale a model).

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Measurement *":
        return _tools.Measurement_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.Measurement_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.Measurement_getClassName()

    def clone(self) -> "OpenSim::Measurement *":
        return _tools.Measurement_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.Measurement_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.Measurement_swiginit(self, _tools.new_Measurement(*args))
    __swig_destroy__ = _tools.delete_Measurement

    def copyData(self, aMeasurement: "Measurement") -> "void":
        return _tools.Measurement_copyData(self, aMeasurement)

    def getBodyScaleSet(self) -> "OpenSim::BodyScaleSet &":
        return _tools.Measurement_getBodyScaleSet(self)

    def getMarkerPairSet(self) -> "OpenSim::MarkerPairSet &":
        return _tools.Measurement_getMarkerPairSet(self)

    def getNumMarkerPairs(self) -> "int":
        return _tools.Measurement_getNumMarkerPairs(self)

    def getMarkerPair(self, aIndex: "int") -> "OpenSim::MarkerPair const &":
        return _tools.Measurement_getMarkerPair(self, aIndex)

    def getApply(self) -> "bool":
        return _tools.Measurement_getApply(self)

    def setApply(self, aApply: "bool") -> "void":
        return _tools.Measurement_setApply(self, aApply)

    def applyScaleFactor(self, aFactor: "double", aScaleSet: "ScaleSet") -> "void":
        return _tools.Measurement_applyScaleFactor(self, aFactor, aScaleSet)

    @staticmethod
    def registerTypes() -> "void":
        return _tools.Measurement_registerTypes()

# Register Measurement in _tools:
_tools.Measurement_swigregister(Measurement)

def Measurement_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Measurement *":
    return _tools.Measurement_safeDownCast(obj)

def Measurement_getClassName() -> "std::string const &":
    return _tools.Measurement_getClassName()

def Measurement_registerTypes() -> "void":
    return _tools.Measurement_registerTypes()

class SetMeasurements(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Measurement,OpenSim::Object > *":
        return _tools.SetMeasurements_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.SetMeasurements_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.SetMeasurements_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::Measurement,OpenSim::Object > *":
        return _tools.SetMeasurements_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.SetMeasurements_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_SetMeasurements

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::Measurement,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _tools.SetMeasurements_swiginit(self, _tools.new_SetMeasurements(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _tools.SetMeasurements_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _tools.SetMeasurements_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _tools.SetMeasurements_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _tools.SetMeasurements_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`Measurement`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _tools.SetMeasurements_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _tools.SetMeasurements_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "Measurement") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`Measurement`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetMeasurements_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "Measurement") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`Measurement`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetMeasurements_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "Measurement") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Measurement`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _tools.SetMeasurements_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`Measurement`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _tools.SetMeasurements_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _tools.SetMeasurements_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "Measurement", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`Measurement`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _tools.SetMeasurements_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::Measurement &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`Measurement`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`Measurement`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _tools.SetMeasurements_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _tools.SetMeasurements_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _tools.SetMeasurements_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _tools.SetMeasurements_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _tools.SetMeasurements_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _tools.SetMeasurements_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _tools.SetMeasurements_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _tools.SetMeasurements_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _tools.SetMeasurements_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _tools.SetMeasurements_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetMeasurements in _tools:
_tools.SetMeasurements_swigregister(SetMeasurements)

def SetMeasurements_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::Measurement,OpenSim::Object > *":
    return _tools.SetMeasurements_safeDownCast(obj)

def SetMeasurements_getClassName() -> "std::string const &":
    return _tools.SetMeasurements_getClassName()

class MeasurementSet(SetMeasurements):
    r"""
    A class for holding a set of measurements.

    Authors: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MeasurementSet *":
        return _tools.MeasurementSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.MeasurementSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.MeasurementSet_getClassName()

    def clone(self) -> "OpenSim::MeasurementSet *":
        return _tools.MeasurementSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.MeasurementSet_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.MeasurementSet_swiginit(self, _tools.new_MeasurementSet(*args))
    __swig_destroy__ = _tools.delete_MeasurementSet

    def adoptAndAppend(self, aMeasurement):
        aMeasurement._markAdopted()
        return super(MeasurementSet, self).adoptAndAppend(aMeasurement)


# Register MeasurementSet in _tools:
_tools.MeasurementSet_swigregister(MeasurementSet)

def MeasurementSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MeasurementSet *":
    return _tools.MeasurementSet_safeDownCast(obj)

def MeasurementSet_getClassName() -> "std::string const &":
    return _tools.MeasurementSet_getClassName()

class GenericModelMaker(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing
    a generic musculoskeletal model.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::GenericModelMaker *":
        return _tools.GenericModelMaker_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.GenericModelMaker_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.GenericModelMaker_getClassName()

    def clone(self) -> "OpenSim::GenericModelMaker *":
        return _tools.GenericModelMaker_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.GenericModelMaker_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.GenericModelMaker_swiginit(self, _tools.new_GenericModelMaker(*args))
    __swig_destroy__ = _tools.delete_GenericModelMaker

    def copyData(self, aGenericModelMaker: "GenericModelMaker") -> "void":
        return _tools.GenericModelMaker_copyData(self, aGenericModelMaker)

    def processModel(self, *args) -> "OpenSim::Model *":
        return _tools.GenericModelMaker_processModel(self, *args)

    @staticmethod
    def registerTypes() -> "void":
        return _tools.GenericModelMaker_registerTypes()

    def getModelFileName(self) -> "std::string const &":
        r"""Get file name for generic model"""
        return _tools.GenericModelMaker_getModelFileName(self)

    def setModelFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.GenericModelMaker_setModelFileName(self, aFileName)

    def getMarkerSetFileName(self) -> "std::string const &":
        return _tools.GenericModelMaker_getMarkerSetFileName(self)

    def setMarkerSetFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.GenericModelMaker_setMarkerSetFileName(self, aFileName)

# Register GenericModelMaker in _tools:
_tools.GenericModelMaker_swigregister(GenericModelMaker)

def GenericModelMaker_safeDownCast(obj: "OpenSimObject") -> "OpenSim::GenericModelMaker *":
    return _tools.GenericModelMaker_safeDownCast(obj)

def GenericModelMaker_getClassName() -> "std::string const &":
    return _tools.GenericModelMaker_getClassName()

def GenericModelMaker_registerTypes() -> "void":
    return _tools.GenericModelMaker_registerTypes()

class ModelScaler(opensim.common.OpenSimObject):
    r"""
    A class for scaling a model. The default method of scaling involves
    measuring distances between pairs of markers on the model and in a
    static pose to determine scale factors.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelScaler *":
        return _tools.ModelScaler_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.ModelScaler_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.ModelScaler_getClassName()

    def clone(self) -> "OpenSim::ModelScaler *":
        return _tools.ModelScaler_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.ModelScaler_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.ModelScaler_swiginit(self, _tools.new_ModelScaler(*args))
    __swig_destroy__ = _tools.delete_ModelScaler

    def copyData(self, aModelScaler: "ModelScaler") -> "void":
        return _tools.ModelScaler_copyData(self, aModelScaler)

    def processModel(self, *args) -> "bool":
        return _tools.ModelScaler_processModel(self, *args)

    @staticmethod
    def registerTypes() -> "void":
        return _tools.ModelScaler_registerTypes()

    def addMeasurement(self, aMeasurement: "Measurement") -> "void":
        r"""add a measurement"""
        val = _tools.ModelScaler_addMeasurement(self, aMeasurement)

        aMeasurement._markAdopted()


        return val


    def addScale(self, aScale: "Scale") -> "void":
        r"""add a scale factor to current scaleSet"""
        val = _tools.ModelScaler_addScale(self, aScale)

        aScale._markAdopted()


        return val


    def getApply(self) -> "bool":
        return _tools.ModelScaler_getApply(self)

    def setApply(self, aApply: "bool") -> "void":
        return _tools.ModelScaler_setApply(self, aApply)

    def getMeasurementSet(self) -> "OpenSim::MeasurementSet &":
        return _tools.ModelScaler_getMeasurementSet(self)

    def setMeasurementSet(self, measurementSet: "MeasurementSet") -> "void":
        return _tools.ModelScaler_setMeasurementSet(self, measurementSet)

    def getScaleSet(self) -> "OpenSim::ScaleSet &":
        return _tools.ModelScaler_getScaleSet(self)

    def setScaleSetFile(self, aScaleSetFilename: "std::string const &") -> "void":
        return _tools.ModelScaler_setScaleSetFile(self, aScaleSetFilename)

    def getTimeRange(self) -> "OpenSim::Array< double > const &":
        return _tools.ModelScaler_getTimeRange(self)

    def setTimeRange(self, timeRange: "ArrayDouble") -> "void":
        return _tools.ModelScaler_setTimeRange(self, timeRange)

    def getPreserveMassDist(self) -> "bool":
        return _tools.ModelScaler_getPreserveMassDist(self)

    def setPreserveMassDist(self, preserveMassDist: "bool") -> "void":
        return _tools.ModelScaler_setPreserveMassDist(self, preserveMassDist)

    def getScalingOrder(self) -> "OpenSim::Array< std::string > &":
        return _tools.ModelScaler_getScalingOrder(self)

    def setScalingOrder(self, scalingOrder: "ArrayStr") -> "void":
        return _tools.ModelScaler_setScalingOrder(self, scalingOrder)

    def getMarkerFileName(self) -> "std::string const &":
        return _tools.ModelScaler_getMarkerFileName(self)

    def setMarkerFileName(self, aMarkerFileName: "std::string const &") -> "void":
        return _tools.ModelScaler_setMarkerFileName(self, aMarkerFileName)

    def getOutputModelFileName(self) -> "std::string const &":
        return _tools.ModelScaler_getOutputModelFileName(self)

    def setOutputModelFileName(self, aOutputModelFileName: "std::string const &") -> "void":
        return _tools.ModelScaler_setOutputModelFileName(self, aOutputModelFileName)

    def getOutputScaleFileName(self) -> "std::string const &":
        return _tools.ModelScaler_getOutputScaleFileName(self)

    def setOutputScaleFileName(self, aOutputScaleFileName: "std::string const &") -> "void":
        return _tools.ModelScaler_setOutputScaleFileName(self, aOutputScaleFileName)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _tools.ModelScaler_setPrintResultFiles(self, aToWrite)

    def computeMeasurementScaleFactor(self, s: "State", aModel: "Model", aMarkerData: "MarkerData", aMeasurement: "Measurement") -> "double":
        return _tools.ModelScaler_computeMeasurementScaleFactor(self, s, aModel, aMarkerData, aMeasurement)

# Register ModelScaler in _tools:
_tools.ModelScaler_swigregister(ModelScaler)

def ModelScaler_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelScaler *":
    return _tools.ModelScaler_safeDownCast(obj)

def ModelScaler_getClassName() -> "std::string const &":
    return _tools.ModelScaler_getClassName()

def ModelScaler_registerTypes() -> "void":
    return _tools.ModelScaler_registerTypes()

class MarkerPlacer(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how to place markers
    on a model (presumably after it has been scaled to fit a subject).

    MarkerPlacer is bundled with ModelScaler and GenericModelMaker to
    form the ScaleTool

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPlacer *":
        return _tools.MarkerPlacer_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.MarkerPlacer_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.MarkerPlacer_getClassName()

    def clone(self) -> "OpenSim::MarkerPlacer *":
        return _tools.MarkerPlacer_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.MarkerPlacer_swiginit(self, _tools.new_MarkerPlacer(*args))
    __swig_destroy__ = _tools.delete_MarkerPlacer

    def copyData(self, aMarkerPlacementParams: "MarkerPlacer") -> "void":
        return _tools.MarkerPlacer_copyData(self, aMarkerPlacementParams)

    def processModel(self, *args) -> "bool":
        return _tools.MarkerPlacer_processModel(self, *args)

    def getApply(self) -> "bool":
        return _tools.MarkerPlacer_getApply(self)

    def setApply(self, aApply: "bool") -> "void":
        return _tools.MarkerPlacer_setApply(self, aApply)

    def getStaticPoseFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getStaticPoseFileName(self)

    def setStaticPoseFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setStaticPoseFileName(self, aFileName)

    def getTimeRange(self) -> "OpenSim::Array< double > const &":
        return _tools.MarkerPlacer_getTimeRange(self)

    def setTimeRange(self, timeRange: "ArrayDouble") -> "void":
        return _tools.MarkerPlacer_setTimeRange(self, timeRange)

    def getIKTaskSet(self) -> "OpenSim::IKTaskSet &":
        return _tools.MarkerPlacer_getIKTaskSet(self)

    def getCoordinateFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getCoordinateFileName(self)

    def setCoordinateFileName(self, aCoordinateFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setCoordinateFileName(self, aCoordinateFileName)

    def getMarkerFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getMarkerFileName(self)

    def setMarkerFileName(self, aMarkerFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setMarkerFileName(self, aMarkerFileName)

    def getMaxMarkerMovement(self) -> "double":
        return _tools.MarkerPlacer_getMaxMarkerMovement(self)

    def setMaxMarkerMovement(self, aMaxMarkerMovement: "double") -> "void":
        return _tools.MarkerPlacer_setMaxMarkerMovement(self, aMaxMarkerMovement)

    def getOutputModelFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getOutputModelFileName(self)

    def setOutputModelFileName(self, aOutputModelFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setOutputModelFileName(self, aOutputModelFileName)

    def getOutputMarkerFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getOutputMarkerFileName(self)

    def setOutputMarkerFileName(self, outputMarkerFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setOutputMarkerFileName(self, outputMarkerFileName)

    def getOutputMotionFileName(self) -> "std::string const &":
        return _tools.MarkerPlacer_getOutputMotionFileName(self)

    def setOutputMotionFileName(self, outputMotionFileName: "std::string const &") -> "void":
        return _tools.MarkerPlacer_setOutputMotionFileName(self, outputMotionFileName)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _tools.MarkerPlacer_setPrintResultFiles(self, aToWrite)

    def getMoveModelMarkers(self) -> "bool":
        return _tools.MarkerPlacer_getMoveModelMarkers(self)

    def setMoveModelMarkers(self, aMove: "bool") -> "void":
        return _tools.MarkerPlacer_setMoveModelMarkers(self, aMove)

    def getOutputStorage(self) -> "OpenSim::Storage *":
        return _tools.MarkerPlacer_getOutputStorage(self)

# Register MarkerPlacer in _tools:
_tools.MarkerPlacer_swigregister(MarkerPlacer)

def MarkerPlacer_safeDownCast(obj: "OpenSimObject") -> "OpenSim::MarkerPlacer *":
    return _tools.MarkerPlacer_safeDownCast(obj)

def MarkerPlacer_getClassName() -> "std::string const &":
    return _tools.MarkerPlacer_getClassName()

class ScaleTool(opensim.common.OpenSimObject):
    r"""
    A class implementing a set of parameters describing how to scale a model
    to fit a subject, place markers on it, and do IK on one or more motion
    trials.

    Author: Peter Loan
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScaleTool *":
        return _tools.ScaleTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.ScaleTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.ScaleTool_getClassName()

    def clone(self) -> "OpenSim::ScaleTool *":
        return _tools.ScaleTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.ScaleTool_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.ScaleTool_swiginit(self, _tools.new_ScaleTool(*args))
    __swig_destroy__ = _tools.delete_ScaleTool

    def copyData(self, aSubject: "ScaleTool") -> "void":
        return _tools.ScaleTool_copyData(self, aSubject)

    def createModel(self) -> "OpenSim::Model *":
        return _tools.ScaleTool_createModel(self)

    def getGenericModelMaker(self) -> "OpenSim::GenericModelMaker const &":
        return _tools.ScaleTool_getGenericModelMaker(self)

    def getModelScaler(self) -> "OpenSim::ModelScaler const &":
        return _tools.ScaleTool_getModelScaler(self)

    def getMarkerPlacer(self) -> "OpenSim::MarkerPlacer const &":
        return _tools.ScaleTool_getMarkerPlacer(self)

    def run(self) -> "bool":
        r"""
         Run the scale tool. This first runs the ModelScaler, then runs the
        MarkerPlacer. This is the method called by the command line `scale`
        executable.
        :rtype: boolean
        :return: whether or not the scale procedure was successful.
        """
        return _tools.ScaleTool_run(self)

    def isDefaultGenericModelMaker(self) -> "bool":
        return _tools.ScaleTool_isDefaultGenericModelMaker(self)

    def isDefaultModelScaler(self) -> "bool":
        return _tools.ScaleTool_isDefaultModelScaler(self)

    def isDefaultMarkerPlacer(self) -> "bool":
        return _tools.ScaleTool_isDefaultMarkerPlacer(self)

    @staticmethod
    def registerTypes() -> "void":
        return _tools.ScaleTool_registerTypes()

    def getSubjectMass(self) -> "double":
        r""" Accessor methods to obtain model attributes"""
        return _tools.ScaleTool_getSubjectMass(self)

    def getSubjectAge(self) -> "double":
        return _tools.ScaleTool_getSubjectAge(self)

    def getSubjectHeight(self) -> "double":
        return _tools.ScaleTool_getSubjectHeight(self)

    def setSubjectMass(self, mass: "double") -> "void":
        return _tools.ScaleTool_setSubjectMass(self, mass)

    def setSubjectAge(self, age: "double") -> "void":
        return _tools.ScaleTool_setSubjectAge(self, age)

    def setSubjectHeight(self, height: "double") -> "void":
        return _tools.ScaleTool_setSubjectHeight(self, height)

    def getPathToSubject(self) -> "std::string const &":
        r"""
        Accessor methods to set and get path to Subject. This is needed
        since all file names referred to in the subject file are relative
        to the subject file.
        """
        return _tools.ScaleTool_getPathToSubject(self)

    def setPathToSubject(self, aPath: "std::string const &") -> "void":
        return _tools.ScaleTool_setPathToSubject(self, aPath)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _tools.ScaleTool_setPrintResultFiles(self, aToWrite)

# Register ScaleTool in _tools:
_tools.ScaleTool_swigregister(ScaleTool)

def ScaleTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ScaleTool *":
    return _tools.ScaleTool_safeDownCast(obj)

def ScaleTool_getClassName() -> "std::string const &":
    return _tools.ScaleTool_getClassName()

def ScaleTool_registerTypes() -> "void":
    return _tools.ScaleTool_registerTypes()

class Tool(opensim.common.OpenSimObject):
    r"""
    A Tool is an OpenSim abstraction that encapsulates an analysis or series of
    modeling and analysis steps. Its primary duty is to provide an interface
    for use by the GUI or as a standalone command line executable. It includes
    common methods for invoking the tool and performing routine I/O.


    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Tool *":
        return _tools.Tool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.Tool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.Tool_getClassName()

    def clone(self) -> "OpenSim::Tool *":
        return _tools.Tool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.Tool_getConcreteClassName(self)

    def copyProperty_results_directory(self, source: "Tool") -> "void":
        return _tools.Tool_copyProperty_results_directory(self, source)

    def append_results_directory(self, value: "std::string const &") -> "int":
        return _tools.Tool_append_results_directory(self, value)

    def constructProperty_results_directory(self, initValue: "std::string const &") -> "void":
        return _tools.Tool_constructProperty_results_directory(self, initValue)

    def get_results_directory(self, *args) -> "std::string const &":
        return _tools.Tool_get_results_directory(self, *args)

    def upd_results_directory(self, *args) -> "std::string &":
        return _tools.Tool_upd_results_directory(self, *args)

    def set_results_directory(self, *args) -> "void":
        return _tools.Tool_set_results_directory(self, *args)
    __swig_destroy__ = _tools.delete_Tool

    def run(self) -> "bool":
        r"""
        The run() method of a Tool embodies what would be the main() routine
               for a standalone program.  Therefore, any OpenSim main program can
               become a Tool executable from the GUI by making it a run() method for
               a new Tool.

               It is expected that the run() method be composed of a sequence of calls
               to underlying computational and reporting objects and should
        """
        return _tools.Tool_run(self)

    def getResultsDir(self) -> "std::string const &":
        r"""Get/set Results Directory, will replace with Property accessors eventually"""
        return _tools.Tool_getResultsDir(self)

    def setResultsDir(self, aString: "std::string const &") -> "void":
        return _tools.Tool_setResultsDir(self, aString)

# Register Tool in _tools:
_tools.Tool_swigregister(Tool)

def Tool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Tool *":
    return _tools.Tool_safeDownCast(obj)

def Tool_getClassName() -> "std::string const &":
    return _tools.Tool_getClassName()

class DynamicsTool(Tool):
    r"""
    An abstract Tool for defining tools for performing a dynamics analysis
    with a given model. For example, InverseDynamics and ForwardDynamics Tools
    derive from DynamicsTool, which provides convenient method for performing
    and dynamics analysis over or to produce a trajectory in time.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::DynamicsTool *":
        return _tools.DynamicsTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.DynamicsTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.DynamicsTool_getClassName()

    def clone(self) -> "OpenSim::DynamicsTool *":
        return _tools.DynamicsTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.DynamicsTool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_DynamicsTool

    def disableModelForces(self, model: "Model", s: "State", forcesByNameOrGroup: "ArrayStr") -> "void":
        r""" Modify model to exclude specified forces by disabling those identified by name or group"""
        return _tools.DynamicsTool_disableModelForces(self, model, s, forcesByNameOrGroup)

    def getExternalLoads(self) -> "OpenSim::ExternalLoads const &":
        return _tools.DynamicsTool_getExternalLoads(self)

    def updExternalLoads(self) -> "OpenSim::ExternalLoads &":
        return _tools.DynamicsTool_updExternalLoads(self)

    def getExternalLoadsFileName(self) -> "std::string const &":
        return _tools.DynamicsTool_getExternalLoadsFileName(self)

    def setExternalLoadsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.DynamicsTool_setExternalLoadsFileName(self, aFileName)

    def setModelFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.DynamicsTool_setModelFileName(self, aFileName)

    def getModelFileName(self) -> "std::string":
        return _tools.DynamicsTool_getModelFileName(self)

    def setStartTime(self, d: "double") -> "void":
        return _tools.DynamicsTool_setStartTime(self, d)

    def getStartTime(self) -> "double":
        return _tools.DynamicsTool_getStartTime(self)

    def setEndTime(self, d: "double") -> "void":
        return _tools.DynamicsTool_setEndTime(self, d)

    def getEndTime(self) -> "double":
        return _tools.DynamicsTool_getEndTime(self)

    def setModel(self, aModel: "Model") -> "void":
        return _tools.DynamicsTool_setModel(self, aModel)

    def setExcludedForces(self, aExcluded: "ArrayStr") -> "void":
        return _tools.DynamicsTool_setExcludedForces(self, aExcluded)

    def createExternalLoads(self, externalLoadsFileName: "std::string const &", model: "Model") -> "bool":
        return _tools.DynamicsTool_createExternalLoads(self, externalLoadsFileName, model)

    def modelHasExternalLoads(self) -> "bool":
        return _tools.DynamicsTool_modelHasExternalLoads(self)

    def removeExternalLoadsFromModel(self) -> "void":
        return _tools.DynamicsTool_removeExternalLoadsFromModel(self)

    def run(self) -> "bool":
        return _tools.DynamicsTool_run(self)

# Register DynamicsTool in _tools:
_tools.DynamicsTool_swigregister(DynamicsTool)

def DynamicsTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::DynamicsTool *":
    return _tools.DynamicsTool_safeDownCast(obj)

def DynamicsTool_getClassName() -> "std::string const &":
    return _tools.DynamicsTool_getClassName()

class InverseDynamicsTool(DynamicsTool):
    r"""
    A Tool that performs an Inverse Dynamics analysis with a given model.
    Inverse Dynamics is the solution for the generalized-coordinate forces that
    generate given generalized-coordinate accelerations at a given state.
    This Tool determines the state from provided coordinate trajectories as
    functions as that are twice differentiable to estimate velocities and
    accelerations.

    As an additional service, the InverseDynamicsTool can provide an equivalent
    body force (torque and force) applied to the joint frame. Since generalized
    forces include scaling (due to units conversion as well as coupling between
    translations and rotations, for example) they are not necessarily joint torques
    or forces.  OpenSim employs a pseudo inverse to find the smallest applied
    torque and/or force that will generate the equivalent generalized force.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseDynamicsTool *":
        return _tools.InverseDynamicsTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.InverseDynamicsTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.InverseDynamicsTool_getClassName()

    def clone(self) -> "OpenSim::InverseDynamicsTool *":
        return _tools.InverseDynamicsTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.InverseDynamicsTool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_InverseDynamicsTool

    def __init__(self, *args):
        _tools.InverseDynamicsTool_swiginit(self, _tools.new_InverseDynamicsTool(*args))

    @staticmethod
    def registerTypes() -> "void":
        return _tools.InverseDynamicsTool_registerTypes()

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.InverseDynamicsTool_updateFromXMLNode(self, aNode, versionNumber)

    def setCoordinateValues(self, aStorage: "Storage") -> "void":
        return _tools.InverseDynamicsTool_setCoordinateValues(self, aStorage)

    def getOutputGenForceFileName(self) -> "std::string":
        r"""get/set the name of the file to be used as output from the tool"""
        return _tools.InverseDynamicsTool_getOutputGenForceFileName(self)

    def setOutputGenForceFileName(self, desiredOutputFileName: "std::string const &") -> "void":
        return _tools.InverseDynamicsTool_setOutputGenForceFileName(self, desiredOutputFileName)

    def getCoordinatesFileName(self) -> "std::string const &":
        r"""get/set the name of the file containing coordinates"""
        return _tools.InverseDynamicsTool_getCoordinatesFileName(self)

    def setCoordinatesFileName(self, aCoordinateFile: "std::string const &") -> "void":
        r"""
        %Set the name of the coordinatesFile to be used. This call resets
            _coordinateValues as well.
        """
        return _tools.InverseDynamicsTool_setCoordinatesFileName(self, aCoordinateFile)

    def getLowpassCutoffFrequency(self) -> "double":
        return _tools.InverseDynamicsTool_getLowpassCutoffFrequency(self)

    def setLowpassCutoffFrequency(self, aFrequency: "double") -> "void":
        return _tools.InverseDynamicsTool_setLowpassCutoffFrequency(self, aFrequency)

    def run(self) -> "bool":
        return _tools.InverseDynamicsTool_run(self)

# Register InverseDynamicsTool in _tools:
_tools.InverseDynamicsTool_swigregister(InverseDynamicsTool)

def InverseDynamicsTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseDynamicsTool *":
    return _tools.InverseDynamicsTool_safeDownCast(obj)

def InverseDynamicsTool_getClassName() -> "std::string const &":
    return _tools.InverseDynamicsTool_getClassName()

def InverseDynamicsTool_registerTypes() -> "void":
    return _tools.InverseDynamicsTool_registerTypes()

class ForwardTool(opensim.simulation.AbstractTool):
    r"""
    A concrete tool for performing forward dynamics simulations

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForwardTool *":
        return _tools.ForwardTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.ForwardTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.ForwardTool_getClassName()

    def clone(self) -> "OpenSim::ForwardTool *":
        return _tools.ForwardTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.ForwardTool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_ForwardTool

    def __init__(self, *args):
        _tools.ForwardTool_swiginit(self, _tools.new_ForwardTool(*args))

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.ForwardTool_updateFromXMLNode(self, aNode, versionNumber)

    def setManager(self, m: "Manager") -> "void":
        return _tools.ForwardTool_setManager(self, m)

    def getManager(self) -> "OpenSim::Manager const &":
        return _tools.ForwardTool_getManager(self)

    def getStatesFileName(self) -> "std::string const &":
        return _tools.ForwardTool_getStatesFileName(self)

    def setStatesFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.ForwardTool_setStatesFileName(self, aFileName)

    def getUseSpecifiedDt(self) -> "bool":
        return _tools.ForwardTool_getUseSpecifiedDt(self)

    def setUseSpecifiedDt(self, aUseSpecifiedDt: "bool") -> "void":
        return _tools.ForwardTool_setUseSpecifiedDt(self, aUseSpecifiedDt)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _tools.ForwardTool_setPrintResultFiles(self, aToWrite)

    def run(self) -> "bool":
        return _tools.ForwardTool_run(self)

    def printResults(self) -> "void":
        r""" **(Deprecated)** Use setPrintResultFiles(true) and run() instead."""
        return _tools.ForwardTool_printResults(self)

    @staticmethod
    def Step(t: "double", t0: "double", t1: "double") -> "double":
        return _tools.ForwardTool_Step(t, t0, t1)

    @staticmethod
    def SigmaUp(tau: "double", to: "double", t: "double") -> "double":
        return _tools.ForwardTool_SigmaUp(tau, to, t)

    @staticmethod
    def SigmaDn(tau: "double", to: "double", t: "double") -> "double":
        return _tools.ForwardTool_SigmaDn(tau, to, t)

    def loadStatesStorage(self, statesFileName: "std::string &", rYStore: "OpenSim::Storage *&") -> "void":
        return _tools.ForwardTool_loadStatesStorage(self, statesFileName, rYStore)

    def getParsingLog(self) -> "std::string const &":
        return _tools.ForwardTool_getParsingLog(self)

# Register ForwardTool in _tools:
_tools.ForwardTool_swigregister(ForwardTool)

def ForwardTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ForwardTool *":
    return _tools.ForwardTool_safeDownCast(obj)

def ForwardTool_getClassName() -> "std::string const &":
    return _tools.ForwardTool_getClassName()

def ForwardTool_Step(t: "double", t0: "double", t1: "double") -> "double":
    return _tools.ForwardTool_Step(t, t0, t1)

def ForwardTool_SigmaUp(tau: "double", to: "double", t: "double") -> "double":
    return _tools.ForwardTool_SigmaUp(tau, to, t)

def ForwardTool_SigmaDn(tau: "double", to: "double", t: "double") -> "double":
    return _tools.ForwardTool_SigmaDn(tau, to, t)

class TrackingTask(opensim.common.OpenSimObject):
    r"""
    An abstract base class for specifying a target for a tracking problem.

    Author: Ayman Habib & Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TrackingTask *":
        return _tools.TrackingTask_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.TrackingTask_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.TrackingTask_getClassName()

    def clone(self) -> "OpenSim::TrackingTask *":
        return _tools.TrackingTask_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.TrackingTask_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_TrackingTask

    def setModel(self, aModel: "Model") -> "void":
        return _tools.TrackingTask_setModel(self, aModel)

    def getModel(self) -> "OpenSim::Model *":
        return _tools.TrackingTask_getModel(self)

    def setOn(self, aTrueFalse: "bool") -> "void":
        return _tools.TrackingTask_setOn(self, aTrueFalse)

    def getOn(self) -> "bool":
        return _tools.TrackingTask_getOn(self)

    def setWeight(self, aW0: "double", aW1: "double"=0.0, aW2: "double"=0.0) -> "void":
        return _tools.TrackingTask_setWeight(self, aW0, aW1, aW2)

    def setWeights(self, aWeights: "ArrayDouble") -> "void":
        return _tools.TrackingTask_setWeights(self, aWeights)

    def getWeight(self, aWhich: "int") -> "double":
        return _tools.TrackingTask_getWeight(self, aWhich)

    def getWeights(self) -> "OpenSim::Array< double > const &":
        return _tools.TrackingTask_getWeights(self)

    def getNumTaskFunctions(self) -> "int":
        return _tools.TrackingTask_getNumTaskFunctions(self)

    def setTaskFunctions(self, aF0: "Function", aF1: "Function"=None, aF2: "Function"=None) -> "void":
        return _tools.TrackingTask_setTaskFunctions(self, aF0, aF1, aF2)

# Register TrackingTask in _tools:
_tools.TrackingTask_swigregister(TrackingTask)

def TrackingTask_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TrackingTask *":
    return _tools.TrackingTask_safeDownCast(obj)

def TrackingTask_getClassName() -> "std::string const &":
    return _tools.TrackingTask_getClassName()

class CMC_Task(TrackingTask):
    r"""
    An abstract base class for specifying a task objective for
    a dynamic simulation.  This class supports joint, point, and orientation
    task objectives.  Specific implementations for these kinds of control
    tasks should inherit from this class.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Task *":
        return _tools.CMC_Task_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.CMC_Task_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.CMC_Task_getClassName()

    def clone(self) -> "OpenSim::CMC_Task *":
        return _tools.CMC_Task_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.CMC_Task_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_CMC_Task

    def setWRTBodyName(self, aBodyName: "std::string") -> "void":
        return _tools.CMC_Task_setWRTBodyName(self, aBodyName)

    def getWRTBodyName(self) -> "std::string":
        return _tools.CMC_Task_getWRTBodyName(self)

    def setExpressBodyName(self, aBodyName: "std::string") -> "void":
        return _tools.CMC_Task_setExpressBodyName(self, aBodyName)

    def getExpressBodyName(self) -> "std::string":
        return _tools.CMC_Task_getExpressBodyName(self)

    def setActive(self, a0: "bool", a1: "bool"=False, a2: "bool"=False) -> "void":
        return _tools.CMC_Task_setActive(self, a0, a1, a2)

    def getActive(self, aWhich: "int") -> "bool":
        return _tools.CMC_Task_getActive(self, aWhich)

    def setWeight(self, aW0: "double", aW1: "double"=0.0, aW2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setWeight(self, aW0, aW1, aW2)

    def getWeight(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getWeight(self, aWhich)

    def setKP(self, aK0: "double", aK1: "double"=0.0, aK2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setKP(self, aK0, aK1, aK2)

    def getKP(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getKP(self, aWhich)

    def setKV(self, aK0: "double", aK1: "double"=0.0, aK2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setKV(self, aK0, aK1, aK2)

    def getKV(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getKV(self, aWhich)

    def setKA(self, aK0: "double", aK1: "double"=0.0, aK2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setKA(self, aK0, aK1, aK2)

    def getKA(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getKA(self, aWhich)

    def setDirection_0(self, aR: "Vec3") -> "void":
        return _tools.CMC_Task_setDirection_0(self, aR)

    def getDirection_0(self, rR: "Vec3") -> "void":
        return _tools.CMC_Task_getDirection_0(self, rR)

    def setDirection_1(self, aR: "Vec3") -> "void":
        return _tools.CMC_Task_setDirection_1(self, aR)

    def getDirection_1(self, rR: "Vec3") -> "void":
        return _tools.CMC_Task_getDirection_1(self, rR)

    def setDirection_2(self, aR: "Vec3") -> "void":
        return _tools.CMC_Task_setDirection_2(self, aR)

    def getDirection_2(self, rR: "Vec3") -> "void":
        return _tools.CMC_Task_getDirection_2(self, rR)

    def getTaskFunction(self, aWhich: "int") -> "OpenSim::Function *":
        return _tools.CMC_Task_getTaskFunction(self, aWhich)

    def setTaskFunctionsForVelocity(self, aF0: "Function", aF1: "Function"=None, aF2: "Function"=None) -> "void":
        return _tools.CMC_Task_setTaskFunctionsForVelocity(self, aF0, aF1, aF2)

    def getTaskFunctionForVelocity(self, aWhich: "int") -> "OpenSim::Function *":
        return _tools.CMC_Task_getTaskFunctionForVelocity(self, aWhich)

    def setTaskFunctionsForAcceleration(self, aF0: "Function", aF1: "Function"=None, aF2: "Function"=None) -> "void":
        return _tools.CMC_Task_setTaskFunctionsForAcceleration(self, aF0, aF1, aF2)

    def getTaskFunctionForAcceleration(self, aWhich: "int") -> "OpenSim::Function *":
        return _tools.CMC_Task_getTaskFunctionForAcceleration(self, aWhich)

    def getTaskPosition(self, aWhich: "int", aT: "double") -> "double":
        return _tools.CMC_Task_getTaskPosition(self, aWhich, aT)

    def getTaskVelocity(self, aWhich: "int", aT: "double") -> "double":
        return _tools.CMC_Task_getTaskVelocity(self, aWhich, aT)

    def getTaskAcceleration(self, aWhich: "int", aT: "double") -> "double":
        return _tools.CMC_Task_getTaskAcceleration(self, aWhich, aT)

    def setPositionErrorLast(self, aE0: "double", aE1: "double"=0.0, aE2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setPositionErrorLast(self, aE0, aE1, aE2)

    def getPositionErrorLast(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getPositionErrorLast(self, aWhich)

    def setVelocityErrorLast(self, aE0: "double", aE1: "double"=0.0, aE2: "double"=0.0) -> "void":
        return _tools.CMC_Task_setVelocityErrorLast(self, aE0, aE1, aE2)

    def getVelocityErrorLast(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getVelocityErrorLast(self, aWhich)

    def getPositionError(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getPositionError(self, aWhich)

    def getVelocityError(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getVelocityError(self, aWhich)

    def getDesiredAcceleration(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getDesiredAcceleration(self, aWhich)

    def getAcceleration(self, aWhich: "int") -> "double":
        return _tools.CMC_Task_getAcceleration(self, aWhich)

    def computeErrors(self, s: "State", aT: "double") -> "void":
        return _tools.CMC_Task_computeErrors(self, s, aT)

    def computeDesiredAccelerations(self, *args) -> "void":
        return _tools.CMC_Task_computeDesiredAccelerations(self, *args)

    def computeAccelerations(self, s: "State") -> "void":
        return _tools.CMC_Task_computeAccelerations(self, s)

    def computeJacobian(self) -> "void":
        return _tools.CMC_Task_computeJacobian(self)

    def computeEffectiveMassMatrix(self) -> "void":
        return _tools.CMC_Task_computeEffectiveMassMatrix(self)

# Register CMC_Task in _tools:
_tools.CMC_Task_swigregister(CMC_Task)

def CMC_Task_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Task *":
    return _tools.CMC_Task_safeDownCast(obj)

def CMC_Task_getClassName() -> "std::string const &":
    return _tools.CMC_Task_getClassName()

class CMC_Joint(CMC_Task):
    r"""
    A class for specifying the tracking task for a joint.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Joint *":
        return _tools.CMC_Joint_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.CMC_Joint_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.CMC_Joint_getClassName()

    def clone(self) -> "OpenSim::CMC_Joint *":
        return _tools.CMC_Joint_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.CMC_Joint_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.CMC_Joint_swiginit(self, _tools.new_CMC_Joint(*args))
    __swig_destroy__ = _tools.delete_CMC_Joint

    def setModel(self, aModel: "Model") -> "void":
        return _tools.CMC_Joint_setModel(self, aModel)

    def setCoordinateName(self, aName: "std::string const &") -> "void":
        return _tools.CMC_Joint_setCoordinateName(self, aName)

    def getCoordinateName(self) -> "std::string":
        return _tools.CMC_Joint_getCoordinateName(self)

    def getLimit(self) -> "double":
        return _tools.CMC_Joint_getLimit(self)

    def computeErrors(self, s: "State", aT: "double") -> "void":
        return _tools.CMC_Joint_computeErrors(self, s, aT)

    def computeDesiredAccelerations(self, *args) -> "void":
        return _tools.CMC_Joint_computeDesiredAccelerations(self, *args)

    def computeAccelerations(self, s: "State") -> "void":
        return _tools.CMC_Joint_computeAccelerations(self, s)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.CMC_Joint_updateFromXMLNode(self, aNode, versionNumber)

# Register CMC_Joint in _tools:
_tools.CMC_Joint_swigregister(CMC_Joint)

def CMC_Joint_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Joint *":
    return _tools.CMC_Joint_safeDownCast(obj)

def CMC_Joint_getClassName() -> "std::string const &":
    return _tools.CMC_Joint_getClassName()

class CMC_Point(CMC_Task):
    r"""
    A class for specifying and computing parameters for tracking a point.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Point *":
        return _tools.CMC_Point_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.CMC_Point_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.CMC_Point_getClassName()

    def clone(self) -> "OpenSim::CMC_Point *":
        return _tools.CMC_Point_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.CMC_Point_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.CMC_Point_swiginit(self, _tools.new_CMC_Point(*args))
    __swig_destroy__ = _tools.delete_CMC_Point

    def setModel(self, aModel: "Model") -> "void":
        return _tools.CMC_Point_setModel(self, aModel)

    def setPoint(self, aPoint: "Vec3") -> "void":
        return _tools.CMC_Point_setPoint(self, aPoint)

    def getPoint(self) -> "SimTK::Vec3":
        return _tools.CMC_Point_getPoint(self)

    def computeErrors(self, s: "State", aT: "double") -> "void":
        return _tools.CMC_Point_computeErrors(self, s, aT)

    def computeDesiredAccelerations(self, *args) -> "void":
        return _tools.CMC_Point_computeDesiredAccelerations(self, *args)

    def computeAccelerations(self, s: "State") -> "void":
        return _tools.CMC_Point_computeAccelerations(self, s)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.CMC_Point_updateFromXMLNode(self, aNode, versionNumber)

# Register CMC_Point in _tools:
_tools.CMC_Point_swigregister(CMC_Point)

def CMC_Point_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_Point *":
    return _tools.CMC_Point_safeDownCast(obj)

def CMC_Point_getClassName() -> "std::string const &":
    return _tools.CMC_Point_getClassName()

class SetTrackingTasks(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::TrackingTask,OpenSim::Object > *":
        return _tools.SetTrackingTasks_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.SetTrackingTasks_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.SetTrackingTasks_getClassName()

    def clone(self) -> "OpenSim::Set< OpenSim::TrackingTask,OpenSim::Object > *":
        return _tools.SetTrackingTasks_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.SetTrackingTasks_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_SetTrackingTasks

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::TrackingTask,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _tools.SetTrackingTasks_swiginit(self, _tools.new_SetTrackingTasks(*args))

    def setupGroups(self) -> "void":
        r"""Setup groups (match group member names to set members)."""
        return _tools.SetTrackingTasks_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse: "bool") -> "void":
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _tools.SetTrackingTasks_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize: "int") -> "bool":
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _tools.SetTrackingTasks_setSize(self, aSize)

    def getSize(self) -> "int":
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _tools.SetTrackingTasks_getSize(self)

    def getIndex(self, *args) -> "int":
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`TrackingTask`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _tools.SetTrackingTasks_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName: "std::string const &", rGroupNames: "ArrayStr") -> "void":
        r"""Get names of groups containing a given object"""
        return _tools.SetTrackingTasks_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject: "TrackingTask") -> "bool":
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`TrackingTask`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetTrackingTasks_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject: "TrackingTask") -> "bool":
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`TrackingTask`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _tools.SetTrackingTasks_cloneAndAppend(self, aObject)

    def insert(self, aIndex: "int", aObject: "TrackingTask") -> "bool":
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`TrackingTask`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _tools.SetTrackingTasks_insert(self, aIndex, aObject)

    def remove(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`TrackingTask`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _tools.SetTrackingTasks_remove(self, *args)

    def clearAndDestroy(self) -> "void":
        return _tools.SetTrackingTasks_clearAndDestroy(self)

    def set(self, aIndex: "int", aObject: "TrackingTask", preserveGroups: "bool"=False) -> "bool":
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`TrackingTask`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _tools.SetTrackingTasks_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args) -> "OpenSim::TrackingTask &":
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`TrackingTask`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`TrackingTask`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _tools.SetTrackingTasks_get(self, *args)

    def contains(self, aName: "std::string const &") -> "bool":
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _tools.SetTrackingTasks_contains(self, aName)

    def getNames(self, rNames: "ArrayStr") -> "void":
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _tools.SetTrackingTasks_getNames(self, rNames)

    def getNumGroups(self) -> "int":
        r"""Get the number of groups."""
        return _tools.SetTrackingTasks_getNumGroups(self)

    def addGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Add an empty group to the set."""
        return _tools.SetTrackingTasks_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName: "std::string const &") -> "void":
        r"""Remove a group from the set. Elements are not removed."""
        return _tools.SetTrackingTasks_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName: "std::string const &", newGroupName: "std::string const &") -> "void":
        r"""Rename a group."""
        return _tools.SetTrackingTasks_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName: "std::string const &", aObjectName: "std::string const &") -> "void":
        r"""Add an object to a group."""
        return _tools.SetTrackingTasks_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames: "ArrayStr") -> "void":
        r"""Get names of all groups"""
        return _tools.SetTrackingTasks_getGroupNames(self, rGroupNames)

    def getGroup(self, *args) -> "OpenSim::ObjectGroup const *":
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _tools.SetTrackingTasks_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetTrackingTasks in _tools:
_tools.SetTrackingTasks_swigregister(SetTrackingTasks)

def SetTrackingTasks_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Set< OpenSim::TrackingTask,OpenSim::Object > *":
    return _tools.SetTrackingTasks_safeDownCast(obj)

def SetTrackingTasks_getClassName() -> "std::string const &":
    return _tools.SetTrackingTasks_getClassName()

class CMC_TaskSet(SetTrackingTasks):
    r"""
    An class for holding and managing a set of tasks.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_TaskSet *":
        return _tools.CMC_TaskSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.CMC_TaskSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.CMC_TaskSet_getClassName()

    def clone(self) -> "OpenSim::CMC_TaskSet *":
        return _tools.CMC_TaskSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.CMC_TaskSet_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_CMC_TaskSet

    def __init__(self, *args):
        _tools.CMC_TaskSet_swiginit(self, _tools.new_CMC_TaskSet(*args))

    def setModel(self, aModel: "Model") -> "void":
        return _tools.CMC_TaskSet_setModel(self, aModel)

    def getModel(self) -> "OpenSim::Model *":
        return _tools.CMC_TaskSet_getModel(self)

    def getDataFileName(self) -> "std::string const &":
        return _tools.CMC_TaskSet_getDataFileName(self)

    def setFunctions(self, aFuncSet: "FunctionSet") -> "void":
        return _tools.CMC_TaskSet_setFunctions(self, aFuncSet)

    def setFunctionsForVelocity(self, aFuncSet: "FunctionSet") -> "void":
        return _tools.CMC_TaskSet_setFunctionsForVelocity(self, aFuncSet)

    def setFunctionsForAcceleration(self, aFuncSet: "FunctionSet") -> "void":
        return _tools.CMC_TaskSet_setFunctionsForAcceleration(self, aFuncSet)

    def getNumActiveTaskFunctions(self) -> "int":
        return _tools.CMC_TaskSet_getNumActiveTaskFunctions(self)

    def getTaskPositions(self, aT: "double") -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getTaskPositions(self, aT)

    def getTaskVelocities(self, aT: "double") -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getTaskVelocities(self, aT)

    def getTaskAccelerations(self, aT: "double") -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getTaskAccelerations(self, aT)

    def getPositionGains(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getPositionGains(self)

    def getVelocityGains(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getVelocityGains(self)

    def getAccelerationGains(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getAccelerationGains(self)

    def getPositionErrorsLast(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getPositionErrorsLast(self)

    def getPositionErrors(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getPositionErrors(self)

    def getVelocityErrorsLast(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getVelocityErrorsLast(self)

    def getVelocityErrors(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getVelocityErrors(self)

    def getWeights(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getWeights(self)

    def getDesiredAccelerations(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getDesiredAccelerations(self)

    def getAccelerations(self) -> "OpenSim::Array< double > &":
        return _tools.CMC_TaskSet_getAccelerations(self)

    def recordErrorsAsLastErrors(self) -> "void":
        return _tools.CMC_TaskSet_recordErrorsAsLastErrors(self)

    def computeErrors(self, s: "State", aT: "double") -> "void":
        return _tools.CMC_TaskSet_computeErrors(self, s, aT)

    def computeDesiredAccelerations(self, *args) -> "void":
        return _tools.CMC_TaskSet_computeDesiredAccelerations(self, *args)

    def computeAccelerations(self, s: "State") -> "void":
        return _tools.CMC_TaskSet_computeAccelerations(self, s)

# Register CMC_TaskSet in _tools:
_tools.CMC_TaskSet_swigregister(CMC_TaskSet)

def CMC_TaskSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMC_TaskSet *":
    return _tools.CMC_TaskSet_safeDownCast(obj)

def CMC_TaskSet_getClassName() -> "std::string const &":
    return _tools.CMC_TaskSet_getClassName()

class CMCTool(opensim.simulation.AbstractTool):
    r"""
    An abstract class for specifying the interface for an investigation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMCTool *":
        return _tools.CMCTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.CMCTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.CMCTool_getClassName()

    def clone(self) -> "OpenSim::CMCTool *":
        return _tools.CMCTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.CMCTool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_CMCTool

    def __init__(self, *args):
        _tools.CMCTool_swiginit(self, _tools.new_CMCTool(*args))

    def getExcludedActuators(self) -> "OpenSim::Array< std::string > const &":
        return _tools.CMCTool_getExcludedActuators(self)

    def setExcludedActuators(self, excludedActs: "ArrayStr") -> "void":
        return _tools.CMCTool_setExcludedActuators(self, excludedActs)

    def getDesiredPointsFileName(self) -> "std::string const &":
        return _tools.CMCTool_getDesiredPointsFileName(self)

    def setDesiredPointsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setDesiredPointsFileName(self, aFileName)

    def getDesiredKinematicsFileName(self) -> "std::string const &":
        return _tools.CMCTool_getDesiredKinematicsFileName(self)

    def setDesiredKinematicsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setDesiredKinematicsFileName(self, aFileName)

    def getConstraintsFileName(self) -> "std::string const &":
        return _tools.CMCTool_getConstraintsFileName(self)

    def setConstraintsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setConstraintsFileName(self, aFileName)

    def getTaskSetFileName(self) -> "std::string const &":
        return _tools.CMCTool_getTaskSetFileName(self)

    def setTaskSetFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setTaskSetFileName(self, aFileName)

    def getRRAControlsFileName(self) -> "std::string const &":
        return _tools.CMCTool_getRRAControlsFileName(self)

    def setRRAControlsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setRRAControlsFileName(self, aFileName)

    def getLowpassCutoffFrequency(self) -> "double":
        return _tools.CMCTool_getLowpassCutoffFrequency(self)

    def setLowpassCutoffFrequency(self, aLowpassCutoffFrequency: "double") -> "void":
        return _tools.CMCTool_setLowpassCutoffFrequency(self, aLowpassCutoffFrequency)

    def getTimeWindow(self) -> "double":
        return _tools.CMCTool_getTimeWindow(self)

    def setTimeWindow(self, aTargetDT: "double") -> "void":
        return _tools.CMCTool_setTimeWindow(self, aTargetDT)

    def getExternalLoadsFileName(self) -> "std::string const &":
        return _tools.CMCTool_getExternalLoadsFileName(self)

    def setExternalLoadsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.CMCTool_setExternalLoadsFileName(self, aFileName)

    def getUseFastTarget(self) -> "bool":
        return _tools.CMCTool_getUseFastTarget(self)

    def setUseFastTarget(self, useFastTarget: "bool") -> "void":
        return _tools.CMCTool_setUseFastTarget(self, useFastTarget)

    def getUseVerbosePrinting(self) -> "bool":
        return _tools.CMCTool_getUseVerbosePrinting(self)

    def setUseVerbosePrinting(self, verbose: "bool") -> "void":
        return _tools.CMCTool_setUseVerbosePrinting(self, verbose)

    def run(self) -> "bool":
        return _tools.CMCTool_run(self)

    def getForceStorage(self) -> "OpenSim::Storage &":
        return _tools.CMCTool_getForceStorage(self)

    def setOriginalForceSet(self, aForceSet: "ForceSet") -> "void":
        return _tools.CMCTool_setOriginalForceSet(self, aForceSet)

# Register CMCTool in _tools:
_tools.CMCTool_swigregister(CMCTool)

def CMCTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CMCTool *":
    return _tools.CMCTool_safeDownCast(obj)

def CMCTool_getClassName() -> "std::string const &":
    return _tools.CMCTool_getClassName()

class RRATool(opensim.simulation.AbstractTool):
    r"""
    An abstract class for specifying the interface for an investigation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::RRATool *":
        return _tools.RRATool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.RRATool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.RRATool_getClassName()

    def clone(self) -> "OpenSim::RRATool *":
        return _tools.RRATool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.RRATool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_RRATool

    def __init__(self, *args):
        _tools.RRATool_swiginit(self, _tools.new_RRATool(*args))

    def getDesiredPointsFileName(self) -> "std::string const &":
        return _tools.RRATool_getDesiredPointsFileName(self)

    def setDesiredPointsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setDesiredPointsFileName(self, aFileName)

    def getDesiredKinematicsFileName(self) -> "std::string const &":
        return _tools.RRATool_getDesiredKinematicsFileName(self)

    def setDesiredKinematicsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setDesiredKinematicsFileName(self, aFileName)

    def getConstraintsFileName(self) -> "std::string const &":
        return _tools.RRATool_getConstraintsFileName(self)

    def setConstraintsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setConstraintsFileName(self, aFileName)

    def getTaskSetFileName(self) -> "std::string const &":
        return _tools.RRATool_getTaskSetFileName(self)

    def setTaskSetFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setTaskSetFileName(self, aFileName)

    def getOutputModelFileName(self) -> "std::string const &":
        return _tools.RRATool_getOutputModelFileName(self)

    def setOutputModelFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setOutputModelFileName(self, aFileName)

    def getAdjustCOMToReduceResiduals(self) -> "bool":
        return _tools.RRATool_getAdjustCOMToReduceResiduals(self)

    def setAdjustCOMToReduceResiduals(self, aAdjust: "bool") -> "void":
        return _tools.RRATool_setAdjustCOMToReduceResiduals(self, aAdjust)

    def getAdjustedCOMBody(self) -> "std::string const &":
        return _tools.RRATool_getAdjustedCOMBody(self)

    def setAdjustedCOMBody(self, aBody: "std::string const &") -> "void":
        return _tools.RRATool_setAdjustedCOMBody(self, aBody)

    def getLowpassCutoffFrequency(self) -> "double":
        return _tools.RRATool_getLowpassCutoffFrequency(self)

    def setLowpassCutoffFrequency(self, aLowpassCutoffFrequency: "double") -> "void":
        return _tools.RRATool_setLowpassCutoffFrequency(self, aLowpassCutoffFrequency)

    def getExternalLoadsFileName(self) -> "std::string const &":
        return _tools.RRATool_getExternalLoadsFileName(self)

    def setExternalLoadsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.RRATool_setExternalLoadsFileName(self, aFileName)

    def run(self) -> "bool":
        return _tools.RRATool_run(self)

    def getForceStorage(self) -> "OpenSim::Storage &":
        return _tools.RRATool_getForceStorage(self)

    def setOriginalForceSet(self, aForceSet: "ForceSet") -> "void":
        return _tools.RRATool_setOriginalForceSet(self, aForceSet)

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.RRATool_updateFromXMLNode(self, aNode, versionNumber)

# Register RRATool in _tools:
_tools.RRATool_swigregister(RRATool)

def RRATool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::RRATool *":
    return _tools.RRATool_safeDownCast(obj)

def RRATool_getClassName() -> "std::string const &":
    return _tools.RRATool_getClassName()

class AnalyzeTool(opensim.simulation.AbstractTool):
    r"""
    An abstract class for specifying the interface for an investigation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalyzeTool *":
        return _tools.AnalyzeTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.AnalyzeTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.AnalyzeTool_getClassName()

    def clone(self) -> "OpenSim::AnalyzeTool *":
        return _tools.AnalyzeTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.AnalyzeTool_getConcreteClassName(self)
    __swig_destroy__ = _tools.delete_AnalyzeTool

    def __init__(self, *args):
        _tools.AnalyzeTool_swiginit(self, _tools.new_AnalyzeTool(*args))

    def setStatesStorage(self, aStore: "Storage") -> "void":
        return _tools.AnalyzeTool_setStatesStorage(self, aStore)

    @staticmethod
    def createStatesStorageFromCoordinatesAndSpeeds(aModel: "Model", aQStore: "Storage", aUStore: "Storage") -> "OpenSim::Storage *":
        return _tools.AnalyzeTool_createStatesStorageFromCoordinatesAndSpeeds(aModel, aQStore, aUStore)

    def getStatesStorage(self) -> "OpenSim::Storage &":
        return _tools.AnalyzeTool_getStatesStorage(self)

    def getStatesFileName(self) -> "std::string const &":
        return _tools.AnalyzeTool_getStatesFileName(self)

    def setStatesFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.AnalyzeTool_setStatesFileName(self, aFileName)

    def getCoordinatesFileName(self) -> "std::string const &":
        return _tools.AnalyzeTool_getCoordinatesFileName(self)

    def setCoordinatesFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.AnalyzeTool_setCoordinatesFileName(self, aFileName)

    def getSpeedsFileName(self) -> "std::string const &":
        return _tools.AnalyzeTool_getSpeedsFileName(self)

    def setSpeedsFileName(self, aFileName: "std::string const &") -> "void":
        return _tools.AnalyzeTool_setSpeedsFileName(self, aFileName)

    def getLowpassCutoffFrequency(self) -> "double":
        return _tools.AnalyzeTool_getLowpassCutoffFrequency(self)

    def setLowpassCutoffFrequency(self, aLowpassCutoffFrequency: "double") -> "void":
        return _tools.AnalyzeTool_setLowpassCutoffFrequency(self, aLowpassCutoffFrequency)

    def getLoadModelAndInput(self) -> "bool":
        return _tools.AnalyzeTool_getLoadModelAndInput(self)

    def setLoadModelAndInput(self, b: "bool") -> "void":
        return _tools.AnalyzeTool_setLoadModelAndInput(self, b)

    def setStatesFromMotion(self, s: "State", aMotion: "Storage", aInDegrees: "bool") -> "void":
        return _tools.AnalyzeTool_setStatesFromMotion(self, s, aMotion, aInDegrees)

    def loadStatesFromFile(self, s: "State") -> "void":
        return _tools.AnalyzeTool_loadStatesFromFile(self, s)

    def verifyControlsStates(self) -> "void":
        return _tools.AnalyzeTool_verifyControlsStates(self)

    def setPrintResultFiles(self, aToWrite: "bool") -> "void":
        return _tools.AnalyzeTool_setPrintResultFiles(self, aToWrite)

    def disableIntegrationOnlyProbes(self) -> "void":
        return _tools.AnalyzeTool_disableIntegrationOnlyProbes(self)

    def run(self, *args) -> "bool":
        return _tools.AnalyzeTool_run(self, *args)

# Register AnalyzeTool in _tools:
_tools.AnalyzeTool_swigregister(AnalyzeTool)

def AnalyzeTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::AnalyzeTool *":
    return _tools.AnalyzeTool_safeDownCast(obj)

def AnalyzeTool_getClassName() -> "std::string const &":
    return _tools.AnalyzeTool_getClassName()

def AnalyzeTool_createStatesStorageFromCoordinatesAndSpeeds(aModel: "Model", aQStore: "Storage", aUStore: "Storage") -> "OpenSim::Storage *":
    return _tools.AnalyzeTool_createStatesStorageFromCoordinatesAndSpeeds(aModel, aQStore, aUStore)

class InverseKinematicsToolBase(Tool):
    r"""
    A Tool that performs an Inverse Kinematics analysis with a given model.
    Inverse kinematics is the solution of internal coordinates that poses
    the model such that the landmark locations (markers), or orientations of
    Sensor (IMUs) affixed to the model, minimize the weighted least-squares
    error with observations of markers in spatial coordinates, or Sensor
    (IMU) orientations.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseKinematicsToolBase *":
        return _tools.InverseKinematicsToolBase_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.InverseKinematicsToolBase_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.InverseKinematicsToolBase_getClassName()

    def clone(self) -> "OpenSim::InverseKinematicsToolBase *":
        return _tools.InverseKinematicsToolBase_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.InverseKinematicsToolBase_getConcreteClassName(self)

    def copyProperty_model_file(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_model_file(self, source)

    def append_model_file(self, value: "std::string const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_model_file(self, value)

    def constructProperty_model_file(self, initValue: "std::string const &") -> "void":
        return _tools.InverseKinematicsToolBase_constructProperty_model_file(self, initValue)

    def get_model_file(self, *args) -> "std::string const &":
        return _tools.InverseKinematicsToolBase_get_model_file(self, *args)

    def upd_model_file(self, *args) -> "std::string &":
        return _tools.InverseKinematicsToolBase_upd_model_file(self, *args)

    def set_model_file(self, *args) -> "void":
        return _tools.InverseKinematicsToolBase_set_model_file(self, *args)

    def copyProperty_constraint_weight(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_constraint_weight(self, source)

    def append_constraint_weight(self, value: "double const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_constraint_weight(self, value)

    def constructProperty_constraint_weight(self, initValue: "double const &") -> "void":
        return _tools.InverseKinematicsToolBase_constructProperty_constraint_weight(self, initValue)

    def get_constraint_weight(self, *args) -> "double const &":
        return _tools.InverseKinematicsToolBase_get_constraint_weight(self, *args)

    def upd_constraint_weight(self, *args) -> "double &":
        return _tools.InverseKinematicsToolBase_upd_constraint_weight(self, *args)

    def set_constraint_weight(self, *args) -> "void":
        return _tools.InverseKinematicsToolBase_set_constraint_weight(self, *args)

    def copyProperty_accuracy(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_accuracy(self, source)

    def append_accuracy(self, value: "double const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_accuracy(self, value)

    def constructProperty_accuracy(self, initValue: "double const &") -> "void":
        return _tools.InverseKinematicsToolBase_constructProperty_accuracy(self, initValue)

    def get_accuracy(self, *args) -> "double const &":
        return _tools.InverseKinematicsToolBase_get_accuracy(self, *args)

    def upd_accuracy(self, *args) -> "double &":
        return _tools.InverseKinematicsToolBase_upd_accuracy(self, *args)

    def set_accuracy(self, *args) -> "void":
        return _tools.InverseKinematicsToolBase_set_accuracy(self, *args)

    def copyProperty_time_range(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_time_range(self, source)

    def get_time_range(self, i: "int") -> "double const &":
        return _tools.InverseKinematicsToolBase_get_time_range(self, i)

    def upd_time_range(self, i: "int") -> "double &":
        return _tools.InverseKinematicsToolBase_upd_time_range(self, i)

    def set_time_range(self, i: "int", value: "double const &") -> "void":
        return _tools.InverseKinematicsToolBase_set_time_range(self, i, value)

    def append_time_range(self, value: "double const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_time_range(self, value)

    def copyProperty_report_errors(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_report_errors(self, source)

    def append_report_errors(self, value: "bool const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_report_errors(self, value)

    def constructProperty_report_errors(self, initValue: "bool const &") -> "void":
        return _tools.InverseKinematicsToolBase_constructProperty_report_errors(self, initValue)

    def get_report_errors(self, *args) -> "bool const &":
        return _tools.InverseKinematicsToolBase_get_report_errors(self, *args)

    def upd_report_errors(self, *args) -> "bool &":
        return _tools.InverseKinematicsToolBase_upd_report_errors(self, *args)

    def set_report_errors(self, *args) -> "void":
        return _tools.InverseKinematicsToolBase_set_report_errors(self, *args)

    def copyProperty_output_motion_file(self, source: "InverseKinematicsToolBase") -> "void":
        return _tools.InverseKinematicsToolBase_copyProperty_output_motion_file(self, source)

    def append_output_motion_file(self, value: "std::string const &") -> "int":
        return _tools.InverseKinematicsToolBase_append_output_motion_file(self, value)

    def constructProperty_output_motion_file(self, initValue: "std::string const &") -> "void":
        return _tools.InverseKinematicsToolBase_constructProperty_output_motion_file(self, initValue)

    def get_output_motion_file(self, *args) -> "std::string const &":
        return _tools.InverseKinematicsToolBase_get_output_motion_file(self, *args)

    def upd_output_motion_file(self, *args) -> "std::string &":
        return _tools.InverseKinematicsToolBase_upd_output_motion_file(self, *args)

    def set_output_motion_file(self, *args) -> "void":
        return _tools.InverseKinematicsToolBase_set_output_motion_file(self, *args)
    __swig_destroy__ = _tools.delete_InverseKinematicsToolBase

    def setModel(self, aModel: "Model") -> "void":
        return _tools.InverseKinematicsToolBase_setModel(self, aModel)

    def setStartTime(self, d: "double") -> "void":
        return _tools.InverseKinematicsToolBase_setStartTime(self, d)

    def getStartTime(self) -> "double":
        return _tools.InverseKinematicsToolBase_getStartTime(self)

    def setEndTime(self, d: "double") -> "void":
        return _tools.InverseKinematicsToolBase_setEndTime(self, d)

    def getEndTime(self) -> "double":
        return _tools.InverseKinematicsToolBase_getEndTime(self)

    def setOutputMotionFileName(self, aOutputMotionFileName: "std::string const") -> "void":
        return _tools.InverseKinematicsToolBase_setOutputMotionFileName(self, aOutputMotionFileName)

    def getOutputMotionFileName(self) -> "std::string":
        return _tools.InverseKinematicsToolBase_getOutputMotionFileName(self)

# Register InverseKinematicsToolBase in _tools:
_tools.InverseKinematicsToolBase_swigregister(InverseKinematicsToolBase)

def InverseKinematicsToolBase_safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseKinematicsToolBase *":
    return _tools.InverseKinematicsToolBase_safeDownCast(obj)

def InverseKinematicsToolBase_getClassName() -> "std::string const &":
    return _tools.InverseKinematicsToolBase_getClassName()

class InverseKinematicsTool(InverseKinematicsToolBase):
    r"""
    A Tool that performs an Inverse Kinematics analysis with a given model.
    Inverse kinematics is the solution of internal coordinates that poses
    the model such that the landmark locations (markers), affixed to the model,
    minimize the weighted least-squares error with observations of markers
    in spatial coordinates. Observations of coordinates can also be included.

    Author: Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseKinematicsTool *":
        return _tools.InverseKinematicsTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.InverseKinematicsTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.InverseKinematicsTool_getClassName()

    def clone(self) -> "OpenSim::InverseKinematicsTool *":
        return _tools.InverseKinematicsTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.InverseKinematicsTool_getConcreteClassName(self)

    def copyProperty_IKTaskSet(self, source: "InverseKinematicsTool") -> "void":
        return _tools.InverseKinematicsTool_copyProperty_IKTaskSet(self, source)

    def append_IKTaskSet(self, value: "IKTaskSet") -> "int":
        return _tools.InverseKinematicsTool_append_IKTaskSet(self, value)

    def constructProperty_IKTaskSet(self, initValue: "IKTaskSet") -> "void":
        return _tools.InverseKinematicsTool_constructProperty_IKTaskSet(self, initValue)

    def get_IKTaskSet(self, *args) -> "OpenSim::IKTaskSet const &":
        return _tools.InverseKinematicsTool_get_IKTaskSet(self, *args)

    def upd_IKTaskSet(self, *args) -> "OpenSim::IKTaskSet &":
        return _tools.InverseKinematicsTool_upd_IKTaskSet(self, *args)

    def set_IKTaskSet(self, *args) -> "void":
        return _tools.InverseKinematicsTool_set_IKTaskSet(self, *args)

    def copyProperty_marker_file(self, source: "InverseKinematicsTool") -> "void":
        return _tools.InverseKinematicsTool_copyProperty_marker_file(self, source)

    def append_marker_file(self, value: "std::string const &") -> "int":
        return _tools.InverseKinematicsTool_append_marker_file(self, value)

    def constructProperty_marker_file(self, initValue: "std::string const &") -> "void":
        return _tools.InverseKinematicsTool_constructProperty_marker_file(self, initValue)

    def get_marker_file(self, *args) -> "std::string const &":
        return _tools.InverseKinematicsTool_get_marker_file(self, *args)

    def upd_marker_file(self, *args) -> "std::string &":
        return _tools.InverseKinematicsTool_upd_marker_file(self, *args)

    def set_marker_file(self, *args) -> "void":
        return _tools.InverseKinematicsTool_set_marker_file(self, *args)

    def copyProperty_coordinate_file(self, source: "InverseKinematicsTool") -> "void":
        return _tools.InverseKinematicsTool_copyProperty_coordinate_file(self, source)

    def append_coordinate_file(self, value: "std::string const &") -> "int":
        return _tools.InverseKinematicsTool_append_coordinate_file(self, value)

    def constructProperty_coordinate_file(self, initValue: "std::string const &") -> "void":
        return _tools.InverseKinematicsTool_constructProperty_coordinate_file(self, initValue)

    def get_coordinate_file(self, *args) -> "std::string const &":
        return _tools.InverseKinematicsTool_get_coordinate_file(self, *args)

    def upd_coordinate_file(self, *args) -> "std::string &":
        return _tools.InverseKinematicsTool_upd_coordinate_file(self, *args)

    def set_coordinate_file(self, *args) -> "void":
        return _tools.InverseKinematicsTool_set_coordinate_file(self, *args)

    def copyProperty_report_marker_locations(self, source: "InverseKinematicsTool") -> "void":
        return _tools.InverseKinematicsTool_copyProperty_report_marker_locations(self, source)

    def append_report_marker_locations(self, value: "bool const &") -> "int":
        return _tools.InverseKinematicsTool_append_report_marker_locations(self, value)

    def constructProperty_report_marker_locations(self, initValue: "bool const &") -> "void":
        return _tools.InverseKinematicsTool_constructProperty_report_marker_locations(self, initValue)

    def get_report_marker_locations(self, *args) -> "bool const &":
        return _tools.InverseKinematicsTool_get_report_marker_locations(self, *args)

    def upd_report_marker_locations(self, *args) -> "bool &":
        return _tools.InverseKinematicsTool_upd_report_marker_locations(self, *args)

    def set_report_marker_locations(self, *args) -> "void":
        return _tools.InverseKinematicsTool_set_report_marker_locations(self, *args)
    __swig_destroy__ = _tools.delete_InverseKinematicsTool

    def __init__(self, *args):
        _tools.InverseKinematicsTool_swiginit(self, _tools.new_InverseKinematicsTool(*args))

    def updateFromXMLNode(self, aNode: "SimTK::Xml::Element &", versionNumber: "int"=-1) -> "void":
        return _tools.InverseKinematicsTool_updateFromXMLNode(self, aNode, versionNumber)

    def setMarkerDataFileName(self, markerDataFileName: "std::string const &") -> "void":
        return _tools.InverseKinematicsTool_setMarkerDataFileName(self, markerDataFileName)

    def getMarkerDataFileName(self) -> "std::string const &":
        return _tools.InverseKinematicsTool_getMarkerDataFileName(self)

    def setCoordinateFileName(self, coordDataFileName: "std::string const &") -> "void":
        return _tools.InverseKinematicsTool_setCoordinateFileName(self, coordDataFileName)

    def getCoordinateFileName(self) -> "std::string const &":
        return _tools.InverseKinematicsTool_getCoordinateFileName(self)

    def getIKTaskSet(self) -> "OpenSim::IKTaskSet &":
        return _tools.InverseKinematicsTool_getIKTaskSet(self)

    def run(self) -> "bool":
        return _tools.InverseKinematicsTool_run(self)

    def populateReferences(self, markersReference: "MarkersReference", coordinateReferences: "SimTKArrayCoordinateReference") -> "void":
        return _tools.InverseKinematicsTool_populateReferences(self, markersReference, coordinateReferences)

# Register InverseKinematicsTool in _tools:
_tools.InverseKinematicsTool_swigregister(InverseKinematicsTool)

def InverseKinematicsTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::InverseKinematicsTool *":
    return _tools.InverseKinematicsTool_safeDownCast(obj)

def InverseKinematicsTool_getClassName() -> "std::string const &":
    return _tools.InverseKinematicsTool_getClassName()

class OrientationWeightSet(opensim.simulation.SetOientationWeights):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationWeightSet *":
        return _tools.OrientationWeightSet_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.OrientationWeightSet_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.OrientationWeightSet_getClassName()

    def clone(self) -> "OpenSim::OrientationWeightSet *":
        return _tools.OrientationWeightSet_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.OrientationWeightSet_getConcreteClassName(self)

    def __init__(self, *args):
        _tools.OrientationWeightSet_swiginit(self, _tools.new_OrientationWeightSet(*args))
    __swig_destroy__ = _tools.delete_OrientationWeightSet

# Register OrientationWeightSet in _tools:
_tools.OrientationWeightSet_swigregister(OrientationWeightSet)

def OrientationWeightSet_safeDownCast(obj: "OpenSimObject") -> "OpenSim::OrientationWeightSet *":
    return _tools.OrientationWeightSet_safeDownCast(obj)

def OrientationWeightSet_getClassName() -> "std::string const &":
    return _tools.OrientationWeightSet_getClassName()

class IMUInverseKinematicsTool(InverseKinematicsToolBase):
    r"""
    A Study that performs an Inverse Kinematics analysis with a given model.
    Inverse kinematics is the solution of internal coordinates that poses
    the model such that the body rotations (as measured by IMUs) affixed to the
    model minimize the weighted least-squares error with observations of IMU
    orientations in their spatial coordinates.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMUInverseKinematicsTool *":
        return _tools.IMUInverseKinematicsTool_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _tools.IMUInverseKinematicsTool_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _tools.IMUInverseKinematicsTool_getClassName()

    def clone(self) -> "OpenSim::IMUInverseKinematicsTool *":
        return _tools.IMUInverseKinematicsTool_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _tools.IMUInverseKinematicsTool_getConcreteClassName(self)

    def copyProperty_orientations_file(self, source: "IMUInverseKinematicsTool") -> "void":
        return _tools.IMUInverseKinematicsTool_copyProperty_orientations_file(self, source)

    def append_orientations_file(self, value: "std::string const &") -> "int":
        return _tools.IMUInverseKinematicsTool_append_orientations_file(self, value)

    def constructProperty_orientations_file(self, initValue: "std::string const &") -> "void":
        return _tools.IMUInverseKinematicsTool_constructProperty_orientations_file(self, initValue)

    def get_orientations_file(self, *args) -> "std::string const &":
        return _tools.IMUInverseKinematicsTool_get_orientations_file(self, *args)

    def upd_orientations_file(self, *args) -> "std::string &":
        return _tools.IMUInverseKinematicsTool_upd_orientations_file(self, *args)

    def set_orientations_file(self, *args) -> "void":
        return _tools.IMUInverseKinematicsTool_set_orientations_file(self, *args)

    def copyProperty_sensor_to_opensim_rotations(self, source: "IMUInverseKinematicsTool") -> "void":
        return _tools.IMUInverseKinematicsTool_copyProperty_sensor_to_opensim_rotations(self, source)

    def append_sensor_to_opensim_rotations(self, value: "Vec3") -> "int":
        return _tools.IMUInverseKinematicsTool_append_sensor_to_opensim_rotations(self, value)

    def constructProperty_sensor_to_opensim_rotations(self, initValue: "Vec3") -> "void":
        return _tools.IMUInverseKinematicsTool_constructProperty_sensor_to_opensim_rotations(self, initValue)

    def get_sensor_to_opensim_rotations(self, *args) -> "SimTK::Vec3 const &":
        return _tools.IMUInverseKinematicsTool_get_sensor_to_opensim_rotations(self, *args)

    def upd_sensor_to_opensim_rotations(self, *args) -> "SimTK::Vec3 &":
        return _tools.IMUInverseKinematicsTool_upd_sensor_to_opensim_rotations(self, *args)

    def set_sensor_to_opensim_rotations(self, *args) -> "void":
        return _tools.IMUInverseKinematicsTool_set_sensor_to_opensim_rotations(self, *args)

    def copyProperty_orientation_weights(self, source: "IMUInverseKinematicsTool") -> "void":
        return _tools.IMUInverseKinematicsTool_copyProperty_orientation_weights(self, source)

    def append_orientation_weights(self, value: "OrientationWeightSet") -> "int":
        return _tools.IMUInverseKinematicsTool_append_orientation_weights(self, value)

    def constructProperty_orientation_weights(self, initValue: "OrientationWeightSet") -> "void":
        return _tools.IMUInverseKinematicsTool_constructProperty_orientation_weights(self, initValue)

    def get_orientation_weights(self, *args) -> "OpenSim::OrientationWeightSet const &":
        return _tools.IMUInverseKinematicsTool_get_orientation_weights(self, *args)

    def upd_orientation_weights(self, *args) -> "OpenSim::OrientationWeightSet &":
        return _tools.IMUInverseKinematicsTool_upd_orientation_weights(self, *args)

    def set_orientation_weights(self, *args) -> "void":
        return _tools.IMUInverseKinematicsTool_set_orientation_weights(self, *args)
    __swig_destroy__ = _tools.delete_IMUInverseKinematicsTool

    def __init__(self, *args):
        _tools.IMUInverseKinematicsTool_swiginit(self, _tools.new_IMUInverseKinematicsTool(*args))

    def run(self, *args) -> "bool":
        return _tools.IMUInverseKinematicsTool_run(self, *args)

    @staticmethod
    def loadMarkersFile(markerFile: "std::string const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 >":
        return _tools.IMUInverseKinematicsTool_loadMarkersFile(markerFile)

    def runInverseKinematicsWithOrientationsFromFile(self, model: "Model", quaternionStoFileName: "std::string const &", visualizeResults: "bool"=False) -> "void":
        return _tools.IMUInverseKinematicsTool_runInverseKinematicsWithOrientationsFromFile(self, model, quaternionStoFileName, visualizeResults)

# Register IMUInverseKinematicsTool in _tools:
_tools.IMUInverseKinematicsTool_swigregister(IMUInverseKinematicsTool)

def IMUInverseKinematicsTool_safeDownCast(obj: "OpenSimObject") -> "OpenSim::IMUInverseKinematicsTool *":
    return _tools.IMUInverseKinematicsTool_safeDownCast(obj)

def IMUInverseKinematicsTool_getClassName() -> "std::string const &":
    return _tools.IMUInverseKinematicsTool_getClassName()

def IMUInverseKinematicsTool_loadMarkersFile(markerFile: "std::string const &") -> "OpenSim::TimeSeriesTable_< SimTK::Vec3 >":
    return _tools.IMUInverseKinematicsTool_loadMarkersFile(markerFile)



