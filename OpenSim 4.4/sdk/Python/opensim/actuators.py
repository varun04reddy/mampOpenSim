# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _actuators
else:
    import _actuators

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _actuators.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _actuators.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _actuators.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _actuators.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _actuators.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _actuators.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _actuators.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _actuators.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _actuators.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _actuators.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _actuators.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _actuators.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _actuators.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _actuators.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _actuators.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _actuators.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _actuators.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _actuators:
_actuators.SwigPyIterator_swigregister(SwigPyIterator)

import opensim.simulation
import opensim.common
import opensim.simbody
class CoordinateActuator(opensim.simulation.ScalarActuator):
    r"""
    An actuator that applies a generalized force in the direction of a
    generalized coordinate. The applied generalized force is proportional to the
    input control of the CoordinateActuator. Replaces the GeneralizedForce class.

    Author: Ajay Seth
    Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateActuator *":
        return _actuators.CoordinateActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.CoordinateActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.CoordinateActuator_getClassName()

    def clone(self) -> "OpenSim::CoordinateActuator *":
        return _actuators.CoordinateActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.CoordinateActuator_getConcreteClassName(self)

    def copyProperty_coordinate(self, source: "CoordinateActuator") -> "void":
        return _actuators.CoordinateActuator_copyProperty_coordinate(self, source)

    def append_coordinate(self, value: "std::string const &") -> "int":
        return _actuators.CoordinateActuator_append_coordinate(self, value)

    def constructProperty_coordinate(self, *args) -> "void":
        return _actuators.CoordinateActuator_constructProperty_coordinate(self, *args)

    def get_coordinate(self, *args) -> "std::string const &":
        return _actuators.CoordinateActuator_get_coordinate(self, *args)

    def upd_coordinate(self, *args) -> "std::string &":
        return _actuators.CoordinateActuator_upd_coordinate(self, *args)

    def set_coordinate(self, *args) -> "void":
        return _actuators.CoordinateActuator_set_coordinate(self, *args)

    def copyProperty_optimal_force(self, source: "CoordinateActuator") -> "void":
        return _actuators.CoordinateActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value: "double const &") -> "int":
        return _actuators.CoordinateActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue: "double const &") -> "void":
        return _actuators.CoordinateActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args) -> "double const &":
        return _actuators.CoordinateActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args) -> "double &":
        return _actuators.CoordinateActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args) -> "void":
        return _actuators.CoordinateActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        Default constructor leaves coordinate name unspecified, or you can
           provide it. *
        """
        _actuators.CoordinateActuator_swiginit(self, _actuators.new_CoordinateActuator(*args))

    def setOptimalForce(self, optimalForce: "double") -> "void":
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.CoordinateActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self) -> "double":
        r""" Get the current setting of the 'optimal_force' property. *"""
        return _actuators.CoordinateActuator_getOptimalForce(self)

    @staticmethod
    def CreateForceSetOfCoordinateActuatorsForModel(s: "State", aModel: "Model", aOptimalForce: "double"=1, aIncludeLockedAndConstrainedCoordinates: "bool"=True) -> "OpenSim::ForceSet *":
        return _actuators.CoordinateActuator_CreateForceSetOfCoordinateActuatorsForModel(s, aModel, aOptimalForce, aIncludeLockedAndConstrainedCoordinates)

    def isCoordinateValid(self) -> "bool":
        return _actuators.CoordinateActuator_isCoordinateValid(self)

    def getSpeed(self, s: "State") -> "double":
        return _actuators.CoordinateActuator_getSpeed(self, s)

    def setCoordinate(self, aCoordinate: "Coordinate") -> "void":
        r"""
        %Set the reference pointer to point to the given Coordinate and set
           the 'coordinate' name property also. *
        """
        return _actuators.CoordinateActuator_setCoordinate(self, aCoordinate)

    def getCoordinate(self) -> "OpenSim::Coordinate *":
        r""" Get a pointer to the Coordinate to which this actuator refers. *"""
        return _actuators.CoordinateActuator_getCoordinate(self)
    __swig_destroy__ = _actuators.delete_CoordinateActuator

# Register CoordinateActuator in _actuators:
_actuators.CoordinateActuator_swigregister(CoordinateActuator)

def CoordinateActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::CoordinateActuator *":
    return _actuators.CoordinateActuator_safeDownCast(obj)

def CoordinateActuator_getClassName() -> "std::string const &":
    return _actuators.CoordinateActuator_getClassName()

def CoordinateActuator_CreateForceSetOfCoordinateActuatorsForModel(s: "State", aModel: "Model", aOptimalForce: "double"=1, aIncludeLockedAndConstrainedCoordinates: "bool"=True) -> "OpenSim::ForceSet *":
    return _actuators.CoordinateActuator_CreateForceSetOfCoordinateActuatorsForModel(s, aModel, aOptimalForce, aIncludeLockedAndConstrainedCoordinates)

class ActivationCoordinateActuator(CoordinateActuator):
    r"""
    Similar to CoordinateActuator (simply produces a generalized force) but
    with first-order linear activation dynamics. This actuator has one state
    variable, `activation`, with :math:`\dot{a} = (x - a) / \tau`, where
    :math:`a` is activation, :math:`x` is excitation, and :math:`\tau` is the
    activation time constant (there is no separate deactivation time constant).
    The statebounds_activation output is used in Moco to set default values for
    the activation state variable.
    **Default %Property Values**
    activation_time_constant: 0.01
    default_activation: 0.5
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActivationCoordinateActuator *":
        return _actuators.ActivationCoordinateActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ActivationCoordinateActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ActivationCoordinateActuator_getClassName()

    def clone(self) -> "OpenSim::ActivationCoordinateActuator *":
        return _actuators.ActivationCoordinateActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ActivationCoordinateActuator_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source: "ActivationCoordinateActuator") -> "void":
        return _actuators.ActivationCoordinateActuator_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value: "double const &") -> "int":
        return _actuators.ActivationCoordinateActuator_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue: "double const &") -> "void":
        return _actuators.ActivationCoordinateActuator_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _actuators.ActivationCoordinateActuator_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args) -> "double &":
        return _actuators.ActivationCoordinateActuator_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args) -> "void":
        return _actuators.ActivationCoordinateActuator_set_activation_time_constant(self, *args)

    def copyProperty_default_activation(self, source: "ActivationCoordinateActuator") -> "void":
        return _actuators.ActivationCoordinateActuator_copyProperty_default_activation(self, source)

    def append_default_activation(self, value: "double const &") -> "int":
        return _actuators.ActivationCoordinateActuator_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue: "double const &") -> "void":
        return _actuators.ActivationCoordinateActuator_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args) -> "double const &":
        return _actuators.ActivationCoordinateActuator_get_default_activation(self, *args)

    def upd_default_activation(self, *args) -> "double &":
        return _actuators.ActivationCoordinateActuator_upd_default_activation(self, *args)

    def set_default_activation(self, *args) -> "void":
        return _actuators.ActivationCoordinateActuator_set_default_activation(self, *args)
    _has_output_statebounds_activation = property(_actuators.ActivationCoordinateActuator__has_output_statebounds_activation_get, _actuators.ActivationCoordinateActuator__has_output_statebounds_activation_set)

    def __init__(self, *args):
        r""" Provide the coordinate name."""
        _actuators.ActivationCoordinateActuator_swiginit(self, _actuators.new_ActivationCoordinateActuator(*args))

    def getBoundsActivation(self, arg2: "State") -> "SimTK::Vec2":
        r"""
        The lower bound on activation is getMinControl() and the upper bound is
        getMaxControl().
        Whether these bounds are enforced is determined by the solver used.
        """
        return _actuators.ActivationCoordinateActuator_getBoundsActivation(self, arg2)
    __swig_destroy__ = _actuators.delete_ActivationCoordinateActuator

# Register ActivationCoordinateActuator in _actuators:
_actuators.ActivationCoordinateActuator_swigregister(ActivationCoordinateActuator)

def ActivationCoordinateActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ActivationCoordinateActuator *":
    return _actuators.ActivationCoordinateActuator_safeDownCast(obj)

def ActivationCoordinateActuator_getClassName() -> "std::string const &":
    return _actuators.ActivationCoordinateActuator_getClassName()

class PointActuator(opensim.simulation.ScalarActuator):
    r"""
    A class that implements a point actuator acting on the model.
    This actuator has no states; the control is simply the force to
    be applied to the model.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointActuator *":
        return _actuators.PointActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.PointActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.PointActuator_getClassName()

    def clone(self) -> "OpenSim::PointActuator *":
        return _actuators.PointActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.PointActuator_getConcreteClassName(self)

    def copyProperty_body(self, source: "PointActuator") -> "void":
        return _actuators.PointActuator_copyProperty_body(self, source)

    def append_body(self, value: "std::string const &") -> "int":
        return _actuators.PointActuator_append_body(self, value)

    def constructProperty_body(self, *args) -> "void":
        return _actuators.PointActuator_constructProperty_body(self, *args)

    def get_body(self, *args) -> "std::string const &":
        return _actuators.PointActuator_get_body(self, *args)

    def upd_body(self, *args) -> "std::string &":
        return _actuators.PointActuator_upd_body(self, *args)

    def set_body(self, *args) -> "void":
        return _actuators.PointActuator_set_body(self, *args)

    def copyProperty_point(self, source: "PointActuator") -> "void":
        return _actuators.PointActuator_copyProperty_point(self, source)

    def append_point(self, value: "Vec3") -> "int":
        return _actuators.PointActuator_append_point(self, value)

    def constructProperty_point(self, initValue: "Vec3") -> "void":
        return _actuators.PointActuator_constructProperty_point(self, initValue)

    def get_point(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.PointActuator_get_point(self, *args)

    def upd_point(self, *args) -> "SimTK::Vec3 &":
        return _actuators.PointActuator_upd_point(self, *args)

    def set_point(self, *args) -> "void":
        return _actuators.PointActuator_set_point(self, *args)

    def copyProperty_point_is_global(self, source: "PointActuator") -> "void":
        r""" The default is point_is_global=false. *"""
        return _actuators.PointActuator_copyProperty_point_is_global(self, source)

    def append_point_is_global(self, value: "bool const &") -> "int":
        return _actuators.PointActuator_append_point_is_global(self, value)

    def constructProperty_point_is_global(self, initValue: "bool const &") -> "void":
        return _actuators.PointActuator_constructProperty_point_is_global(self, initValue)

    def get_point_is_global(self, *args) -> "bool const &":
        return _actuators.PointActuator_get_point_is_global(self, *args)

    def upd_point_is_global(self, *args) -> "bool &":
        return _actuators.PointActuator_upd_point_is_global(self, *args)

    def set_point_is_global(self, *args) -> "void":
        return _actuators.PointActuator_set_point_is_global(self, *args)

    def copyProperty_direction(self, source: "PointActuator") -> "void":
        return _actuators.PointActuator_copyProperty_direction(self, source)

    def append_direction(self, value: "Vec3") -> "int":
        return _actuators.PointActuator_append_direction(self, value)

    def constructProperty_direction(self, initValue: "Vec3") -> "void":
        return _actuators.PointActuator_constructProperty_direction(self, initValue)

    def get_direction(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.PointActuator_get_direction(self, *args)

    def upd_direction(self, *args) -> "SimTK::Vec3 &":
        return _actuators.PointActuator_upd_direction(self, *args)

    def set_direction(self, *args) -> "void":
        return _actuators.PointActuator_set_direction(self, *args)

    def copyProperty_force_is_global(self, source: "PointActuator") -> "void":
        r""" The default is force_is_global=false. *"""
        return _actuators.PointActuator_copyProperty_force_is_global(self, source)

    def append_force_is_global(self, value: "bool const &") -> "int":
        return _actuators.PointActuator_append_force_is_global(self, value)

    def constructProperty_force_is_global(self, initValue: "bool const &") -> "void":
        return _actuators.PointActuator_constructProperty_force_is_global(self, initValue)

    def get_force_is_global(self, *args) -> "bool const &":
        return _actuators.PointActuator_get_force_is_global(self, *args)

    def upd_force_is_global(self, *args) -> "bool &":
        return _actuators.PointActuator_upd_force_is_global(self, *args)

    def set_force_is_global(self, *args) -> "void":
        return _actuators.PointActuator_set_force_is_global(self, *args)

    def copyProperty_optimal_force(self, source: "PointActuator") -> "void":
        return _actuators.PointActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value: "double const &") -> "int":
        return _actuators.PointActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue: "double const &") -> "void":
        return _actuators.PointActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args) -> "double const &":
        return _actuators.PointActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args) -> "double &":
        return _actuators.PointActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args) -> "void":
        return _actuators.PointActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        Default constructor or construct with body name given. An empty
           name ("") is treated as though it were unspecified. *
        """
        _actuators.PointActuator_swiginit(self, _actuators.new_PointActuator(*args))

    def setOptimalForce(self, aOptimalForce: "double") -> "void":
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.PointActuator_setOptimalForce(self, aOptimalForce)

    def getOptimalForce(self) -> "double":
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.PointActuator_getOptimalForce(self)
    __swig_destroy__ = _actuators.delete_PointActuator

# Register PointActuator in _actuators:
_actuators.PointActuator_swigregister(PointActuator)

def PointActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointActuator *":
    return _actuators.PointActuator_safeDownCast(obj)

def PointActuator_getClassName() -> "std::string const &":
    return _actuators.PointActuator_getClassName()

class TorqueActuator(opensim.simulation.ScalarActuator):
    r"""
    A TorqueActuator applies equal and opposite torques on the two bodies
    (bodyA and B) that it connects. The torque is applied about an axis
    specified in ground (global) by default, otherwise it is in bodyA's frame.
    The magnitude of the torque is equal to the product of the optimal_force of
    the actuator and its control signal.

    Author: Ajay Seth, Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::TorqueActuator *":
        return _actuators.TorqueActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.TorqueActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.TorqueActuator_getClassName()

    def clone(self) -> "OpenSim::TorqueActuator *":
        return _actuators.TorqueActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.TorqueActuator_getConcreteClassName(self)

    def copyProperty_bodyA(self, source: "TorqueActuator") -> "void":
        return _actuators.TorqueActuator_copyProperty_bodyA(self, source)

    def append_bodyA(self, value: "std::string const &") -> "int":
        return _actuators.TorqueActuator_append_bodyA(self, value)

    def constructProperty_bodyA(self, *args) -> "void":
        return _actuators.TorqueActuator_constructProperty_bodyA(self, *args)

    def get_bodyA(self, *args) -> "std::string const &":
        return _actuators.TorqueActuator_get_bodyA(self, *args)

    def upd_bodyA(self, *args) -> "std::string &":
        return _actuators.TorqueActuator_upd_bodyA(self, *args)

    def set_bodyA(self, *args) -> "void":
        return _actuators.TorqueActuator_set_bodyA(self, *args)

    def copyProperty_bodyB(self, source: "TorqueActuator") -> "void":
        return _actuators.TorqueActuator_copyProperty_bodyB(self, source)

    def append_bodyB(self, value: "std::string const &") -> "int":
        return _actuators.TorqueActuator_append_bodyB(self, value)

    def constructProperty_bodyB(self, *args) -> "void":
        return _actuators.TorqueActuator_constructProperty_bodyB(self, *args)

    def get_bodyB(self, *args) -> "std::string const &":
        return _actuators.TorqueActuator_get_bodyB(self, *args)

    def upd_bodyB(self, *args) -> "std::string &":
        return _actuators.TorqueActuator_upd_bodyB(self, *args)

    def set_bodyB(self, *args) -> "void":
        return _actuators.TorqueActuator_set_bodyB(self, *args)

    def copyProperty_torque_is_global(self, source: "TorqueActuator") -> "void":
        r""" The default is torque_is_global=true. *"""
        return _actuators.TorqueActuator_copyProperty_torque_is_global(self, source)

    def append_torque_is_global(self, value: "bool const &") -> "int":
        return _actuators.TorqueActuator_append_torque_is_global(self, value)

    def constructProperty_torque_is_global(self, initValue: "bool const &") -> "void":
        return _actuators.TorqueActuator_constructProperty_torque_is_global(self, initValue)

    def get_torque_is_global(self, *args) -> "bool const &":
        return _actuators.TorqueActuator_get_torque_is_global(self, *args)

    def upd_torque_is_global(self, *args) -> "bool &":
        return _actuators.TorqueActuator_upd_torque_is_global(self, *args)

    def set_torque_is_global(self, *args) -> "void":
        return _actuators.TorqueActuator_set_torque_is_global(self, *args)

    def copyProperty_axis(self, source: "TorqueActuator") -> "void":
        r""" The default direction for the axis is z (0,0,1). *"""
        return _actuators.TorqueActuator_copyProperty_axis(self, source)

    def append_axis(self, value: "Vec3") -> "int":
        return _actuators.TorqueActuator_append_axis(self, value)

    def constructProperty_axis(self, initValue: "Vec3") -> "void":
        return _actuators.TorqueActuator_constructProperty_axis(self, initValue)

    def get_axis(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.TorqueActuator_get_axis(self, *args)

    def upd_axis(self, *args) -> "SimTK::Vec3 &":
        return _actuators.TorqueActuator_upd_axis(self, *args)

    def set_axis(self, *args) -> "void":
        return _actuators.TorqueActuator_set_axis(self, *args)

    def copyProperty_optimal_force(self, source: "TorqueActuator") -> "void":
        r""" The default for optimal force is 1. *"""
        return _actuators.TorqueActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value: "double const &") -> "int":
        return _actuators.TorqueActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue: "double const &") -> "void":
        return _actuators.TorqueActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args) -> "double const &":
        return _actuators.TorqueActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args) -> "double &":
        return _actuators.TorqueActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args) -> "void":
        return _actuators.TorqueActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience Constructor.
            Create a torque actuator that applies equal and opposite torques
            on the two bodies (bodyA and B) that it connects. The torque is applied
            about an axis specified in ground if axisInGround is true, otherwise
            it is specified in bodyA's body frame.

            :type bodyA: :py:class:`PhysicalFrame`
            :param bodyA:   the body that the actuator applies torque to
            :type bodyB: :py:class:`PhysicalFrame`
            :param bodyB:   the body that the actuator applies the opposite torque to
            :type axis: :py:class:`Vec3`
            :param axis:    the axis about which the torque is applied
            :type axisInGround: boolean, optional
            :param axisInGround: flag to indicate the axis is expressed in ground
                                      otherwise, it is expressed in bodyA's frame

        |

        *Overload 3:*
        Convenience Constructor.
            Create a torque actuator that applies equal and opposite torques
            on the two bodies (bodyA and B) that it connects. The torque is applied
            about an axis specified in ground if axisInGround is true, otherwise
            it is specified in bodyA's body frame.

            :type bodyA: :py:class:`PhysicalFrame`
            :param bodyA:   the body that the actuator applies torque to
            :type bodyB: :py:class:`PhysicalFrame`
            :param bodyB:   the body that the actuator applies the opposite torque to
            :type axis: :py:class:`Vec3`
            :param axis:    the axis about which the torque is applied
            :param axisInGround: flag to indicate the axis is expressed in ground
                                      otherwise, it is expressed in bodyA's frame
        """
        _actuators.TorqueActuator_swiginit(self, _actuators.new_TorqueActuator(*args))

    def setAxis(self, axis: "Vec3") -> "void":
        r"""
        %Set the 'axis' property to the supplied value; frame is interpreted
           according to the 'torque_is_global' property. *
        """
        return _actuators.TorqueActuator_setAxis(self, axis)

    def getAxis(self) -> "SimTK::Vec3 const &":
        r""" Return the current value of the 'axis' property. *"""
        return _actuators.TorqueActuator_getAxis(self)

    def setTorqueIsGlobal(self, isGlobal: "bool") -> "void":
        r"""
        %Set the 'torque_is_global' property that determines how to interpret
           the 'axis' vector; if not global (Ground frame) it is in body A's frame. *
        """
        return _actuators.TorqueActuator_setTorqueIsGlobal(self, isGlobal)

    def getTorqueIsGlobal(self) -> "bool":
        r""" Return the current value of the 'torque_is_global' property. *"""
        return _actuators.TorqueActuator_getTorqueIsGlobal(self)

    def setOptimalForce(self, optimalForce: "double") -> "void":
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.TorqueActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self) -> "double":
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.TorqueActuator_getOptimalForce(self)

    def setBodyA(self, body: "PhysicalFrame") -> "void":
        r""" %Set the first body (bodyA) to which this actuator applies torque."""
        return _actuators.TorqueActuator_setBodyA(self, body)

    def setBodyB(self, body: "PhysicalFrame") -> "void":
        r""" %Set the second body (bodyB) to which this actuator applies torque."""
        return _actuators.TorqueActuator_setBodyB(self, body)

    def getBodyA(self) -> "OpenSim::PhysicalFrame const &":
        r""" Get the first body (bodyA) to which this actuator applies torque."""
        return _actuators.TorqueActuator_getBodyA(self)

    def getBodyB(self) -> "OpenSim::PhysicalFrame const &":
        r""" Get the second body (bodyB) to which this actuator applies torque."""
        return _actuators.TorqueActuator_getBodyB(self)
    __swig_destroy__ = _actuators.delete_TorqueActuator

# Register TorqueActuator in _actuators:
_actuators.TorqueActuator_swigregister(TorqueActuator)

def TorqueActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::TorqueActuator *":
    return _actuators.TorqueActuator_safeDownCast(obj)

def TorqueActuator_getClassName() -> "std::string const &":
    return _actuators.TorqueActuator_getClassName()

class BodyActuator(opensim.simulation.Actuator):
    r"""
    Apply a spatial force (that is, [torque, force]) on a given point of the
    given body. That is, the force is applied at the given point; torques don't
    have associated points. This actuator has no states; the control signal
    should provide a 6D vector including [torque(3D), force(3D)] that is supposed
    to be applied to the body.
    The associated controller can generate the spatial force [torque, force] both
    in the body and global (ground) frame. The default is assumed to be global
    frame. The point of application can be specified both in the body and global
    (ground) frame. The default is assumed to be the body frame.

    Author: Soha Pouya, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyActuator *":
        return _actuators.BodyActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.BodyActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.BodyActuator_getClassName()

    def clone(self) -> "OpenSim::BodyActuator *":
        return _actuators.BodyActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.BodyActuator_getConcreteClassName(self)

    def copyProperty_point(self, source: "BodyActuator") -> "void":
        return _actuators.BodyActuator_copyProperty_point(self, source)

    def append_point(self, value: "Vec3") -> "int":
        return _actuators.BodyActuator_append_point(self, value)

    def constructProperty_point(self, initValue: "Vec3") -> "void":
        return _actuators.BodyActuator_constructProperty_point(self, initValue)

    def get_point(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.BodyActuator_get_point(self, *args)

    def upd_point(self, *args) -> "SimTK::Vec3 &":
        return _actuators.BodyActuator_upd_point(self, *args)

    def set_point(self, *args) -> "void":
        return _actuators.BodyActuator_set_point(self, *args)

    def copyProperty_point_is_global(self, source: "BodyActuator") -> "void":
        r""" The default is point_is_global=false. *"""
        return _actuators.BodyActuator_copyProperty_point_is_global(self, source)

    def append_point_is_global(self, value: "bool const &") -> "int":
        return _actuators.BodyActuator_append_point_is_global(self, value)

    def constructProperty_point_is_global(self, initValue: "bool const &") -> "void":
        return _actuators.BodyActuator_constructProperty_point_is_global(self, initValue)

    def get_point_is_global(self, *args) -> "bool const &":
        return _actuators.BodyActuator_get_point_is_global(self, *args)

    def upd_point_is_global(self, *args) -> "bool &":
        return _actuators.BodyActuator_upd_point_is_global(self, *args)

    def set_point_is_global(self, *args) -> "void":
        return _actuators.BodyActuator_set_point_is_global(self, *args)

    def copyProperty_spatial_force_is_global(self, source: "BodyActuator") -> "void":
        r""" The default is spatial_force_is_global=true. *"""
        return _actuators.BodyActuator_copyProperty_spatial_force_is_global(self, source)

    def append_spatial_force_is_global(self, value: "bool const &") -> "int":
        return _actuators.BodyActuator_append_spatial_force_is_global(self, value)

    def constructProperty_spatial_force_is_global(self, initValue: "bool const &") -> "void":
        return _actuators.BodyActuator_constructProperty_spatial_force_is_global(self, initValue)

    def get_spatial_force_is_global(self, *args) -> "bool const &":
        return _actuators.BodyActuator_get_spatial_force_is_global(self, *args)

    def upd_spatial_force_is_global(self, *args) -> "bool &":
        return _actuators.BodyActuator_upd_spatial_force_is_global(self, *args)

    def set_spatial_force_is_global(self, *args) -> "void":
        return _actuators.BodyActuator_set_spatial_force_is_global(self, *args)
    PropertyIndex_socket_body = property(_actuators.BodyActuator_PropertyIndex_socket_body_get, _actuators.BodyActuator_PropertyIndex_socket_body_set)

    def connectSocket_body(self, object: "OpenSimObject") -> "void":
        return _actuators.BodyActuator_connectSocket_body(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :type pointIsGlobal: boolean, in, optional
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :type spatialForceIsGlobal: boolean, in, optional
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 3:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :type pointIsGlobal: boolean, in, optional
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 4:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 5:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :param point:                the point that the force is applied to
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame
        """
        _actuators.BodyActuator_swiginit(self, _actuators.new_BodyActuator(*args))

    def setPoint(self, point: "Vec3") -> "void":
        r"""
        %Set the 'point' property that determines where the force vector should
           be applied. The default is the origin of the body Vec3(0). *
        """
        return _actuators.BodyActuator_setPoint(self, point)

    def getPoint(self) -> "SimTK::Vec3 const &":
        r""" Return the current value of the 'point' property. *"""
        return _actuators.BodyActuator_getPoint(self)

    def setPointForceIsGlobal(self, isGlobal: "bool") -> "void":
        r"""
        %Set the 'point_is_global' property that determines whether the point is
           specified in inertial coordinates or in the body's local coordinates. *
        """
        return _actuators.BodyActuator_setPointForceIsGlobal(self, isGlobal)

    def getPointIsGlobal(self) -> "bool":
        r""" Return the current value of the 'point_is_global' property. *"""
        return _actuators.BodyActuator_getPointIsGlobal(self)

    def setSpatialForceIsGlobal(self, isGlobal: "bool") -> "void":
        r"""
        %Set the 'spatial_force_is_global' property that determines how to
           interpret the 'axis' vector; if not global (Ground frame) it is in body's
           frame. *
        """
        return _actuators.BodyActuator_setSpatialForceIsGlobal(self, isGlobal)

    def getSpatialForceIsGlobal(self) -> "bool":
        r""" Return the current value of the 'spatial_force_is_global' property. *"""
        return _actuators.BodyActuator_getSpatialForceIsGlobal(self)

    def setBody(self, body: "Body") -> "void":
        return _actuators.BodyActuator_setBody(self, body)

    def getBody(self) -> "OpenSim::Body const &":
        return _actuators.BodyActuator_getBody(self)

    def setBodyName(self, name: "std::string const &") -> "void":
        return _actuators.BodyActuator_setBodyName(self, name)

    def getBodyName(self) -> "std::string const &":
        return _actuators.BodyActuator_getBodyName(self)
    __swig_destroy__ = _actuators.delete_BodyActuator

# Register BodyActuator in _actuators:
_actuators.BodyActuator_swigregister(BodyActuator)

def BodyActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::BodyActuator *":
    return _actuators.BodyActuator_safeDownCast(obj)

def BodyActuator_getClassName() -> "std::string const &":
    return _actuators.BodyActuator_getClassName()

class PointToPointActuator(opensim.simulation.ScalarActuator):
    r"""
    A class that implements a force actuator acting between two points on two bodies.
    The direction of the force is along the line between the points, with a positive
    value acting to expand the distance between them.  This actuator has no states;
    the control is simply the force to be applied to the model.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointToPointActuator *":
        return _actuators.PointToPointActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.PointToPointActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.PointToPointActuator_getClassName()

    def clone(self) -> "OpenSim::PointToPointActuator *":
        return _actuators.PointToPointActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.PointToPointActuator_getConcreteClassName(self)

    def copyProperty_bodyA(self, source: "PointToPointActuator") -> "void":
        return _actuators.PointToPointActuator_copyProperty_bodyA(self, source)

    def append_bodyA(self, value: "std::string const &") -> "int":
        return _actuators.PointToPointActuator_append_bodyA(self, value)

    def constructProperty_bodyA(self, *args) -> "void":
        return _actuators.PointToPointActuator_constructProperty_bodyA(self, *args)

    def get_bodyA(self, *args) -> "std::string const &":
        return _actuators.PointToPointActuator_get_bodyA(self, *args)

    def upd_bodyA(self, *args) -> "std::string &":
        return _actuators.PointToPointActuator_upd_bodyA(self, *args)

    def set_bodyA(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_bodyA(self, *args)

    def copyProperty_bodyB(self, source: "PointToPointActuator") -> "void":
        return _actuators.PointToPointActuator_copyProperty_bodyB(self, source)

    def append_bodyB(self, value: "std::string const &") -> "int":
        return _actuators.PointToPointActuator_append_bodyB(self, value)

    def constructProperty_bodyB(self, *args) -> "void":
        return _actuators.PointToPointActuator_constructProperty_bodyB(self, *args)

    def get_bodyB(self, *args) -> "std::string const &":
        return _actuators.PointToPointActuator_get_bodyB(self, *args)

    def upd_bodyB(self, *args) -> "std::string &":
        return _actuators.PointToPointActuator_upd_bodyB(self, *args)

    def set_bodyB(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_bodyB(self, *args)

    def copyProperty_points_are_global(self, source: "PointToPointActuator") -> "void":
        r""" The default is points_are_global=false. *"""
        return _actuators.PointToPointActuator_copyProperty_points_are_global(self, source)

    def append_points_are_global(self, value: "bool const &") -> "int":
        return _actuators.PointToPointActuator_append_points_are_global(self, value)

    def constructProperty_points_are_global(self, initValue: "bool const &") -> "void":
        return _actuators.PointToPointActuator_constructProperty_points_are_global(self, initValue)

    def get_points_are_global(self, *args) -> "bool const &":
        return _actuators.PointToPointActuator_get_points_are_global(self, *args)

    def upd_points_are_global(self, *args) -> "bool &":
        return _actuators.PointToPointActuator_upd_points_are_global(self, *args)

    def set_points_are_global(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_points_are_global(self, *args)

    def copyProperty_pointA(self, source: "PointToPointActuator") -> "void":
        r""" The default location for pointA is bodyA's origin. *"""
        return _actuators.PointToPointActuator_copyProperty_pointA(self, source)

    def append_pointA(self, value: "Vec3") -> "int":
        return _actuators.PointToPointActuator_append_pointA(self, value)

    def constructProperty_pointA(self, initValue: "Vec3") -> "void":
        return _actuators.PointToPointActuator_constructProperty_pointA(self, initValue)

    def get_pointA(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.PointToPointActuator_get_pointA(self, *args)

    def upd_pointA(self, *args) -> "SimTK::Vec3 &":
        return _actuators.PointToPointActuator_upd_pointA(self, *args)

    def set_pointA(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_pointA(self, *args)

    def copyProperty_pointB(self, source: "PointToPointActuator") -> "void":
        r""" The default location for pointB is bodyB's origin. *"""
        return _actuators.PointToPointActuator_copyProperty_pointB(self, source)

    def append_pointB(self, value: "Vec3") -> "int":
        return _actuators.PointToPointActuator_append_pointB(self, value)

    def constructProperty_pointB(self, initValue: "Vec3") -> "void":
        return _actuators.PointToPointActuator_constructProperty_pointB(self, initValue)

    def get_pointB(self, *args) -> "SimTK::Vec3 const &":
        return _actuators.PointToPointActuator_get_pointB(self, *args)

    def upd_pointB(self, *args) -> "SimTK::Vec3 &":
        return _actuators.PointToPointActuator_upd_pointB(self, *args)

    def set_pointB(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_pointB(self, *args)

    def copyProperty_optimal_force(self, source: "PointToPointActuator") -> "void":
        r""" The default for optimal force is 1. *"""
        return _actuators.PointToPointActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value: "double const &") -> "int":
        return _actuators.PointToPointActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue: "double const &") -> "void":
        return _actuators.PointToPointActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args) -> "double const &":
        return _actuators.PointToPointActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args) -> "double &":
        return _actuators.PointToPointActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args) -> "void":
        return _actuators.PointToPointActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Construct with specified body names. *
        """
        _actuators.PointToPointActuator_swiginit(self, _actuators.new_PointToPointActuator(*args))

    def setPointA(self, pointAPos: "Vec3") -> "void":
        r"""
        %Set the 'pointA' property to the supplied value; frame is interpreted
           according to the 'points_are_global' property. *
        """
        return _actuators.PointToPointActuator_setPointA(self, pointAPos)

    def getPointA(self) -> "SimTK::Vec3 const &":
        r""" Return the current value of the 'pointA' property. *"""
        return _actuators.PointToPointActuator_getPointA(self)

    def setPointB(self, pointBPos: "Vec3") -> "void":
        r"""
        %Set the 'pointB' property to the supplied value; frame is interpreted
           according to the 'points_are_global' property. *
        """
        return _actuators.PointToPointActuator_setPointB(self, pointBPos)

    def getPointB(self) -> "SimTK::Vec3 const &":
        r""" Return the current value of the 'pointB' property. *"""
        return _actuators.PointToPointActuator_getPointB(self)

    def setPointsAreGlobal(self, isGlobal: "bool") -> "void":
        r"""
        %Set the 'points_are_global' property that determines how to interpret
           the 'pointA' and 'pointB' location vectors: if not global (Ground frame)
           then they are in the local frame of 'bodyA' and 'bodyB' respectively. *
        """
        return _actuators.PointToPointActuator_setPointsAreGlobal(self, isGlobal)

    def getPointsAreGlobal(self) -> "bool":
        r""" Return the current value of the 'points_are_global' property. *"""
        return _actuators.PointToPointActuator_getPointsAreGlobal(self)

    def setOptimalForce(self, optimalForce: "double") -> "void":
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.PointToPointActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self) -> "double":
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.PointToPointActuator_getOptimalForce(self)
    __swig_destroy__ = _actuators.delete_PointToPointActuator

# Register PointToPointActuator in _actuators:
_actuators.PointToPointActuator_swigregister(PointToPointActuator)

def PointToPointActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::PointToPointActuator *":
    return _actuators.PointToPointActuator_safeDownCast(obj)

def PointToPointActuator_getClassName() -> "std::string const &":
    return _actuators.PointToPointActuator_getClassName()

class ClutchedPathSpring(opensim.simulation.PathActuator):
    r"""
    The ClutchedPathSpring is an actuator that has passive path spring behavior
    only when the clutch is engaged. The clutch is engaged by a control signal
    of 1 and is off for a control signal of 0. Off means the spring is not
    engaged and the path is free to change length with the motion of the bodies
    it is connected to. The tension produced by the spring is proportional
    to the stretch (z) from the instant that the clutch is engaged.

    The spring tension = x*(K*z)*(1+D*Ldot), where
         - x is the control signal to the actuator
         - z is the stretch in the spring
         - Ldot is the lengthening speed of the actuator
         - K is the spring's linear stiffness (N/m)
         - D is the spring's dissipation factor

    The ClutchedPathSpring maintains the "stretch", z, as an internal state with
    the following dynamics:


         |dz/dt = |Ldot, when x>0 (clutch is engaged)|
         || -(1/Tau)*z, (decay to zero), otherwise|


    Note that the control signal, x, is clamped to (0,1).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ClutchedPathSpring *":
        return _actuators.ClutchedPathSpring_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ClutchedPathSpring_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ClutchedPathSpring_getClassName()

    def clone(self) -> "OpenSim::ClutchedPathSpring *":
        return _actuators.ClutchedPathSpring_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ClutchedPathSpring_getConcreteClassName(self)

    def copyProperty_stiffness(self, source: "ClutchedPathSpring") -> "void":
        return _actuators.ClutchedPathSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value: "double const &") -> "int":
        return _actuators.ClutchedPathSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue: "double const &") -> "void":
        return _actuators.ClutchedPathSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args) -> "double const &":
        return _actuators.ClutchedPathSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args) -> "double &":
        return _actuators.ClutchedPathSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args) -> "void":
        return _actuators.ClutchedPathSpring_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source: "ClutchedPathSpring") -> "void":
        return _actuators.ClutchedPathSpring_copyProperty_dissipation(self, source)

    def append_dissipation(self, value: "double const &") -> "int":
        return _actuators.ClutchedPathSpring_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue: "double const &") -> "void":
        return _actuators.ClutchedPathSpring_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args) -> "double const &":
        return _actuators.ClutchedPathSpring_get_dissipation(self, *args)

    def upd_dissipation(self, *args) -> "double &":
        return _actuators.ClutchedPathSpring_upd_dissipation(self, *args)

    def set_dissipation(self, *args) -> "void":
        return _actuators.ClutchedPathSpring_set_dissipation(self, *args)

    def copyProperty_relaxation_time_constant(self, source: "ClutchedPathSpring") -> "void":
        return _actuators.ClutchedPathSpring_copyProperty_relaxation_time_constant(self, source)

    def append_relaxation_time_constant(self, value: "double const &") -> "int":
        return _actuators.ClutchedPathSpring_append_relaxation_time_constant(self, value)

    def constructProperty_relaxation_time_constant(self, initValue: "double const &") -> "void":
        return _actuators.ClutchedPathSpring_constructProperty_relaxation_time_constant(self, initValue)

    def get_relaxation_time_constant(self, *args) -> "double const &":
        return _actuators.ClutchedPathSpring_get_relaxation_time_constant(self, *args)

    def upd_relaxation_time_constant(self, *args) -> "double &":
        return _actuators.ClutchedPathSpring_upd_relaxation_time_constant(self, *args)

    def set_relaxation_time_constant(self, *args) -> "void":
        return _actuators.ClutchedPathSpring_set_relaxation_time_constant(self, *args)

    def copyProperty_initial_stretch(self, source: "ClutchedPathSpring") -> "void":
        return _actuators.ClutchedPathSpring_copyProperty_initial_stretch(self, source)

    def append_initial_stretch(self, value: "double const &") -> "int":
        return _actuators.ClutchedPathSpring_append_initial_stretch(self, value)

    def constructProperty_initial_stretch(self, initValue: "double const &") -> "void":
        return _actuators.ClutchedPathSpring_constructProperty_initial_stretch(self, initValue)

    def get_initial_stretch(self, *args) -> "double const &":
        return _actuators.ClutchedPathSpring_get_initial_stretch(self, *args)

    def upd_initial_stretch(self, *args) -> "double &":
        return _actuators.ClutchedPathSpring_upd_initial_stretch(self, *args)

    def set_initial_stretch(self, *args) -> "void":
        return _actuators.ClutchedPathSpring_set_initial_stretch(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a ClutchedPathSpring with default parameters. Users should
                note that the default values for stiffness and dissipation are `NaN`
                so they must be set before simulating.

        |

        *Overload 2:*
         Convenience constructor with ClutchedPathSpring parameters
        :type name: string
        :param name:          the name of a %ClutchedPathSpring instance
        :type stiffness: float
        :param stiffness:     the spring stiffness (K) in N/m
        :type dissipation: float
        :param dissipation:   the dissipation factor (D) in s/m
        :type relaxationTau: float
        :param relaxationTau: the spring relaxation time constant (Tau) in s
        :type stretch0: float, optional
        :param stretch0:      the initial stretch of the spring in m

        |

        *Overload 3:*
         Convenience constructor with ClutchedPathSpring parameters
        :type name: string
        :param name:          the name of a %ClutchedPathSpring instance
        :type stiffness: float
        :param stiffness:     the spring stiffness (K) in N/m
        :type dissipation: float
        :param dissipation:   the dissipation factor (D) in s/m
        :type relaxationTau: float
        :param relaxationTau: the spring relaxation time constant (Tau) in s
        :param stretch0:      the initial stretch of the spring in m
        """
        _actuators.ClutchedPathSpring_swiginit(self, _actuators.new_ClutchedPathSpring(*args))

    def getStiffness(self) -> "double":
        r""" Spring stiffness in N/m when clutch is engaged."""
        return _actuators.ClutchedPathSpring_getStiffness(self)

    def setStiffness(self, stiffness: "double") -> "void":
        return _actuators.ClutchedPathSpring_setStiffness(self, stiffness)

    def getDissipation(self) -> "double":
        r""" Spring dissipation factor in s/m when clutch is engaged."""
        return _actuators.ClutchedPathSpring_getDissipation(self)

    def setDissipation(self, dissipation: "double") -> "void":
        return _actuators.ClutchedPathSpring_setDissipation(self, dissipation)

    def getInitialStretch(self) -> "double":
        r""" Initial spring stretch in m."""
        return _actuators.ClutchedPathSpring_getInitialStretch(self)

    def setInitialStretch(self, stretch0: "double") -> "void":
        return _actuators.ClutchedPathSpring_setInitialStretch(self, stretch0)

    def getStretch(self, s: "State") -> "double":
        r"""
        The stretch in the PathSpring. The value of the stretch
               can only be obtained after the system has been realized to
               Stage::Position
        """
        return _actuators.ClutchedPathSpring_getStretch(self, s)

    def getTension(self, s: "State") -> "double":
        r"""
        The tension generated by the PathSpring. The value of the tension
               can only be obtained after the system has been realized to
               Stage::Dynamics
        """
        return _actuators.ClutchedPathSpring_getTension(self, s)
    __swig_destroy__ = _actuators.delete_ClutchedPathSpring

# Register ClutchedPathSpring in _actuators:
_actuators.ClutchedPathSpring_swigregister(ClutchedPathSpring)

def ClutchedPathSpring_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ClutchedPathSpring *":
    return _actuators.ClutchedPathSpring_safeDownCast(obj)

def ClutchedPathSpring_getClassName() -> "std::string const &":
    return _actuators.ClutchedPathSpring_getClassName()

class SpringGeneralizedForce(opensim.simulation.Force):
    r"""
    A Force that exerts a generalized force based on spring-like
    characteristics (stiffness and viscosity).

    Author: Frank C. Anderson, Ajay Seth
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::SpringGeneralizedForce *":
        return _actuators.SpringGeneralizedForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.SpringGeneralizedForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.SpringGeneralizedForce_getClassName()

    def clone(self) -> "OpenSim::SpringGeneralizedForce *":
        return _actuators.SpringGeneralizedForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.SpringGeneralizedForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source: "SpringGeneralizedForce") -> "void":
        return _actuators.SpringGeneralizedForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value: "std::string const &") -> "int":
        return _actuators.SpringGeneralizedForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, *args) -> "void":
        return _actuators.SpringGeneralizedForce_constructProperty_coordinate(self, *args)

    def get_coordinate(self, *args) -> "std::string const &":
        return _actuators.SpringGeneralizedForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args) -> "std::string &":
        return _actuators.SpringGeneralizedForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args) -> "void":
        return _actuators.SpringGeneralizedForce_set_coordinate(self, *args)

    def copyProperty_stiffness(self, source: "SpringGeneralizedForce") -> "void":
        return _actuators.SpringGeneralizedForce_copyProperty_stiffness(self, source)

    def append_stiffness(self, value: "double const &") -> "int":
        return _actuators.SpringGeneralizedForce_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue: "double const &") -> "void":
        return _actuators.SpringGeneralizedForce_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args) -> "double const &":
        return _actuators.SpringGeneralizedForce_get_stiffness(self, *args)

    def upd_stiffness(self, *args) -> "double &":
        return _actuators.SpringGeneralizedForce_upd_stiffness(self, *args)

    def set_stiffness(self, *args) -> "void":
        return _actuators.SpringGeneralizedForce_set_stiffness(self, *args)

    def copyProperty_rest_length(self, source: "SpringGeneralizedForce") -> "void":
        return _actuators.SpringGeneralizedForce_copyProperty_rest_length(self, source)

    def append_rest_length(self, value: "double const &") -> "int":
        return _actuators.SpringGeneralizedForce_append_rest_length(self, value)

    def constructProperty_rest_length(self, initValue: "double const &") -> "void":
        return _actuators.SpringGeneralizedForce_constructProperty_rest_length(self, initValue)

    def get_rest_length(self, *args) -> "double const &":
        return _actuators.SpringGeneralizedForce_get_rest_length(self, *args)

    def upd_rest_length(self, *args) -> "double &":
        return _actuators.SpringGeneralizedForce_upd_rest_length(self, *args)

    def set_rest_length(self, *args) -> "void":
        return _actuators.SpringGeneralizedForce_set_rest_length(self, *args)

    def copyProperty_viscosity(self, source: "SpringGeneralizedForce") -> "void":
        return _actuators.SpringGeneralizedForce_copyProperty_viscosity(self, source)

    def append_viscosity(self, value: "double const &") -> "int":
        return _actuators.SpringGeneralizedForce_append_viscosity(self, value)

    def constructProperty_viscosity(self, initValue: "double const &") -> "void":
        return _actuators.SpringGeneralizedForce_constructProperty_viscosity(self, initValue)

    def get_viscosity(self, *args) -> "double const &":
        return _actuators.SpringGeneralizedForce_get_viscosity(self, *args)

    def upd_viscosity(self, *args) -> "double &":
        return _actuators.SpringGeneralizedForce_upd_viscosity(self, *args)

    def set_viscosity(self, *args) -> "void":
        return _actuators.SpringGeneralizedForce_set_viscosity(self, *args)

    def __init__(self, *args):
        r"""
        This serves as default constructor or you can specify the coordinate
           name. A name of "" is treated as though unspecified. *
        """
        _actuators.SpringGeneralizedForce_swiginit(self, _actuators.new_SpringGeneralizedForce(*args))

    def setStiffness(self, aStiffness: "double") -> "void":
        return _actuators.SpringGeneralizedForce_setStiffness(self, aStiffness)

    def getStiffness(self) -> "double":
        return _actuators.SpringGeneralizedForce_getStiffness(self)

    def setRestLength(self, aRestLength: "double") -> "void":
        return _actuators.SpringGeneralizedForce_setRestLength(self, aRestLength)

    def getRestLength(self) -> "double":
        return _actuators.SpringGeneralizedForce_getRestLength(self)

    def setViscosity(self, aViscosity: "double") -> "void":
        return _actuators.SpringGeneralizedForce_setViscosity(self, aViscosity)

    def getViscosity(self) -> "double":
        return _actuators.SpringGeneralizedForce_getViscosity(self)

    def getRecordLabels(self) -> "OpenSim::Array< std::string >":
        r"""
        Methods to query a Force for the value actually applied during simulation
        The names of the quantities (column labels) is returned by this first function
        getRecordLabels()
        """
        return _actuators.SpringGeneralizedForce_getRecordLabels(self)

    def getRecordValues(self, state: "State") -> "OpenSim::Array< double >":
        r"""
        Given SimTK::State object extract all the values necessary to report forces, application location
        frame, etc. used in conjunction with getRecordLabels and should return same size Array
        """
        return _actuators.SpringGeneralizedForce_getRecordValues(self, state)
    __swig_destroy__ = _actuators.delete_SpringGeneralizedForce

# Register SpringGeneralizedForce in _actuators:
_actuators.SpringGeneralizedForce_swigregister(SpringGeneralizedForce)

def SpringGeneralizedForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::SpringGeneralizedForce *":
    return _actuators.SpringGeneralizedForce_safeDownCast(obj)

def SpringGeneralizedForce_getClassName() -> "std::string const &":
    return _actuators.SpringGeneralizedForce_getClassName()

class RigidTendonMuscle(opensim.simulation.Muscle):
    r"""
    A class implementing a RigidTendonMuscle actuator with no states.
    The path information for a RigidTendonMuscle is contained
    in the base class, and the force-generating behavior should is defined in
    this class. The force (muscle tension) assumes rigid tendon so that
    fiber-length and velocity are kinematics dependent and the force-length
    force-velocity relationships are evaluated directly.
    The control of this model is its activation. Force production is instantaneous
    with no excitation-to-activation dynamics and excitation=activation.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::RigidTendonMuscle *":
        return _actuators.RigidTendonMuscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.RigidTendonMuscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.RigidTendonMuscle_getClassName()

    def clone(self) -> "OpenSim::RigidTendonMuscle *":
        return _actuators.RigidTendonMuscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.RigidTendonMuscle_getConcreteClassName(self)

    def copyProperty_active_force_length_curve(self, source: "RigidTendonMuscle") -> "void":
        return _actuators.RigidTendonMuscle_copyProperty_active_force_length_curve(self, source)

    def append_active_force_length_curve(self, value: "Function") -> "int":
        return _actuators.RigidTendonMuscle_append_active_force_length_curve(self, value)

    def constructProperty_active_force_length_curve(self, initValue: "Function") -> "void":
        return _actuators.RigidTendonMuscle_constructProperty_active_force_length_curve(self, initValue)

    def get_active_force_length_curve(self, *args) -> "OpenSim::Function const &":
        return _actuators.RigidTendonMuscle_get_active_force_length_curve(self, *args)

    def upd_active_force_length_curve(self, *args) -> "OpenSim::Function &":
        return _actuators.RigidTendonMuscle_upd_active_force_length_curve(self, *args)

    def set_active_force_length_curve(self, *args) -> "void":
        return _actuators.RigidTendonMuscle_set_active_force_length_curve(self, *args)

    def copyProperty_passive_force_length_curve(self, source: "RigidTendonMuscle") -> "void":
        return _actuators.RigidTendonMuscle_copyProperty_passive_force_length_curve(self, source)

    def append_passive_force_length_curve(self, value: "Function") -> "int":
        return _actuators.RigidTendonMuscle_append_passive_force_length_curve(self, value)

    def constructProperty_passive_force_length_curve(self, initValue: "Function") -> "void":
        return _actuators.RigidTendonMuscle_constructProperty_passive_force_length_curve(self, initValue)

    def get_passive_force_length_curve(self, *args) -> "OpenSim::Function const &":
        return _actuators.RigidTendonMuscle_get_passive_force_length_curve(self, *args)

    def upd_passive_force_length_curve(self, *args) -> "OpenSim::Function &":
        return _actuators.RigidTendonMuscle_upd_passive_force_length_curve(self, *args)

    def set_passive_force_length_curve(self, *args) -> "void":
        return _actuators.RigidTendonMuscle_set_passive_force_length_curve(self, *args)

    def copyProperty_force_velocity_curve(self, source: "RigidTendonMuscle") -> "void":
        return _actuators.RigidTendonMuscle_copyProperty_force_velocity_curve(self, source)

    def append_force_velocity_curve(self, value: "Function") -> "int":
        return _actuators.RigidTendonMuscle_append_force_velocity_curve(self, value)

    def constructProperty_force_velocity_curve(self, initValue: "Function") -> "void":
        return _actuators.RigidTendonMuscle_constructProperty_force_velocity_curve(self, initValue)

    def get_force_velocity_curve(self, *args) -> "OpenSim::Function const &":
        return _actuators.RigidTendonMuscle_get_force_velocity_curve(self, *args)

    def upd_force_velocity_curve(self, *args) -> "OpenSim::Function &":
        return _actuators.RigidTendonMuscle_upd_force_velocity_curve(self, *args)

    def set_force_velocity_curve(self, *args) -> "void":
        return _actuators.RigidTendonMuscle_set_force_velocity_curve(self, *args)

    def __init__(self, *args):
        _actuators.RigidTendonMuscle_swiginit(self, _actuators.new_RigidTendonMuscle(*args))

    def setActivation(self, s: "State", activation: "double") -> "void":
        r""" activation level for this muscle"""
        return _actuators.RigidTendonMuscle_setActivation(self, s, activation)
    __swig_destroy__ = _actuators.delete_RigidTendonMuscle

# Register RigidTendonMuscle in _actuators:
_actuators.RigidTendonMuscle_swigregister(RigidTendonMuscle)

def RigidTendonMuscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::RigidTendonMuscle *":
    return _actuators.RigidTendonMuscle_safeDownCast(obj)

def RigidTendonMuscle_getClassName() -> "std::string const &":
    return _actuators.RigidTendonMuscle_getClassName()

class Millard2012AccelerationMuscle(opensim.simulation.Muscle):
    r"""
    This class implements a 3 state (activation,fiber length and fiber velocity)
    acceleration musculo-tendon model that has several advantages over
    equilibrium musculo-tendon models: it is possible to simulate 0 activation, it
    requires fewer integrator steps to simulate, and physiological active
    force-length (with a minimum value of 0) and force velocity (with true
    asymptotes at the maximum shortening and lengthening velocities)
    curves can be employed.

    Image: fig_Millard2012AccelerationMuscle.png

    The dynamic equation of the mass, constrained to move in direction
    :math:`\hat{i}` is given by the scalar equation:

    .. math::

        m \ddot{x} = F_{SE} - F_{CE} \cdot \hat{i}


    The kinematic expression for the acceleration of the mass, :math:`\ddot{s}`,
    expressed in terms of the fiber length,_{CE}:math:`, and pennation angle`:math:`is\f[\ddot{x} = \Big(\ddot{l}_{CE} \cos \phi - 2 \dot{l}_{CE}\dot{\phi}\sin\phi - \dot{\phi}^2 l_{CE} \cos \phi - \ddot{\phi} l_{CE} \sin \phi\Big)The kinematic expression for the angular acceleration of the pennation angle can be found by taking the second derivative of the pennation constraint equationl_{CE} \sin \phi = hwhich yields\ddot{\phi} = -\Big( \ddot{l}_{CE}\sin\phi +                     2 \dot{l}_{CE} \dot{\phi} \cos\phi                    - \dot{\phi}^2 l_{CE} \sin \phi \Big) \Big( l_{CE} \cos \phi \Big)An expression for` \ddot{l}_{CE}:math:`can be obtained by substituting inthe equations` \ddot{\phi} :math:`into the equation for`\ddot{x}:math:`and simplifying:\ddot{l}_{CE} = \frac{1}{m} \Big(  F_{SE} - F_{CE} \cdot \hat{i} \Big) \cos \phi                + l_{CE} \dot{\phi}^2Notice that the above equation for`\ddot{l}_{CE}:math:`has no singularities,provided that there are no singularities in` F_{SE}:math:`and` F_{M}\cdot\hat{i}:math:`. The force the fiber applies to the tendon (in N), _{CE}`, is given by (+'ve is tension)

    \f[
    F_{CE} \cdot \hat{i} =
    f_{ISO}\Big(\mathbf{a} \mathbf{f}_L(\hat{l}_{CE})
    \mathbf{f}_V(\frac{\hat{v}_{CE}}{v_{MAX}})
    + \beta_{CE}\hat{v}_{CE}
    + \mathbf{f}_{PE}(\hat{l}_{CE})(1+\beta_{PE}\hat{v}_{CE})
    - \mathbf{f}_K(\hat{l}_{CE})(1-\beta_{K}\hat{v}_{CE})  \Big) \cos \phi
    -  f_{ISO} \Big( \mathbf{f}_{c\phi}(\cos \phi)
    (1- \beta_{c \phi}
    \frac{d}{dt}(\frac{l_{CE}\cos\phi}{l_{CE,OPT}\cos\phi_{OPT}})) \Big)


    The force the tendon generates (in N) is given by (+'ve is tension)

    .. math::

        F_{SE} =  
        f_{ISO} \mathbf{f}_{SE}(\hat{l}_{SE})(1+\beta_{SE}\hat{v}_{SE})

    Every elastic element (:math:`\mathbf{f}_{PE}`,:math:`\mathbf{f}_{K}`,
    :math:`\mathbf{f}_{c\phi}`, and :math:`\mathbf{f}_{SE}`) is accompanied by a
    non-linear damping element of a form that is identical to the damping found
    in a Hunt-Crossley contact model. Additionally a linear damping element,
    :math:`\beta_{CE}\hat{v}_{CE}`, is
    located in the fiber as in J.He et al. Damping is necessary to include in this
    model to prevent the mass from oscillating in a non-physiologic manner.
    Nonlinear damping Hunt-Crossley damping (where the damping force is scaled
    by the elastic force) has been chosen because this form of damping doesn't
    increase the stiffness of the system equations
    (because it is gradually turned on).

    As with the Hunt-Crossley contact model, the force generated by the nonlinear
    spring and damper saturated so that it is greater than or equal to zero. This
    saturation is necessary to ensure that tension elements can only generate
    tensile forces, and that compressive elements only generate compressive forces.
    Note that the sign conventions have been chosen so that damping forces are
    generated in the correct direction for each element.

    *}{
    (1+_{PE}_{CE}) > 0 \
    (1-_{K}_{CE}) > 0 \
    (1- _{c
    (_{CE}_{CE,OPT}_{OPT}})) > 0 \
    (1+_{SE}_{SE}) > 0



    For more information on these new terms please see the
    doxygen for FiberCompressiveForceLengthCurve,
    FiberCompressiveForceCosPennationCurve, and
    MuscleFirstOrderActivationDynamicModel.

    **Units**

    * m: meters
    * rad: radians
    * N: Newtons
    * kg: kilograms
    * s: seconds

    **Caution**

    The Millard2012AccelerationMuscle class is experimental and has not been
    extensively tested in all operational conditions.

    **Usage**

     Note that this object should be updated through the set methods provided.
     These set methods will take care of rebuilding the muscle correctly. If you
     modify the properties directly, the curve will not be rebuilt, and upon
     calling a function that requires a state an exception will be thrown because
     the muscle is out of date with its properties.

     Note that this muscle does not currently implement the ignore_tendon_compliance
     flag, nor the ignore_activation_dynamics flag.

    **Nomenclature**

    Note that dot notation is used to denote time derivatives (units of
    /s:math:`and \f$m/s^2` in this case), where as the hat symbol
    (as in :math:`\hat{l}`,:math:`\hat{v}`) is used to denote time derivatives that have
    been scaled by a characteristic dimension (appear in units of
    /s:math:`and \f$1/s^2` in this case)

    * :math:`: is the mass located at the junction between the fiber and the     tendon. This mass should be thought of as a time constant that indicates    how quickly this model will converge to the force an equilibrium     muscle-tendon model would produce (\f$kg`)
    * :math:`\ddot{x}`: is the acceleration of the mass,
         in the :math:`\hat{i}` direction (/s^2:math:`)\li \f$F_{SE}`: is the force developed by the tendon (:math:`)\li \f$F_{CE}\cdot\hat{i}`: is the force developed by the fiber along the
        tendon (:math:`)\li \f$l_{CE}`: Length of the fiber(m)
    * _{CE,OPT}:math:`: Length the fiber generates maximal isometric force (m)\li`_{CE}=l_{CE}/l_{CE,OPT}:math:`:         Normalized length of the fiber (dimensionless)\li`_{CE}=_{CE}/l_{CE,OPT}:math:`:         Fiber velocity divided by (\f$1/s`)
    * :math:`\hat{v}_{MAX}`:
            Maximum normalized fiber velocity (_{CE,OPT}/s:math:`). This                   quantity typically ranges between 10 and 15 lengths                    per second  (1/s)\li`:math:`: Pennation angle(rad)\li`_{OPT}:math:`: Pennation angle when the fiber is at its optimal                       length (rad)\li \f$l_{SE}`: Length of the series element (tendon) (m)
    * _{SE,R}:math:`: Resting length of the series element(m)\li`_{SE} = l_{SE}/l_{SE,R}:math:`:                 Normalized length of the series element (dimensionless)\li` _{SE} = _{SE}/l_{SE,R}:math:`:                     Normalized velocity of the tendon (1/s)\li \f$f_{ISO}`: maximum force the muscle can develop statically
    (:math:`\hat{v}_{CE}=0`) at its optimal length (_{CE,OPT}:math:`) and pennation angle (`_{OPT}:math:`)\li`:math:`: activation (unitless)\li`_L(_{CE}):math:`:         Active force length multiplier (dimensionless)\li`_V(_{CE}}{v_{MAX}}):math:`:         Force velocity multiplier (dimensionless)\li`_{PE}(_{CE}):math:`:         Passive force length multiplier (dimensionless)\li`_{K}(_{CE}):math:`:        Fiber compressive force length multiplier (dimensionless)\li`_{c():math:`:        Fiber compressive cosine pennation multiplier (dimensionless)\li`_{SE}(_{SE}):math:`:        Series element (tendon) force-length multiplier (dimensionless)\li`_{CE}:math:`: Fiber damping (s)\li`_{PE}:math:`: Fiber parallel element damping coefficient (s)\li`_{K}:math:`: Fiber compressive force length damping coefficient (s)\li`_{c :math:`: Fiber compressive cosine pennation damping                           coefficient (s)\li`_{SE}:math:`: Series element (tendon) force length damping coefficient                       (s)<B> References </B>Hunt,K., and Crossley,F. Coefficient of restitution interpreted as damping in vibroimpact. Transactions of the ASME Journal of Applied Mechanics, 42(E):440445, 1975.J.He, W.S. Levine, and G.E. Leob."The Modelling of the Neuro-musculo-skeletal Control System of A Cat Hindlimb", Proceedings of the IEEE International Symposium on Intelligent Control, 1988.@author Matt Millard`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::Millard2012AccelerationMuscle *":
        return _actuators.Millard2012AccelerationMuscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.Millard2012AccelerationMuscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.Millard2012AccelerationMuscle_getClassName()

    def clone(self) -> "OpenSim::Millard2012AccelerationMuscle *":
        return _actuators.Millard2012AccelerationMuscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.Millard2012AccelerationMuscle_getConcreteClassName(self)

    def copyProperty_default_activation(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_default_fiber_length(self, *args)

    def copyProperty_default_fiber_velocity(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_fiber_velocity(self, source)

    def append_default_fiber_velocity(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_default_fiber_velocity(self, value)

    def constructProperty_default_fiber_velocity(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_fiber_velocity(self, initValue)

    def get_default_fiber_velocity(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_default_fiber_velocity(self, *args)

    def upd_default_fiber_velocity(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_default_fiber_velocity(self, *args)

    def set_default_fiber_velocity(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_default_fiber_velocity(self, *args)

    def copyProperty_MuscleFirstOrderActivationDynamicModel(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_MuscleFirstOrderActivationDynamicModel(self, source)

    def append_MuscleFirstOrderActivationDynamicModel(self, value: "MuscleFirstOrderActivationDynamicModel") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_MuscleFirstOrderActivationDynamicModel(self, value)

    def constructProperty_MuscleFirstOrderActivationDynamicModel(self, initValue: "MuscleFirstOrderActivationDynamicModel") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_MuscleFirstOrderActivationDynamicModel(self, initValue)

    def get_MuscleFirstOrderActivationDynamicModel(self, *args) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        return _actuators.Millard2012AccelerationMuscle_get_MuscleFirstOrderActivationDynamicModel(self, *args)

    def upd_MuscleFirstOrderActivationDynamicModel(self, *args) -> "OpenSim::MuscleFirstOrderActivationDynamicModel &":
        return _actuators.Millard2012AccelerationMuscle_upd_MuscleFirstOrderActivationDynamicModel(self, *args)

    def set_MuscleFirstOrderActivationDynamicModel(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_MuscleFirstOrderActivationDynamicModel(self, *args)

    def copyProperty_ActiveForceLengthCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_ActiveForceLengthCurve(self, source)

    def append_ActiveForceLengthCurve(self, value: "ActiveForceLengthCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_ActiveForceLengthCurve(self, value)

    def constructProperty_ActiveForceLengthCurve(self, initValue: "ActiveForceLengthCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_ActiveForceLengthCurve(self, initValue)

    def get_ActiveForceLengthCurve(self, *args) -> "OpenSim::ActiveForceLengthCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_ActiveForceLengthCurve(self, *args)

    def upd_ActiveForceLengthCurve(self, *args) -> "OpenSim::ActiveForceLengthCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_ActiveForceLengthCurve(self, *args)

    def set_ActiveForceLengthCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_ActiveForceLengthCurve(self, *args)

    def copyProperty_ForceVelocityCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_ForceVelocityCurve(self, source)

    def append_ForceVelocityCurve(self, value: "ForceVelocityCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_ForceVelocityCurve(self, value)

    def constructProperty_ForceVelocityCurve(self, initValue: "ForceVelocityCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_ForceVelocityCurve(self, initValue)

    def get_ForceVelocityCurve(self, *args) -> "OpenSim::ForceVelocityCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_ForceVelocityCurve(self, *args)

    def upd_ForceVelocityCurve(self, *args) -> "OpenSim::ForceVelocityCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_ForceVelocityCurve(self, *args)

    def set_ForceVelocityCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_ForceVelocityCurve(self, *args)

    def copyProperty_FiberForceLengthCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberForceLengthCurve(self, source)

    def append_FiberForceLengthCurve(self, value: "FiberForceLengthCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_FiberForceLengthCurve(self, value)

    def constructProperty_FiberForceLengthCurve(self, initValue: "FiberForceLengthCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberForceLengthCurve(self, initValue)

    def get_FiberForceLengthCurve(self, *args) -> "OpenSim::FiberForceLengthCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_FiberForceLengthCurve(self, *args)

    def upd_FiberForceLengthCurve(self, *args) -> "OpenSim::FiberForceLengthCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_FiberForceLengthCurve(self, *args)

    def set_FiberForceLengthCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_FiberForceLengthCurve(self, *args)

    def copyProperty_TendonForceLengthCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_TendonForceLengthCurve(self, source)

    def append_TendonForceLengthCurve(self, value: "TendonForceLengthCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_TendonForceLengthCurve(self, value)

    def constructProperty_TendonForceLengthCurve(self, initValue: "TendonForceLengthCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_TendonForceLengthCurve(self, initValue)

    def get_TendonForceLengthCurve(self, *args) -> "OpenSim::TendonForceLengthCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_TendonForceLengthCurve(self, *args)

    def upd_TendonForceLengthCurve(self, *args) -> "OpenSim::TendonForceLengthCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_TendonForceLengthCurve(self, *args)

    def set_TendonForceLengthCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_TendonForceLengthCurve(self, *args)

    def copyProperty_FiberCompressiveForceLengthCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceLengthCurve(self, source)

    def append_FiberCompressiveForceLengthCurve(self, value: "FiberCompressiveForceLengthCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_FiberCompressiveForceLengthCurve(self, value)

    def constructProperty_FiberCompressiveForceLengthCurve(self, initValue: "FiberCompressiveForceLengthCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceLengthCurve(self, initValue)

    def get_FiberCompressiveForceLengthCurve(self, *args) -> "OpenSim::FiberCompressiveForceLengthCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_FiberCompressiveForceLengthCurve(self, *args)

    def upd_FiberCompressiveForceLengthCurve(self, *args) -> "OpenSim::FiberCompressiveForceLengthCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_FiberCompressiveForceLengthCurve(self, *args)

    def set_FiberCompressiveForceLengthCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_FiberCompressiveForceLengthCurve(self, *args)

    def copyProperty_FiberCompressiveForceCosPennationCurve(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceCosPennationCurve(self, source)

    def append_FiberCompressiveForceCosPennationCurve(self, value: "FiberCompressiveForceCosPennationCurve") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_FiberCompressiveForceCosPennationCurve(self, value)

    def constructProperty_FiberCompressiveForceCosPennationCurve(self, initValue: "FiberCompressiveForceCosPennationCurve") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceCosPennationCurve(self, initValue)

    def get_FiberCompressiveForceCosPennationCurve(self, *args) -> "OpenSim::FiberCompressiveForceCosPennationCurve const &":
        return _actuators.Millard2012AccelerationMuscle_get_FiberCompressiveForceCosPennationCurve(self, *args)

    def upd_FiberCompressiveForceCosPennationCurve(self, *args) -> "OpenSim::FiberCompressiveForceCosPennationCurve &":
        return _actuators.Millard2012AccelerationMuscle_upd_FiberCompressiveForceCosPennationCurve(self, *args)

    def set_FiberCompressiveForceCosPennationCurve(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_FiberCompressiveForceCosPennationCurve(self, *args)

    def copyProperty_fiber_damping(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_fiber_damping(self, *args)

    def copyProperty_fiber_force_length_damping(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_force_length_damping(self, source)

    def append_fiber_force_length_damping(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_fiber_force_length_damping(self, value)

    def constructProperty_fiber_force_length_damping(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_force_length_damping(self, initValue)

    def get_fiber_force_length_damping(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_fiber_force_length_damping(self, *args)

    def upd_fiber_force_length_damping(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_force_length_damping(self, *args)

    def set_fiber_force_length_damping(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_fiber_force_length_damping(self, *args)

    def copyProperty_fiber_compressive_force_length_damping(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_length_damping(self, source)

    def append_fiber_compressive_force_length_damping(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_fiber_compressive_force_length_damping(self, value)

    def constructProperty_fiber_compressive_force_length_damping(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_length_damping(self, initValue)

    def get_fiber_compressive_force_length_damping(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_fiber_compressive_force_length_damping(self, *args)

    def upd_fiber_compressive_force_length_damping(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_compressive_force_length_damping(self, *args)

    def set_fiber_compressive_force_length_damping(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_fiber_compressive_force_length_damping(self, *args)

    def copyProperty_fiber_compressive_force_cos_pennation_damping(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_cos_pennation_damping(self, source)

    def append_fiber_compressive_force_cos_pennation_damping(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_fiber_compressive_force_cos_pennation_damping(self, value)

    def constructProperty_fiber_compressive_force_cos_pennation_damping(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_cos_pennation_damping(self, initValue)

    def get_fiber_compressive_force_cos_pennation_damping(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_fiber_compressive_force_cos_pennation_damping(self, *args)

    def upd_fiber_compressive_force_cos_pennation_damping(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_compressive_force_cos_pennation_damping(self, *args)

    def set_fiber_compressive_force_cos_pennation_damping(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_fiber_compressive_force_cos_pennation_damping(self, *args)

    def copyProperty_tendon_force_length_damping(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_tendon_force_length_damping(self, source)

    def append_tendon_force_length_damping(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_tendon_force_length_damping(self, value)

    def constructProperty_tendon_force_length_damping(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_tendon_force_length_damping(self, initValue)

    def get_tendon_force_length_damping(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_tendon_force_length_damping(self, *args)

    def upd_tendon_force_length_damping(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_tendon_force_length_damping(self, *args)

    def set_tendon_force_length_damping(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_tendon_force_length_damping(self, *args)

    def copyProperty_mass(self, source: "Millard2012AccelerationMuscle") -> "void":
        return _actuators.Millard2012AccelerationMuscle_copyProperty_mass(self, source)

    def append_mass(self, value: "double const &") -> "int":
        return _actuators.Millard2012AccelerationMuscle_append_mass(self, value)

    def constructProperty_mass(self, initValue: "double const &") -> "void":
        return _actuators.Millard2012AccelerationMuscle_constructProperty_mass(self, initValue)

    def get_mass(self, *args) -> "double const &":
        return _actuators.Millard2012AccelerationMuscle_get_mass(self, *args)

    def upd_mass(self, *args) -> "double &":
        return _actuators.Millard2012AccelerationMuscle_upd_mass(self, *args)

    def set_mass(self, *args) -> "void":
        return _actuators.Millard2012AccelerationMuscle_set_mass(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor: produces a non-functional empty muscle

        |

        *Overload 2:*
        Constructs a functional muscle using all of the default curves and
               activation model.

               :type aName: string
               :param aName: The name of the muscle.

               :type aMaxIsometricForce: float
               :param aMaxIsometricForce:
                    The force generated by the muscle when it at its optimal resting length,
                    has a contraction velocity of zero, and is fully activated
                    (Newtons).

               :type aOptimalFiberLength: float
               :param aOptimalFiberLength:
                    The optimal length of the muscle fiber (meters).

               :type aTendonSlackLength: float
               :param aTendonSlackLength:
                    The resting length of the tendon (meters).

               :type aPennationAngle: float
               :param aPennationAngle:
                    The angle of the fiber relative to the tendon when the fiber is at its
                    optimal resting length (radians).
        """
        _actuators.Millard2012AccelerationMuscle_swiginit(self, _actuators.new_Millard2012AccelerationMuscle(*args))

    def getFiberCompressiveForceLengthMultiplier(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with the compressive force length
                   element, :math:`\mathbf{f}_K(\hat{l}_{CE})`, in the equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthMultiplier(self, s)

    def getFiberCompressiveForceCosPennationMultiplier(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with the compressive force
                    cosine pennation element, :math:`\mathbf{f}_{c\phi}(\cos \phi)`, in the
                    equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationMultiplier(self, s)

    def getTendonForceMultiplier(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with tendon element,
                     :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getTendonForceMultiplier(self, s)

    def getMass(self) -> "double":
        r"""
        :rtype: float
        :return: the size of the mass between the tendon and fiber
        """
        return _actuators.Millard2012AccelerationMuscle_getMass(self)

    def getActivationModel(self) -> "OpenSim::MuscleFirstOrderActivationDynamicModel const &":
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getActivationModel(self)

    def getPennationModel(self) -> "OpenSim::MuscleFixedWidthPennationModel const &":
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getPennationModel(self)

    def getActiveForceLengthCurve(self) -> "OpenSim::ActiveForceLengthCurve const &":
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: the ActiveForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self) -> "OpenSim::ForceVelocityCurve const &":
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: the ForceVelocityInverseCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self) -> "OpenSim::FiberForceLengthCurve const &":
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: the FiberForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self) -> "OpenSim::TendonForceLengthCurve const &":
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: the TendonForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getTendonForceLengthCurve(self)

    def getFiberCompressiveForceLengthCurve(self) -> "OpenSim::FiberCompressiveForceLengthCurve const &":
        r"""
        :rtype: :py:class:`FiberCompressiveForceLengthCurve`
        :return: the FiberCompressiveForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthCurve(self)

    def getFiberCompressiveForceCosPennationCurve(self) -> "OpenSim::FiberCompressiveForceCosPennationCurve const &":
        r"""
        :rtype: :py:class:`FiberCompressiveForceCosPennationCurve`
        :return: the FiberCompressiveForceCosPennationCurve that this muscle
                     model uses.
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationCurve(self)

    def getFiberStiffnessAlongTendon(self, s: "State") -> "double":
        r"""
        :rtype: float
        :return: the stiffness of the muscle fibers along the tendon (N/m)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberStiffnessAlongTendon(self, s)

    def setActivationModel(self, aActivationMdl: "MuscleFirstOrderActivationDynamicModel") -> "void":
        r"""
        :type aActivationMdl: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :param aActivationMdl: the MuscleFirstOrderActivationDynamicModel that this
                                  muscle model uses to simulate activation dynamics
        """
        return _actuators.Millard2012AccelerationMuscle_setActivationModel(self, aActivationMdl)

    def setActiveForceLengthCurve(self, aActiveForceLengthCurve: "ActiveForceLengthCurve") -> "void":
        r"""
        :type aActiveForceLengthCurve: :py:class:`ActiveForceLengthCurve`
        :param aActiveForceLengthCurve: the ActiveForceLengthCurve that this muscle
                                    model uses to scale active fiber force as a function
                                    of length
        """
        return _actuators.Millard2012AccelerationMuscle_setActiveForceLengthCurve(self, aActiveForceLengthCurve)

    def setForceVelocityCurve(self, aForceVelocityCurve: "ForceVelocityCurve") -> "void":
        r"""
        :type aForceVelocityCurve: :py:class:`ForceVelocityCurve`
        :param aForceVelocityCurve: the ForceVelocityCurve that this
                                    muscle model uses to calculate the derivative of
                                    fiber length.
        """
        return _actuators.Millard2012AccelerationMuscle_setForceVelocityCurve(self, aForceVelocityCurve)

    def setFiberForceLengthCurve(self, aFiberForceLengthCurve: "FiberForceLengthCurve") -> "void":
        r"""
        :type aFiberForceLengthCurve: :py:class:`FiberForceLengthCurve`
        :param aFiberForceLengthCurve: the FiberForceLengthCurve that this muscle
                                    model uses to calculate the passive force the muscle
                                    fiber generates as the length of the fiber changes
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberForceLengthCurve(self, aFiberForceLengthCurve)

    def setTendonForceLengthCurve(self, aTendonForceLengthCurve: "TendonForceLengthCurve") -> "void":
        r"""
        :type aTendonForceLengthCurve: :py:class:`TendonForceLengthCurve`
        :param aTendonForceLengthCurve: the TendonForceLengthCurve that this muscle
                                    model uses to define the tendon force length curve
        """
        return _actuators.Millard2012AccelerationMuscle_setTendonForceLengthCurve(self, aTendonForceLengthCurve)

    def setFiberCompressiveForceLengthCurve(self, aFiberCompressiveForceLengthCurve: "FiberCompressiveForceLengthCurve") -> "void":
        r"""
        :type aFiberCompressiveForceLengthCurve: :py:class:`FiberCompressiveForceLengthCurve`
        :param aFiberCompressiveForceLengthCurve: the
                    FiberCompressiveForceLengthCurve that this muscle model uses to
                    ensure the length of the fiber is always greater than a physically
                    realistic lower bound.
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberCompressiveForceLengthCurve(self, aFiberCompressiveForceLengthCurve)

    def setFiberCompressiveForceCosPennationCurve(self, aFiberCompressiveForceCosPennationCurve: "FiberCompressiveForceCosPennationCurve") -> "void":
        r"""
        :type aFiberCompressiveForceCosPennationCurve: :py:class:`FiberCompressiveForceCosPennationCurve`
        :param aFiberCompressiveForceCosPennationCurve: the
                    FiberCompressiveForceCosPennationCurve that this muscle model uses
                    to prevent pennation angles from approaching 90 degrees, which is
                    associated with a singularity in this model.
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberCompressiveForceCosPennationCurve(self, aFiberCompressiveForceCosPennationCurve)

    def setMass(self, mass: "double") -> "void":
        r"""
        :type mass: float
        :param mass:
                    The size of the mass parameter between the fiber and the tendon.
                    Making this parameter small will make the muscle model more rapidly
                    converge to the results an equilibrium model would produce.

        **Conditions**
                mass >= 0.001
        """
        return _actuators.Millard2012AccelerationMuscle_setMass(self, mass)

    def getDefaultActivation(self) -> "double":
        r"""
        :rtype: float
        :return: the default activation level that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultActivation(self)

    def getDefaultFiberLength(self) -> "double":
        r"""
        :rtype: float
        :return: the default fiber length that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultFiberLength(self)

    def getDefaultFiberVelocity(self) -> "double":
        r"""
        :rtype: float
        :return: the default fiber velocity that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultFiberVelocity(self)

    def getActivationRate(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the time derivative of activation
        """
        return _actuators.Millard2012AccelerationMuscle_getActivationRate(self, s)

    def getFiberVelocity(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the velocity of the fiber (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberVelocity(self, s)

    def getFiberAcceleration(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the acceleration of the fiber (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberAcceleration(self, s)

    def setDefaultActivation(self, activation: "double") -> "void":
        r"""
        :type activation: float
        :param activation: the default activation level that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultActivation(self, activation)

    def setDefaultFiberLength(self, fiberLength: "double") -> "void":
        r"""
        :type fiberLength: float
        :param fiberLength: the default fiber length that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultFiberLength(self, fiberLength)

    def setDefaultFiberVelocity(self, fiberVelocity: "double") -> "void":
        r"""
        :type fiberVelocity: float
        :param fiberVelocity: the default fiber velocity that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultFiberVelocity(self, fiberVelocity)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type activation: float
        :param activation: the desired activation level
        """
        return _actuators.Millard2012AccelerationMuscle_setActivation(self, s, activation)

    def setFiberLength(self, s: "State", fiberLength: "double") -> "void":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type fiberLength: float
        :param fiberLength: the desired fiber length (m)
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberLength(self, s, fiberLength)

    def setFiberVelocity(self, s: "State", fiberVelocity: "double") -> "void":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type fiberVelocity: float
        :param fiberVelocity: the desired fiber velocity (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberVelocity(self, s, fiberVelocity)

    def computeActuation(self, s: "State") -> "double":
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the tensile force the muscle is generating in N
        """
        return _actuators.Millard2012AccelerationMuscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        This function computes the fiber length such that muscle fiber and
               tendon are developing the same force, and so that the velocity of
               the entire muscle-tendon is spread between the fiber and the tendon
               according to their relative compliances.

               :type s: :py:class:`State`
               :param s: the state of the system
               :raises: MuscleCannotEquilibrate
        """
        return _actuators.Millard2012AccelerationMuscle_computeInitialFiberEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s: "State", aActivation: "double") -> "double":
        r"""Conditional comment: DEPRECATED"""
        return _actuators.Millard2012AccelerationMuscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def calcActiveFiberForceAlongTendon(self, activation: "double", fiberLength: "double", fiberVelocity: "double") -> "double":
        return _actuators.Millard2012AccelerationMuscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The
                optimal fiber length and tendon slack length are each multiplied by the
                ratio of the current path length and the path length before scaling.
        """
        return _actuators.Millard2012AccelerationMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _actuators.delete_Millard2012AccelerationMuscle

# Register Millard2012AccelerationMuscle in _actuators:
_actuators.Millard2012AccelerationMuscle_swigregister(Millard2012AccelerationMuscle)

def Millard2012AccelerationMuscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::Millard2012AccelerationMuscle *":
    return _actuators.Millard2012AccelerationMuscle_safeDownCast(obj)

def Millard2012AccelerationMuscle_getClassName() -> "std::string const &":
    return _actuators.Millard2012AccelerationMuscle_getClassName()

class McKibbenActuator(opensim.simulation.PathActuator):
    r"""
    McKibben Pneumatic Actuator Model based on the simple cylindrical
    formulation described in J. Dyn. Sys., Meas., Control 122, 386-388
    (1998) (3 pages); doi:10.1115/1.482478.

    Pressure is used as a control signal. There is an optional 'cord'
    attached to the actuator which allows for the path length of the actuator
    to be shorter than the total distance spanned by the points to which the
    actuator is connected. By default its length is zero. Please
    refer to the above paper for details regarding the rest of the
    properties.

    Author: Nabeel Allana
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::McKibbenActuator *":
        return _actuators.McKibbenActuator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.McKibbenActuator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.McKibbenActuator_getClassName()

    def clone(self) -> "OpenSim::McKibbenActuator *":
        return _actuators.McKibbenActuator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.McKibbenActuator_getConcreteClassName(self)

    def copyProperty_thread_length(self, source: "McKibbenActuator") -> "void":
        return _actuators.McKibbenActuator_copyProperty_thread_length(self, source)

    def append_thread_length(self, value: "double const &") -> "int":
        return _actuators.McKibbenActuator_append_thread_length(self, value)

    def constructProperty_thread_length(self, initValue: "double const &") -> "void":
        return _actuators.McKibbenActuator_constructProperty_thread_length(self, initValue)

    def get_thread_length(self, *args) -> "double const &":
        return _actuators.McKibbenActuator_get_thread_length(self, *args)

    def upd_thread_length(self, *args) -> "double &":
        return _actuators.McKibbenActuator_upd_thread_length(self, *args)

    def set_thread_length(self, *args) -> "void":
        return _actuators.McKibbenActuator_set_thread_length(self, *args)

    def copyProperty_number_of_turns(self, source: "McKibbenActuator") -> "void":
        return _actuators.McKibbenActuator_copyProperty_number_of_turns(self, source)

    def append_number_of_turns(self, value: "double const &") -> "int":
        return _actuators.McKibbenActuator_append_number_of_turns(self, value)

    def constructProperty_number_of_turns(self, initValue: "double const &") -> "void":
        return _actuators.McKibbenActuator_constructProperty_number_of_turns(self, initValue)

    def get_number_of_turns(self, *args) -> "double const &":
        return _actuators.McKibbenActuator_get_number_of_turns(self, *args)

    def upd_number_of_turns(self, *args) -> "double &":
        return _actuators.McKibbenActuator_upd_number_of_turns(self, *args)

    def set_number_of_turns(self, *args) -> "void":
        return _actuators.McKibbenActuator_set_number_of_turns(self, *args)

    def copyProperty_cord_length(self, source: "McKibbenActuator") -> "void":
        return _actuators.McKibbenActuator_copyProperty_cord_length(self, source)

    def append_cord_length(self, value: "double const &") -> "int":
        return _actuators.McKibbenActuator_append_cord_length(self, value)

    def constructProperty_cord_length(self, initValue: "double const &") -> "void":
        return _actuators.McKibbenActuator_constructProperty_cord_length(self, initValue)

    def get_cord_length(self, *args) -> "double const &":
        return _actuators.McKibbenActuator_get_cord_length(self, *args)

    def upd_cord_length(self, *args) -> "double &":
        return _actuators.McKibbenActuator_upd_cord_length(self, *args)

    def set_cord_length(self, *args) -> "void":
        return _actuators.McKibbenActuator_set_cord_length(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience constructor for API users. *
        """
        _actuators.McKibbenActuator_swiginit(self, _actuators.new_McKibbenActuator(*args))

    def setNumberOfTurns(self, val: "double") -> "void":
        r""" %Set the 'number of turns' property. *"""
        return _actuators.McKibbenActuator_setNumberOfTurns(self, val)

    def getNumberOfTurns(self) -> "double":
        r""" Get the current value of the 'number of turns' property. *"""
        return _actuators.McKibbenActuator_getNumberOfTurns(self)

    def setThreadLength(self, val: "double") -> "void":
        r""" %Set the 'thread length' property. *"""
        return _actuators.McKibbenActuator_setThreadLength(self, val)

    def getThreadLength(self) -> "double":
        r""" Get the current value of the 'thread length' property. *"""
        return _actuators.McKibbenActuator_getThreadLength(self)

    def setCordLength(self, val: "double") -> "void":
        r""" %Set the 'cord length' property. *"""
        return _actuators.McKibbenActuator_setCordLength(self, val)

    def getCordLength(self) -> "double":
        r""" Get the current value of the 'cord length' property. *"""
        return _actuators.McKibbenActuator_getCordLength(self)

    def computeActuation(self, s: "State") -> "double":
        r""" Compute actuation for current state. *"""
        return _actuators.McKibbenActuator_computeActuation(self, s)
    __swig_destroy__ = _actuators.delete_McKibbenActuator

# Register McKibbenActuator in _actuators:
_actuators.McKibbenActuator_swigregister(McKibbenActuator)

def McKibbenActuator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::McKibbenActuator *":
    return _actuators.McKibbenActuator_safeDownCast(obj)

def McKibbenActuator_getClassName() -> "std::string const &":
    return _actuators.McKibbenActuator_getClassName()

class DeGrooteFregly2016Muscle(opensim.simulation.Muscle):
    r"""
     This muscle model was published in De Groote et al. 2016.

    The parameters of the active force-length and force-velocity curves have
    been slightly modified from what was published to ensure the curves go
    through key points:
    - Active force-length curve goes through (1, 1).
    - Force-velocity curve goes through (-1, 0) and (0, 1).
    The default tendon force curve parameters are modified from that in De
    Groote et al., 2016: the curve is parameterized by the strain at 1 norm
    force (rather than "kT"), and the default value for this parameter is
    0.049 (same as in TendonForceLengthCurve) rather than 0.0474.

    This implementation introduces the property 'active_force_width_scale' as
    an addition to the original model, which allows users to effectively make
    the active force-length curve wider. This property may be useful for
    improving the force-generating capacity of a muscle without increasing
    maximum isometric force. This property works by scaling the normalized
    fiber length when the active force-length curve is computed. For example,
    a scale factor of 2 means that the fiber muscle traverses half as far
    along the force-length curve in either direction.

    This implementation adds fiber damping as an addition to the original model.
    Users can specify this via the 'fiber_damping' property, and damping force
    along the fiber is computed by multiplying the property value by the
    normalized fiber velocity and max isometric force. If using this muscle for
    optimization, fiber damping is recommended as it can improve convergence.

    Notes: If converting from Thelen2003Muscles via replaceMuscles(), fiber
       damping will be set to zero since there is no damping in that muscle
       model.

    This class supports tendon compliance dynamics in both explicit and implicit
    form (formulations 1 and 3 from De Groote et al. 2016). Both forms of the
    dynamics use normalized tendon force as the state variable (rather than the
    typical fiber length state). The explicit form is handled through the usual
    Component dynamics interface. The implicit form introduces an additional
    discrete state variable and cache variable in the SimTK::State for the
    derivative of normalized tendon force and muscle-tendon equilibrium residual
    respectively. In general, it is preferable to use the implicit form in
    optimization since it can be robust to arbitrary initial guesses (see De
    Groote et al. 2016). However, the implicit form is only for use with solvers
    that support implicit dynamics (i.e. Moco) and cannot be used to perform a
    time-stepping forward simulation with Manager; use explicit mode for
    time-stepping.

    Normalized tendon force is bounded in the range [0, 5] in this class.
       The methods getMinNormalizedTendonForce() and
       getMaxNormalizedTendonForce() provide these bounds for use in custom solvers.



    The documentation for Muscle::MuscleLengthInfo states that the
    optimalFiberLength of a muscle is also its resting length, but this is not
    true for this muscle: there is a non-zero passive fiber force at the
    optimal fiber length.

    In the Muscle class, setIgnoreTendonCompliance() and
    setIngoreActivationDynamics() control modeling options, meaning these
    settings could theoretically be changed. However, for this class, the
    modeling option is ignored and the values of the ignore_tendon_compliance
    and ignore_activation_dynamics properties are used directly.

    De Groote, F., Kinney, A. L., Rao, A. V., & Fregly, B. J. (2016). Evaluation
    of Direct Collocation Optimal Control Problem Formulations for Solving the
    Muscle Redundancy Problem. Annals of Biomedical Engineering, 44(10), 115.
    http://doi.org/10.1007/s10439-016-1591-9
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::DeGrooteFregly2016Muscle *":
        return _actuators.DeGrooteFregly2016Muscle_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.DeGrooteFregly2016Muscle_getClassName()

    def clone(self) -> "OpenSim::DeGrooteFregly2016Muscle *":
        return _actuators.DeGrooteFregly2016Muscle_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.DeGrooteFregly2016Muscle_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_deactivation_time_constant(self, *args)

    def copyProperty_default_activation(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_default_activation(self, *args)

    def copyProperty_default_normalized_tendon_force(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_default_normalized_tendon_force(self, source)

    def append_default_normalized_tendon_force(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_default_normalized_tendon_force(self, value)

    def constructProperty_default_normalized_tendon_force(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_default_normalized_tendon_force(self, initValue)

    def get_default_normalized_tendon_force(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_default_normalized_tendon_force(self, *args)

    def upd_default_normalized_tendon_force(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_default_normalized_tendon_force(self, *args)

    def set_default_normalized_tendon_force(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_default_normalized_tendon_force(self, *args)

    def copyProperty_active_force_width_scale(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_active_force_width_scale(self, source)

    def append_active_force_width_scale(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_active_force_width_scale(self, value)

    def constructProperty_active_force_width_scale(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_active_force_width_scale(self, initValue)

    def get_active_force_width_scale(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_active_force_width_scale(self, *args)

    def upd_active_force_width_scale(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_active_force_width_scale(self, *args)

    def set_active_force_width_scale(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_active_force_width_scale(self, *args)

    def copyProperty_fiber_damping(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_fiber_damping(self, *args)

    def copyProperty_ignore_passive_fiber_force(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_ignore_passive_fiber_force(self, source)

    def append_ignore_passive_fiber_force(self, value: "bool const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_ignore_passive_fiber_force(self, value)

    def constructProperty_ignore_passive_fiber_force(self, initValue: "bool const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_ignore_passive_fiber_force(self, initValue)

    def get_ignore_passive_fiber_force(self, *args) -> "bool const &":
        return _actuators.DeGrooteFregly2016Muscle_get_ignore_passive_fiber_force(self, *args)

    def upd_ignore_passive_fiber_force(self, *args) -> "bool &":
        return _actuators.DeGrooteFregly2016Muscle_upd_ignore_passive_fiber_force(self, *args)

    def set_ignore_passive_fiber_force(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_ignore_passive_fiber_force(self, *args)

    def copyProperty_passive_fiber_strain_at_one_norm_force(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_passive_fiber_strain_at_one_norm_force(self, source)

    def append_passive_fiber_strain_at_one_norm_force(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_passive_fiber_strain_at_one_norm_force(self, value)

    def constructProperty_passive_fiber_strain_at_one_norm_force(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_passive_fiber_strain_at_one_norm_force(self, initValue)

    def get_passive_fiber_strain_at_one_norm_force(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_passive_fiber_strain_at_one_norm_force(self, *args)

    def upd_passive_fiber_strain_at_one_norm_force(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_passive_fiber_strain_at_one_norm_force(self, *args)

    def set_passive_fiber_strain_at_one_norm_force(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_passive_fiber_strain_at_one_norm_force(self, *args)

    def copyProperty_tendon_strain_at_one_norm_force(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_tendon_strain_at_one_norm_force(self, source)

    def append_tendon_strain_at_one_norm_force(self, value: "double const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_tendon_strain_at_one_norm_force(self, value)

    def constructProperty_tendon_strain_at_one_norm_force(self, initValue: "double const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_tendon_strain_at_one_norm_force(self, initValue)

    def get_tendon_strain_at_one_norm_force(self, *args) -> "double const &":
        return _actuators.DeGrooteFregly2016Muscle_get_tendon_strain_at_one_norm_force(self, *args)

    def upd_tendon_strain_at_one_norm_force(self, *args) -> "double &":
        return _actuators.DeGrooteFregly2016Muscle_upd_tendon_strain_at_one_norm_force(self, *args)

    def set_tendon_strain_at_one_norm_force(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_tendon_strain_at_one_norm_force(self, *args)

    def copyProperty_tendon_compliance_dynamics_mode(self, source: "DeGrooteFregly2016Muscle") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_tendon_compliance_dynamics_mode(self, source)

    def append_tendon_compliance_dynamics_mode(self, value: "std::string const &") -> "int":
        return _actuators.DeGrooteFregly2016Muscle_append_tendon_compliance_dynamics_mode(self, value)

    def constructProperty_tendon_compliance_dynamics_mode(self, initValue: "std::string const &") -> "void":
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_tendon_compliance_dynamics_mode(self, initValue)

    def get_tendon_compliance_dynamics_mode(self, *args) -> "std::string const &":
        return _actuators.DeGrooteFregly2016Muscle_get_tendon_compliance_dynamics_mode(self, *args)

    def upd_tendon_compliance_dynamics_mode(self, *args) -> "std::string &":
        return _actuators.DeGrooteFregly2016Muscle_upd_tendon_compliance_dynamics_mode(self, *args)

    def set_tendon_compliance_dynamics_mode(self, *args) -> "void":
        return _actuators.DeGrooteFregly2016Muscle_set_tendon_compliance_dynamics_mode(self, *args)
    _has_output_passive_fiber_elastic_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_set)
    _has_output_passive_fiber_elastic_force_along_tendon = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_set)
    _has_output_passive_fiber_damping_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_set)
    _has_output_passive_fiber_damping_force_along_tendon = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_set)
    _has_output_implicitresidual_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_set)
    _has_output_implicitenabled_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_set)
    _has_output_statebounds_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_set)

    def __init__(self):
        _actuators.DeGrooteFregly2016Muscle_swiginit(self, _actuators.new_DeGrooteFregly2016Muscle())

    def getActivation(self, s: "State") -> "double":
        r""" If ignore_activation_dynamics is true, this gets excitation instead."""
        return _actuators.DeGrooteFregly2016Muscle_getActivation(self, s)

    def setActivation(self, s: "State", activation: "double") -> "void":
        r""" If ignore_activation_dynamics is true, this sets excitation instead."""
        return _actuators.DeGrooteFregly2016Muscle_setActivation(self, s, activation)

    def computeInitialFiberEquilibrium(self, s: "State") -> "void":
        r"""
        In this method, calcEquilibriumResidual() is used to find a value of the
        normalized tendon force state variable that produces muscle-tendon
        equilibrium. This relies on the implicit form of tendon compliance since
        the explicit form uses the normalized tendon force state variable
        directly to compute fiber force, which always produces a zero
        muscle-tendon equilibrium residual. The derivative of normalized tendon
        force is set to zero since a value is required for the implicit form of
        the model.
        """
        return _actuators.DeGrooteFregly2016Muscle_computeInitialFiberEquilibrium(self, s)

    def getPassiveFiberElasticForce(self, s: "State") -> "double":
        r"""
        Get the portion of the passive fiber force generated by the elastic
        element only (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s: "State") -> "double":
        r"""
        Get the portion of the passive fiber force generated by the elastic
        element only, projected onto the tendon direction (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s: "State") -> "double":
        r"""
        Get the portion of the passive fiber force generated by the damping
        element only (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s: "State") -> "double":
        r"""
        Get the portion of the passive fiber force generated by the damping
        element only, projected onto the tendon direction (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberDampingForceAlongTendon(self, s)

    def getImplicitEnabledNormalizedTendonForce(self, arg2: "State") -> "bool":
        r"""
        Get whether fiber dynamics is in implicit dynamics mode when using
        normalized tendon force as the state. This is useful to indicate to
        solvers to handle the normalized tendon force derivative and
        muscle-tendon equilibrium variables, which are added to the State as
        discrete and cache variables, respectively.
        This function is intended primarily for the model Output
        'implicitenabled_normalized_tendon_force'. We don't need the state, but
        the state parameter is a requirement of Output functions.
        """
        return _actuators.DeGrooteFregly2016Muscle_getImplicitEnabledNormalizedTendonForce(self, arg2)

    def getImplicitResidualNormalizedTendonForce(self, s: "State") -> "double":
        r"""
        Compute the muscle-tendon force equilibrium residual value when using
        implicit contraction dynamics with normalized tendon force as the
        state.
        This function is intended primarily for the model Output
        'implicitresidual_normalized_tendon_force'.
        """
        return _actuators.DeGrooteFregly2016Muscle_getImplicitResidualNormalizedTendonForce(self, s)

    def getNormalizedTendonForce(self, s: "State") -> "double":
        r"""
        If ignore_tendon_compliance is true, this gets normalized fiber force
        along the tendon instead.
        """
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForce(self, s)

    def getNormalizedTendonForceDerivative(self, s: "State") -> "double":
        r"""
        Obtain the time derivative of the normalized tendon force.
        - If ignore_tendon_compliance is false, this returns zero.
        - If tendon_compliance_dynamics_mode is 'implicit', this gets the
        discrete variable normalized tendon force derivative value.
        - If tendon_compliance_dynamics_mode is 'explicit', this gets the value
        returned by getStateVariableDerivativeValue() for the
        'normalized_tendon_force' state.
        """
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForceDerivative(self, s)

    def getEquilibriumResidual(self, s: "State") -> "double":
        r"""
        This calls calcEquilibriumResidual() using values from the provided
        SimTK::State as arguments. While is computed using implicit mode, the
        value of normalized tendon force derivative used *is* consistent with
        the property `tendon_compliance_dynamics_mode` (see
        getNormalizedTendonForceDerivative()).
        """
        return _actuators.DeGrooteFregly2016Muscle_getEquilibriumResidual(self, s)

    def getLinearizedEquilibriumResidualDerivative(self, s: "State") -> "double":
        
        return _actuators.DeGrooteFregly2016Muscle_getLinearizedEquilibriumResidualDerivative(self, s)

    @staticmethod
    def getActivationStateName() -> "std::string":
        return _actuators.DeGrooteFregly2016Muscle_getActivationStateName()

    @staticmethod
    def getNormalizedTendonForceStateName() -> "std::string":
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForceStateName()

    @staticmethod
    def getImplicitDynamicsDerivativeName() -> "std::string":
        return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsDerivativeName()

    @staticmethod
    def getImplicitDynamicsResidualName() -> "std::string":
        return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsResidualName()

    @staticmethod
    def getMinNormalizedTendonForce() -> "double":
        return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedTendonForce()

    @staticmethod
    def getMaxNormalizedTendonForce() -> "double":
        return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedTendonForce()

    def getBoundsNormalizedTendonForce(self, arg2: "State") -> "SimTK::Vec2":
        r"""
        The first element of the Vec2 is the lower bound, and the second is the
        upper bound.
        This function is intended primarily for the model Output
        'statebounds_normalized_tendon_force'. We don't need the state, but the
        state parameter is a requirement of Output functions.
        """
        return _actuators.DeGrooteFregly2016Muscle_getBoundsNormalizedTendonForce(self, arg2)

    @staticmethod
    def getMinNormalizedFiberLength() -> "double":
        return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedFiberLength()

    @staticmethod
    def getMaxNormalizedFiberLength() -> "double":
        return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedFiberLength()

    def getBoundsNormalizedFiberLength(self) -> "SimTK::Vec2":
        r"""
        The first element of the Vec2 is the lower bound, and the second is the
        upper bound.
        Note that since fiber length is not used as a state variable, these
        bounds cannot be enforced directly. It is upon the user to ensure the
        muscle fiber is operating within the specified domain.
        """
        return _actuators.DeGrooteFregly2016Muscle_getBoundsNormalizedFiberLength(self)

    def setNormalizedTendonForce(self, s: "State", normTendonForce: "double") -> "void":
        r""" If ignore_tendon_compliance is true, this sets nothing."""
        return _actuators.DeGrooteFregly2016Muscle_setNormalizedTendonForce(self, s, normTendonForce)

    def calcActiveForceLengthMultiplier(self, normFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        These functions compute the values of normalized/dimensionless curves,
        their derivatives and integrals, and other quantities of the muscle.
        These do not depend on a SimTK::State.

        The active force-length curve is the sum of 3 Gaussian-like curves. The
        width of the curve can be adjusted via the 'active_force_width_scale'
        property.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplier(self, normFiberLength)

    def calcActiveForceLengthMultiplierDerivative(self, normFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The derivative of the active force-length curve with respect to
        normalized fiber length. This curve is based on the derivative of the
        Gaussian-like curve used in calcActiveForceLengthMultiplier(). The
        'active_force_width_scale' property also affects the value of the
        derivative curve.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplierDerivative(self, normFiberLength)

    @staticmethod
    def calcForceVelocityMultiplier(normFiberVelocity: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The parameters of this curve are not modifiable, so this function is
        static.
        Domain: [-1, 1]
        Range: [0, 1.794]
        Notes: It is upon the user to check that the muscle fiber is acting
              within the specified domain. Force computations outside this range
              may be incorrect.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityMultiplier(normFiberVelocity)

    @staticmethod
    def calcForceVelocityInverseCurve(forceVelocityMult: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the inverse of the force-velocity multiplier function, and
        returns the normalized fiber velocity (in [-1, 1]) as a function of
        the force-velocity multiplier.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityInverseCurve(forceVelocityMult)

    def calcPassiveForceMultiplier(self, normFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the passive force-length curve. The curve becomes negative below
        the minNormFiberLength.

        We modified this equation from that in the supplementary materials of De
        Groote et al., 2016, which is the same function used in
        Thelen2003Muscle. The version in the supplementary materials passes
        through y = 0 at x = 1.0 and allows for negative forces. We do not want
        negative forces within the allowed range of fiber lengths, so we
        modified the equation to pass through y = 0 at x = minNormFiberLength.
        (This is not an issue for Thelen2003Muscle because the curve is not
        smooth and returns 0 for lengths less than optimal fiber length.)
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplier(self, normFiberLength)

    def calcPassiveForceMultiplierDerivative(self, normFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the derivative of the passive force-length curve with respect to
        the normalized fiber length.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierDerivative(self, normFiberLength)

    def calcPassiveForceMultiplierIntegral(self, normFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the integral of the passive force-length curve with respect to
        the normalized fiber length over the domain
        [minNormFiberLength normFiberLength], where minNormFiberLength is the
        value return by getMinNormalizedFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierIntegral(self, normFiberLength)

    def calcTendonForceMultiplier(self, normTendonLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The normalized tendon force as a function of normalized tendon length.
        Note that this curve does not go through (1, 0); when
        normTendonLength=1, this function returns a slightly negative number.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplier(self, normTendonLength)

    def calcTendonForceMultiplierDerivative(self, normTendonLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the derivative of the tendon-force length curve with respect to
        normalized tendon length.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplierDerivative(self, normTendonLength)

    def calcTendonForceMultiplierIntegral(self, normTendonLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the integral of the tendon-force length curve with respect to
        normalized tendon length over the domain
        [minNormTendonLength normTendonLength]. The lower bound on the domain
        is computed by passing the value return by getMinNormalizedTendonForce()
        to calcTendonForceLengthInverseCurve().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplierIntegral(self, normTendonLength)

    def calcTendonForceLengthInverseCurve(self, normTendonForce: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This is the inverse of the tendon force-length curve, and returns the
        normalized tendon length as a function of the normalized tendon force.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurve(self, normTendonForce)

    def calcTendonForceLengthInverseCurveDerivative(self, derivNormTendonForce: "SimTK::Real const &", normTendonLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        This returns normalized tendon velocity given the derivative of
        normalized tendon force and normalized tendon length. This is derived
        by taking the derivative of the tendon force multiplier curve with
        respect to time and then solving for normalized fiber velocity (see
        supplementary information for De Groote et al. 2016).
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurveDerivative(self, derivNormTendonForce, normTendonLength)

    def calcFiberForce(self, activation: "SimTK::Real const &", activeForceLengthMultiplier: "SimTK::Real const &", forceVelocityMultiplier: "SimTK::Real const &", normPassiveFiberForce: "SimTK::Real const &", normFiberVelocity: "SimTK::Real const &", activeFiberForce: "SimTK::Real &", conPassiveFiberForce: "SimTK::Real &", nonConPassiveFiberForce: "SimTK::Real &", totalFiberForce: "SimTK::Real &") -> "void":
        r"""
        This computes both the total fiber force and the individual components
        of fiber force (active, conservative passive, and non-conservative
        passive).
        Notes: based on Millard2012EquilibriumMuscle::calcFiberForce().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberForce(self, activation, activeForceLengthMultiplier, forceVelocityMultiplier, normPassiveFiberForce, normFiberVelocity, activeFiberForce, conPassiveFiberForce, nonConPassiveFiberForce, totalFiberForce)

    def calcFiberStiffness(self, activation: "SimTK::Real const &", normFiberLength: "SimTK::Real const &", fiberVelocityMultiplier: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The stiffness of the fiber in the direction of the fiber. This includes
        both active and passive force contributions to stiffness from the muscle
        fiber.
        Notes: based on Millard2012EquilibriumMuscle::calcFiberStiffness().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberStiffness(self, activation, normFiberLength, fiberVelocityMultiplier)

    def calcTendonStiffness(self, normTendonLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The stiffness of the tendon in the direction of the tendon.
        Notes: based on Millard2012EquilibriumMuscle.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonStiffness(self, normTendonLength)

    def calcMuscleStiffness(self, tendonStiffness: "SimTK::Real const &", fiberStiffnessAlongTendon: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The stiffness of the whole musculotendon unit in the direction of the
        tendon.
        Notes: based on Millard2012EquilibriumMuscle.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcMuscleStiffness(self, tendonStiffness, fiberStiffnessAlongTendon)

    def calcPartialPennationAnglePartialFiberLength(self, fiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The derivative of pennation angle with respect to fiber length.
        Notes: based on
        MuscleFixedWidthPennationModel::calc_DPennationAngle_DFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialPennationAnglePartialFiberLength(self, fiberLength)

    def calcPartialFiberForceAlongTendonPartialFiberLength(self, fiberForce: "SimTK::Real const &", fiberStiffness: "SimTK::Real const &", sinPennationAngle: "SimTK::Real const &", cosPennationAngle: "SimTK::Real const &", partialPennationAnglePartialFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The derivative of the fiber force along the tendon with respect to fiber
        length.
        Notes: based on
        Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialFiberForceAlongTendonPartialFiberLength(self, fiberForce, fiberStiffness, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcFiberStiffnessAlongTendon(self, fiberLength: "SimTK::Real const &", partialFiberForceAlongTendonPartialFiberLength: "SimTK::Real const &", sinPennationAngle: "SimTK::Real const &", cosPennationAngle: "SimTK::Real const &", partialPennationAnglePartialFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The derivative of the fiber force along the tendon with respect to the
        fiber length along the tendon.
        Notes: based on
        Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLengthAT.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberStiffnessAlongTendon(self, fiberLength, partialFiberForceAlongTendonPartialFiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcPartialTendonLengthPartialFiberLength(self, fiberLength: "SimTK::Real const &", sinPennationAngle: "SimTK::Real const &", cosPennationAngle: "SimTK::Real const &", partialPennationAnglePartialFiberLength: "SimTK::Real const &") -> "SimTK::Real":
        return _actuators.DeGrooteFregly2016Muscle_calcPartialTendonLengthPartialFiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcPartialTendonForcePartialFiberLength(self, tendonStiffness: "SimTK::Real const &", fiberLength: "SimTK::Real const &", sinPennationAngle: "SimTK::Real const &", cosPennationAngle: "SimTK::Real const &") -> "SimTK::Real":
        return _actuators.DeGrooteFregly2016Muscle_calcPartialTendonForcePartialFiberLength(self, tendonStiffness, fiberLength, sinPennationAngle, cosPennationAngle)

    def calcEquilibriumResidual(self, muscleTendonLength: "SimTK::Real const &", muscleTendonVelocity: "SimTK::Real const &", activation: "SimTK::Real const &", normTendonForce: "SimTK::Real const &", normTendonForceDerivative: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The residual (i.e. error) in the muscle-tendon equilibrium equation:
            residual = normTendonForce - normFiberForce * cosPennationAngle
        The residual is unitless (units of normalized force).
        This is computed using the muscle in implicit mode, since explicit mode
        uses the normalized tendon force state variable directly
        to compute fiber force, which always produces a zero muscle-tendon
        equilibrium residual.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcEquilibriumResidual(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative)

    def calcLinearizedEquilibriumResidualDerivative(self, muscleTendonLength: "SimTK::Real const &", muscleTendonVelocity: "SimTK::Real const &", activation: "SimTK::Real const &", normTendonForce: "SimTK::Real const &", normTendonForceDerivative: "SimTK::Real const &") -> "SimTK::Real":
        r"""
        The residual (i.e. error) in the time derivative of the linearized
        muscle-tendon equilibrium equation (Millard et al. 2013, equation A6):
            residual = fiberStiffnessAlongTendon * fiberVelocityAlongTendon -
                       tendonStiffness *
                           (muscleTendonVelocity - fiberVelocityAlongTendon)
        This may be useful for finding equilibrium when there is velocity in the
        muscle-tendon actuator. Velocity is divided between the muscle and
        tendon based on their relative stiffnesses.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcLinearizedEquilibriumResidualDerivative(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative)

    def exportFiberLengthCurvesToTable(self, *args) -> "OpenSim::DataTable":
        r"""
        Export the active force-length multiplier and passive force multiplier
        curves to a DataTable. If the normFiberLengths argument is omitted, we
        use createVectorLinspace(200, minNormFiberLength, maxNormFiberLength).
        """
        return _actuators.DeGrooteFregly2016Muscle_exportFiberLengthCurvesToTable(self, *args)

    def exportFiberVelocityMultiplierToTable(self, *args) -> "OpenSim::DataTable":
        r"""
        Export the fiber force-velocity multiplier curve to a DataTable. If
        the normFiberVelocities argument is omitted, we use
        createVectorLinspace(200, -1.1, 1.1).
        """
        return _actuators.DeGrooteFregly2016Muscle_exportFiberVelocityMultiplierToTable(self, *args)

    def exportTendonForceMultiplierToTable(self, *args) -> "OpenSim::DataTable":
        r"""
        Export the fiber tendon force multiplier curve to a DataTable. If
        the normFiberVelocities argument is omitted, we use
        createVectorLinspace(200, 0.95, 1 + <strain at 1 norm force>)
        """
        return _actuators.DeGrooteFregly2016Muscle_exportTendonForceMultiplierToTable(self, *args)

    def printCurvesToSTOFiles(self, *args) -> "void":
        r"""
        Print the muscle curves to STO files. The files will be named as
        `<muscle-name>_<curve_type>.sto`.

        :type directory: string, optional
        :param directory:
                The directory to which the data files should be written. Do NOT
                include the filename. By default, the files are printed to the
                current working directory.
        """
        return _actuators.DeGrooteFregly2016Muscle_printCurvesToSTOFiles(self, *args)

    @staticmethod
    def replaceMuscles(model: "Model", allowUnsupportedMuscles: "bool"=False) -> "void":
        r"""
        Replace muscles of other types in the model with muscles of this type.
        Currently, only Millard2012EquilibriumMuscles and Thelen2003Muscles
        are replaced. For these two muscle classes, we copy property values into
        equivalent properties of the newly created DeGrooteFregly2016Muscle.
        If the model has muscles of other types, an exception is
        thrown unless allowUnsupportedMuscles is true, in which a
        DeGrooteFregly2016Muscle is created using only the base Muscle class
        property values.
        Since the DeGrooteFregly2016Muscle implements tendon compliance dynamics
        with normalized tendon force as the state variable, this function
        ignores the 'default_fiber_length' property in replaced muscles.
        """
        return _actuators.DeGrooteFregly2016Muscle_replaceMuscles(model, allowUnsupportedMuscles)

    def extendPostScale(self, s: "State", scaleSet: "ScaleSet") -> "void":
        r"""
        Adjust the properties of the muscle after the model has been scaled. The
        optimal fiber length and tendon slack length are each multiplied by the
        ratio of the current path length and the path length before scaling.
        """
        return _actuators.DeGrooteFregly2016Muscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _actuators.delete_DeGrooteFregly2016Muscle

# Register DeGrooteFregly2016Muscle in _actuators:
_actuators.DeGrooteFregly2016Muscle_swigregister(DeGrooteFregly2016Muscle)

def DeGrooteFregly2016Muscle_safeDownCast(obj: "OpenSimObject") -> "OpenSim::DeGrooteFregly2016Muscle *":
    return _actuators.DeGrooteFregly2016Muscle_safeDownCast(obj)

def DeGrooteFregly2016Muscle_getClassName() -> "std::string const &":
    return _actuators.DeGrooteFregly2016Muscle_getClassName()

def DeGrooteFregly2016Muscle_getActivationStateName() -> "std::string":
    return _actuators.DeGrooteFregly2016Muscle_getActivationStateName()

def DeGrooteFregly2016Muscle_getNormalizedTendonForceStateName() -> "std::string":
    return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForceStateName()

def DeGrooteFregly2016Muscle_getImplicitDynamicsDerivativeName() -> "std::string":
    return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsDerivativeName()

def DeGrooteFregly2016Muscle_getImplicitDynamicsResidualName() -> "std::string":
    return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsResidualName()

def DeGrooteFregly2016Muscle_getMinNormalizedTendonForce() -> "double":
    return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedTendonForce()

def DeGrooteFregly2016Muscle_getMaxNormalizedTendonForce() -> "double":
    return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedTendonForce()

def DeGrooteFregly2016Muscle_getMinNormalizedFiberLength() -> "double":
    return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedFiberLength()

def DeGrooteFregly2016Muscle_getMaxNormalizedFiberLength() -> "double":
    return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedFiberLength()

def DeGrooteFregly2016Muscle_calcForceVelocityMultiplier(normFiberVelocity: "SimTK::Real const &") -> "SimTK::Real":
    r"""
    The parameters of this curve are not modifiable, so this function is
    static.
    Domain: [-1, 1]
    Range: [0, 1.794]
    Notes: It is upon the user to check that the muscle fiber is acting
          within the specified domain. Force computations outside this range
          may be incorrect.
    """
    return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityMultiplier(normFiberVelocity)

def DeGrooteFregly2016Muscle_calcForceVelocityInverseCurve(forceVelocityMult: "SimTK::Real const &") -> "SimTK::Real":
    r"""
    This is the inverse of the force-velocity multiplier function, and
    returns the normalized fiber velocity (in [-1, 1]) as a function of
    the force-velocity multiplier.
    """
    return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityInverseCurve(forceVelocityMult)

def DeGrooteFregly2016Muscle_replaceMuscles(model: "Model", allowUnsupportedMuscles: "bool"=False) -> "void":
    r"""
    Replace muscles of other types in the model with muscles of this type.
    Currently, only Millard2012EquilibriumMuscles and Thelen2003Muscles
    are replaced. For these two muscle classes, we copy property values into
    equivalent properties of the newly created DeGrooteFregly2016Muscle.
    If the model has muscles of other types, an exception is
    thrown unless allowUnsupportedMuscles is true, in which a
    DeGrooteFregly2016Muscle is created using only the base Muscle class
    property values.
    Since the DeGrooteFregly2016Muscle implements tendon compliance dynamics
    with normalized tendon force as the state variable, this function
    ignores the 'default_fiber_length' property in replaced muscles.
    """
    return _actuators.DeGrooteFregly2016Muscle_replaceMuscles(model, allowUnsupportedMuscles)

class ModelFactory(object):
    r""" This class provides utilities for creating OpenSim models."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createNLinkPendulum(numLinks: "int") -> "OpenSim::Model":
        r"""
        Create a pendulum with the provided number of links.
        For each link, there is a body `/bodyset/b#` (where `#` is the link
        index starting at 0), a PinJoint `/jointset/j#` with coordinate
        `/jointset/j#/q#`, a CoordinateActuator `/tau#`, a Marker
        `/markerset/marker#` at the origin of the link's body, and a
        PhysicalOffsetFrame ``/b``#center at the center of the link.
        """
        return _actuators.ModelFactory_createNLinkPendulum(numLinks)

    @staticmethod
    def createPendulum() -> "OpenSim::Model":
        r""" This is a convenience for `createNLinkPendulum(1)`."""
        return _actuators.ModelFactory_createPendulum()

    @staticmethod
    def createDoublePendulum() -> "OpenSim::Model":
        r""" This is a convenience for `createNLinkPendulum(2)`."""
        return _actuators.ModelFactory_createDoublePendulum()

    @staticmethod
    def createSlidingPointMass() -> "OpenSim::Model":
        r"""
        This model contains:
        - 1 body: mass 1.0 kg, `/bodyset/body`.
        - 1 joint: SliderJoint along x axis, `/jointset/slider`, with
                   coordinate `/jointset/slider/position`.
        - 1 actuator: CoordinateActuator, controls [-10, 10], `/actuator`.
        Gravity is default; that is, (0, -g, 0).
        """
        return _actuators.ModelFactory_createSlidingPointMass()

    @staticmethod
    def createPlanarPointMass() -> "OpenSim::Model":
        r"""
        This model contains:
        - 2 bodies: a massless body "intermed", and "body" with mass 1.
        - 2 slider joints: "tx" and "ty" (coordinates "tx" and "ty").
        - 2 coordinate actuators: "force_x" and "force_y".
        Gravity is default; that is, (0, -g, 0).
        """
        return _actuators.ModelFactory_createPlanarPointMass()

    @staticmethod
    def replaceMusclesWithPathActuators(model: "Model") -> "void":
        r"""
        Replace muscles in a model with a PathActuator of the same GeometryPath,
        optimal force, and min/max control defaults.
        Notes: This only replaces muscles within the model's ForceSet.
        """
        return _actuators.ModelFactory_replaceMusclesWithPathActuators(model)

    @staticmethod
    def removeMuscles(model: "Model") -> "void":
        r"""
        Remove muscles from the model.
        Notes: This only removes muscles within the model's ForceSet.
        """
        return _actuators.ModelFactory_removeMuscles(model)

    @staticmethod
    def replaceJointWithWeldJoint(model: "Model", jointName: "std::string const &") -> "void":
        r"""
        Replace a joint in the model with a WeldJoint.
        Notes: This assumes the joint is in the JointSet and that the joint's
              connectees are PhysicalOffsetFrames.
        """
        return _actuators.ModelFactory_replaceJointWithWeldJoint(model, jointName)

    @staticmethod
    def createReserveActuators(*args) -> "void":
        r"""
        Add CoordinateActuator%s for each unconstrained coordinate (e.g.,
        `! Coordinate::isConstrained()`) in the model, using the provided optimal
        force. Increasing the optimal force decreases the required control
        signal to generate a given actuation level. The actuators are added to
        the model's ForceSet and are named "reserve_<coordinate-path>" with
        forward slashes converted to underscores. The `bound` argument, if
        supplied, sets the min and max controls to `-bound` and `bound`,
        respectively.
        The fourth (optional) argument
        specifies whether or not to skip coordinates that already have
        CoordinateActuator%s associated with them (default: true).
        """
        return _actuators.ModelFactory_createReserveActuators(*args)

    def __init__(self):
        _actuators.ModelFactory_swiginit(self, _actuators.new_ModelFactory())
    __swig_destroy__ = _actuators.delete_ModelFactory

# Register ModelFactory in _actuators:
_actuators.ModelFactory_swigregister(ModelFactory)

def ModelFactory_createNLinkPendulum(numLinks: "int") -> "OpenSim::Model":
    r"""
    Create a pendulum with the provided number of links.
    For each link, there is a body `/bodyset/b#` (where `#` is the link
    index starting at 0), a PinJoint `/jointset/j#` with coordinate
    `/jointset/j#/q#`, a CoordinateActuator `/tau#`, a Marker
    `/markerset/marker#` at the origin of the link's body, and a
    PhysicalOffsetFrame ``/b``#center at the center of the link.
    """
    return _actuators.ModelFactory_createNLinkPendulum(numLinks)

def ModelFactory_createPendulum() -> "OpenSim::Model":
    r""" This is a convenience for `createNLinkPendulum(1)`."""
    return _actuators.ModelFactory_createPendulum()

def ModelFactory_createDoublePendulum() -> "OpenSim::Model":
    r""" This is a convenience for `createNLinkPendulum(2)`."""
    return _actuators.ModelFactory_createDoublePendulum()

def ModelFactory_createSlidingPointMass() -> "OpenSim::Model":
    r"""
    This model contains:
    - 1 body: mass 1.0 kg, `/bodyset/body`.
    - 1 joint: SliderJoint along x axis, `/jointset/slider`, with
               coordinate `/jointset/slider/position`.
    - 1 actuator: CoordinateActuator, controls [-10, 10], `/actuator`.
    Gravity is default; that is, (0, -g, 0).
    """
    return _actuators.ModelFactory_createSlidingPointMass()

def ModelFactory_createPlanarPointMass() -> "OpenSim::Model":
    r"""
    This model contains:
    - 2 bodies: a massless body "intermed", and "body" with mass 1.
    - 2 slider joints: "tx" and "ty" (coordinates "tx" and "ty").
    - 2 coordinate actuators: "force_x" and "force_y".
    Gravity is default; that is, (0, -g, 0).
    """
    return _actuators.ModelFactory_createPlanarPointMass()

def ModelFactory_replaceMusclesWithPathActuators(model: "Model") -> "void":
    r"""
    Replace muscles in a model with a PathActuator of the same GeometryPath,
    optimal force, and min/max control defaults.
    Notes: This only replaces muscles within the model's ForceSet.
    """
    return _actuators.ModelFactory_replaceMusclesWithPathActuators(model)

def ModelFactory_removeMuscles(model: "Model") -> "void":
    r"""
    Remove muscles from the model.
    Notes: This only removes muscles within the model's ForceSet.
    """
    return _actuators.ModelFactory_removeMuscles(model)

def ModelFactory_replaceJointWithWeldJoint(model: "Model", jointName: "std::string const &") -> "void":
    r"""
    Replace a joint in the model with a WeldJoint.
    Notes: This assumes the joint is in the JointSet and that the joint's
          connectees are PhysicalOffsetFrames.
    """
    return _actuators.ModelFactory_replaceJointWithWeldJoint(model, jointName)

def ModelFactory_createReserveActuators(*args) -> "void":
    r"""
    Add CoordinateActuator%s for each unconstrained coordinate (e.g.,
    `! Coordinate::isConstrained()`) in the model, using the provided optimal
    force. Increasing the optimal force decreases the required control
    signal to generate a given actuation level. The actuators are added to
    the model's ForceSet and are named "reserve_<coordinate-path>" with
    forward slashes converted to underscores. The `bound` argument, if
    supplied, sets the min and max controls to `-bound` and `bound`,
    respectively.
    The fourth (optional) argument
    specifies whether or not to skip coordinates that already have
    CoordinateActuator%s associated with them (default: true).
    """
    return _actuators.ModelFactory_createReserveActuators(*args)

class ModelOperator(opensim.common.OpenSimObject):
    r"""
     This abstract base class describes *any* operation that modifies a Model
    as part of a ModelProcessor.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelOperator *":
        return _actuators.ModelOperator_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModelOperator_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModelOperator_getClassName()

    def clone(self) -> "OpenSim::ModelOperator *":
        return _actuators.ModelOperator_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModelOperator_getConcreteClassName(self)

    def operate(self, model: "Model", relativeToDirectory: "std::string const &") -> "void":
        r"""
        Perform an operation on the model, using `relativeToDirectory` to locate
           any files that this operator reads.
        """
        return _actuators.ModelOperator_operate(self, model, relativeToDirectory)
    __swig_destroy__ = _actuators.delete_ModelOperator

# Register ModelOperator in _actuators:
_actuators.ModelOperator_swigregister(ModelOperator)

def ModelOperator_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelOperator *":
    return _actuators.ModelOperator_safeDownCast(obj)

def ModelOperator_getClassName() -> "std::string const &":
    return _actuators.ModelOperator_getClassName()

class ModelProcessor(opensim.common.OpenSimObject):
    r"""
     This class describes a workflow for processing a Model using
    ModelOperator%s. The user must provide a source model via either the model
    property or the filepath property. In C++, one can easily chain together
    the operators in a processor using the C++ pipe operator:

    .. code-block:: c++

        ModelProcessor proc = ModelProcessor("model.osim") | ModOpAddReserves();
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelProcessor *":
        return _actuators.ModelProcessor_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModelProcessor_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModelProcessor_getClassName()

    def clone(self) -> "OpenSim::ModelProcessor *":
        return _actuators.ModelProcessor_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModelProcessor_getConcreteClassName(self)

    def copyProperty_filepath(self, source: "ModelProcessor") -> "void":
        return _actuators.ModelProcessor_copyProperty_filepath(self, source)

    def append_filepath(self, value: "std::string const &") -> "int":
        return _actuators.ModelProcessor_append_filepath(self, value)

    def constructProperty_filepath(self, initValue: "std::string const &") -> "void":
        return _actuators.ModelProcessor_constructProperty_filepath(self, initValue)

    def get_filepath(self, *args) -> "std::string const &":
        return _actuators.ModelProcessor_get_filepath(self, *args)

    def upd_filepath(self, *args) -> "std::string &":
        return _actuators.ModelProcessor_upd_filepath(self, *args)

    def set_filepath(self, *args) -> "void":
        return _actuators.ModelProcessor_set_filepath(self, *args)

    def copyProperty_operators(self, source: "ModelProcessor") -> "void":
        return _actuators.ModelProcessor_copyProperty_operators(self, source)

    def get_operators(self, i: "int") -> "OpenSim::ModelOperator const &":
        return _actuators.ModelProcessor_get_operators(self, i)

    def upd_operators(self, i: "int") -> "OpenSim::ModelOperator &":
        return _actuators.ModelProcessor_upd_operators(self, i)

    def set_operators(self, i: "int", value: "ModelOperator") -> "void":
        return _actuators.ModelProcessor_set_operators(self, i, value)

    def append_operators(self, value: "ModelOperator") -> "int":
        return _actuators.ModelProcessor_append_operators(self, value)

    def constructProperty_operators(self) -> "void":
        return _actuators.ModelProcessor_constructProperty_operators(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        This constructor is only for use when reading (deserializing) from an
           XML file.

        |

        *Overload 2:*
        Use a Model object as the source model.
           Since this constructor is not explicit, you can provide a Model to
           any function that takes a ModelProcessor (in C++).

        |

        *Overload 3:*
        Use the filepath of a .osim file to obtain the source model.
           Since this constructor is not explicit, you can provide a string
           filepath any function that takes a ModelProcessor (in C++).
        """
        _actuators.ModelProcessor_swiginit(self, _actuators.new_ModelProcessor(*args))

    def getModel(self) -> "OpenSim::Model const &":
        r"""
        Obtain the base model, if one was provided via the model property or
           setModel(). This ignores base models specified via the filepath
           property.
        """
        return _actuators.ModelProcessor_getModel(self)

    def updModel(self) -> "OpenSim::Model &":
        r"""
        Obtain a mutable reference to the base model, if one was provided via
           the model property or setModel(). This ignores base models specified
           via the filepath property.
        """
        return _actuators.ModelProcessor_updModel(self)

    def process(self, *args) -> "OpenSim::Model":
        r"""
        Process and obtain the model. If the base model is specified via the
           filepath property, the filepath will be evaluated relative to
           `relativeToDirectory`, if provided.
        """
        return _actuators.ModelProcessor_process(self, *args)

    def append(self, op: "ModelOperator") -> "OpenSim::ModelProcessor &":
        r""" Append an operation to the end of the operations in this processor."""
        return _actuators.ModelProcessor_append(self, op)

    def __or__(self, right: "ModelOperator") -> "OpenSim::ModelProcessor &":
        r"""
        This operator allows one to write the following code in C++:

           .. code-block:: c++

               ModelProcessor proc = ModelProcessor("model.osim") | ModOpAddReserves();
        """
        return _actuators.ModelProcessor___or__(self, right)

    def setModel(self, model: "Model") -> "void":
        return _actuators.ModelProcessor_setModel(self, model)
    __swig_destroy__ = _actuators.delete_ModelProcessor

# Register ModelProcessor in _actuators:
_actuators.ModelProcessor_swigregister(ModelProcessor)

def ModelProcessor_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModelProcessor *":
    return _actuators.ModelProcessor_safeDownCast(obj)

def ModelProcessor_getClassName() -> "std::string const &":
    return _actuators.ModelProcessor_getClassName()

class ModOpIgnoreActivationDynamics(ModelOperator):
    r""" Turn off activation dynamics for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnoreActivationDynamics *":
        return _actuators.ModOpIgnoreActivationDynamics_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpIgnoreActivationDynamics_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpIgnoreActivationDynamics_getClassName()

    def clone(self) -> "OpenSim::ModOpIgnoreActivationDynamics *":
        return _actuators.ModOpIgnoreActivationDynamics_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpIgnoreActivationDynamics_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpIgnoreActivationDynamics_operate(self, model, arg3)

    def __init__(self):
        _actuators.ModOpIgnoreActivationDynamics_swiginit(self, _actuators.new_ModOpIgnoreActivationDynamics())
    __swig_destroy__ = _actuators.delete_ModOpIgnoreActivationDynamics

# Register ModOpIgnoreActivationDynamics in _actuators:
_actuators.ModOpIgnoreActivationDynamics_swigregister(ModOpIgnoreActivationDynamics)

def ModOpIgnoreActivationDynamics_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnoreActivationDynamics *":
    return _actuators.ModOpIgnoreActivationDynamics_safeDownCast(obj)

def ModOpIgnoreActivationDynamics_getClassName() -> "std::string const &":
    return _actuators.ModOpIgnoreActivationDynamics_getClassName()

class ModOpIgnoreTendonCompliance(ModelOperator):
    r""" Turn off tendon compliance for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnoreTendonCompliance *":
        return _actuators.ModOpIgnoreTendonCompliance_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpIgnoreTendonCompliance_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpIgnoreTendonCompliance_getClassName()

    def clone(self) -> "OpenSim::ModOpIgnoreTendonCompliance *":
        return _actuators.ModOpIgnoreTendonCompliance_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpIgnoreTendonCompliance_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpIgnoreTendonCompliance_operate(self, model, arg3)

    def __init__(self):
        _actuators.ModOpIgnoreTendonCompliance_swiginit(self, _actuators.new_ModOpIgnoreTendonCompliance())
    __swig_destroy__ = _actuators.delete_ModOpIgnoreTendonCompliance

# Register ModOpIgnoreTendonCompliance in _actuators:
_actuators.ModOpIgnoreTendonCompliance_swigregister(ModOpIgnoreTendonCompliance)

def ModOpIgnoreTendonCompliance_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpIgnoreTendonCompliance *":
    return _actuators.ModOpIgnoreTendonCompliance_safeDownCast(obj)

def ModOpIgnoreTendonCompliance_getClassName() -> "std::string const &":
    return _actuators.ModOpIgnoreTendonCompliance_getClassName()

class ModOpScaleMaxIsometricForce(ModelOperator):
    r""" Scale the max isometric force for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpScaleMaxIsometricForce *":
        return _actuators.ModOpScaleMaxIsometricForce_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpScaleMaxIsometricForce_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpScaleMaxIsometricForce_getClassName()

    def clone(self) -> "OpenSim::ModOpScaleMaxIsometricForce *":
        return _actuators.ModOpScaleMaxIsometricForce_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpScaleMaxIsometricForce_getConcreteClassName(self)

    def __init__(self, *args):
        _actuators.ModOpScaleMaxIsometricForce_swiginit(self, _actuators.new_ModOpScaleMaxIsometricForce(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpScaleMaxIsometricForce_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpScaleMaxIsometricForce

# Register ModOpScaleMaxIsometricForce in _actuators:
_actuators.ModOpScaleMaxIsometricForce_swigregister(ModOpScaleMaxIsometricForce)

def ModOpScaleMaxIsometricForce_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpScaleMaxIsometricForce *":
    return _actuators.ModOpScaleMaxIsometricForce_safeDownCast(obj)

def ModOpScaleMaxIsometricForce_getClassName() -> "std::string const &":
    return _actuators.ModOpScaleMaxIsometricForce_getClassName()

class ModOpRemoveMuscles(ModelOperator):
    r""" Remove all muscles contained in the model's ForceSet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpRemoveMuscles *":
        return _actuators.ModOpRemoveMuscles_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpRemoveMuscles_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpRemoveMuscles_getClassName()

    def clone(self) -> "OpenSim::ModOpRemoveMuscles *":
        return _actuators.ModOpRemoveMuscles_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpRemoveMuscles_getConcreteClassName(self)

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpRemoveMuscles_operate(self, model, arg3)

    def __init__(self):
        _actuators.ModOpRemoveMuscles_swiginit(self, _actuators.new_ModOpRemoveMuscles())
    __swig_destroy__ = _actuators.delete_ModOpRemoveMuscles

# Register ModOpRemoveMuscles in _actuators:
_actuators.ModOpRemoveMuscles_swigregister(ModOpRemoveMuscles)

def ModOpRemoveMuscles_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpRemoveMuscles *":
    return _actuators.ModOpRemoveMuscles_safeDownCast(obj)

def ModOpRemoveMuscles_getClassName() -> "std::string const &":
    return _actuators.ModOpRemoveMuscles_getClassName()

class ModOpAddReserves(ModelOperator):
    r"""
     Add reserve actuators to the model using
    ModelFactory::createReserveActuators.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpAddReserves *":
        return _actuators.ModOpAddReserves_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpAddReserves_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpAddReserves_getClassName()

    def clone(self) -> "OpenSim::ModOpAddReserves *":
        return _actuators.ModOpAddReserves_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpAddReserves_getConcreteClassName(self)

    def __init__(self, *args):
        _actuators.ModOpAddReserves_swiginit(self, _actuators.new_ModOpAddReserves(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpAddReserves_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpAddReserves

# Register ModOpAddReserves in _actuators:
_actuators.ModOpAddReserves_swigregister(ModOpAddReserves)

def ModOpAddReserves_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpAddReserves *":
    return _actuators.ModOpAddReserves_safeDownCast(obj)

def ModOpAddReserves_getClassName() -> "std::string const &":
    return _actuators.ModOpAddReserves_getClassName()

class ModOpAddExternalLoads(ModelOperator):
    r"""
     Add external loads (e.g., ground reaction forces) to the model from a
    XML file. The ExternalLoads setting
    external_loads_model_kinematics_file is ignored.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpAddExternalLoads *":
        return _actuators.ModOpAddExternalLoads_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpAddExternalLoads_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpAddExternalLoads_getClassName()

    def clone(self) -> "OpenSim::ModOpAddExternalLoads *":
        return _actuators.ModOpAddExternalLoads_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpAddExternalLoads_getConcreteClassName(self)

    def __init__(self, *args):
        _actuators.ModOpAddExternalLoads_swiginit(self, _actuators.new_ModOpAddExternalLoads(*args))

    def operate(self, model: "Model", relativeToDirectory: "std::string const &") -> "void":
        r""" The ExternalLoads XML file is located relative to `relativeToDirectory`."""
        return _actuators.ModOpAddExternalLoads_operate(self, model, relativeToDirectory)
    __swig_destroy__ = _actuators.delete_ModOpAddExternalLoads

# Register ModOpAddExternalLoads in _actuators:
_actuators.ModOpAddExternalLoads_swigregister(ModOpAddExternalLoads)

def ModOpAddExternalLoads_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpAddExternalLoads *":
    return _actuators.ModOpAddExternalLoads_safeDownCast(obj)

def ModOpAddExternalLoads_getClassName() -> "std::string const &":
    return _actuators.ModOpAddExternalLoads_getClassName()

class ModOpReplaceJointsWithWelds(ModelOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpReplaceJointsWithWelds *":
        return _actuators.ModOpReplaceJointsWithWelds_safeDownCast(obj)

    def assign(self, aObject: "OpenSimObject") -> "void":
        return _actuators.ModOpReplaceJointsWithWelds_assign(self, aObject)

    @staticmethod
    def getClassName() -> "std::string const &":
        return _actuators.ModOpReplaceJointsWithWelds_getClassName()

    def clone(self) -> "OpenSim::ModOpReplaceJointsWithWelds *":
        return _actuators.ModOpReplaceJointsWithWelds_clone(self)

    def getConcreteClassName(self) -> "std::string const &":
        return _actuators.ModOpReplaceJointsWithWelds_getConcreteClassName(self)

    def __init__(self, *args):
        _actuators.ModOpReplaceJointsWithWelds_swiginit(self, _actuators.new_ModOpReplaceJointsWithWelds(*args))

    def operate(self, model: "Model", arg3: "std::string const &") -> "void":
        return _actuators.ModOpReplaceJointsWithWelds_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpReplaceJointsWithWelds

# Register ModOpReplaceJointsWithWelds in _actuators:
_actuators.ModOpReplaceJointsWithWelds_swigregister(ModOpReplaceJointsWithWelds)

def ModOpReplaceJointsWithWelds_safeDownCast(obj: "OpenSimObject") -> "OpenSim::ModOpReplaceJointsWithWelds *":
    return _actuators.ModOpReplaceJointsWithWelds_safeDownCast(obj)

def ModOpReplaceJointsWithWelds_getClassName() -> "std::string const &":
    return _actuators.ModOpReplaceJointsWithWelds_getClassName()



